---
title: Nest 通关秘籍
author: Nest 通关秘籍
date: 2025-02-15
lang: zh-CN
---

## 1.开篇词

一直做前端开发，都会有成为全栈工程师的想法，而 Nest 就是一个很好的途径，它是 Node 最流行的企业级开发框架，提供了 IOC、AOP、微服务等架构特性。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f14b806512ff4bc2973824653e7054cd~tplv-k3u1fbpfcp-watermark.image?)

我们会学习 Nest 全部功能，并且会顺带把 mysql、mongodb、redis、rabbitmq、nacos 等后端中间件学一遍，也会学习 pm2、docker、docker compose 等部署方案，并做几个综合的全栈项目：

**会议室预订系统** ：这是一个单体应用，主要是练习使用 mysql + typeorm + redis + docker + nest 开发后端服务

**考试系统** ：这是微服务架构的项目，练习使用 RabbitMQ + MySQL + Redis + Docker Compose + etcd + Nest 进行开发。

**聊天室项目** ：这是 websocket 项目，练习使用 websocket + mongodb + redis + docker compose + nginx + nest 开发 ws 项目

课程前面部分是 Nest 基础，会讲解 Nest 各种功能的使用，包括 IOC、AOP、全局模块、动态模块、自定义 provider、middleware、pipe、interceptor、guard 等功能，还有 Nest CLI 的使用，Nest 项目的调试。

接下来会讲 docker 和 mysql、redis 等中间件的使用以及 typeorm 这个 orm 库的使用，还有 jwt、session 登录和 RBAC 权限控制，还会学习 pm2 部署，然后做第一个项目实战：会议室预订系统

然后开始微服务部分，会讲 Nest 如何开发微服务，如何创建 monorepo 项目，会讲微服务相关的中间件，比如用 rabbitmq 做削峰填谷，用 etcd、nacos 做配置中心和注册中心，还会学习 passport 做身份认证和 Docker Compose 部署多个项目以及 nginx，然后开发第二个实战项目：考试系统

之后会学习 WebSocket，我们会自己实现 WebSocket 协议来深入理解它，之后学习 Nest 里如何启动 WebSocket 服务，学习 mongodb，之后会做第三个实战项目：聊天室项目

然后开始学习 graphql，学习 graphql 的基础以及如何在 Nest 里使用，学习第二个消息中间件 kafka

之后学习 ElasticSearch，学习如何用它做全文检索、它和 mysql 的关系

还有不定期的加餐，比如 oauth2.0 做授权，用它实现三方登录等

相信等你学完这本小册后，就已经是一个真正意义上的全栈工程师了。



## 10.一网打尽 Nest 全部装饰器

Nest 的功能都是大多通过装饰器来使用的，这节我们就把所有的装饰器过一遍。

我们创建个新的 nest 项目：

    nest new all-decorator -p npm

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1824b5769a7c4cd4a1862918af0dffe8~tplv-k3u1fbpfcp-watermark.image?)

Nest 提供了一套模块系统，通过 @Module声明模块：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/350bf6ae1f1d425aba1e30a2112c75f4~tplv-k3u1fbpfcp-watermark.image?)

通过 @Controller、@Injectable 分别声明其中的 controller 和 provider：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/835bb7e52eb24497bec4a6c97a682307~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63c2e0a4e2e04d638fd510e658429265~tplv-k3u1fbpfcp-watermark.image?)

这个 provider 可以是任何的 class：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a32aed0be559462d8734925deebc8e1f~tplv-k3u1fbpfcp-watermark.image?)

注入的方式可以是构造器注入：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97763942ca1843eab617d82a2b6ee164~tplv-k3u1fbpfcp-watermark.image?)

或者属性注入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b66d2ff31184e689a22bef888eb4b77~tplv-k3u1fbpfcp-watermark.image?)

属性注入要指定注入的 token，可能是 class 也可能是 string。

你可以通过 useFactory、useValue 等方式声明 provider：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/035c9f0ee8e540aaa5e1ceadb1ce9aa2~tplv-k3u1fbpfcp-watermark.image?)

这时候也需要通过 @Inject 指定注入的 token：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16e14a5849b64701b3f74162046c6f38~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c08058adb944cabe6367d070c01546~tplv-k3u1fbpfcp-watermark.image?)

这些注入的依赖如果没有的话，创建对象时会报错。但如果它是可选的，你可以用 @Optional 声明一下，这样没有对应的 provider 也能正常创建这个对象。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9742d2a930b47018c07a627b57cfdb3~tplv-k3u1fbpfcp-watermark.image?)

如果模块被很多地方都引用，为了方便，可以用 @Global 把它声明为全局的，这样它 exports 的 provider 就可以直接注入了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16ce92233e484b4e974c9af63f24a8bc~tplv-k3u1fbpfcp-watermark.image?)

filter 是处理抛出的未捕获异常的，通过 @Catch 来指定处理的异常：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cd95a5fb6b44d17869c3ae45fda9467~tplv-k3u1fbpfcp-watermark.image?)

然后通过 @UseFilters 应用到 handler 上：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f824522eee2d4c9f96b38b1784879280~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73b48391b96245438e60872b913d5108~tplv-k3u1fbpfcp-watermark.image?)

除了 filter 之外，interceptor、guard、pipe 也是这样用：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54b937a0d54a40a19b81624eb8e82a1b~tplv-k3u1fbpfcp-watermark.image?)

当然，pipe 更多还是单独在某个参数的位置应用：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fced92c2344495b86524871d8ed9cfa~tplv-k3u1fbpfcp-watermark.image?)

这里的 @Query 是取 url 后的 ?bbb=true，而 @Param 是取路径中的参数，比如 /xxx/111 种的 111

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f61a443880944b1bb1aff47d2e77e769~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/493ea39f11f1488ba3bd53dc6f4ee405~tplv-k3u1fbpfcp-watermark.image?)

此外，如果是 @Post 请求，可以通过 @Body 取到 body 部分：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a10d3521580a486ca1348b3f9b7bdde8~tplv-k3u1fbpfcp-watermark.image?)

我们一般用 dto 的 class 来接受请求体里的参数：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58338c7cc0634a388c58bde39f5bc8b6~tplv-k3u1fbpfcp-watermark.image?)

nest 会实例化一个 dto 对象：

用 postman 发个 post 请求：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a959786094d4690832d0af884921c12~tplv-k3u1fbpfcp-watermark.image?)

可以看到 nest 接受到了 body 里的参数：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bfb3d526abb4b478ccd3bc9988d486f~tplv-k3u1fbpfcp-watermark.image?)

除了 @Get、@Post 外，还可以用 @Put、@Delete、@Patch、@Options、@Head 装饰器分别接受 put、delete、patch、options、head 请求：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf5a32293fde40beb8e9f19d91e81329~tplv-k3u1fbpfcp-watermark.image?)

handler 和 class 可以通过 @SetMetadata 指定 metadata：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/937ac8e44f2d4fedb9818a0b6c8e70c5~tplv-k3u1fbpfcp-watermark.image?)

然后在 guard 或者 interceptor 里取出来：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27163078cd944d68b10c13068dc08145~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5971233494fb4a1bb6968501878dd66a~tplv-k3u1fbpfcp-watermark.image?)

你可以通过 @Headers 装饰器取某个请求头 或者全部请求头：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59578d6bc6a64764a276c3fb8abbb1e8~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/583883749dc14df0b5d1ed7efbffee1c~tplv-k3u1fbpfcp-watermark.image?)

通过 @Ip 拿到请求的 ip：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dadc94181774a94aa3913d8d793909f~tplv-k3u1fbpfcp-watermark.image?)

通过 @Session 拿到 session 对象：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f8c71364e3849e3b6fd1b9b9dacaeea~tplv-k3u1fbpfcp-watermark.image?)

但要使用 session 需要安装一个 express 中间件：

    npm install express-session

在 main.ts 里引入并启用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5971294374b641c7b099f95471b4f6e6~tplv-k3u1fbpfcp-watermark.image?)

指定加密的密钥和 cookie 的存活时间。

然后刷新页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d3b62447a4041e6b9f666da1d8e2705~tplv-k3u1fbpfcp-watermark.image?)

会返回 set-cookie 的响应头，设置了 cookie，包含 sid 也就是 sesssionid。

之后每次请求都会自动带上这个 cookie：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/466415bd1d9941a38053e08a61d53d89~tplv-k3u1fbpfcp-watermark.image?)

这样就可以在 session 对象里存储信息了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f5bb63a915e4218aa6e1a997e8e4db0~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83805b26ffed403fb45106412479d766~tplv-k3u1fbpfcp-watermark.image?)

@HostParam 用于取域名部分的参数：

我们再创建个 controller：

    nest g controller aaa --no-spec --flat

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a30b153d260842c4b0a21aa9ab37bd46~tplv-k3u1fbpfcp-watermark.image?)

这样指定 controller 的生效路径：

```javascript
import { Controller, Get, HostParam } from '@nestjs/common';

@Controller({ host: ':host.0.0.1', path: 'aaa' })
export class AaaController {
    @Get('bbb')
    hello() {
        return 'hello';
    }
}
```

controller 除了可以指定某些 path 生效外，还可以指定 host：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0acf98f2b82041df81cb8a7e92f639b2~tplv-k3u1fbpfcp-watermark.image?)

然后再访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44328d1d6d74a01914d0ac5187a8bc4~tplv-k3u1fbpfcp-watermark.image?)

这时候你会发现只有 host 满足 xx.0.0.1 的时候才会路由到这个 controller。

host 里的参数就可以通过 @HostParam 取出来：

```javascript
import { Controller, Get, HostParam } from '@nestjs/common';

@Controller({ host: ':host.0.0.1', path: 'aaa' })
export class AaaController {
    @Get('bbb')
    hello(@HostParam('host') host) {
        return host;
    }
}
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a059c8c10ae74b80862238fdf7935043~tplv-k3u1fbpfcp-watermark.image?)

前面取的这些都是 request 里的属性，当然也可以直接注入 request 对象：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f2bd6c37caf46b6b1e4b96f29e78291~tplv-k3u1fbpfcp-watermark.image?)

通过 @Req 或者 @Request 装饰器，这俩是同一个东西：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4041e1d300b14403bc05d1bc296829f4~tplv-k3u1fbpfcp-watermark.image?)

注入 request 对象后，可以手动取任何参数：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bfdaeb455a34a6a8d1bf655fdc979c4~tplv-k3u1fbpfcp-watermark.image?)

当然，也可以 @Res 或者 @Response 注入 response 对象，只不过 response 对象有点特殊：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0069b293e87e44a8af1df6a6150ff511~tplv-k3u1fbpfcp-watermark.image?)

当你注入 response 对象之后，服务器会一直没有响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a328cef97c9242fb8c2b93e50feb9b9c~tplv-k3u1fbpfcp-watermark.image?)

因为这时候 Nest 就不会再把 handler 返回值作为响应内容了。

你可以自己返回响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b22ecf0abbab49eca095d05d8a03644e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b940ec0f01b4a268b32ac10f7d15842~tplv-k3u1fbpfcp-watermark.image?)

Nest 这么设计是为了避免你自己返回的响应和 Nest 返回的响应的冲突。

如果你不会自己返回响应，可以通过 passthrough 参数告诉 Nest：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/404c6fe6d28947de89e1b94d3b535e5c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b940ec0f01b4a268b32ac10f7d15842~tplv-k3u1fbpfcp-watermark.image?)

除了注入 @Res 不会返回响应外，注入 @Next 也不会：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b696471d11644cc8dc4a07efd697546~tplv-k3u1fbpfcp-watermark.image?)

当你有两个 handler 来处理同一个路由的时候，可以在第一个 handler 里注入 next，调用它来把请求转发到第二个 handler：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f74e4f19b09e434496a5dfe35caedc66~tplv-k3u1fbpfcp-watermark.image?)

Nest 不会处理注入 @Next 的 handler 的返回值。

handler 默认返回的是 200 的状态码，你可以通过 @HttpCode 修改它：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7148d5f586494f9891b1d4a43cebc103~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2e4d8c9ee3b4598b6bfdd53f6d1c61d~tplv-k3u1fbpfcp-watermark.image?)

当然，你也可以修改 response header，通过 @Header 装饰器：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ce211852e9e4d5c9d9f954355f5c60b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ef498cad0d4670821b46eb64a12731~tplv-k3u1fbpfcp-watermark.image?)

此外，你还可以通过 @Redirect 装饰器来指定路由重定向的 url：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ee4edf4a78b4fb683fb4f48d91270a5~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d563d9e5836f49038f9ad7db40702f85~tplv-k3u1fbpfcp-watermark.image?)

或者在返回值的地方设置 url：

```javascript
@Get('xxx')
@Redirect()
async jump() {
    return {
      url: 'https://www.baidu.com',
      statusCode: 302
    }  
}
```

你还可以给返回的响应内容指定渲染引擎，不过这需要先这样设置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc3a9722af1467eb26f7b21f028abfe~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.useStaticAssets(join(__dirname, '..', 'public'));
  app.setBaseViewsDir(join(__dirname, '..', 'views'));
  app.setViewEngine('hbs');

  await app.listen(3000);
}
bootstrap();

```

分别指定静态资源的路径和模版的路径，并指定模版引擎为 handlerbars。

当然，还需要安装模版引擎的包 hbs：

    npm install --save hbs

然后准备图片和模版文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eab9c35c1534e2b9a173302480cda32~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5afa60e3c49c4ac7af3fe65f1f52a96c~tplv-k3u1fbpfcp-watermark.image?)

在 handler 里指定模版和数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd6047993244f07a6ac050aaf654573~tplv-k3u1fbpfcp-watermark.image?)

就可以看到渲染出的 html 了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b59a367d570e4a5f84332ee02b8ac0d8~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/all-decorator)。

## 总结

这节我们梳理了下 Nest 全部的装饰器

*   @Module： 声明 Nest 模块
*   @Controller：声明模块里的 controller
*   @Injectable：声明模块里可以注入的 provider
*   @Inject：通过 token 手动指定注入的 provider，token 可以是 class 或者 string
*   @Optional：声明注入的 provider 是可选的，可以为空
*   @Global：声明全局模块
*   @Catch：声明 exception filter 处理的 exception 类型
*   @UseFilters：路由级别使用 exception filter
*   @UsePipes：路由级别使用 pipe
*   @UseInterceptors：路由级别使用 interceptor
*   @SetMetadata：在 class 或者 handler 上添加 metadata
*   @Get、@Post、@Put、@Delete、@Patch、@Options、@Head：声明 get、post、put、delete、patch、options、head 的请求方式
*   @Param：取出 url 中的参数，比如 /aaa/:id 中的 id
*   @Query: 取出 query 部分的参数，比如 /aaa?name=xx 中的 name
*   @Body：取出请求 body，通过 dto class 来接收
*   @Headers：取出某个或全部请求头
*   @Session：取出 session 对象，需要启用 express-session 中间件
*   @HostParm： 取出 host 里的参数
*   @Req、@Request：注入 request 对象
*   @Res、@Response：注入 response 对象，一旦注入了这个 Nest 就不会把返回值作为响应了，除非指定 passthrough 为true
*   @Next：注入调用下一个 handler 的 next 方法
*   @HttpCode： 修改响应的状态码
*   @Header：修改响应头
*   @Redirect：指定重定向的 url
*   @Render：指定渲染用的模版引擎

把这些装饰器用熟，就掌握了 nest 大部分功能了。


## 100.Nest 如何实现国际化？

如果你的网站要支持多种语言访问，那就要做国际化。

也就是中文用户访问返回中文界面，英文用户访问返回英文界面。

如果你在外企，那可能经常要做这些，比如我在韩企的时候，要支持韩文、英文，在日企的时候，要支持日文、英文。

不只是前端要做国际化，后端也要做，不然英文用户用着英文的界面登录的时候，突然返回一个“用户不存在”的错误，是不是一脸懵逼？

今天我们就来学一下 Nest 如何实现国际化。

Nest 里做国际化用 [nestjs-i18n](https://www.npmjs.com/package/nestjs-i18n) 这个包：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9faf1d3a9f774c5880e13a926b01583e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2448&h=1110&s=277787&e=png&b=ffffff)

我们来试一下：

```
nest new i18n-test
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd6d1eff0419492ab013d0b9fab27082~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=584&s=350868&e=png&b=fefefe)

安装 nestjs-i18n：

```
npm install --save nestjs-i18n
```

在 AppModule 引入 I18nModule：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { I18nModule, QueryResolver } from 'nestjs-i18n';
import * as path from 'path';

@Module({
  imports: [
    I18nModule.forRoot({
      fallbackLanguage: 'en',
      loaderOptions: {
        path: path.join(__dirname, '/i18n/'),
        watch: true,
      },
      resolvers: [
        new QueryResolver(["lang", "l"]),
      ]
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
默认语言是 en，然后资源包在 i18n 目录下。

resolver 也就是从哪里读取当前语言信息，这里是从 query 中读取，比如 ?lang=en、?l=zh

我们添加一下资源包：

i18n/en/test.json
```json
{
    "hello": "Hello World"
}
```

i18n/zh/test.json

```json
{
    "hello": "你好世界"
}
```

这里的国际化资源包要在 nest-cli.json 里配置下自动复制：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e64dcfd66198407db8bdf1e2c7c3d2d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=988&h=512&s=73876&e=png&b=1f1f1f)

```json
"assets": [
  { "include": "i18n/**/*", "watchAssets": true }
]
```

然后改下 AppService：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { I18nContext, I18nService } from 'nestjs-i18n';

@Injectable()
export class AppService {

  @Inject()
  i18n: I18nService;

  getHello(): string {
    return this.i18n.t('test.hello', { lang: I18nContext.current().lang })
  }
}
```
注入 I18nService，从资源包中取 test.hello 的值，也就是对应 test.json 里的 hello 的值，用当前的语言。

把服务跑起来：

```
npm run start:dev
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74a20169c1f34a7284d510e93a2ecf58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1604&h=394&s=142757&e=png&b=181818)

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df0739f9673e4e6d8c378b808acb5204~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=666&h=232&s=19328&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4dda52d62f24b07b08046c039055993~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=672&h=234&s=20889&e=png&b=ffffff)

可以看到，文案根据语言环境做了国际化。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0081d2a6f54b8f958d7033df709b06~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1834&h=1014&s=228999&e=png&b=1f1f1f)

还有其他 resolver，比如根据自定义 header、cookie、accepet-language 的 header 等。

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AcceptLanguageResolver, CookieResolver, HeaderResolver, I18nModule, QueryResolver } from 'nestjs-i18n';
import * as path from 'path';

@Module({
  imports: [
    I18nModule.forRoot({
      fallbackLanguage: 'en',
      loaderOptions: {
        path: path.join(__dirname, '/i18n/'),
        watch: true,
      },
      resolvers: [
        new QueryResolver(["lang", "l"]),
        new HeaderResolver(["x-custom-lang"]),
        new CookieResolver(['lang']),
        AcceptLanguageResolver,
      ]
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
我们试一下 cookie：

在 postman 里访问，添加一个 cookie：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d783876fb2e54190b628b0f53336d37d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1694&h=920&s=102721&e=png&b=fefefe)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66391fbf262d4e2fb125000d3037ab4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1772&h=1464&s=103106&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d3073ca52394728b2f36a24b4970577~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1656&h=876&s=85534&e=png&b=f9f9f9)

再访问就变成了中文的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61dc3d86dd2743c58014cc4d82a52602~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=654&s=68114&e=png&b=fdfdfd)

有的同学可能问了，现在是用 I18nService 做的翻译，那不在 IoC 容器里的类，怎么翻译呢？

比如 dto：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595877fedcf24d8a82748092cf7a565b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1036&h=1114&s=159542&e=png&b=1f1f1f)

它并不在 IoC 容器里，没法注入 I18nService，怎么翻译这些文案呢？

这时候可以用专门的 Pipe。

我们加一个模块：

```
nest g resource user
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57914fe2f4554ba4958f9865de31406c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1058&h=466&s=122685&e=png&b=181818)

安装 dto 验证用的包：

```
npm install --save class-validator class-transformer
```

改一下 CreateUserDto：

```javascript
import { IsNotEmpty, MinLength } from "class-validator";

export class CreateUserDto {
    @IsNotEmpty({
        message: "用户名不能为空"
    })
    username: string;
    
    @IsNotEmpty({
        message: '密码不能为空'
    })
    @MinLength(6, {
        message: '密码不能少于 6 位'
    })
    password: string;
                    
}
```

校验 body 的错误需要全局启用 ValidationPipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73643f732d294c1d98add9d41cbae9bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=498&s=101599&e=png&b=1f1f1f)

```javascript
app.useGlobalPipes(new ValidationPipe());
```
访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc4d50c68b0e4299b40dffabbef88178~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=974&h=894&s=108943&e=png&b=fdfdfd)

如果是英文网站，需要返回英文的错误信息，但是 dto 不在 IoC 容器里，不能注入 I18nService，怎么办呢？

这时候可以用 nestjs-i18n 提供的 I18nValidationPipe 来替换 ValidationPipe。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb0c3172f064f90803816c664066a9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1334&h=640&s=136970&e=png&b=1f1f1f)

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { I18nValidationExceptionFilter, I18nValidationPipe } from 'nestjs-i18n';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalPipes(new I18nValidationPipe());

  app.useGlobalFilters(new I18nValidationExceptionFilter({
    detailedErrors: false
  }));

  await app.listen(3000);
}
bootstrap();
```
然后把 message 改为资源的 key：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9902db4009a74318a82353ae07209fc2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1002&h=646&s=103255&e=png&b=1f1f1f)

访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e11cf0e3dbc642ac805386963b737ee4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1026&h=890&s=104185&e=png&b=fdfdfd)

可以看到，key 被替换成了具体的文案。

把 cookie 里的 lang 改为 en：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2df78660c8a45d5b9c20b9713ae741a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1632&h=962&s=86864&e=png&b=f9f9f9)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a87d5189204fd78b954f92f08afc81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1336&h=888&s=119979&e=png&b=fefefe)

文案也换成了英文。

那接下来我们只要添加对应的资源包就可以了。

添加 i18n/zh/validate.json

```json
{
    "usernameNotEmpty": "用户名不能为空",
    "passwordNotEmpty": "密码不能为空",
    "passwordNotLessThan6": "密码不能少于 6 位"
}
```
i18n/en/validate.json
```json
{
    "usernameNotEmpty": "The username cannot be empty",
    "passwordNotEmpty": "Password cannot be empty",
    "passwordNotLessThan6": "The password cannot be less than 6 characters"
}
```
然后改下 dto 里的 message，换成资源的 key：

```javascript
import { IsNotEmpty, MinLength } from "class-validator";

export class CreateUserDto {
    @IsNotEmpty({
        message: "validate.usernameNotEmpty"
    })
    username: string;
    
    @IsNotEmpty({
        message: 'validate.passwordNotEmpty'
    })
    @MinLength(6, {
        message: 'validate.passwordNotLessThan6'
    })
    password: string;                    
}
```

再次访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c7a1eb880249ddbc853b1bf2089f45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=916&s=129635&e=png&b=fefefe)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76345cc215b34ea8a7665f5f89c138be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1632&h=962&s=86864&e=png&b=f9f9f9)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6c7049f525c4b24b4f5e3a93f2b6cd9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=840&h=892&s=102889&e=png&b=fdfdfd)

中文环境返回中文文案、英文环境返回英文文案，这样就实现了国际化。

那如果这个密码位数不一定是 6 位呢？

文案里可以填占位符：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9348b4b337514c8b831b5f23fd5fdf3e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=916&h=274&s=52508&e=png&b=202020)

然后用的时候传入参数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d48b5db4e9ca4628930b4105580800a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1230&h=750&s=141877&e=png&b=1f1f1f)

```javascript
@MinLength(6, {
    message: i18nValidationMessage("validate.passwordNotLessThan6", {
        num: 88
    })
})
```
试一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e4b0f2ea4694f8da9c7dfc82cae1f6c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=974&h=928&s=110196&e=png&b=fdfdfd)

I18nService 的 api 同样支持这个：

加一下占位符：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd70859382a24e1e94aea05153727063~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=622&h=208&s=23116&e=png&b=1f1f1f)

然后用的时候传入 args：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { I18nContext, I18nService } from 'nestjs-i18n';

@Injectable()
export class AppService {

  @Inject()
  i18n: I18nService;

  getHello(): string {
    return this.i18n.t('test.hello', {
      lang: I18nContext.current().lang,
      args: {
        name: 'guang'
      }
    })
  }
}
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb83c9a4c1544bba6bff65953f9d578~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=576&s=58124&e=png&b=fdfdfd)

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/i18n-test)

## 总结

当你的应用需要支持多种语言环境的用户访问时，就要做国际化。

前端要做界面的国际化，后端也同样要做返回的信息的国际化。

nest 里我们用 nestjs-i18n 这个包，在 AppModule 里引入 I18nModule，指定资源包的路径，resolver（取 lang 配置的方式）。

然后就可以注入 I18nSerive，用它的 t 方法来取资源包中的文案了。

dto 的国际化需要全局启用 I18nValidationPipe 和 I18nValidationExceptionFilter，然后把 message 换成资源包的 key 就好了。

文案支持占位符，可以在资源包里写 {xxx} 然后用的时候传入 xxx 的值。

如果你做一个面向多种语言用户的网站，那么国际化功能是必不可少的。


## 101.会议室预订系统：需求分析和原型图

在公司里开会，需要先预定会议室，这时候就会用到会议室预订系统。

我们第一个项目实战就来做这个系统吧。

这节来分析下需求：

首先，用户分为普通用户和管理员两种，各自有不同的功能。

普通用户可以注册，注册的时候会发邮件来验证身份，注册之后就可以登录系统了。

管理员账号密码是内置的，不需要注册。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/906d4fbf82004b8d98db97b4fcf85086~tplv-k3u1fbpfcp-watermark.image?)

普通用户可以查看会议室列表、搜索可用会议室、提交预订申请、取消预订、查看预订历史等。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9596890a69e44ce7956ad0667e000468~tplv-k3u1fbpfcp-watermark.image?)

预订成功会邮件通知，就是注册时的那个邮箱。

如果管理员一直没审批，可以催办。

管理员可以查看用户列表、冻结用户、会议室列表、搜索会议室、添加/修改/删除会议室、审批预订申请、查看会议室统计信息等。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4d405db23da46e2982f7b4404c2125a~tplv-k3u1fbpfcp-watermark.image?)

整体分为用户管理、会议室管理、预订管理、统计这 4 部分。

如果超过 10 分钟没审批，会发送邮件提醒管理员，如果超过半个小时没审批，会发送短信。

管理员可以解除用户的预订，释放会议室。

冻结用户是指把用户设置为冻结状态，冻结状态的用户不能预订会议室。

统计模块会按照会议室维度和用户维度进行统计，并报表展示。

这些功能涉及到用户端和后台管理两套前端界面。

用户端原型图如下：

### 用户端--登录

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b03c3012fd17481da7107e7e8a990507~tplv-k3u1fbpfcp-watermark.image?)

可以用用户名 + 密码登录。

### 用户端--注册

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a64b198da4c4bdc84a701b87323b74e~tplv-k3u1fbpfcp-watermark.image?)

注册要填入用户名（唯一）、昵称、密码、邮箱，还会发送邮箱验证码。

### 用户端--修改密码

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c114411bf1274e2a9f202d5188ebf55a~tplv-k3u1fbpfcp-watermark.image?)

修改密码也需要邮箱验证。

### 用户端--会议室列表

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a6f760e036d49bab8ff8191b8c5a8ff~tplv-k3u1fbpfcp-watermark.image?)

按照分页搜索会议室信息，可以指定名字、容纳人数、位置、设备来搜索。

### 用户端--预订会议室

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aec8133e2c664fbd994723b540716370~tplv-k3u1fbpfcp-watermark.image?)

填入开始时间、结束时间，参会人员等，就可以预定了。

### 用户端--预订历史

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6fbf9ffe01419eaf44bf0eca5b3e6f~tplv-k3u1fbpfcp-watermark.image?)

可以查看预订申请的历史，审核状态等，可以撤销预订，也可以催办。

### 用户端--个人信息修改

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32f66ca20c2e4c98b95b7f9bf5e80cc2~tplv-k3u1fbpfcp-watermark.image?)

可以修改个人信息，比如头像、昵称、邮箱等，修改了邮箱需要验证码验证。

**总之，用户注册账号后，可以登录系统，搜索会议室，提交预订申请，查看预订历史。也可以修改个人信息。**

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6082cea7db14f7bbbea0f268b81035b~tplv-k3u1fbpfcp-watermark.image?)

接下来是后台管理部分：

### 后台管理--登录

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5832a873c53249d1b7dca93604a78024~tplv-k3u1fbpfcp-watermark.image?)
管理员通过用户名 + 密码登录。

### 后台管理--预订管理

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0653717aa7840af923ba84eb9fae146~tplv-k3u1fbpfcp-watermark.image?)

管理员可以通过、驳回、解除预订信息。解除预订就是已经通过审核的预订在这里手动解除。

### 后台管理--会议室管理

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1794ecbb9564d5fb3fe5daee2fc6f9a~tplv-k3u1fbpfcp-watermark.image?)

管理员可以对搜索会议室，查看会议室信息、删除会议室。

## 后台管理--会议室添加/修改

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3114dba5c0d49ac8b24936c8115f7da~tplv-k3u1fbpfcp-watermark.image?)

管理员可以添加修改会议室。


### 后台管理--用户管理

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f73b4f9b2d47b2800069207a205831~tplv-k3u1fbpfcp-watermark.image?)

管理员可以查看用户信息、冻结用户。冻结状态的用户不能预订会议室。

### 后台管理--统计

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0df7c49dbb84b33a6589816a68e619a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e83c09ddcd54e2a997f083784154baa~tplv-k3u1fbpfcp-watermark.image?)

可以分别统计会议室使用频率、用户预订频率等，图表类型可以切换。

### 后台管理--信息修改
 
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d46f08ea894a4c3096bb6999e9aa49c7~tplv-k3u1fbpfcp-watermark.image?)

管理员可以修改个人信息，如果改了邮箱需要验证。

### 后台管理--密码修改

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba086b9a407b469fbc79517adeb22ce1~tplv-k3u1fbpfcp-watermark.image?)

管理员可以修改密码，不过需要邮箱验证。

**管理员登录系统后，可以管理用户、管理会议室、管理预订、查看会议室的使用统计等。**

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb40691995584b6eab431ab3afc43065~tplv-k3u1fbpfcp-watermark.image?)

## 总结

这节我们分析了会议室预订系统的需求，并画了用例图、原型图。

很多功能的设计并不唯一：比如会议室需不需要先提申请、让管理员审批？用户信息管理员是否可以修改？

这些与具体需求有关，没有对错，都是可以的。

需求确定了之后，下一节我们就开始分析技术层面的实现方案。


## 102.会议室预订系统：技术方案和数据库设计

上节我们梳理了有哪些需求，并且画了原型图，明确了要做什么。

这节我们来过一下技术方案，设计下数据库，也就是怎么做。

## 技术栈

我们要做的是一个全栈项目，前端用 React + AntD （或者可以换成其他前端框架），后端用 Nest。

技术栈如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a31317feed0415eb61ae2648f3aa946~tplv-k3u1fbpfcp-watermark.image?)

前端使用 create-react-app 脚手架创建项目，使用 react + antd 开发页面。

使用 nginx 来网关层，实现静态资源的托管，并且对于动态资源请求做负载均衡。

使用 Nest 开发后端业务逻辑，使用 TypeORM + mysql 来做 CRUD。

使用 Redis 来做缓存，减轻数据库的压力，提高响应性能。

api 文档使用 Swagger 来生成。

部署使用 Docker Compose 的方式。

PM2 可用可不用，不用 PM2 就要启动容器的时候指定重启策略了，这里为了简单我们还是用 PM2。

都是前面讲过的技术，这里只是综合运用。

然后来设计下数据库：

## 数据库设计

首先是用户表 users：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 用户ID |
| username | VARCHAR(50) |用户名 |
| password | VARCHAR(50) |密码 |
| nick_name | VARCHAR(50) |昵称 |
| email | VARCHAR(50) | 邮箱 |
| head_pic| VARCHAR(100) | 头像 |
| phone_number| VARCHAR(20) | 手机号 |
| is_frozen| BOOLEAN | 是否被冻结 |
| is_admin| BOOLEAN | 是否是管理员 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

用户需要区分普通用户和管理员，所以加了个 is_admin 字段。

然后是会议室表 meeting_rooms：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 会议室ID |
| name | VARCHAR(50) |会议室名字 |
| capacity | INT |会议室容量 |
| location | VARCHAR(50) |会议室位置 |
| equipment | VARCHAR(50) | 设备 |
| description | VARCHAR(100) | 描述 |
| is_booked | BOOLEAN | 是否被预订 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

接下来是预订表 bookings：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 预订ID |
| user_id | INT |预订用户ID |
| room_id | INT |会议室ID |
| start_time | DATETIME | 会议开始时间 |
| end_time | DATETIME | 会议结束时间 |
| status | VARCHAR(20) | 状态（申请中、审批通过、审批驳回、已解除） |
| note | VARCHAR(100) | 备注 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |
 
然后是预订-参会人表 booking_attendees：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| user_id | INT |参会用户ID |
| booking_id | INT |预订ID |

这几个表的关系如下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb13cbbd6dda4c8e95e46aeea52b21c5~tplv-k3u1fbpfcp-watermark.image?)

再加上角色表、权限表，还有 2 个中间表：

角色表 roles

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| name | VARCHAR(20) | 角色名 |

权限表 permissions

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| code | VARCHAR(20) | 权限代码 |
| description | VARCHAR(100) | 权限描述 |

用户-角色中间表 user_roles

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| user_id | INT | 用户 ID |
| role_id | INT | 角色 ID |

角色-权限中间表 role_permissions

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| role_id | INT | 角色 ID |
| permission_id | INT | 权限 ID |

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/698725b25d9843af8e5f41691830054e~tplv-k3u1fbpfcp-watermark.image?)

设计完数据库，我们再来划分下模块：

## 模块划分

首先是用户模块，实现普通用户和管理员的登录、注册、信息修改的功能：

大概有这些接口：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /user/login | POST | 普通用户登录 |
| /user/register | POST | 普通用户注册 |
| /user/update | POST | 普通用户个人信息修改|
| /user/update_password | POST |普通用户修改密码|
| /user/admin/login | POST | 管理员登录|
| /user/admin/update_password| POST |管理员修改密码|
| /user/admin/update | POST | 管理员个人信息修改|
| /user/list | GET |用户列表|
| /user/freeze | GET | 冻结用户|

然后是会议室管理模块：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /meeting_room/list | GET | 会议室列表 |
| /meeting_room/delete/:id | DELETE | 会议室删除 |
| /meeting_room/update/:id | PUT |会议室更新|
| /meeting_room/create | POST |会议室新增|
| /meeting_room/search | GET |会议室搜索|

然后是预订管理模块：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /booking/list | GET | 预订列表 |
| /booking/approve | POST| 审批预订申请 |
| /booking/add | POST |申请预订|
| /booking/apply/:id | GET |通过预订|
| /booking/reject/:id | GET |取消预订|
| /booking/unbind/:id | GET |解除预订|
| /booking/history | GET|预订历史 |
| /booking/urge | GET |催办 |

然后是统计模块：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /statistics/meeting_room_usage_frequency | GET |  会议室使用频率统计 |
| /statistics/user_booking_frequency | GET | 用户预订频率统计 |

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0d69f1729d4a2eb689446c2e7179c3~tplv-k3u1fbpfcp-watermark.image?)

## 角色划分

权限控制使用 RBAC 的方式，有普通用户和管理员两个角色，

两个角色各自可以操作的接口就是上节用例图画的那些：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c9a82600a748f0aa322086e26ad363~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf790f3bbf44c5fa8cc2bc9b46fd14c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b7490fc6316448b94ab6fcbd54c4a7f~tplv-k3u1fbpfcp-watermark.image?)

## 总结

这节我们设计了下技术方案。

技术栈：前端是 antd + react + cra，后端是 nest + typeorm，数据库是 mysql + redis，API 文档用 swagger 生成，部署用 docker compose + pm2，网关使用 nginx。

数据库表有 8 个：用户表 users、会议室表 meeting_rooms、预订表 bookings、预订-参会者表 booking_attendees、角色表 roles、权限表 permissions、用户-角色表 user_roles、角色-权限表 role_permissions。

模块有 4 个：用户管理模块、会议室管理模块、预订管理模块、统计管理模块。

角色有两个：普通用户、管理员，各自拥有的权限按照用例图来。使用 RBAC 来控制接口访问权限。

技术方案确定之后，下节开始我们就正式进入开发了。


## 103.会议室预订系统：用户管理模块--用户注册

前两节我们理清了需求、画了原型图，并且确定了技术选型、设计了数据库，划分了接口和模块。

这节我们正式开始写代码。

首先创建个 nest 项目：

```
nest new meeting_room_booking_system_backend
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca0adc9f3e74e35a69440442e9474ce~tplv-k3u1fbpfcp-watermark.image?)

在 docker desktop 里把 mysql 的容器跑起来：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f88a32bf05364377b78fa25ca8a5f49d~tplv-k3u1fbpfcp-watermark.image?)

详细过程可以看 [mysql 的第一篇](https://juejin.cn/book/7226988578700525605/section/7228944127025479738)。

安装 typeorm 相关的包：

```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [ 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "meeting_room_booking_system",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
在 mysql workbench 里创建这个 database

```
CREATE DATABASE meeting_room_booking_system DEFAULT CHARACTER SET utf8mb4;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a76cd0d46244b40bb4860e9183f64da~tplv-k3u1fbpfcp-watermark.image?)

刷新可以看到这个 database

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c85b2a150b4d1a99673ce30a3ca33c~tplv-k3u1fbpfcp-watermark.image?)

用户模块涉及到这些表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5155677421f4b0cbd3afeba49200f03~tplv-k3u1fbpfcp-watermark.image?)

我们创建下它们的 entity：

先在 nest-cli.json 里添加 generateOptions，设置 spec 为 false

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10f482ea683e4e8ca88e7c0cd76e148e~tplv-k3u1fbpfcp-watermark.image?)

这样生成代码的时候不会生成测试代码，和 nest g xxx --no-spec 效果一样

生成 user 模块：

```
nest g resource user
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bb13dd8246a437c9f489f75523d65dd~tplv-k3u1fbpfcp-watermark.image?)

确实没有生成测试代码。

然后我们添加个 src/user/entities 目录，新建 3 个实体 User、Role、Permission。

按照上节的表格来创建就好：

用户表：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 用户ID |
| username | VARCHAR(50) |用户名 |
| password | VARCHAR(50) |密码 |
| nick_name | VARCHAR(50) |昵称 |
| email | VARCHAR(50) | 邮箱 |
| head_pic| VARCHAR(100) | 头像 |
| phone_number| VARCHAR(20) | 手机号 |
| is_frozen| BOOLEAN | 是否被冻结 |
| is_admin| BOOLEAN | 是否是管理员 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |
角色表 roles

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| name | VARCHAR(20) | 角色名 |

权限表 permissions

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| code | VARCHAR(20) | 权限代码 |
| description | VARCHAR(100) | 权限描述 |

用户-角色中间表 user_roles

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| user_id | INT | 用户 ID |
| role_id | INT | 角色 ID |

角色-权限中间表 role_permissions

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT |  ID |
| role_id | INT | 角色 ID |
| permission_id | INT | 权限 ID |

也就是这样：

```javascript
import { Column, CreateDateColumn, Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";
import { Role } from "./role.entity";

@Entity({
    name: 'users'
})
export class User {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50,
        comment: '用户名'
    })
    username: string;

    @Column({
        length: 50,
        comment: '密码'
    })
    password: string;

    @Column({
        name: 'nick_name',
        length: 50,
        comment: '昵称'
    })
    nickName: string;


    @Column({
        comment: '邮箱',
        length: 50
    })
    email: string;


    @Column({
        comment: '头像',
        length: 100,
        nullable: true
    })
    headPic: string;

    @Column({
        comment: '手机号',
        length: 20,
        nullable: true
    })
    phoneNumber: string;

    @Column({
        comment: '是否冻结',
        default: false
    })
    isFrozen: boolean;

    @Column({
        comment: '是否是管理员',
        default: false
    })
    isAdmin: boolean;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;

    @ManyToMany(() => Role)
    @JoinTable({
        name: 'user_roles'
    })
    roles: Role[] 
}

```

```javascript
import { Column, CreateDateColumn, Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";
import { Permission } from "./permission.entity";

@Entity({
    name: 'roles'
})
export class Role {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 20,
        comment: '角色名'
    })
    name: string;

    @ManyToMany(() => Permission)
    @JoinTable({
        name: 'role_permissions'
    })
    permissions: Permission[] 
}
```
```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity({
    name: 'permissions'
})
export class Permission {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 20,
        comment: '权限代码'
    })
    code: string;

    @Column({
        length: 100,
        comment: '权限描述'
    })
    description: string;
}
```

在 entities 里引入下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fa0945e90c7471b871e7d9bdf738404~tplv-k3u1fbpfcp-watermark.image?)

然后把项目跑起来：

```
npm run start:dev
```
正好是 5 条建表 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc10ab387cb84819a04b3a455098177c~tplv-k3u1fbpfcp-watermark.image?)

我们去数据库看下：

users 表没啥问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae391c596d304bbca8a59d0c1b9899ad~tplv-k3u1fbpfcp-watermark.image?)

要注意的是 mysql 里没有 boolean 类型，使用 TINYINT 实现的，用 1、0 存储 true、false。

typeorm 会自动把它映射成 true、false。

然后是 roles 表：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/154e793e28794359b1f9457f9e55c50e~tplv-k3u1fbpfcp-watermark.image?)

permissions 表：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e5c9ed1b8974ac181b51a0270b948ed~tplv-k3u1fbpfcp-watermark.image?)

还有两个中间表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b4b2f150c544913ae59d4682a39fc82~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682e3851f5c64e4f8611c24c4f5f198e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c140a7f5a9c54f87a4536609b15a4073~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84e5991695374e52b3d055f15e1c828b~tplv-k3u1fbpfcp-watermark.image?)

没啥问题，外键也都是对的。

接下来就可以实现接口了。

上节我们列了 user 模块有这些接口：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /user/login | POST | 普通用户登录 |
| /user/register | POST | 普通用户注册 |
| /user/update | POST | 普通用户个人信息修改|
| /user/update_password | POST |普通用户修改密码|
| /user/admin/login | POST | 管理员登录|
| /user/admin/update_password| POST |管理员修改密码|
| /user/admin/update | POST | 管理员个人信息修改|
| /user/list | GET |用户列表|
| /user/freeze | GET | 冻结用户|

我们分别来实现下。

先实现下注册：

在 UserController 增加一个 post 接口：

```javascript
@Post('register')
register(@Body() registerUser: RegisterUserDto) {
    console.log(registerUser);
    return "success"
}
```
dto 是封装 body 里的请求参数的，根据界面上要填的信息，创建 RegisterUserDto：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099301a7951e4b27b1d20e46c1eecd7c~tplv-k3u1fbpfcp-watermark.image?)

```javascript
export class RegisterUserDto {

    username: string;
    
    nickName: string;
    
    password: string;
    
    email: string;
    
    captcha: string;
}

```

在 postman 里调用下试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/636b2472f517431aa4f7c0110620ba5f~tplv-k3u1fbpfcp-watermark.image?)
```javascript
{
    "username": "guang",
    "nickName": "神说要有光",
    "password": "123456",
    "email": "xxxx@xx.com",
    "captcha": "abc123"
}
```
服务端也接收到了 body 里的数据，并创建了对应的 dto 对象：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1a38f3360364ddbb2b884bb44af12fb~tplv-k3u1fbpfcp-watermark.image?)

然后加一下 ValidationPipe，来对请求体做校验。

安装用到的包：

```
npm install --save class-validator class-transformer
```

全局启用 ValidationPipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d3f39712c6f469ba987c119d271b92b~tplv-k3u1fbpfcp-watermark.image?)

然后加一下校验规则：

```javascript
import { IsEmail, IsNotEmpty, MinLength } from "class-validator";

export class RegisterUserDto {

    @IsNotEmpty({
        message: "用户名不能为空"
    })
    username: string;
    
    @IsNotEmpty({
        message: '昵称不能为空'
    })
    nickName: string;
    
    @IsNotEmpty({
        message: '密码不能为空'
    })
    @MinLength(6, {
        message: '密码不能少于 6 位'
    })
    password: string;
    
    @IsNotEmpty({
        message: '邮箱不能为空'
    })
    @IsEmail({}, {
        message: '不是合法的邮箱格式'
    })
    email: string;
    
    @IsNotEmpty({
        message: '验证码不能为空'
    })
    captcha: string;
}
```
测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb954318be2a442b90515d8b943385e1~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e12c35e3721f486ba001d8b580f930e3~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

然后实现注册的逻辑。

在 userService 里添加 register 方法：

```javascript
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { md5 } from 'src/utils';
import { Repository } from 'typeorm';
import { RegisterUserDto } from './dto/register-user.dto';
import { User } from './entities/user.entity';

@Injectable()
export class UserService {
    private logger = new Logger();

    @InjectRepository(User)
    private userRepository: Repository<User>;

    async register(user: RegisterUserDto) {
        
    }
}
```

创建 logger 对象，注入 Repository\<User>。
    
这里注入 Repository 需要在 UserModule 里引入下 TypeOrm.forFeature

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/766df7c2d54345f2b3423b6463f66f27~tplv-k3u1fbpfcp-watermark.image?)

注册的逻辑是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fca11ff8154b31bf76cc2cea3d908a~tplv-k3u1fbpfcp-watermark.image?)

我们需要先封装个 redis 模块。

```
nest g module redis
nest g service redis
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ab411fe9be34d3fab2e52c9e4dbec08~tplv-k3u1fbpfcp-watermark.image?)

安装 redis 的包：

```
npm install --save redis
```
确保 redis 的 docker 容器是启动的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e7584c6b664f13b8521c1a3db3c342~tplv-k3u1fbpfcp-watermark.image?)

添加连接 redis 的 provider

```javascript
import { Global, Module } from '@nestjs/common';
import { RedisService } from './redis.service';
import { createClient } from 'redis';

@Global()
@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            },
            database: 1
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```
这里用 @Global() 把它声明为全局模块，这样只需要在 AppModule 里引入，别的模块不用引入也可以注入 RedisService 了。

database 指定为 1，因为我们之前都是用的默认的 0

redis 的 database 就是一个命名空间的概念：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/883238ac1aee4223bd114c87e6539551~tplv-k3u1fbpfcp-watermark.image?)

把存储的 key-value 的数据放到不同命名空间下，避免冲突。

然后写下 RedisService

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async get(key: string) {
        return await this.redisClient.get(key);
    }

    async set(key: string, value: string | number, ttl?: number) {
        await this.redisClient.set(key, value);

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```

注入 redisClient，实现 get、set 方法，set 方法支持指定过期时间。

然后回过头来继续实现 register 方法。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fca11ff8154b31bf76cc2cea3d908a~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Inject(RedisService)
private redisService: RedisService;

async register(user: RegisterUserDto) {
    const captcha = await this.redisService.get(`captcha_${user.email}`);

    if(!captcha) {
        throw new HttpException('验证码已失效', HttpStatus.BAD_REQUEST);
    }

    if(user.captcha !== captcha) {
        throw new HttpException('验证码不正确', HttpStatus.BAD_REQUEST);
    }

    const foundUser = await this.userRepository.findOneBy({
      username: user.username
    });

    if(foundUser) {
      throw new HttpException('用户已存在', HttpStatus.BAD_REQUEST);
    }

    const newUser = new User();
    newUser.username = user.username;
    newUser.password = md5(user.password);
    newUser.email = user.email;
    newUser.nickName = user.nickName;

    try {
      await this.userRepository.save(newUser);
      return '注册成功';
    } catch(e) {
      this.logger.error(e, UserService);
      return '注册失败';
    }
}
```
根据流程图，很容易写出注册的实现逻辑。

这里的 md5 方法放在 src/utils.ts 里，用 node 内置的 crypto 包实现。
```javascript
import * as crypto from 'crypto';

export function md5(str) {
    const hash = crypto.createHash('md5');
    hash.update(str);
    return hash.digest('hex');
}
```
在 controller 里调用下：

```javascript
@Post('register')
async register(@Body() registerUser: RegisterUserDto) {    
    return await this.userService.register(registerUser);
}
```

然后 postman 里测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1c150a682894387b7db7e86c9ed0555~tplv-k3u1fbpfcp-watermark.image?)

因为还没实现发送邮箱验证码的逻辑，这里我们手动在 redis 添加一个 key：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1372a1d3c0641dabbe1c442f6c0075a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595e2e90f5054069afdc95bda2ef376f~tplv-k3u1fbpfcp-watermark.image?)

测试下：

带上错误的验证码，返回验证码不正确；

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b8a22cf35184fabbd877f0a14857b0d~tplv-k3u1fbpfcp-watermark.image?)

带上正确的验证码，返回注册成功：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/053d568e56594e30ab723649af608661~tplv-k3u1fbpfcp-watermark.image?)

这时可以在数据库里看到这条记录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80c739ee88504e5c9b8ab7a8b8878410~tplv-k3u1fbpfcp-watermark.image?)

这就代表注册成功了。

然后我们来实现发送邮箱验证码的功能。

封装个 email 模块：

```
nest g resource email
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/659eefe03f764e3d89faf41ed204b971~tplv-k3u1fbpfcp-watermark.image?)

安装发送邮件用的包：

```
npm install nodemailer --save
```
在 EmailService 里实现 sendMail 方法

```javascript
import { Injectable } from '@nestjs/common';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor() {
      this.transporter = createTransport({
          host: "smtp.qq.com",
          port: 587,
          secure: false,
          auth: {
              user: '你的邮箱地址',
              pass: '你的授权码'
          },
      });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '会议室预定系统',
          address: '你的邮箱地址'
        },
        to,
        subject,
        html
      });
    }
}
```
把邮箱地址和授权码改成你自己的。

这里用的 qq 邮箱，你也可以换成别的邮箱，填写对应的 smtp 服务的域名和端口就好了。

或者你也可以买专门发邮件的服务。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef3904620e3b4dc9bd3158a419111341~tplv-k3u1fbpfcp-watermark.image?)

比如阿里云的[邮件推送服务](https://help.aliyun.com/document_detail/29421.html)：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08e7ce2df5404eff993ab05e180ef4de~tplv-k3u1fbpfcp-watermark.image?)

线上要买这种邮件推送服务来发邮件的，但这里我们还是用 nodemailer 自己发邮件。

把 EmailModule 声明为全局的，并且导出 EmailService

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3ef7c1c9104c2aa069be22cf04bfd1~tplv-k3u1fbpfcp-watermark.image?)

然后在 UserController 里添加一个 get 接口：

```javascript
@Inject(EmailService)
private emailService: EmailService;

@Inject(RedisService)
private redisService: RedisService;

@Get('register-captcha')
async captcha(@Query('address') address: string) {
    const code = Math.random().toString().slice(2,8);

    await this.redisService.set(`captcha_${address}`, code, 5 * 60);

    await this.emailService.sendMail({
      to: address,
      subject: '注册验证码',
      html: `<p>你的注册验证码是 ${code}</p>`
    });
    return '发送成功';
}
```

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bfcaa8df33c441f918169ad6a3db8af~tplv-k3u1fbpfcp-watermark.image?)

邮件发送成功：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8898d7dcefa8436c9d451212daeaebc7~tplv-k3u1fbpfcp-watermark.image?)

redis 里也保存了邮箱地址对应的验证码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d502a0e687994163b2b5b832bf920d87~tplv-k3u1fbpfcp-watermark.image?)

这样整个注册的流程就完成了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d91b2715c99c4e699f00087a3fa9ca89~tplv-k3u1fbpfcp-watermark.image?)

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们创建了 nest 项目，并引入了 typeorm 和 redis。

创建了 User、Role、Permission 的 entity，通过 typeorm 的自动建表功能，在数据库创建了对应的 3 个表和 2 个中间表。

引入了 nodemailer 来发邮件，如果是线上可以买阿里云或者其他平台的邮件推送服务。

实现了 /user/register 和 /user/register-captcha 两个接口。

/user/register-captcha 会向邮箱地址发送一个包含验证码的邮件，并在 redis 里存一份。

/user/register 会根据邮箱地址查询 redis 中的验证码，验证通过会把用户信息保存到表中。

这样，注册功能就完成了。


## 104.会议室预订系统：用户管理模块--配置抽离、登录认证鉴权

上节我们实现了用户注册的功能，这节继续实现登录认证鉴权。

在那之前，我们把配置抽离一下，现在的 mysql、redis、nodemailer 等配置都直接写在代码里，不好维护。

安装 config 的包：

```
npm install --save @nestjs/config
```
在 AppModule 引入下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9106db7891c94ca0a43f5f302f9854c7~tplv-k3u1fbpfcp-watermark.image?)

```javascript
ConfigModule.forRoot({
  isGlobal: true,
  envFilePath: 'src/.env'
})
```
设置为全局模块，指定 env 文件的位置。

然后在 src 下添加一个 .env 文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/007d776534584ae181983bc542bbb25a~tplv-k3u1fbpfcp-watermark.image?)

```
redis_server_host=localhost
redis_server_port=3306
```
然后在 RedisModule 里注入 ConfigService 来读取配置：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54c64397f9b4efc96953e3fad44e978~tplv-k3u1fbpfcp-watermark.image?)

跑一下试试：
```
npm run start:dev
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc91656372824748b71505f141b3e3e3~tplv-k3u1fbpfcp-watermark.image?)

正确读取到了 .env 的配置。

有的同学会问为什么 .env 不放在根目录呢？

因为根目录下的配置文件不会自动复制到 dist 目录。

我们在 nest-cli.json 里加一下 assets 的配置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f3feeac265945508f5caea96d1be3c0~tplv-k3u1fbpfcp-watermark.image?)

asssets 是指定 build 时复制的文件，watchAssets 是在 assets 变动之后自动重新复制。

把 dist 删掉，跑下 npm run build。

你会发现 .env 确实复制过去了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12a9899ac8e84b5d9aa0364e45b62d8c~tplv-k3u1fbpfcp-watermark.image?)

然后我们把 .env 移动到根目录，再删掉 dist，重新跑 npm run build。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95925c41d4f6433dbeb55800f2456cb5~tplv-k3u1fbpfcp-watermark.image?)

并没有自动复制 .env 过去。

如果你就是想把 .env 放在根目录，那可以手动加一下复制逻辑：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e25cbd787194adf9e3e2dfed196bf44~tplv-k3u1fbpfcp-watermark.image?)

这样再跑 npm run build，就会把 .env 复制过去了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f339065634d344d8aa947f75e47d8077~tplv-k3u1fbpfcp-watermark.image?)

为了用到 nest cli 的复制 assets 的功能，我们还是把它放在 src 下。

在 .env 里添加 redis、mysql、nodemailer 和 nest 服务的配置：

```
# redis 相关配置
redis_server_host=localhost
redis_server_port=6379
redis_server_db=1

# nodemailer 相关配置
nodemailer_host=smtp.qq.com
nodemailer_port=587
nodemailer_auth_user=你的邮箱
nodemailer_auth_pass=你的授权码

# mysql 相关配置
mysql_server_host=localhost
mysql_server_port=3306
mysql_server_username=root
mysql_server_password=guang
mysql_server_database=meeting_room_booking_system

# nest 服务配置
nest_server_port=3000
```
然后把代码里的这些地方都改成读配置的方式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/534dfecd140f4fbfb550acecb4f560d9~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const configService = app.get(ConfigService);
await app.listen(configService.get('nest_server_port'));
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2d241733d464901be18a0d1de586f28~tplv-k3u1fbpfcp-watermark.image?)

```javascript
constructor(private configService: ConfigService) {
  this.transporter = createTransport({
      host: this.configService.get('nodemailer_host'),
      port: this.configService.get('nodemailer_port'),
      secure: false,
      auth: {
          user: this.configService.get('nodemailer_auth_user'),
          pass: this.configService.get('nodemailer_auth_pass')
      },
  });
}
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/885d3dc1fda7480586926232dff72c0c~tplv-k3u1fbpfcp-watermark.image?)
```javascript
{
  provide: 'REDIS_CLIENT',
  async useFactory(configService: ConfigService) {
    const client = createClient({
        socket: {
            host: configService.get('redis_server_host'),
            port: configService.get('redis_server_port')
        },
        database: configService.get('redis_server_db')
    });
    await client.connect();
    return client;
  },
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eabeb67bfb348afa19c2ad251cd24d6~tplv-k3u1fbpfcp-watermark.image?)

```javascript
TypeOrmModule.forRootAsync({
  useFactory(configService: ConfigService) {
    return {
      type: "mysql",
      host: configService.get('mysql_server_host'),
      port: configService.get('mysql_server_port'),
      username: configService.get('mysql_server_username'),
      password: configService.get('mysql_server_password'),
      database: configService.get('mysql_server_database'),
      synchronize: true,
      logging: true,
      entities: [
        User, Role, Permission
      ],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }
  },
  inject: [ConfigService]
})
```
然后测试下现在的功能是否正常：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81e19c2e8a7d490fb25e5360860f9ccd~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a2479c170344129be0c9fdd7d51ce65~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b065ca55db1f4320a410b2934edfec6d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8c39a9649fe4d05ba8f2bd3d6f177fb~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b045925effaf48808fc7067e1bf43977~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

这样我们配置抽取就成功了。

接下来继续实现登录功能。

我们先初始化用户、角色、权限的数据。

在 UserService 注入 Role 和 Permission 的 Repository：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/742a066ef9a44e4a8cc1a2df55f029bb~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6e22d0922ff4848885cefbff600798b~tplv-k3u1fbpfcp-watermark.image?)

写个初始化数据的方法：
```javascript
async initData() {
    const user1 = new User();
    user1.username = "zhangsan";
    user1.password = md5("111111");
    user1.email = "xxx@xx.com";
    user1.isAdmin = true;
    user1.nickName = '张三';
    user1.phoneNumber = '13233323333';

    const user2 = new User();
    user2.username = 'lisi';
    user2.password = md5("222222");
    user2.email = "yy@yy.com";
    user2.nickName = '李四';

    const role1 = new Role();
    role1.name = '管理员';

    const role2 = new Role();
    role2.name = '普通用户';

    const permission1 = new Permission();
    permission1.code = 'ccc';
    permission1.description = '访问 ccc 接口';

    const permission2 = new Permission();
    permission2.code = 'ddd';
    permission2.description = '访问 ddd 接口';

    user1.roles = [role1];
    user2.roles = [role2];

    role1.permissions = [permission1, permission2];
    role2.permissions = [permission1];

    await this.permissionRepository.save([permission1, permission2]);
    await this.roleRepository.save([role1, role2]);
    await this.userRepository.save([user1, user2]);
}
```
张三是管理员，有 ccc 和 ddd 接口访问权限。

李四是普通用户，只有 ccc 接口的访问权限。

然后在 UserController 添加个 handler：

```javascript
@Get("init-data") 
async initData() {
    await this.userService.initData();
    return 'done';
}
```
浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e7bf6f7ba7448f490ebb9502bdce8c6~tplv-k3u1fbpfcp-watermark.image?)

服务端打印了包裹在事务里的 insert 语句：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23d930b1904346aab99f483bb9d2e487~tplv-k3u1fbpfcp-watermark.image?)

在 mysql workbench 里看下：

users 表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1df6e65fd8148d39b7898522a6d47b1~tplv-k3u1fbpfcp-watermark.image?)

roles 表：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66eecfbd84a946038efe9c25398febf7~tplv-k3u1fbpfcp-watermark.image?)

permissions 表：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf1d9095a5454205a39a197be7ff067f~tplv-k3u1fbpfcp-watermark.image?)

user_roles 表：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac69fb57d9ad436f9f172d5eef9b51ac~tplv-k3u1fbpfcp-watermark.image?)

role_permissions 表：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099da22171b64bd99b7e092494bc4d87~tplv-k3u1fbpfcp-watermark.image?)

都插入成功了。

有的同学问，在生产环境也这么初始化数据么？

那肯定不会啊，开发环境可以用代码来初始化数据，然后把数据导出为 sql，生产环境可以用这个 sql 文件来初始化。

在 mysql workbench 里这样导出数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054b34873cee48948eed51c9a7657611~tplv-k3u1fbpfcp-watermark.image?)

你可以修改生成的 sql 文件位置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f34792324d834946bf42e10ea508ab65~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592&h=336&s=92490&e=png&b=f1f1f1)

然后我们来实现登录：

后台管理的登录和用户端的登录是分开的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e6f4216cf9f481aa1ccfaf07c0116d9~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d93a6b34ccfb45f69daca28f8554d5f1~tplv-k3u1fbpfcp-watermark.image?)

但实现起来差别不大，我们一起来实现下。

在 UserController 添加两个接口：
```javascript
@Post('login')
async userLogin(@Body() loginUser: LoginUserDto) {
    console.log(loginUser);
    return 'success';
}

@Post('admin/login')
async adminLogin(@Body() loginUser: LoginUserDto) {
    console.log(loginUser);
    return 'success';
}
```
添加 src/user/dto/login-user.dto.ts：

```javascript
import { IsNotEmpty } from "class-validator";

export class LoginUserDto {

    @IsNotEmpty({
        message: "用户名不能为空"
    })
    username: string;
    
    @IsNotEmpty({
        message: '密码不能为空'
    })
    password: string;    
}
```

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44a0ffbcd40413f82add369d2349022~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff1357a6f5f40d496ce18c8fd872672~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44d2b0b1cc364ecca55e47c211d3b3fe~tplv-k3u1fbpfcp-watermark.image?)

然后在 UserService 实现 login 方法：

```javascript
async login(loginUserDto: LoginUserDto, isAdmin: boolean) {
    const user = await this.userRepository.findOne({
        where: {
            username: loginUserDto.username,
            isAdmin
        },
        relations: [ 'roles', 'roles.permissions']
    });

    if(!user) {
        throw new HttpException('用户不存在', HttpStatus.BAD_REQUEST);
    }

    if(user.password !== md5(loginUserDto.password)) {
        throw new HttpException('密码错误', HttpStatus.BAD_REQUEST);
    }

    return user;
}
```
根据 username 和 isAdmin 查询数据库，设置级联查询 roles 和 roles.permissions。

如果没有找到用户，返回 400 响应提示用户不存在。

如果密码不对，返回 400 响应，提示密码错误。

在 UserController 里调用下：

```javascript
@Post('login')
async userLogin(@Body() loginUser: LoginUserDto) {
    const user = await this.userService.login(loginUser, false);

    return 'success';
}

@Post('admin/login')
async adminLogin(@Body() loginUser: LoginUserDto) {
    const user = await this.userService.login(loginUser, true);

    return 'success';
}
```

我们创建个 vo （view object）对象来封装返回的数据。

dto 是接收参数的，vo 是封装返回的数据的，entity 是和数据库表对应的。

创建  src/user/vo/login-user.vo.ts

```typescript
interface UserInfo {
    id: number;

    username: string;

    nickName: string;

    email: string;

    headPic: string;

    phoneNumber: string;

    isFrozen: boolean;

    isAdmin: boolean;

    createTime: number;

    roles: string[];

    permissions: string[]
}
export class LoginUserVo {

    userInfo: UserInfo;

    accessToken: string;

    refreshToken: string;
}

```

返回用户信息和两个 token。

在 UserService 的 login 方法里封装返回的数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be22882d08542019f01263de01aadf4~tplv-k3u1fbpfcp-watermark.image?)

permissions 是所有 roles 的 permissions 的合并，要去下重。

```javascript
const vo = new LoginUserVo();
vo.userInfo = {
    id: user.id,
    username: user.username,
    nickName: user.nickName,
    email: user.email,
    phoneNumber: user.phoneNumber,
    headPic: user.headPic,
    createTime: user.createTime.getTime(),
    isFrozen: user.isFrozen,
    isAdmin: user.isAdmin,
    roles: user.roles.map(item => item.name),
    permissions: user.roles.reduce((arr, item) => {
        item.permissions.forEach(permission => {
            if(arr.indexOf(permission) === -1) {
                arr.push(permission);
            }
        })
        return arr;
    }, [])
}
```

在 UserController 里返回 vo：

```javascript
@Post('login')
async userLogin(@Body() loginUser: LoginUserDto) {
    const vo = await this.userService.login(loginUser, false);

    return vo;
}

@Post('admin/login')
async adminLogin(@Body() loginUser: LoginUserDto) {
    const vo = await this.userService.login(loginUser, true);

    return vo;
}
```
测试下:

/user/login

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/854c2f62a0c145668b85ec2af5fe4c9d~tplv-k3u1fbpfcp-watermark.image?)

/user/admin/login

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fc9b5bbd4944a1ca76f9ccd3696a2d4~tplv-k3u1fbpfcp-watermark.image?)

然后引入 jwt 模块：

```
npm install --save @nestjs/jwt
```

在 AppModule 里引入：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a1ef7c4da314fb6b1db6a35f3eb688f~tplv-k3u1fbpfcp-watermark.image?)
```javascript
JwtModule.registerAsync({
  global: true,
  useFactory(configService: ConfigService) {
    return {
      secret: configService.get('jwt_secret'),
      signOptions: {
        expiresIn: '30m' // 默认 30 分钟
      }
    }
  },
  inject: [ConfigService]
}),
```
这里的密钥放到 .env 里配置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c888db5cc9247d1974b0209e3b67307~tplv-k3u1fbpfcp-watermark.image?)

```
# jwt 配置
jwt_secret=guang
jwt_access_token_expires_time=30m
jwt_refresh_token_expres_time=7d
```
这里 jwt 过期时间的语法可以看[这个文档](https://github.com/vercel/ms#examples)。

然后登录认证通过之后返回 access_token 和 refresh_token：

```javascript
@Inject(JwtService)
private jwtService: JwtService;

@Inject(ConfigService)
private configService: ConfigService;

@Post('login')
async userLogin(@Body() loginUser: LoginUserDto) {
    const vo = await this.userService.login(loginUser, false);

    vo.accessToken = this.jwtService.sign({
      userId: vo.userInfo.id,
      username: vo.userInfo.username,
      roles: vo.userInfo.roles,
      permissions: vo.userInfo.permissions
    }, {
      expiresIn: this.configService.get('jwt_access_token_expires_time') || '30m'
    });

    vo.refreshToken = this.jwtService.sign({
      userId: vo.userInfo.id
    }, {
      expiresIn: this.configService.get('jwt_refresh_token_expres_time') || '7d'
    });

    return vo;
}
```

另一个接口同样的处理。

然后再增加一个 refresh_token 的接口用来刷新 token：
```javascript
@Get('refresh')
async refresh(@Query('refreshToken') refreshToken: string) {
    try {
      const data = this.jwtService.verify(refreshToken);

      const user = await this.userService.findUserById(data.userId, false);

      const access_token = this.jwtService.sign({
        userId: user.id,
        username: user.username,
        roles: user.roles,
        permissions: user.permissions
      }, {
        expiresIn: this.configService.get('jwt_access_token_expires_time') || '30m'
      });

      const refresh_token = this.jwtService.sign({
        userId: user.id
      }, {
        expiresIn: this.configService.get('jwt_refresh_token_expres_time') || '7d'
      });

      return {
        access_token,
        refresh_token
      }
    } catch(e) {
      throw new UnauthorizedException('token 已失效，请重新登录');
    }
}
```
在 UserService 实现这个 findUserById 方法：

```javascript
async findUserById(userId: number, isAdmin: boolean) {
    const user =  await this.userRepository.findOne({
        where: {
            id: userId,
            isAdmin
        },
        relations: [ 'roles', 'roles.permissions']
    });

    return {
        id: user.id,
        username: user.username,
        isAdmin: user.isAdmin,
        roles: user.roles.map(item => item.name),
        permissions: user.roles.reduce((arr, item) => {
            item.permissions.forEach(permission => {
                if(arr.indexOf(permission) === -1) {
                    arr.push(permission);
                }
            })
            return arr;
        }, [])
    }
}
```

同样的方式再实现一个后台管理的 refresh 接口：

```javascript
@Get('admin/refresh')
async adminRefresh(@Query('refreshToken') refreshToken: string) {
    try {
      const data = this.jwtService.verify(refreshToken);

      const user = await this.userService.findUserById(data.userId, true);

      const access_token = this.jwtService.sign({
        userId: user.id,
        username: user.username,
        roles: user.roles,
        permissions: user.permissions
      }, {
        expiresIn: this.configService.get('jwt_access_token_expires_time') || '30m'
      });

      const refresh_token = this.jwtService.sign({
        userId: user.id
      }, {
        expiresIn: this.configService.get('jwt_refresh_token_expres_time') || '7d'
      });

      return {
        access_token,
        refresh_token
      }
    } catch(e) {
      throw new UnauthorizedException('token 已失效，请重新登录');
    }
}
```

整体测试下：

POST /user/login

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a159ff6e41043d18b7bc0fbc6428488~tplv-k3u1fbpfcp-watermark.image?)

GET /user/refresh

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1181cacaf8c94d90bf5f08ee3682f74e~tplv-k3u1fbpfcp-watermark.image?)

POST /user/admin/login

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbc23e11743140f98d593522ec0e1a10~tplv-k3u1fbpfcp-watermark.image?)

GET /user/admin/refresh

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dacf025c8e3b48c3bb971cc2314b90b4~tplv-k3u1fbpfcp-watermark.image?)

都没啥问题。

其实现在 controller 里有很多重复代码，比如多次生成 jwt 的代码，这个大家可以自己重构下，抽一个方法出来。

然后我们加上 LoginGuard 和 PermissionGuard 来做鉴权：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a363d08394dc4a5ab4a0d7d17aafc0c2~tplv-k3u1fbpfcp-watermark.image?)

```
nest g guard login --flat --no-spec
nest g guard permission --flat --no-spec
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c33f90df18542cfa660bfeb757f4ecc~tplv-k3u1fbpfcp-watermark.image?)

LoginGuard 的实现代码如下：

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';
import { Observable } from 'rxjs';
import { Permission } from './user/entities/permission.entity';

interface JwtUserData {
  userId: number;
  username: string;
  roles: string[];
  permissions: Permission[]
}

declare module 'express' {
  interface Request {
    user: JwtUserData
  }
}

@Injectable()
export class LoginGuard implements CanActivate {
  
  @Inject()
  private reflector: Reflector;

  @Inject(JwtService)
  private jwtService: JwtService;
  
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request: Request = context.switchToHttp().getRequest();
    
    const requireLogin = this.reflector.getAllAndOverride('require-login', [
      context.getClass(),
      context.getHandler()
    ]);


    if(!requireLogin) {
      return true;
    }
    
    const authorization = request.headers.authorization;

    if(!authorization) {
      throw new UnauthorizedException('用户未登录');
    }

    try{
      const token = authorization.split(' ')[1];
      const data = this.jwtService.verify<JwtUserData>(token);

      request.user = {
        userId: data.userId,
        username: data.username,
        roles: data.roles,
        permissions: data.permissions
      }
      return true;
    } catch(e) {
      throw new UnauthorizedException('token 失效，请重新登录');
    }
  }
}
```
用 reflector 从目标 controller 和 handler 上拿到 require-login 的 metadata。

如果没有 metadata，就是不需要登录，返回 true 放行。

否则从 authorization 的 header 取出 jwt 来，把用户信息设置到 request，然后放行。

如果 jwt 无效，返回 401 响应，提示 token 失效，请重新登录。

（这段代码看不懂的话，回头去看下 RBAC 权限控制那节）

然后全局启用这个 Guard，在 AppModule 里添加这个 provider：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19288ab861fe4f5db81bc4707a3d40c1~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
  provide: APP_GUARD,
  useClass: LoginGuard
}
```

然后在 AppController 添加 aaa、bbb 两个接口：

```javascript
@Get('aaa')
aaaa() {
    return 'aaa';
}

@Get('bbb')
bbb() {
    return 'bbb';
}
```
访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ce5b1a9fa34fde98ea0e601a3d5529~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6866d98a227a446dbfca8579a47d1923~tplv-k3u1fbpfcp-watermark.image?)

然后在 aaa 加上 require-login 的 matadata

```javascript
@Get('aaa')
@SetMetadata('require-login', true)
aaaa() {
    return 'aaa';
}
```
会提示用户未登录：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/417db2362bed417696ebc720dc3386a1~tplv-k3u1fbpfcp-watermark.image?)

而 bbb 还是可以直接访问的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf99617dd41541678117162c635cd980~tplv-k3u1fbpfcp-watermark.image?)

在 postman 里登录下，拿到 access_token：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b490f6a5e3244358bb050f44643c4e06~tplv-k3u1fbpfcp-watermark.image?)

添加到 authorization 的 header 里，就可以访问了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5835e537a98432ba2e5df63a14e6748~tplv-k3u1fbpfcp-watermark.image?)

然后我们继续实现 PermissionGuard：

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Request } from 'express';

@Injectable()
export class PermissionGuard implements CanActivate {

  @Inject(Reflector)
  private reflector: Reflector;

  async canActivate(
    context: ExecutionContext,
  ): Promise<boolean> {
    const request: Request = context.switchToHttp().getRequest();

    if(!request.user) {
      return true;
    }

    const permissions = request.user.permissions;

    const requiredPermissions = this.reflector.getAllAndOverride<string[]>('require-permission', [
      context.getClass(),
      context.getHandler()
    ])
    
    if(!requiredPermissions) {
      return true;
    }
    
    for(let i = 0; i < requiredPermissions.length; i++) {
      const curPermission = requiredPermissions[i];
      const found = permissions.find(item => item.code === curPermission);
      if(!found) {
        throw new UnauthorizedException('您没有访问该接口的权限');
      }
    }

    return true;
  }
}
```
同样是用 reflector 取出 handler 或者 controller 上的 require-permission 的 metadata。

如果没有，就是不需要权限，直接放行，返回 true。

对于需要的每个权限，检查下用户是否拥有，没有的话就返回 401，提示没权限。

否则就放行，返回 true。

同样是全局启用这个 PermissionGuard

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/769f59165f9243dc800639ab510691cd~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
  provide: APP_GUARD,
  useClass: PermissionGuard
}  
```
然后在 aaa 方法上声明需要的权限：

```javascript
@Get('aaa')
@SetMetadata('require-login', true)
@SetMetadata('require-permission', ['ddd'])
aaaa() {
    return 'aaa';
}
```
测试下：

访问 /user/admin/login 登录 zhangsan 账号，拿到 accessToken

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b7dec279171416a9409196b11887407~tplv-k3u1fbpfcp-watermark.image?)

带上 accessToken，是可以访问 aaa 接口的，因为 zhangsan 有这个权限

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d42f56d76c904c938fb615e9f4d951c8~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f256e3d8030540628cfbf1b3c1faa05d~tplv-k3u1fbpfcp-watermark.image?)

访问 /user/login 登录 lisi 账号，拿到 accessToken

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c32f552f9d7e4d85b8f39ed777747178~tplv-k3u1fbpfcp-watermark.image?)

带上 accessToken，就不能访问 aaa 接口的，因为 lisi 没有这个权限

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf4691eb4b674480a8b7abcef5a6719f~tplv-k3u1fbpfcp-watermark.image?)

这样，接口鉴权就完成了。

最后我们把这两个 @SetMetadata 封装成自定义装饰器

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fddd3e3c32b4ad7ac9d52bdcfc6aeec~tplv-k3u1fbpfcp-watermark.image?)

新建 src/custom.decorator.ts

```javascript
import { SetMetadata } from "@nestjs/common";

export const  RequireLogin = () => SetMetadata('require-login', true);

export const  RequirePermission = (...permissions: string[]) => SetMetadata('require-permission', permissions);
```
然后给接口添加鉴权就可以这样写了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a51ade8ea195498fb8b6c31eb880c703~tplv-k3u1fbpfcp-watermark.image?)

此外还可以创建个自定义参数装饰器：

```javascript
import { SetMetadata } from "@nestjs/common";
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Request } from "express";

export const  RequireLogin = () => SetMetadata('require-login', true);

export const  RequirePermission = (...permissions: string[]) => SetMetadata('require-permission', permissions);

export const UserInfo = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest<Request>();

    if(!request.user) {
        return null;
    }
    return data ? request.user[data] : request.user;
  },
)
```
UserInfo 装饰器是用来取 user 信息传入 handler 的。

传入属性名的时候，返回对应的属性值，否则返回全部的 user 信息。

我们在 aaa 方法里测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a30bd723075742dea8fe863ff5f7b3a5~tplv-k3u1fbpfcp-watermark.image?)

拿到 zhangsan 的 accessToken 来访问下 aaa 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/210187049ea742f28431c7d2e0555488~tplv-k3u1fbpfcp-watermark.image?)

可以看到，服务端从 request 取出了 user 的值传入了 handler：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acaac249b1cd48b9865025fb975b2d31~tplv-k3u1fbpfcp-watermark.image?)

而这个 request.user 是在 LoginGuard 里设置的。

这样，就完成了鉴权和拿到用户信息的功能。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们实现了配置抽离、基于 jwt 登录、鉴权功能。

配置抽离使用 @nestjs/config 包，把配置放在 src 下的 .env 文件里，然后代码里从 configService 读取配置。

这样可以配置 nest-cli.json 的 assets 和 watchAssets 来自动把 env 文件复制到 dist 目录下。

我们使用代码做的数据初始化，线上要删掉这个接口，用导出的 sql 文件来初始化。

登录成功之后，返回 access_token、refresh_token 还有用户信息、roles、permissions 等。

并支持使用 refreshToken 来刷新 token。

之后使用 LoginGuard、PermissionGuard 来做登录和权限的鉴权，根据 handler 上的 metadata 来确定要不要做鉴权、需要什么权限。

我们还封装了几个自定义装饰器，用于方便的设置 metadata，从 request 取数据注入 handler。

至此，注册、登录、鉴权、配置抽离等功能就完成了。


## 105.会议室预订系统：用户管理模块-- interceptor、修改信息接口

用户管理模块我们实现了登录、注册、认证鉴权，还剩下一些列表、更新等接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a58b258db9d4449913d0194cbbc1006~tplv-k3u1fbpfcp-watermark.image?)

这节把修改密码、修改信息的接口写完。

在那之前，我们先加一个修改响应内容的拦截器。把响应的格式改成 {code、message、data} 这种。

```
nest g interceptor format-response --flat
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a8b8759fb744a7e8ee24bf6ec478b15~tplv-k3u1fbpfcp-watermark.image?)

使用 map 操作符来修改响应：

```javascript
import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Response } from 'express';
import { map, Observable } from 'rxjs';

@Injectable()
export class FormatResponseInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const response = context.switchToHttp().getResponse<Response>();

    return next.handle().pipe(map((data) => {
      return {
        code: response.statusCode,
        message: 'success',
        data
      }
    }));
  }
}

```
全局启用它：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01b6e7aaca854229826e588d46a0914c~tplv-k3u1fbpfcp-watermark.image?)

这时候访问 http://localhost:3000 ，可以看到响应格式变了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/574ea5d4ef8642aabe863b9769b86fd2~tplv-k3u1fbpfcp-watermark.image?)

这里我用了一个 [JSON Formatter](https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?utm_source=ext_sidebar&hl=zh-CN) 的 chrome 插件来格式化。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6370ba96078440649a1f49a43890c2b6~tplv-k3u1fbpfcp-watermark.image?)

然后再试下其它接口：

响应格式确实变了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4ff7c8076a493395775ae6fbb8d224~tplv-k3u1fbpfcp-watermark.image?)

抛出的异常还是由内置的 Exception Filter 来处理，返回响应：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d017ea629bf4d47b512070949b1313f~tplv-k3u1fbpfcp-watermark.image?)

然后再加一个接口访问记录的 interceptor：

```
nest g interceptor invoke-record --flat
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a2ccc8cfa2945c1b32171ffc48acb69~tplv-k3u1fbpfcp-watermark.image?)

记录下访问的 ip、user agent、请求的 controller、method，接口耗时、响应内容，当前登录用户等信息。

```javascript
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { Response } from 'express';
import { Request } from 'express';
import { Observable, tap } from 'rxjs';

@Injectable()
export class InvokeRecordInterceptor implements NestInterceptor {
  private readonly logger = new Logger(InvokeRecordInterceptor.name);

  intercept(
    context: ExecutionContext,
    next: CallHandler<any>,
  ): Observable<any> | Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();

    const userAgent = request.headers['user-agent'];

    const { ip, method, path } = request;

    this.logger.debug(
      `${method} ${path} ${ip} ${userAgent}: ${
        context.getClass().name
      } ${
        context.getHandler().name
      } invoked...`,
    );
  
    this.logger.debug(`user: ${request.user?.userId}, ${request.user?.username}`);

    const now = Date.now();

    return next.handle().pipe(
      tap((res) => {
        this.logger.debug(
          `${method} ${path} ${ip} ${userAgent}: ${response.statusCode}: ${Date.now() - now}ms`,
        );
        this.logger.debug(`Response: ${JSON.stringify(res)}`);
      }),
    );
  }
}

```
全局启用这个 interceptor：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9d34854adda4076979d96f9e26c3a87~tplv-k3u1fbpfcp-watermark.image?)

试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b01861d339ca4ae2a7069f61569d5192~tplv-k3u1fbpfcp-watermark.image?)

访问管理员的登录的接口。

可以看到控制台打印了请求的路径、请求方法、controller、handler 等信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/399a1cf537cc4a929c99df71f26b6592~tplv-k3u1fbpfcp-watermark.image?)

这里因为是本地访问，所以是 ::1 的 ip，相当于 localhost。

user 因为当前还没有，所以是 undefined

响应之后打印了接口耗时以及接口返回的数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb637af933ec421dbd69f2c6b5f0084c~tplv-k3u1fbpfcp-watermark.image?)

我们拿着个 access_token 放在 header 来访问 /aaa 接口试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4930687fa5841a284335de8a03b4cf1~tplv-k3u1fbpfcp-watermark.image?)

可以看到，请求之前打印了访问的 controller、handler、user等信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ab9cb388bb84a6aa6b351489aa9c2ba~tplv-k3u1fbpfcp-watermark.image?)

响应之后打印了接口耗时和响应内容等信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d41fc558b07845c39485d3ad8851422e~tplv-k3u1fbpfcp-watermark.image?)

为什么 interceptor 里能拿到 user 信息呢？

因为这是在 LoginGuard 里从 jwt 取出来放到  request.user 的，而 Guard 在 interceptor 之前调用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24060e0f32204907887ede38c1aa018c~tplv-k3u1fbpfcp-watermark.image?)

然后实现普通用户和管理员修改密码、修改信息的接口。

涉及到这 4 个页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c114411bf1274e2a9f202d5188ebf55a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba086b9a407b469fbc79517adeb22ce1~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed7c126be9bb4a8ba9283af6d2974331~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e41292a1b954faaa343a2bf166500d5~tplv-k3u1fbpfcp-watermark.image?)

分别是 /user/update_password 和 /user/admin/update_password、/user/update、/user/admin/update

不过在修改信息之前，需要先实现查询用户信息的接口，用来回显数据。

在 UserController 添加一个 /user/info 接口：

```javascript
@Get('info')
@RequireLogin()
async info(@UserInfo('userId') userId: number) {
  return await this.userService.findUserDetailById(userId);
}
```
用前面封装的自定义装饰器 @UserInfo 从 reqeust.user 取 userId 注入 handler。

加上 @RequireLogin 装饰，这样 LoginGuard 就会对 /user/info 的请求做登录检查。

在 UserService  实现 findUserDetailById 方法：

```javascript
async findUserDetailById(userId: number) {
    const user =  await this.userRepository.findOne({
        where: {
            id: userId
        }
    });

    return user;
}
```
我们测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/966a6657688d4a6fa6791451b66cf3ea~tplv-k3u1fbpfcp-watermark.image?)

登录用户端，拿到 access_token。

然后加到 header 里访问 /user/info

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdd9f904865481d9c38f29e15d90c45~tplv-k3u1fbpfcp-watermark.image?)

成功拿到了 user 的信息。

但这些信息并不是全都需要，比如密码就不需要返回。

我们创建个 vo 来封装返回的结果：

创建 /user/vo/user-info.vo.ts

```javascript
export class UserDetailVo {
    id: number;

    username: string;

    nickName: string;

    email: string;

    headPic: string;

    phoneNumber: string;

    isFrozen: boolean;

    createTime: Date;
}
```
然后把 controller 里的返回值封装成 vo：

```javascript
@Get('info')
@RequireLogin()
async info(@UserInfo('userId') userId: number) {
  const user = await this.userService.findUserDetailById(userId);

  const vo = new UserDetailVo();
  vo.id = user.id;
  vo.email = user.email;
  vo.username = user.username;
  vo.headPic = user.headPic;
  vo.phoneNumber = user.phoneNumber;
  vo.nickName = user.nickName;
  vo.createTime = user.createTime;
  vo.isFrozen = user.isFrozen;

  return vo;
}
```
测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c49feb281701423baa0616962971bd20~tplv-k3u1fbpfcp-watermark.image?)

现在返回的内容就是合理的了。

然后实现修改密码的接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65f846d206a403087fad09b01e1d934~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19a290b2c22f4fe680469d6487f9c462~tplv-k3u1fbpfcp-watermark.image?)

管理员和用户修改密码的页面是一样的，我们就用一个接口就好了。

```javascript
@Post(['update_password', 'admin/update_password'])
@RequireLogin()
async updatePassword(@UserInfo('userId') userId: number, @Body() passwordDto: UpdateUserPasswordDto) {
    console.log(passwordDto);
    return 'success';
}
```

@Post 写个数组，就代表数组里的这两个路由是同一个 handler 处理。

这个接口同样是需要登录的，所以加上 @RequireLogin 的装饰器。

用 @UserInfo 从 request.user 取 userId，其余的通过 dto 传。

创建 src/user/dto/update-user-password.dto.ts

```javascript
import { IsEmail, IsNotEmpty, MinLength } from "class-validator";

export class UpdateUserPasswordDto {    
    @IsNotEmpty({
        message: '密码不能为空'
    })
    @MinLength(6, {
        message: '密码不能少于 6 位'
    })
    password: string;
    
    @IsNotEmpty({
        message: '邮箱不能为空'
    })
    @IsEmail({}, {
        message: '不是合法的邮箱格式'
    })
    email: string;
    
    @IsNotEmpty({
        message: '验证码不能为空'
    })
    captcha: string;
}
```
需要传的是邮箱、密码、验证码。

确认密码在前端和密码对比就行，不需要传到后端。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d55bf2cbdb4f67b9e25f3f4249aac3~tplv-k3u1fbpfcp-watermark.image?)

登录用户端，拿到 access_token，然后访问 /user/update_password 和 /user/admin/update_password 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafdf225f1384f118de02dafb7f06ec6~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e52666915b4ad482a685a8e7b41a42~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3292d88ef3a648a8bf4285ce6e0c9234~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67e1b0442614ec68ef0e765a4b7ecfa~tplv-k3u1fbpfcp-watermark.image?)

都能正常接收到数据。

然后实现下具体的更新密码的逻辑：

先查询 redis 中有没有邮箱对应的验证码，没有的话就返回验证码不存在或者不正确。

查到的话再调用 Repository 去更新数据库中的用户密码。

也就是这样的：

在 UserController 里调用 UserService 的方法：

```javascript
@Post(['update_password', 'admin/update_password'])
@RequireLogin()
async updatePassword(@UserInfo('userId') userId: number, @Body() passwordDto: UpdateUserPasswordDto) {
    return await this.userService.updatePassword(userId, passwordDto);
}
```
UserService 实现具体的逻辑：
```javascript
async updatePassword(userId: number, passwordDto: UpdateUserPasswordDto) {
    const captcha = await this.redisService.get(`update_password_captcha_${passwordDto.email}`);

    if(!captcha) {
        throw new HttpException('验证码已失效', HttpStatus.BAD_REQUEST);
    }

    if(passwordDto.captcha !== captcha) {
        throw new HttpException('验证码不正确', HttpStatus.BAD_REQUEST);
    }

    const foundUser = await this.userRepository.findOneBy({
      id: userId
    });

    foundUser.password = md5(passwordDto.password);

    try {
      await this.userRepository.save(foundUser);
      return '密码修改成功';
    } catch(e) {
      this.logger.error(e, UserService);
      return '密码修改失败';
    }
}
```
先查询 redis 中有相对应的验证码，检查通过之后根据 id 查询用户信息，修改密码之后 save。

测试下：

登录 lisi 账号，拿到 access_token

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e319f1f1a75649e7a0bd17ffc6127bb2~tplv-k3u1fbpfcp-watermark.image?)

数据库中可以查到 lisi 的邮箱：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25c7bb113f8547b8883790c9ed3b2a3d~tplv-k3u1fbpfcp-watermark.image?)

带上 access_token 访问更新密码接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c65750439d5a40058510dafcd5b6f494~tplv-k3u1fbpfcp-watermark.image?)

先手动去 redis 里添加 update_password_captcha_yy@yy.com 的 key，值为 123123（注意，我们现在用的是 redis 的 db1）

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933ce5b5ab3b4bf782583aa2cf362334~tplv-k3u1fbpfcp-watermark.image?)

半小时过期。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ef5d9c41ccd4de189dd47bf002f26b3~tplv-k3u1fbpfcp-watermark.image?)

然后再试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c06ef3cd4ae4293bc9e76dfb2036261~tplv-k3u1fbpfcp-watermark.image?)

修改成功。

数据库里看不到具体的密码，但也能看出确实变了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0712607079b34a3997aee3ee4a484ea0~tplv-k3u1fbpfcp-watermark.image?)

之前是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25c7bb113f8547b8883790c9ed3b2a3d~tplv-k3u1fbpfcp-watermark.image?)

然后我们登录下试试就知道了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a67c4ee5c824ecaa059abc98bcbbb2d~tplv-k3u1fbpfcp-watermark.image?)

用之前的密码登录，会提示密码错误。

换成新密码就好了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f38faa8921947adb024ad8384d146db~tplv-k3u1fbpfcp-watermark.image?)

然后再加上这个发送邮箱验证码的接口：
```javascript
@Get('update_password/captcha')
async updatePasswordCaptcha(@Query('address') address: string) {
    const code = Math.random().toString().slice(2,8);

    await this.redisService.set(`update_password_captcha_${address}`, code, 10 * 60);

    await this.emailService.sendMail({
      to: address,
      subject: '更改密码验证码',
      html: `<p>你的更改密码验证码是 ${code}</p>`
    });
    return '发送成功';
}
```
和之前注册验证码的逻辑一样。

然后还有修改个人信息的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed7c126be9bb4a8ba9283af6d2974331~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e41292a1b954faaa343a2bf166500d5~tplv-k3u1fbpfcp-watermark.image?)

对应 /user/udpate 和 /user/admin/update 接口。

回显数据的接口就用 /user/info 这个。

实现流程和修改密码的差不多：

```javascript
@Post(['update', 'admin/update'])
@RequireLogin()
async update(@UserInfo('userId') userId: number, @Body() updateUserDto: UpdateUserDto) {
    return await this.userService.update(userId, updateUserDto); 
}
```
在 UserController 定义两个 post 接口。

创建 src/user/dto/udpate-user.dto.ts

```javascript
import { IsEmail, IsNotEmpty } from "class-validator";

export class UpdateUserDto {

    headPic: string;

    nickName: string;
    
    @IsNotEmpty({
        message: '邮箱不能为空'
    })
    @IsEmail({}, {
        message: '不是合法的邮箱格式'
    })
    email: string;
    
    @IsNotEmpty({
        message: '验证码不能为空'
    })
    captcha: string;
}
```
这里 headPic 和 nickName 就不做非空约束了，也就是说可以不改。

对应的 UserService 里的逻辑和修改密码的差不多：

```javascript
async update(userId: number, updateUserDto: UpdateUserDto) {
    const captcha = await this.redisService.get(`update_user_captcha_${updateUserDto.email}`);

    if(!captcha) {
        throw new HttpException('验证码已失效', HttpStatus.BAD_REQUEST);
    }

    if(updateUserDto.captcha !== captcha) {
        throw new HttpException('验证码不正确', HttpStatus.BAD_REQUEST);
    }

    const foundUser = await this.userRepository.findOneBy({
      id: userId
    });

    if(updateUserDto.nickName) {
        foundUser.nickName = updateUserDto.nickName;
    }
    if(updateUserDto.headPic) {
        foundUser.headPic = updateUserDto.headPic;
    }

    try {
      await this.userRepository.save(foundUser);
      return '用户信息修改成功';
    } catch(e) {
      this.logger.error(e, UserService);
      return '用户信息修改成功';
    }
}
```
只不过现在是传了的属性才会修改，没传的不修改。

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e71ec42689634a16babd5168267d07e9~tplv-k3u1fbpfcp-watermark.image?)

登录 lisi 账号拿到 token

带上 token 访问 /user/update 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/541a3999e234491e934cca29000332c4~tplv-k3u1fbpfcp-watermark.image?)

提示验证码失效，在 redis 里添加 update_user_captcha_yy@yy.com 的 key，值为 123456

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c8cff2e7c6149dfb6222f7cea7661f4~tplv-k3u1fbpfcp-watermark.image?)

然后再试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43ca8c083d7b4b168d954870f0f647c6~tplv-k3u1fbpfcp-watermark.image?)

用户信息修改成功了，在数据库里也可以看到确实修改了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57a1d28fd08d44abaea93fa7ee562e9e~tplv-k3u1fbpfcp-watermark.image?)

这样，修改接口就完成了。

然后还要加一个发验证码的接口，这个和别的发验证码的逻辑一样：

```javascript
@Get('update/captcha')
async updateCaptcha(@Query('address') address: string) {
    const code = Math.random().toString().slice(2,8);

    await this.redisService.set(`update_user_captcha_${address}`, code, 10 * 60);

    await this.emailService.sendMail({
      to: address,
      subject: '更改用户信息验证码',
      html: `<p>你的验证码是 ${code}</p>`
    });
    return '发送成功';
}
```
代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。
## 总结

这节我们添加了 interceptor 用来对响应格式做转换，改成 {code、message、data} 的格式，用到了 map 操作符。

并且还用 interceptor 实现了接口访问的日志记录，用到 tap 操作符。

然后实现了修改信息、修改密码的接口。

这些流程都差不多，首先实现一个查询的接口用来回显数据，通过 vo 封装返回的数据。

然后提交数据进行更新，用到的 userId 通过之前封装的 @UserInfo 装饰从 request.user 来取。

还剩个列表接口，我们下节再写。


## 106.会议室预订系统：用户管理模块--用户列表和分页查询

用户管理模块我们实现了注册、登录鉴权、信息修改接口，还剩下两个接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c29fc9fbb5f44ba880884daac9bc4eae~tplv-k3u1fbpfcp-watermark.image?)

这节来实现下。

在那之前先考虑个问题：

成功的响应是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a403f4f303943c08267d4b667013202~tplv-k3u1fbpfcp-watermark.image?)

但是失败的响应是这样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977a5d130c37442ea9354f55e8b54f41~tplv-k3u1fbpfcp-watermark.image?)

并不统一。

如何让响应统一成 {code、message、data} 的格式呢？

这里就需要自定义 Exception Filter 了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d717b3f94ec4a4894c3efc72feb9831~tplv-k3u1fbpfcp-watermark.image?)

在 Guard、handler、interceptor 等处理逻辑里 throw http 异常，都会被 ExceptionFilter 处理成相应的响应。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3714fcd616094d378a67299a3785fd42~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e575d999150948a8ae81a67e59a1452d~tplv-k3u1fbpfcp-watermark.image?)

如果想修改异常响应的格式，就要自定义了。

我们新建个 exception filter：

```
nest g filter unlogin --flat
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d60d7355149842248850c0f7315d8134~tplv-k3u1fbpfcp-watermark.image?)

@Catch 的参数可以指定具体 catch 的异常类型：

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

export class UnLoginException{
  message: string;

  constructor(message?){
    this.message = message;
  }
}

@Catch(UnLoginException)
export class UnloginFilter implements ExceptionFilter {
  catch(exception: UnLoginException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();

    response.json({
      code: HttpStatus.UNAUTHORIZED,
      message: 'fail',
      data: exception.message || '用户未登录'
    }).end();
  }
}
```
我们自定义了 UnLoginException 的异常，在 @Catch 指定捕获这个异常，返回对应的响应。

在 main.ts 引入下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ecf325a1f004d14a977ec01f0f393d1~tplv-k3u1fbpfcp-watermark.image?)

然后把 LoginGuard 里的异常改成 UnLoginException

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10f23f6d370644cd8120b3829a9f79f5~tplv-k3u1fbpfcp-watermark.image?)

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b3d6e825cea407da29ecb9839f8feaf~tplv-k3u1fbpfcp-watermark.image?)

现在当你不带 token 访问 /aaa 的时候，返回的就是自己定义的格式了。

搜索下之前代码里抛的异常：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8083cfa2b1438da8b7a60b6f80e55a~tplv-k3u1fbpfcp-watermark.image?)

还有不少。

难道有多少种 exception 就定义多少种异常类和 exception filter 么？

没必要，直接修改下对 HttpException 的处理逻辑就好了。

```
nest g filter custom-exception --flat
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/655690d2f52342cb949ec52a4cefc185~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class CustomExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();
    response.statusCode = exception.getStatus();

    response.json({
      code: exception.getStatus(),
      message: 'fail',
      data: exception.message
    }).end();
  }
}
```
直接 @Catch 指定 HttpException，修改返回的响应格式。

然后在 main.ts 里启用：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5b5781a21e742a8b09789ffd9c43ca3~tplv-k3u1fbpfcp-watermark.image?)

这样，所有的代码都不用修改，返回的响应就已经变了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59e937253ef94a76b343a4e4f17b3703~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1aea21c7b9d244fd96069b2c4f81b2a6~tplv-k3u1fbpfcp-watermark.image?)

所以，如果你只是想修改默认的响应格式，直接定义个 catch HttpException 的 filter 就好了。

但这样其实还有个问题：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b21b538ba5c498db1c787784957df54~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=816&s=73953&e=png&b=fdfdfd)

对于 ValidationPipe 报的错，返回的信息不准。

我们可以打个断点看看具体的错误信息：

创建 .vscode/launch.json 文件：

输入调试配置：
```javascript
{
    "name": "Launch via NPM",
    "request": "launch",
    "runtimeArgs": [
        "run-script",
        "start:dev"
    ],
    "console": "integratedTerminal",
    "runtimeExecutable": "npm",
    "skipFiles": [
        "<node_internals>/**"
    ],
    "type": "node"
}
```
然后在 exception filter 打个断点，点击调试启动：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80bce23dbebb4118bfce50b3c58cb55d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1674&h=808&s=248671&e=png&b=1d1d1d)

在 postman 里再次请求这个接口，代码会在断点处断住：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c241f28fb9c4a2ba20a2513bae58fda~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1642&h=888&s=305911&e=png&b=1d1d1d)

可以看到，这时候 message 并不是具体的错误，具体的错误在 response.message 里：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b996b6d56d0c485da8857c79425485f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1316&h=638&s=211009&e=png&b=1f1f1f)

所以我们可以这样改：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65309602f7494642966e2f3f217ece45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1152&h=676&s=168225&e=png&b=1f1f1f)

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class CustomExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();
    response.statusCode = exception.getStatus();

    const res = exception.getResponse() as { message: string[] };
    
    response.json({
      code: exception.getStatus(),
      message: 'fail',
      data: res?.message?.join ? res?.message?.join(',') : exception.message
    }).end();
  }
}

```

就是如果有 response.message 就优先用那个，否则就取 exception.message。

再试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd43c3dd18834db4b601b8a5e297f2a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=910&h=768&s=81793&e=png&b=fcfcfc)

这样，错误显示就对了。

然后我们实现冻结用户的接口，冻结的用户不能预定会议室。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771d852f50324bb9b9bb0e1605fdec5e~tplv-k3u1fbpfcp-watermark.image?)

这个接口非常简单，就是修改一个字段：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f948a99531c84bd7b49d48b91b54b218~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Get('freeze')
async freeze(@Query('id') userId: number) {
    await this.userService.freezeUserById(userId);
    return 'success';
}
```
定义 get 接口，然后从 query 取 id 参数。

其实这个接口也需要登录，而且只有管理员有调用它的权限，这个我们后面再统一处理。

在 UserService 定义这个 freezeUserById 方法：

```javascript
async freezeUserById(id: number) {
    const user = await this.userRepository.findOneBy({
        id
    });

    user.isFrozen = true;

    await this.userRepository.save(user);
}
```

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58286ebb98d9411781aa5b69bd57012c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ccdfe4350d468fb998b5162640b331~tplv-k3u1fbpfcp-watermark.image?)

确实冻结了。

然后实现 /user/list 用户列表接口。

```javascript
@Get('list')
async list(@Query('pageNo', ParseIntPipe) pageNo: number, @Query('pageSize', ParseIntPipe) pageSize: number) {
    return await this.userService.findUsersByPage(pageNo, pageSize);
}
```
这个接口支持分页查询，传入 pageNo、pageSize，返回对应页的数据。

我们在 UserService 里实现下：

还记得如何用 sql 实现分页查询么？

目前 users 表有 4 条数据，我们先查询全部的：

```sql
select * from users
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02a5362b32c546048dba2b8cc49d6ed5~tplv-k3u1fbpfcp-watermark.image?)

然后每 2 条记录一页

查询第一页：

```sql
select * from users limit 0,2
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0aeddefe7e64f00af8c44a734d78e99~tplv-k3u1fbpfcp-watermark.image?)

查询第二页：

```sql
select * from users limit 2,2
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9ef5acae2de4098bd11d96d34c53a78~tplv-k3u1fbpfcp-watermark.image?)

也就是说，只要计算出当前页码跳过多少条记录，取多少条记录就好了。

也就是这样：

```javascript
async findUsersByPage(pageNo: number, pageSize: number) {
    const skipCount = (pageNo - 1) * pageSize;

    const [users, totalCount] = await this.userRepository.findAndCount({
        skip: skipCount,
        take: pageSize
    });

    return {
        users,
        totalCount
    }
}
```
当前页码减一乘以 pageSize，就是要跳过的记录数，然后再取 pageSize 条。

我们这次用的是 findAndCount 的 api，它还会查询总记录数。

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/166d7bca4f5a4c9b8fa8e2db1857add3~tplv-k3u1fbpfcp-watermark.image?)

没传 pageNo 的时候会返回 400 的错误。

这个报错信息不够友好，我们改一下：

```javascript
@Get('list')
async list(
@Query('pageNo', new ParseIntPipe({
  exceptionFactory() {
    throw new BadRequestException('pageNo 应该传数字');
  } 
})) pageNo: number,
@Query('pageSize', new ParseIntPipe({
  exceptionFactory() {
    throw new BadRequestException('pageSize 应该传数字');
  } 
})) pageSize: number
) {
    return await this.userService.findUsersByPage(pageNo, pageSize);
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1484c3c7f33b41b5b43ab3edb7693799~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a15afc208a3947cd97a4e521e67abb45~tplv-k3u1fbpfcp-watermark.image?)

现在的提示信息就友好多了。

我们重构下代码：

把这段代码抽离到 src/utils.ts 里：

```javascript
export function generateParseIntPipe(name) {
    return new ParseIntPipe({
      exceptionFactory() {
        throw new BadRequestException(name + ' 应该传数字');
      } 
    })
}
```
那 controller 的代码就可以简化成这样了：

```javascript
@Get('list')
async list(
    @Query('pageNo', generateParseIntPipe('pageNo')) pageNo: number,
    @Query('pageSize', generateParseIntPipe('pageSize')) pageSize: number,
) {
    return await this.userService.findUsersByPage(pageNo, pageSize);
}
```
那如果没有传 pageNo 和 pageSize 的时候要设置个默认值呢？

可以使用 DefaultValuePipe：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a28ef1855f03451db9ccdb1a12d72347~tplv-k3u1fbpfcp-watermark.image?)

没有传 pageNo 的时候设置为 1，没有传 pageSize 的时候设置为 2。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e7a49cc5e914214acb7e2f6b7d5a6a2~tplv-k3u1fbpfcp-watermark.image?)

现在传入 pageNo 和 pageSize 就可以查询出对应的数据，还有总条数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b3d00e3058437ca6b0e3b127b1d871~tplv-k3u1fbpfcp-watermark.image?)

服务端打印了两条 sql：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45c63b6ee2834fdeb9df50a00efba663~tplv-k3u1fbpfcp-watermark.image?)

一条是分页查询，指定了 limit 2 offset 2，这个和 limit 2, 2 是一样的

一条是 count 统计，统计了用户的总条数。

这里返回的信息同样也需要做一些修改。

我们指定下 select 的字段：

```javascript
async findUsersByPage(pageNo: number, pageSize: number) {
    const skipCount = (pageNo - 1) * pageSize;

    const [users, totalCount] = await this.userRepository.findAndCount({
        select: ['id', 'username', 'nickName', 'email', 'phoneNumber', 'isFrozen', 'headPic', 'createTime'],
        skip: skipCount,
        take: pageSize
    });

    return {
        users,
        totalCount
    }
}
```
这样返回的数据就只包含 select 的字段了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e345a7f045614351a1abb54d325e80b7~tplv-k3u1fbpfcp-watermark.image?)

当然，如果你需要对返回的数据再做一些变换，这时候可以封装个 vo 对象。

用户列表的需求除了分页外，还需要支持根据 username、nickName、email 的搜索：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771d852f50324bb9b9bb0e1605fdec5e~tplv-k3u1fbpfcp-watermark.image?)

添加几个参数：

```javascript
@Get('list')
async list(
    @Query('pageNo', new DefaultValuePipe(1), generateParseIntPipe('pageNo')) pageNo: number,
    @Query('pageSize', new DefaultValuePipe(2), generateParseIntPipe('pageSize')) pageSize: number,
    @Query('username') username: string,
    @Query('nickName') nickName: string,
    @Query('email') email: string
) {
    return await this.userService.findUsers(username, nickName, email, pageNo, pageSize);
}
```
在 UserService 添加 findUsers 方法：

```javascript
async findUsers(username: string, nickName: string, email: string, pageNo: number, pageSize: number) {
    const skipCount = (pageNo - 1) * pageSize;

    const condition: Record<string, any> = {};

    if(username) {
        condition.username = Like(`%${username}%`);   
    }
    if(nickName) {
        condition.nickName = Like(`%${nickName}%`); 
    }
    if(email) {
        condition.email = Like(`%${email}%`); 
    }

    const [users, totalCount] = await this.userRepository.findAndCount({
        select: ['id', 'username', 'nickName', 'email', 'phoneNumber', 'isFrozen', 'headPic', 'createTime'],
        skip: skipCount,
        take: pageSize,
        where: condition
    });

    return {
        users,
        totalCount
    }
}
```
和之前的区别就是多了个 where 条件。

根据 username、nickName、email 搜索的时候，使用模糊查询。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/472118f2b46244e897eaa703b5260c5c~tplv-k3u1fbpfcp-watermark.image?)

当我传 nickName 包含“里”的时候，服务端查询到数据只有一条。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/645e9612eac44e40861b4dd21bba6a5b~tplv-k3u1fbpfcp-watermark.image?)

传入 nickName 包含 “光” 的时候，返回两条数据。

这样，搜索就完成了。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们实现了冻结用户和用户列表接口。

我们通过自定义 exception filter，catch 了 HTTPException，返回了自定义格式的响应，统一了响应格式。

冻结用户接口比较简单，就是修改 users 表的一个字段。

用户列表支持了分页查询和模糊搜索：

分页查询就是根据 (pageNo -1) \* pageSize 计算出从哪里开始，然后取 pageSize 条。

模糊搜索就是通过 like 来匹配。

此外，ParseIntPipe 我们自定义了错误格式，还使用了 DefaultValuePipe 设置了默认值。

至此，用户模块的所有接口都写完了，下节我们用 swagger 来生成接口文档。

## 107.会议室预订系统：用户管理模块-- swagger 接口文档

后端写完接口，都会提供一份接口文档给前端。

这节我们就来做下这件事情，通过 swagger 生成接口文档。

安装 swagger 的包：

```
npm install --save @nestjs/swagger
```
在 main.ts 添加这段代码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cb79629ae02494a8f10ee0ba0d210c3~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const config = new DocumentBuilder()
    .setTitle('会议室预订系统')
    .setDescription('api 接口文档')
    .setVersion('1.0')
    .build();
const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('api-doc', app, document);
```
用 SwaggerModule 生成接口文档，url 是 /api-doc

访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb0ec13a8f534454b21c93635207f038~tplv-k3u1fbpfcp-watermark.image?)

可以看到所有接口都列出来了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2632002787d947f896e24819148cac6d~tplv-k3u1fbpfcp-watermark.image?)

还有用到的 schema，也就是对象的结构：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/422a5f7fc0074ab896e81c8a23ac8f3d~tplv-k3u1fbpfcp-watermark.image?)

只不过很多接口的文档是不对的：

比如用户列表接口，这些参数都不是必选的，而且也没有响应相关的信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8db08cdb95824d03817172059cc059a5~tplv-k3u1fbpfcp-watermark.image?)

还有 schema 也没有具体的内容。

这些需要我们加一些装饰器来告诉 swagger。

在 UserController 添加一个 @ApiTags

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d230e072de054ef4be2972b2c50c78de~tplv-k3u1fbpfcp-watermark.image?)

这样这个 cotroller 的接口会被单独分组：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10fa746380f6435f9fc4e32c868999f2~tplv-k3u1fbpfcp-watermark.image?)

然后我们一个个接口来看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ed9e75309924374a97f66b08911680a~tplv-k3u1fbpfcp-watermark.image?)

先是 /user/register-captcha 接口

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff4429ddfe634070b93ed382853ab6c1~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiQuery({
    name: 'address',
    type: String,
    description: '邮箱地址',
    required: true,
    example: 'xxx@xx.com'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '发送成功',
    type: String
})
```
通过 @ApiQuery 描述 query 参数，通过 @ApiResponse 描述响应。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c226a2c226604c82b080bc06a776aa28~tplv-k3u1fbpfcp-watermark.image?)

然后是 /user/register 接口：

它一共有 2 种状态码，200 和 400：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2348b92ec922492bb9220b5141255cee~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1073f3ea16e14f3d9924a7aac2dbaa7a~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiBody({type: RegisterUserDto})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '验证码已失效/验证码不正确/用户已存在',
    type: String
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '注册成功/失败',
    type: String
})
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7d3888d71464440bc6c4c08d8206055~tplv-k3u1fbpfcp-watermark.image?)

请求体的属性需要去 dto 里标识：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e23b1103900f49c195545a8f211a2969~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c904de33d354e11916f56d400d9e0f5~tplv-k3u1fbpfcp-watermark.image?)

然后接口文档里就可看到请求体的信息了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd9ae1fb9e054b62b36db1e11ff91592~tplv-k3u1fbpfcp-watermark.image?)

下面的 schema 里的 RegisterUserDto 也有了内容：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/507510e54dca43c2a52a79abbec80b1e~tplv-k3u1fbpfcp-watermark.image?)

接下来是 /user/login 接口：

它也是有 400 和 200 两种响应：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1938c62e487448dd847280e2565bb1be~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3138960114d142e793814edbfc206885~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiBody({
    type: LoginUserDto
})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '用户不存在/密码错误',
    type: String
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '用户信息和 token',
    type: LoginUserVo
})
```
通过 @ApiResponse 标识两种响应，通过 @ApiBody 标识请求体。

然后在 LoginUserDto 和 LoginUserVo 里标识下属性：

LoginUserDto：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e784199fc1447ffb5bdffee2d5b6ab8~tplv-k3u1fbpfcp-watermark.image?)

LoginuserVo：

```javascript
import { ApiProperty } from "@nestjs/swagger";

class UserInfo {
    @ApiProperty()
    id: number;

    @ApiProperty({example: 'zhangsan'})
    username: string;

    @ApiProperty({example: '张三'})
    nickName: string;

    @ApiProperty({example: 'xx@xx.com'})
    email: string;

    @ApiProperty({example: 'xxx.png'})
    headPic: string;

    @ApiProperty({example: '13233333333'})
    phoneNumber: string;

    @ApiProperty()
    isFrozen: boolean;

    @ApiProperty()
    isAdmin: boolean;

    @ApiProperty()
    createTime: number;

    @ApiProperty({example: ['管理员']})
    roles: string[];

    @ApiProperty({example: 'query_aaa'})
    permissions: string[]
}
export class LoginUserVo {

    @ApiProperty()
    userInfo: UserInfo;

    @ApiProperty()
    accessToken: string;

    @ApiProperty()
    refreshToken: string;
}
```

之前这里的 UserInfo 是 interface，这里要改成 class 才能加装饰器。

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4becc1d39cbc4a5dbe146986295b6896~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6e1168f077343d4908e1616bbaa9a8b~tplv-k3u1fbpfcp-watermark.image?)

/user/admin/login 的 swagger 装饰器和 /user/login 一样。

然后继续看 /user/refresh 接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c03e7389acd24c89aeaf92d1657ba9c3~tplv-k3u1fbpfcp-watermark.image?)
```javascript
@ApiQuery({
    name: 'refreshToken',
    type: String,
    description: '刷新 token',
    required: true,
    example: 'xxxxxxxxyyyyyyyyzzzzz'
})
@ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'token 已失效，请重新登录'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '刷新成功'
})
```

用 @ApiQuery 标识 query 参数，用 @ApiResponse 标识两种响应。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5d7836c77d445482bd6e1d90414ab2~tplv-k3u1fbpfcp-watermark.image?)
 
但现在刷新成功的 access_token 和 refresh_token 没有显示。

所以我们也需要把这个返回值封装成 vo：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/027cb4c54b00432190bb3554dfa992d4~tplv-k3u1fbpfcp-watermark.image?)

新建 src/user/vo/refresh-token.vo.ts

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class RefreshTokenVo {
    @ApiProperty()
    access_token: string;

    @ApiProperty()
    refresh_token: string;
}
```
把返回的结果封装成 vo：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29ee014300c440d4ab5ce5e322d42f0a~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const vo = new RefreshTokenVo();

vo.access_token = access_token;
vo.refresh_token = refresh_token;

return vo;
```
在 @ApiResponse 里标识这个 type

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d390166b24b4c33952a19651a1338b6~tplv-k3u1fbpfcp-watermark.image?)

刷新下页面，可以看到现在接口文档里就有了返回数据的结构：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8725ded96f484f40acc168a8526547e9~tplv-k3u1fbpfcp-watermark.image?)

/user/admin/login 的处理方式一样。

接下来是 /user/info 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bdef74a687d4786ac2e4b483b1dffdd~tplv-k3u1fbpfcp-watermark.image?)

加一下返回的数据的标识 @ApiResponse。

然后在 UserDetailVo 里加一下 @ApiProperty：

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class UserDetailVo {
    @ApiProperty()
    id: number;

    @ApiProperty()
    username: string;

    @ApiProperty()
    nickName: string;

    @ApiProperty()
    email: string;

    @ApiProperty()
    headPic: string;

    @ApiProperty()
    phoneNumber: string;

    @ApiProperty()
    isFrozen: boolean;

    @ApiProperty()
    createTime: Date;
}
```
这样返回的数据结构就对了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6967a10bb794b11b30b24575a73f97f~tplv-k3u1fbpfcp-watermark.image?)

但这个接口是需要登录的，我们加一下标识：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/413d5a6bf0c945f4a7857742b53f524a~tplv-k3u1fbpfcp-watermark.image?)

然后在 main.ts 里加一下这种 bearer 的认证方式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/586a90ae7d964291b21bedb0f75bcc62~tplv-k3u1fbpfcp-watermark.image?)

这时候这个接口就有了锁的标记，代表需要登录了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f872562f56c54288803535e014dff025~tplv-k3u1fbpfcp-watermark.image?)

点击锁，填入 access_token，这样再测试接口的时候，会自动带上 token 标识：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e90bb9dd2914fc7864dc067df8a3845~tplv-k3u1fbpfcp-watermark.image?)

比如我输入 xxx，然后点击 authorize

然后点击 try it out 和 execute，可以看到浏览器发送了这个请求，并且带上了 authorization 的 header 

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de975505b4374adc932e8980b8602ee7~tplv-k3u1fbpfcp-watermark.image?)

可以在 swagger 文档里测试这个接口。

接下来是 /user/update_password

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7359a3f566124a72b8b601b8014a9314~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiBearerAuth()
@ApiBody({
    type: UpdateUserPasswordDto
})
@ApiResponse({
    type: String,
    description: '验证码已失效/不正确'
})
```
在 UpdateUserPasswordDto 里加一下 @ApiProperty

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f620d8c3ee744c249c6364103c655e02~tplv-k3u1fbpfcp-watermark.image?)
接口文档没啥问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70b6e7de3485400aacd615e947b5c5e5~tplv-k3u1fbpfcp-watermark.image?)

接下来是 /user/update_password/captcha 接口

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1926854b29ed408dbfe6cdb36ed3c3cb~tplv-k3u1fbpfcp-watermark.image?)

这个接口是需要登录的，当时为了测试方便没有加，现在加一下：

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'address',
    description: '邮箱地址',
    type: String
})
@ApiResponse({
    type: String,
    description: '发送成功'
})
@RequireLogin()
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2f4a7401c5849d79f3715bdc1e1c19e~tplv-k3u1fbpfcp-watermark.image?)

然后是 /user/update 接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7dd319f321d46b4b9d13f1cc058d76a~tplv-k3u1fbpfcp-watermark.image?)
```javascript
@ApiBearerAuth()
@ApiBody({
    type: UpdateUserDto
})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '验证码已失效/不正确'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: '更新成功',
    type: String
})
```
在 UpdateUserDto 里标识下 @ApiProperty
 
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1ff3f94f254dc4b6387bc0966104ed~tplv-k3u1fbpfcp-watermark.image?)

刷新下，可以看到最新的接口文档：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a4d3ead23cd499e9aab5fc18fd63def~tplv-k3u1fbpfcp-watermark.image?)

然后是 /user/freeeze 接口

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee6adf9f9a2745eab7d181f23ae83d70~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'id',
    description: 'userId',
    type: Number
})
@ApiResponse({
    type: String,
    description: 'success'
})
@RequireLogin()
```

刷新下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc42883dc2c24c5e94c3c82af1982836~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

最后，还剩下 /user/list 接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac7c6fda80da4c1fa23381a93ecbee06~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'pageNo',
    description: '第几页',
    type: Number
})
@ApiQuery({
    name: 'pageSize',
    description: '每页多少条',
    type: Number
})
@ApiQuery({
    name: 'username',
    description: '用户名',
    type: Number
})
@ApiQuery({
    name: 'nickName',
    description: '昵称',
    type: Number
})
@ApiQuery({
    name: 'email',
    description: '邮箱地址',
    type: Number
})
@ApiResponse({
    type: String,
    description: '用户列表'
})
@RequireLogin()
```
这里的返回值需要封装个 vo：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc5f0e83f0984c51be62858635595658~tplv-k3u1fbpfcp-watermark.image?)

创建 src/user/vo/user-list.vo.ts
```javascript
import { ApiProperty } from "@nestjs/swagger";

class User {
    @ApiProperty()
    id: number;

    @ApiProperty()
    username: string;

    @ApiProperty()
    nickName: string;
    
    @ApiProperty()
    email: string; 

    @ApiProperty()
    phoneNumber: string;

    @ApiProperty()
    isFrozen: boolean;
    
    @ApiProperty()
    headPic: string;

    @ApiProperty()
    createTime: Date;
}

export class UserListVo {

    @ApiProperty({
        type: [User]
    })
    users: User[];

    @ApiProperty()
    totalCount: number;
}
```

注意这里标识 User 数组要用 [User]

然后把 findUsers 的返回值改为 UserListVo

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b61308edae734d78aa9518c0dcc3058a~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const vo = new UserListVo();

vo.users = users;
vo.totalCount = totalCount;
return vo;
```

刷新下接口文档：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bde29165e214d35b8fb42a9a3628a93~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b502e1a38ba4aff97c84993d23778cf~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

这样，我们就给所有的接口生成了 api 文档。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们用 swagger 生成了接口文档。

在 main.ts 里调用 SwaggerModule.setup 来生成接口文档。

然后用 @ApiQuery、@ApiBody、@ApiResponse、@ApiProperty 等来标识每个接口的参数和响应。

并且通过 @ApiBearerAuth 标识需要 jwt 认证的接口。

返回对象的接口需要把它封装成 vo，然后再添加 @ApiProperty。

接口文档提供给前端之后，前端就可以基于这个来写页面了。




## 108.会议室预订系统：用户管理模块-- 用户端登录注册页面

用户模块接口写完之后，这节我们开始写页面。

先写下用户端页面，涉及到到登录、注册、修改密码、修改个人信息这 4 个：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae52c0b82b7342b1a20c94f118726f99~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/486e8f1ad6f845c8b255bb0e78fa5e64~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b7366af920b41c890686f5a10c21d7b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403f30e8cf80493c8af4ab50054aba3c~tplv-k3u1fbpfcp-watermark.image?)

先新建个 react 项目：

```
npx create-react-app --template=typescript meeting_room_booking_system_frontend_u
ser
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afa9e9f98ab34e1780a0beff4d2fd14d~tplv-k3u1fbpfcp-watermark.image?)

进入项目目录，把开发服务跑起来：

```
npm run start
```
浏览器访问 http://localhost:3000 可以看到这个界面：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e578f28f353c488c8426699af3896f48~tplv-k3u1fbpfcp-watermark.image?)

就说明 react 项目成功跑起来了。

然后我们添加 router：

```
npm install --save react-router-dom
```
在 index.tsx 加上路由的配置：

```javascript
import ReactDOM from 'react-dom/client';
import './index.css';
import { RouterProvider, createBrowserRouter, Link, Outlet } from 'react-router-dom';

function Aaa() {
  return <div>aaa</div>;
}

function Bbb(){
  return <div>bbb</div>;
}

function Layout() {
  return <div>
    <div><Link to="/aaa">to aaa</Link></div>
    <div><Link to="/bbb">to bbb</Link></div>
    <div>
      <Outlet/>
    </div>
  </div>
}

function ErrorPage() {
  return <div>error</div>;
}

const routes = [
  {
    path: "/",
    element: <Layout/>,
    errorElement: <ErrorPage/>,
    children: [
      {
        path: "aaa",
        element: <Aaa />,
      },
      {
        path: "bbb",
        element: <Bbb />,
      }    
    ],
  }
];
const router = createBrowserRouter(routes);

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(<RouterProvider router={router}/>);
```

配置了 3 个路由：

访问 / 的时候，渲染 Layout 组件。

访问 /aaa 的时候，渲染 Aaa 组件。

访问 /bbb 的时候，渲染 Bbb 组件。

以及出错的时候，渲染 ErrorPage 组件。

其中，aaa 和 bbb 是 / 的子路由，渲染在 Layout 组件的 Outlet 的地方。

这就是 React Router 的基本用法。

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef9fde0a39ef4892827c3fbb8ad85555~tplv-k3u1fbpfcp-watermark.image?)

都没问题。

然后创建 3 个组件：Login、Register、UpdatePassword

把 src 目录下其余文件去掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e73f7432c44e23bde08e1de692533f~tplv-k3u1fbpfcp-watermark.image?)

然后添加这 3 个组件还有 ErrorPage 组件：

Login.tsx

```javascript
export function Login() {
    return <div>login</div>   
}
```

Register.tsx

```javascript
export function Register() {
    return <div>register</div>
}
```

UpdatePassword.tsx

```javascript
export function UpdatePassword() {
    return <div>UpdatePassword</div>
}
```
ErrorPage.tsx

```javascript
export function ErrorPage() {
    return <div>ErrorPage</div>
}
```

改下 index.tsx 配置对应的路由：

```javascript
import ReactDOM from 'react-dom/client';
import './index.css';
import { RouterProvider, createBrowserRouter, Link, Outlet } from 'react-router-dom';
import { Register } from './Register';
import { Login } from './Login';
import { UpdatePassword } from './UpdatePassword';
import { ErrorPage } from './ErrorPage';

const routes = [
  {
    path: "/",
    element: <div>index</div>,
    errorElement: <ErrorPage />,
  },
  {
    path: "login",
    element: <Login />,
  },
  {
    path: "register",
    element: <Register />,
  },
  {
    path: "update_password",
    element: <UpdatePassword />,
  }
];
const router = createBrowserRouter(routes);

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(<RouterProvider router={router}/>);

```
测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/566f87e45935491bac7da83f494fb250~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66f93212bf484e58b3adb614e41ce4fc~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3b3ac0466f1495e883f91f99b141ca2~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37434753149940ffbed148dd367f763f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35fea399993642eb9824c70e5d909654~tplv-k3u1fbpfcp-watermark.image?)

都没啥问题。

然后来写 Login 页面，也就是这个：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae52c0b82b7342b1a20c94f118726f99~tplv-k3u1fbpfcp-watermark.image?)

引入 Ant Design 组件库：

```
npm install antd --save
```
在 Login 组件引入 DatePicker 组件：

```javascript
import { DatePicker } from "antd";

export function Login() {
    return <div><DatePicker/></div>   
}
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c984c744ec49a1a24e5b9c8bab3b94~tplv-k3u1fbpfcp-watermark.image?)

没啥问题，说明 antd 引入成功了。

然后我们把登录页面写一下：

```javascript
import { Button, Checkbox, Form, Input } from 'antd';
import './login.css';

interface LoginUser {
    username: string;
    password: string;
}

const onFinish = (values: LoginUser) => {
    console.log(values);
};


const layout1 = {
    labelCol: { span: 4 },
    wrapperCol: { span: 20 }
}

const layout2 = {
    labelCol: { span: 0 },
    wrapperCol: { span: 24 }
}

export function Login() {
    return <div id="login-container">
        <h1>会议室预订系统</h1>
        <Form
            {...layout1}
            onFinish={onFinish}
            colon={false}
            autoComplete="off"
        >
            <Form.Item
                label="用户名"
                name="username"
                rules={[{ required: true, message: '请输入用户名!' }]}
            >
                <Input />
            </Form.Item>

            <Form.Item
                label="密码"
                name="password"
                rules={[{ required: true, message: '请输入密码!' }]}
            >
                <Input.Password />
            </Form.Item>

            <Form.Item
                {...layout2}
            >
                <div className='links'>
                    <a href=''>创建账号</a>
                    <a href=''>忘记密码</a>
                </div>
            </Form.Item>

            <Form.Item
                {...layout2}
            >
                <Button className='btn' type="primary" htmlType="submit">
                    登录
                </Button>
            </Form.Item>
        </Form>
    </div>   
}
```

其中，layout 是 label 和 wrapper 的比例分配，antd 的栅格系统一共分了 24 份。

上面两个 Form.Item 是 label 4 份，wrapper 20 份。

下面两个 Form.Item 是 label 0 份，wrapper 24 份。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/449f9e2e63a74ffd8ea6983d8240ea8d~tplv-k3u1fbpfcp-watermark.image?)

colon 为 false 是去掉 label 后的冒号

然后 css 部分如下：

```css
#login-container {
    width: 400px;
    margin: 100px auto 0 auto;
    text-align: center;
}
#login-container .links {
    display: flex;
    justify-content: space-between;
}
#login-container .btn {
    width: 100%;
}
```
访问 /login，可以看到现在的登录页面：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6397c6d6b8e45c491de9434302fce01~tplv-k3u1fbpfcp-watermark.image?)

输入用户名、密码，点击登录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7251c8782c5642d2b4d3fcaaa5c53a43~tplv-k3u1fbpfcp-watermark.image?)

控制台打印了拿到的表单值。

我们在前端项目安装下 axios：

```
npm install --save axios
```
然后把服务端跑起来：

跑之前先把端口配置改为 3005，因为前端开发服务用了 3000 端口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54feea3a1664459eb93155ef0d3a49ff~tplv-k3u1fbpfcp-watermark.image?)

然后在后端项目执行：

```
npm run start:dev
```
登录接口有哪些参数呢？

可以看 swagger 接口文档：

访问 http://localhost:3005/api-doc

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59581cf955ee4284855fe5e4dff6b3d4~tplv-k3u1fbpfcp-watermark.image?)

在 postman 里测试下登录接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb9838a802664241a9d690f784274a18~tplv-k3u1fbpfcp-watermark.image?)

然后在点击登录按钮之后，用 axios 调用它：

在前端项目创建个 interfaces.ts

```javascript
import axios from "axios";

const axiosInstance = axios.create({
    baseURL: 'http://localhost:3005/',
    timeout: 3000
});

export async function login(username: string, password: string) {
    return await axiosInstance.post('/user/login', {
        username, password
    });
}
```

在这里集中管理接口。

然后 onFinish 里调用：

```javascript
const onFinish = async (values: LoginUser) => {
    const res = await login(values.username, values.password);

    if(res.status === 201 || res.status === 200) {
        message.success('登录成功');

        console.log(res.data);
    } else {
        message.error(res.data.data || '系统繁忙，请稍后再试');
    }
};
```

登录下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14a2d9028e84756b745e2a6d25c682d~tplv-k3u1fbpfcp-watermark.image?)

提示跨域错误：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d41e5b3717884fae9b8e75e16e7e1ec5~tplv-k3u1fbpfcp-watermark.image?)

我们在服务端开启下跨域支持：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29f85d1f9974449785fb7f6e211774e8~tplv-k3u1fbpfcp-watermark.image?)

再试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bacfabc97e3b448fb07c630bc4a0fda4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1648&h=854&s=185505&e=gif&f=25&b=fdfdfd)

因为这个时候接口返回 400

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34f1a52fbeaf46488f8d36efa127ade7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=670&h=318&s=58584&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb3534c9da434332b5203eff817e40f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702&h=184&s=32332&e=png&b=ffffff)

axios 对于 400 多、500 多的请求，都会抛出错误。

所以我们加一个响应的拦截器处理下：

在 interface.ts 添加：

```javascript
axiosInstance.interceptors.response.use(
    (response) => {
        return response;
    },
    async (error) => {
        return error.response;
    }
);
```

再次调用，就能正常处理了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2db92139744eb19e7215ff7fbc25db~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1136&h=732&s=60739&e=png&b=fefefe)

如果你把返回的值改为 Promise.reject

```javascript
axiosInstance.interceptors.response.use(
    (response) => {
        return response;
    },
    async (error) => {
        return Promise.reject(error.response);
    }
);
```
就又恢复原样了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bacfabc97e3b448fb07c630bc4a0fda4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1648&h=854&s=185505&e=gif&f=25&b=fdfdfd)

因为 axios 默认就是这样处理的，400 多和 500 多的请求，会返回 reject。

把它改回来，然后测试下正常的请求：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07657faafb6f44c0bacdc6c39d5cb3fd~tplv-k3u1fbpfcp-watermark.image?)

提示登录成功，并且返回了用户信息和 token。

再输入错误的用户名、密码试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70a733d0d7644a6c94254db1cc4c0671~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd8a7f4598cd433c88cb5c30d600e351~tplv-k3u1fbpfcp-watermark.image?)

会返回 400 和具体的错误。

然后完善下 onFinish 方法：

```javascript
const onFinish = async (values: LoginUser) => {
    const res = await login(values.username, values.password);

    const { code, message: msg, data} = res.data;
    if(res.status === 201 || res.status === 200) {
        message.success('登录成功');

        localStorage.setItem('access_token', data.accessToken);
        localStorage.setItem('refresh_token', data.refreshToken);
        localStorage.setItem('user_info', JSON.stringify(data.userInfo));
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
};
```

返回 success 的时候，把 access_token、refresh_token、user_info 存入 localStorage

否则，提示错误。

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d814a38bbe7c427597d8f2af9b64093b~tplv-k3u1fbpfcp-watermark.image?)

登录成功之后，在 Application > Local Storage 里就可以看到这三个值

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff8d2f65c0ad4ff596bdef0725e70243~tplv-k3u1fbpfcp-watermark.image?)

用户不存在或者密码错误的时候，也提示了对应的错误：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/914d0258a4c84fa9975ccc8cc570a4d1~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f959b098c4224a628c5b7632535fb23e~tplv-k3u1fbpfcp-watermark.image?)

这样，登录的前后端功能就都完成了。

然后来写下注册：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/486e8f1ad6f845c8b255bb0e78fa5e64~tplv-k3u1fbpfcp-watermark.image?)

实现下 Register 页面组件：

```javascript
import { Button, Form, Input, message } from 'antd';
import './register.css';
import { login, registerCaptcha } from './interfaces';
import { useForm } from 'antd/es/form/Form';

export interface RegisterUser {
    username: string;
    nickName: string;
    password: string;
    confirmPassword: string;
    email: string;
    captcha: string;
}

const onFinish = async (values: RegisterUser) => {
    const res = await login(values.username, values.password);

    const { code, message: msg, data} = res.data;
    if(res.status === 201 || res.status === 200) {
        message.success('登录成功');

        localStorage.setItem('access_token', data.accessToken);
        localStorage.setItem('refresh_token', data.refreshToken);
        localStorage.setItem('user_info', JSON.stringify(data.userInfo));

        setTimeout(() => {
            navigate('/');
        }, 1000);
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
};


const layout1 = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}

const layout2 = {
    labelCol: { span: 0 },
    wrapperCol: { span: 24 }
}

export function Register() {
    const [form] = useForm();

    async function sendCaptcha() {
        const address = form.getFieldValue('email');

        const res = await registerCaptcha(address);
        console.log(res);
    }

    return <div id="register-container">
        <h1>会议室预订系统</h1>
        <Form
            form={form}
            {...layout1}
            onFinish={onFinish}
            colon={false}
            autoComplete="off"
        >
            <Form.Item
                label="用户名"
                name="username"
                rules={[{ required: true, message: '请输入用户名!' }]}
            >
                <Input />
            </Form.Item>

            <Form.Item
                label="昵称"
                name="nickName"
                rules={[{ required: true, message: '请输入昵称!' }]}
            >
                <Input />
            </Form.Item>

            <Form.Item
                label="密码"
                name="password"
                rules={[{ required: true, message: '请输入密码!' }]}
            >
                <Input.Password />
            </Form.Item>

            <Form.Item
                label="确认密码"
                name="confirmPassword"
                rules={[{ required: true, message: '请输入确认密码!' }]}
            >
                <Input.Password />
            </Form.Item>

            <Form.Item
                label="邮箱"
                name="email"
                rules={[
                    { required: true, message: '请输入邮箱!' },
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}
            >
                <Input />
            </Form.Item>

            <div className='captcha-wrapper'>
                <Form.Item
                    label="验证码"
                    name="captcha"
                    rules={[{ required: true, message: '请输入验证码!' }]}
                >
                    <Input />
                </Form.Item>
                <Button type="primary" onClick={sendCaptcha}>发送验证码</Button>
            </div>

            <Form.Item
                {...layout2}
            >
                <div className='links'>
                    已有账号？去<a href=''>登录</a>
                </div>
            </Form.Item>

            <Form.Item
                {...layout1}
                label=" "
            >
                <Button className='btn' type="primary" htmlType="submit">
                    注册
                </Button>
            </Form.Item>
        </Form>
    </div>   
}
```

和登录页面差不多，只不过多了一个验证码。

对应的 register.css 如下：

```css
#register-container {
    width: 400px;
    margin: 100px auto 0 auto;
    text-align: center;
}
#register-container .links {
    display: flex;
    justify-content: flex-end;
}
#register-container .btn {
    width: 100%;
}
#register-container .captcha-wrapper {
    display: flex;
    justify-content: flex-end;
}

```

浏览器访问下 http://localhost:3000

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21956a0a22d440cdbadfdfc7f54f8881~tplv-k3u1fbpfcp-watermark.image?)

填入信息，点击注册，控制台会打印表单值：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21469f096b8540a7aec77b5298209cb0~tplv-k3u1fbpfcp-watermark.image?)

然后来调用下注册接口和发送验证码的接口。

在 swagger 文档看下这俩接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b5413a4466a46199cc957211859ed0d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1846aa13f249988dbeff81cc24c419~tplv-k3u1fbpfcp-watermark.image?)

同样，我们先在 postman 里调用下：

调用发送验证码接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b663fd1d230e49bfa218be3489d68b1c~tplv-k3u1fbpfcp-watermark.image?)

邮箱收到了对应的邮件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8f0584882b04cbe89ef19ecbbe1e1c1~tplv-k3u1fbpfcp-watermark.image?)

然后调用注册接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a5583723017465e86892b65f1906613~tplv-k3u1fbpfcp-watermark.image?)

注册成功，数据库也多了一条记录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc36081ebb5448a6a660c222cbd3eabb~tplv-k3u1fbpfcp-watermark.image?)

我们在页面是实现这个流程：

在 interface.tsx 里添加这两个接口：

```javascript
export async function registerCaptcha(email: string) {
    return await axiosInstance.get('/user/register-captcha', {
        params: {
            address: email
        }
    });
}

export async function register(registerUser: RegisterUser) {
    return await axiosInstance.post('/user/register', registerUser);
}
```
先调用发送验证码接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/470ee645b6534b8aac4a68009d75a28d~tplv-k3u1fbpfcp-watermark.image?)

绑定点击事件。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d67fc5d86c49c88f72cf756fff55fe~tplv-k3u1fbpfcp-watermark.image?)

使用 useForm 来拿到 form 的 api

```javascript
async function sendCaptcha() {
    const address = form.getFieldValue('email');
    if(!address) {
        return message.error('请输入邮箱地址');
    }

    const res = await registerCaptcha(address);
    if(res.status === 201 || res.status === 200) {
        message.success(res.data.data);
    } else {
        message.error(res.data.data || '系统繁忙，请稍后再试');
    }
}
```
在 sendCaptcha 里调用接口发送验证码。

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e17e40366e7b423c952de75c145f3efa~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5550c07ea3a14910bd444dc50300008d~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

不过这个函数每次都创建新的，会导致重复渲染。

所以我们用 useCallback 包裹下：

```javascript
const sendCaptcha = useCallback(async function () {
    const address = form.getFieldValue('email');
    if(!address) {
        return message.error('请输入邮箱地址');
    }

    const res = await registerCaptcha(address);
    if(res.status === 201 || res.status === 200) {
        message.success(res.data.data);
    } else {
        message.error(res.data.data || '系统繁忙，请稍后再试');
    }
}, []);
```
这是减少不必要渲染的一种性能优化。

然后再来调用注册接口：

```javascript
const onFinish = async (values: RegisterUser) => {
    if(values.password !== values.confirmPassword) {
        return message.error('两次密码不一致');
    }
    const res = await register(values);

    if(res.status === 201 || res.status === 200) {
        message.success('注册成功');

    } else {
        message.error(res.data.data || '系统繁忙，请稍后再试');
    }
}
```
测试下：

填入信息，点击发送验证码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64da43af93d040a3b4eee6fe331ac064~tplv-k3u1fbpfcp-watermark.image?)

去邮箱里看一下验证码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6792e07396264f8aa0150546ef12deb8~tplv-k3u1fbpfcp-watermark.image?)

填入验证码，点击注册：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d8b50cd770842bd9654beb12d9d25b6~tplv-k3u1fbpfcp-watermark.image?)

注册成功，数据库里也看到了这条记录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/329a515636d44ccf9aba75362c857d63~tplv-k3u1fbpfcp-watermark.image?)

这样，注册的前后端流程就走完了。

然后我们给它加上跳转逻辑：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87a63bf3c80f4d648c36b70624fbbffa~tplv-k3u1fbpfcp-watermark.image?)

把 onFinish 移到组件内，使用 useCallback 包裹。

然后调用 useNavigate 的 navigate 方法，注册成功后导航到登录也：

```javascript
const navigate = useNavigate();

    const onFinish = useCallback(async (values: RegisterUser) => {
        if(values.password !== values.confirmPassword) {
            return message.error('两次密码不一致');
        }
        const res = await register(values);
    
        if(res.status === 201 || res.status === 200) {
            message.success('注册成功');
            setTimeout(() => {
                navigate('/login');
            }, 1500);
        } else {
            message.error(res.data.data || '系统繁忙，请稍后再试');
        }
    }, []);
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b0c6402fb644e2b1d36f832b92590c~tplv-k3u1fbpfcp-watermark.image?)

登录也要加上导航，登录成功后导航到首页：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c952cc4b1e8d435fb0c2a99da24a3281~tplv-k3u1fbpfcp-watermark.image?)
```javascript
const navigate = useNavigate();

const onFinish = useCallback(async (values: LoginUser) => {
    const res = await login(values.username, values.password);

    const { code, message: msg, data} = res.data;
    if(res.status === 201 || res.status === 200) {
        message.success('登录成功');

        localStorage.setItem('access_token', data.accessToken);
        localStorage.setItem('refresh_token', data.refreshToken);
        localStorage.setItem('user_info', JSON.stringify(data.userInfo));

        setTimeout(() => {
            navigate('/');
        }, 1000);
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}, []);
```
还有这几个链接也要改成 router 的 Link：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df23c2541a37403db5c1091fcb0421fc~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0522f7516dd9474694026f3ac1f96d23~tplv-k3u1fbpfcp-watermark.image?)

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7603271639064606a217c1d629313766~tplv-k3u1fbpfcp-watermark.image?)

最后，我们再来重构下代码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bbd6c44ba5545ddb614f82d6a30c4ee~tplv-k3u1fbpfcp-watermark.image?)

现在的代码都是平级放的，我们分几个目录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7b018751e0040509b237c960c29a809~tplv-k3u1fbpfcp-watermark.image?)

添加 page 目录和 interface 目录，把对应的文件移动过去，然后修改下引用它的路径。

这样，登录和注册的前后端功能就都完成了。

案例代码在小册仓库：

[用户端前端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_user)

[后端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)

## 总结

这节我们打通了前后端，加上了登录、注册、首页等页面。

首先，引入了 React Router 来做路由，引入了 antd 来做 UI 组件库。

然后，引入了 axios 来发请求。

我们先在 postman 里测试了一遍接口，之后在页面里用 axios 调用了下。

组件里的函数，如果作为参数的话，需要添加 useCallback，这样避免每次都创建新的函数导致不必要的渲染。

经测试，发送邮件验证码正常，注册之后数据库也多了记录，登录成功之后 localStorage 也有了用户信息。

这样，注册登录就实现了完整的前后端功能。

下节，我们继续写其他页面。


## 109.会议室预订系统：用户管理模块-- 用户端信息修改页面

用户相关的页面还剩下两个，这节我们来写一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b7366af920b41c890686f5a10c21d7b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403f30e8cf80493c8af4ab50054aba3c~tplv-k3u1fbpfcp-watermark.image?)

首先是修改密码的页面，把注册页面的表单拿过来改改就行：

```javascript
import { Button, Form, Input, message } from 'antd';
import { useForm } from 'antd/es/form/Form';
import './update_password.css';
import { useCallback } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export interface UpdatePassword {
    email: string;
    captcha: string;
    password: string;
    confirmPassword: string;
}

const layout1 = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}

const layout2 = {
    labelCol: { span: 0 },
    wrapperCol: { span: 24 }
}

export function UpdatePassword() {
    const [form] = useForm();
    const navigate = useNavigate();

    const onFinish = useCallback(async (values: UpdatePassword) => {
        console.log(values);
    }, []);

    const sendCaptcha = useCallback(async function () {
        console.log('send captcha')
    }, []);
    

    return <div id="updatePassword-container">
        <h1>会议室预订系统</h1>
        <Form
            form={form}
            {...layout1}
            onFinish={onFinish}
            colon={false}
            autoComplete="off"
        >
            <Form.Item
                label="邮箱"
                name="email"
                rules={[
                    { required: true, message: '请输入邮箱!' },
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}
            >
                <Input />
            </Form.Item>

            <div className='captcha-wrapper'>
                <Form.Item
                    label="验证码"
                    name="captcha"
                    rules={[{ required: true, message: '请输入验证码!' }]}
                >
                    <Input />
                </Form.Item>
                <Button type="primary" onClick={sendCaptcha}>发送验证码</Button>
            </div>

            <Form.Item
                label="密码"
                name="password"
                rules={[{ required: true, message: '请输入密码!' }]}
            >
                <Input.Password />
            </Form.Item>

            <Form.Item
                label="确认密码"
                name="confirmPassword"
                rules={[{ required: true, message: '请输入确认密码!' }]}
            >
                <Input.Password />
            </Form.Item>

            <Form.Item
                {...layout1}
                label=" "
            >
                <Button className='btn' type="primary" htmlType="submit">
                    修改
                </Button>
            </Form.Item>
        </Form>
    </div>   
}
```
css 部分如下：

```css
#updatePassword-container {
    width: 400px;
    margin: 100px auto 0 auto;
    text-align: center;
}
#updatePassword-container .btn {
    width: 100%;
}
#updatePassword-container .captcha-wrapper {
    display: flex;
    justify-content: flex-end;
}
```
跑起来是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ea926323a3413aa75eb2b72b58f132~tplv-k3u1fbpfcp-watermark.image?)

然后再调用下后端接口。

这时我发现一个问题：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22ee033ec679475aa76cf020c9dc5676~tplv-k3u1fbpfcp-watermark.image?)

之前写的 update_password 接口需要登录，然后用 @UserInfo 从 reqeust.user 取 userId。

但其实这个页面是从这里点进来的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ff34ad6d0ca45f19ad70a44c59fb32a~tplv-k3u1fbpfcp-watermark.image?)

这时候并没有登录，只是通过邮箱验证身份，然后修改密码。

但是邮箱我们并没有添加唯一约束，只有 username 是在注册的时候做了唯一检查：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/713f2f53de354df39ca53076c970e85b~tplv-k3u1fbpfcp-watermark.image?)

所以需要通过 username 来找到修改密码的用户。

可以改成前端传 username，然后后端验证过邮箱验证码之后，再根据 username 查询摇改密码的用户。

此外，我们在 User 的 entity 这里给 username 添加唯一约束：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dbdf294100148f1bc98a82f6b3868f3~tplv-k3u1fbpfcp-watermark.image?)

然后可以看到 typeorm 确实给 username 添加了唯一索引：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c87e80604df24a84abe2e011e578cbd5~tplv-k3u1fbpfcp-watermark.image?)

在 mysql workbench 里也可以看到：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df88120f70d04b98bd9c64ba767ea2b7~tplv-k3u1fbpfcp-watermark.image?)

然后修改下 update_password 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca189ebeadf0487dbff03a672a81a792~tplv-k3u1fbpfcp-watermark.image?)

把 @RequireLogin、@ApiBearAuth 还有 @UsrInfo 去掉。

修改 UpdatePasswordDto，添加 username 属性：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/989f7fec54114abc88a4a388a2da7c10~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@IsNotEmpty({
    message: '用户名不能为空'
})
@ApiProperty()
username: string;
```

然后改下 UserService 的 updatePassword 方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10b19058e7e14a37b54d070fc5ed2f5a~tplv-k3u1fbpfcp-watermark.image?)

改成根据 username 查询用户，并且还要验证下邮箱是否正确。

```javascript
const foundUser = await this.userRepository.findOneBy({
  username: passwordDto.username
});

if(foundUser.email !== passwordDto.email) {
    throw new HttpException('邮箱不正确', HttpStatus.BAD_REQUEST);
}
```
还有，发送验证码接口的 @RequireLogin 和 @ApiBearerAuth 也要去掉：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5877cc929f4f7abdbce26dae113357~tplv-k3u1fbpfcp-watermark.image?)

测试下：

请求 /user/update_password/captcha 接口发送验证码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e64810bb9cf84aa99d9b78f7aae3c880~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b46b5454c2b9490f80c9084d83f54dba~tplv-k3u1fbpfcp-watermark.image?)

然后请求 /user/update_password 接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad21d242955b4f6ea9b029874c483b66~tplv-k3u1fbpfcp-watermark.image?)

提示修改密码成功。

我们在页面登录下试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9352ea8151d6400c9755f8cce24d8ee9~tplv-k3u1fbpfcp-watermark.image?)

用最新密码登录，提示登录成功。

postman 里跑通流程之后，我们在页面里加一下。

在更改密码页面加上 username 表单项：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b12a83a8aa6a4080841fd93368330911~tplv-k3u1fbpfcp-watermark.image?)

```javascript
<Form.Item
    label="用户名"
    name="username"
    rules={[
        { required: true, message: '请输入用户名!' },
    ]}
>
    <Input />
</Form.Item>
```

类型中也加上 username：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/189d1d1ae9d748cb895e5a5ce5f92dc8~tplv-k3u1fbpfcp-watermark.image?)

然后在 interfaces.ts 添加这两个接口：
```javascript
export async function updatePasswordCaptcha(email: string) {
    return await axiosInstance.get('/user/update_password/captcha', {
        params: {
            address: email
        }
    });
}

export async function updatePassword(data: UpdatePassword) {
    return await axiosInstance.post('/user/update_password', data);
}
```
更改密码页面里调用下：

```javascript
const sendCaptcha = useCallback(async function () {
    const address = form.getFieldValue('email');
    if(!address) {
        return message.error('请输入邮箱地址');
    }

    const res = await updatePasswordCaptcha(address);
    if(res.status === 201 || res.status === 200) {
        message.success(res.data.data);
    } else {
        message.error('系统繁忙，请稍后再试');
    }
}, []);
```

发送验证码接口的调用逻辑和注册时一模一样。

更改密码接口的调用逻辑也和注册差不多：

```javascript
const onFinish = useCallback(async (values: UpdatePassword) => {
    if(values.password !== values.confirmPassword) {
        return message.error('两次密码不一致');
    }
    const res = await updatePassword(values);

    const { message: msg, data} = res.data;

    if(res.status === 201 || res.status === 200) {
        message.success('密码修改成功');
        setTimeout(() => {
            navigate('/login');
        }, 1500);
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}, []);
```
测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc7f42bc91e4a34b2c41ec71f9f2973~tplv-k3u1fbpfcp-watermark.image?)

填入邮箱，点击发送验证码。

提示发送成功。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b27af2af83e343c4ba0f25fb0e19d385~tplv-k3u1fbpfcp-watermark.image?)

邮箱里也收到了这个验证码。

然后填入新密码，点击修改密码按钮：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/880d11d06e68489895f6c3ef48f0dc45~tplv-k3u1fbpfcp-watermark.image?)

提示修改成功，然后会跳到登录页面：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2709c92a2b034af2b2e7b9c4e90d5c87~tplv-k3u1fbpfcp-watermark.image?)

在登录页面用新密码登录，提示登录成功。

这样，修改密码功能的前后端就都完成了。

然后还有一个更改个人信息的页面。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403f30e8cf80493c8af4ab50054aba3c~tplv-k3u1fbpfcp-watermark.image?)

这个页面有所不同。

前面几个功能都是未登录时的，而这个修改个人信息的功能需要登录之后才能用。

而且界面上方是有公共的导航栏的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/763f8c79fb924e6c884af3342b767665~tplv-k3u1fbpfcp-watermark.image?)

所以这个页面要声明一个 /index 的路由作为父级路由，然后 /index/update_info 作为子路由。

添加一个 index/index.tsx 页面

```javascript
import { UserOutlined } from "@ant-design/icons";
import { Outlet } from "react-router-dom";
import './index.css';

export function Index() {
    return <div id="index-container">
        <div className="header">
            <h1>会议室预定系统</h1>
            <UserOutlined className="icon"/>
        </div>
        <div className="body">
            <Outlet></Outlet>
        </div>
    </div>
}
```

这里用到了 antd 的 icon 组件，需要安装用到的包：

```
npm install @ant-design/icons --save
```

css 如下：

```css
#index-container{
    height: 100vh;
    display: flex;
    flex-direction: column;
}
#index-container .header{
    height: 80px;
    border-bottom: 1px solid #aaa;
    line-height: 80px;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
}
#index-container h1{
    margin: 0;
}

#index-container .icon {
    font-size: 40px;
    margin-top: 20px;
}
#index-container .body{
    flex: 1;
}
```
整体是竖直的 flex 布局，高度 100vh，上面 80px 下面 flex:1

然后 header 部分是 水平的 flex 布局。

把它添加到 /index 的路由，并且添加两个子路由：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/182471b6be46400db2ac1ce06fd68220~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
    path: "/",
    element: <Index></Index>,
    errorElement: <ErrorPage />,
    children: [
      {
        path: 'aaa',
        element: <div>aaa</div>
      },
      {
        path: 'bbb',
        element: <div>bbb</div>
      }
    ]
},
```
测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35f97b403326489eb77ecefa4e74b034~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b08fa7fd7cc04e0f92d0a48a29f1b27b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b65315e3b34accb9d3b09e60b6090c~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

然后在下面添加 update_info 路由，并实现 page/update_info/UpdateInfo 组件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e2294846df4f7da6ec2a3d721e153b~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { Button, Form, Input, message } from 'antd';
import { useForm } from 'antd/es/form/Form';
import { useCallback } from 'react';
import './update_info.css';
import { useNavigate } from 'react-router-dom';

export interface UserInfo {
    headPic: string;
    nickName: string;
    email: string;
    captcha: string;
}

const layout1 = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}

export function UpdateInfo() {
    const [form] = useForm();
    const navigate = useNavigate();

    const onFinish = useCallback(async (values: UserInfo) => {
        
    }, []);

    const sendCaptcha = useCallback(async function () {
    }, []);

    return <div id="updateInfo-container">
        <Form
            form={form}
            {...layout1}
            onFinish={onFinish}
            colon={false}
            autoComplete="off"
        >
            <Form.Item
                label="头像"
                name="headPic"
                rules={[
                    { required: true, message: '请输入头像!' },
                ]}
            >
                <Input/>
            </Form.Item>

            <Form.Item
                label="昵称"
                name="nickName"
                rules={[
                    { required: true, message: '请输入昵称!' },
                ]}
            >
                <Input />
            </Form.Item>

            <Form.Item
                label="邮箱"
                name="email"
                rules={[
                    { required: true, message: '请输入邮箱!' },
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}
            >
                <Input />
            </Form.Item>

            <div className='captcha-wrapper'>
                <Form.Item
                    label="验证码"
                    name="captcha"
                    rules={[{ required: true, message: '请输入验证码!' }]}
                >
                    <Input />
                </Form.Item>
                <Button type="primary" onClick={sendCaptcha}>发送验证码</Button>
            </div>

            <Form.Item
                {...layout1}
                label=" "
            >
                <Button className='btn' type="primary" htmlType="submit">
                    修改密码
                </Button>
            </Form.Item>
        </Form>
    </div>   
}
```
和前几个页面差不多。

css：

```css
#updateInfo-container {
    width: 400px;
    margin: 50px auto 0 auto;
    text-align: center;
}
#updateInfo-container .btn {
    width: 100%;
}
#updateInfo-container .captcha-wrapper {
    display: flex;
    justify-content: flex-end;
}
```

访问 /update_info 可以看到这个页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdbc7a199b96467c8178303263698d65~tplv-k3u1fbpfcp-watermark.image?)

这个页面涉及到 3 个接口：

- /user/info 查询用户信息的接口，用来回显数据

- /user/update 修改用户信息的接口，用来做修改

- /user/update/captcha 发送验证码的接口

我们看下 swagger 接口文档：

/user/info 接口没有参数，但是需要登录：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f24c63941074ccb8d6f99506f197f78~tplv-k3u1fbpfcp-watermark.image?)

/user/update 接口需要在 body 传这么几个参数：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a0959e2ac2243df85f09c2702ac84ee~tplv-k3u1fbpfcp-watermark.image?)

/user/update/captcha 需要传一个邮箱地址：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457dc1c5ed05499a9d7ea8beeb3d64fb~tplv-k3u1fbpfcp-watermark.image?)

不知道有没有同学发现这里有点不太合理：

邮箱是用户自己传的，那如果传的不是注册用的邮箱呢？

前面发送验证码需要传邮箱地址，是因为那是注册或者修改密码用，没有登录。

而现在已经登录了，就不应该再传邮箱地址了，应该是放在 jwt 里，然后在 LoginGuard 里取出来注入 controller。

我们改一下：

改一下这个 login 接口，在 jwt 里放 email 的信息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/383d258363e64af7a5ed2cf642eb9d5c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1efd2f5ffef435fbce540d1bcfd0696~tplv-k3u1fbpfcp-watermark.image?)

同时 refresh 接口也要改下放在 jwt 里的信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b523801fe1a54d84a597e5911757a0e4~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a02f258ab5c3470ba608be2246f0e44f~tplv-k3u1fbpfcp-watermark.image?)

这里要取 user.email，需要在 UserService 的 findUserById 方法里返回下 email：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84720182cae64e87874d6c71fd480f4f~tplv-k3u1fbpfcp-watermark.image?)

然后在 LoginGuard 里从 jwt 里取出 email 来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74e1689b21e24676864bb2e54c35201d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0753c6be22704694bed07af02f323c9c~tplv-k3u1fbpfcp-watermark.image?)

然后在 /user/update/captcha 就可以直接从 request.user 里拿 email 信息了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01ec356cbab6476ea482c9fdc90e9e9d~tplv-k3u1fbpfcp-watermark.image?)

把参数的标注去掉，其余的都不用变，这样就是从 jwt 里取登录用户的 email 来发邮件了。

我们测试下：

先登录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdff86b66e444cda8ac956f0ae81377b~tplv-k3u1fbpfcp-watermark.image?)

然后用这个 accessToken 访问下发送验证码接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327bf1f73d324d65a76ac98bdf3828d6~tplv-k3u1fbpfcp-watermark.image?)

发送成功，收到了这个验证码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4064d1cc933f40f5b0941f93b146c265~tplv-k3u1fbpfcp-watermark.image?)

然后调用下查询用户信息的接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/640a1930a34348fdb1e9da26ea7b58fa~tplv-k3u1fbpfcp-watermark.image?)

之后调用修改接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad0755d5d7a4de39048f4d9b0d9bd65~tplv-k3u1fbpfcp-watermark.image?)

在数据库里看下，用户信息已经改过来了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76678f13d7e44a3fa128cbad75d52b87~tplv-k3u1fbpfcp-watermark.image?)

postman 里接口的流程跑通之后，我们在页面调用下。

首先在 interfaces.ts 里添加这 3 个接口：

```javascript
export async function getUserInfo() {
    return await axiosInstance.get('/user/info');
}

export async function updateInfo(data: UserInfo) {
    return await axiosInstance.post('/user/update', data);
}

export async function updateUserInfoCaptcha() {
    return await axiosInstance.get('/user/update/captcha');
}
```

然后我们先做用户信息的回显：

```javascript

useEffect(() => {
    async function query() {
        const res = await getUserInfo();

        const { data } = res.data;

        if(res.status === 201 || res.status === 200) {
            console.log(data);
        }
    }
    query();
}, []);
```
调用 getUserInfo 接口，返回数据后打印下。

这个接口的访问需要登录，也就是要从 localStorage 里取出 accessToken 放到 header 里。

这种携带 header 的通用逻辑可以放在 axios 的 interceptor 里做。

并且还有 token 过期之后调用 refresh 刷新 token 的逻辑。

这个我们前面写过，直接拿过来放在 interfaces.ts 里：

```javascript
import { message } from "antd";

const axiosInstance = axios.create({
    baseURL: 'http://localhost:3005/',
    timeout: 3000
});

axiosInstance.interceptors.request.use(function (config) {
    const accessToken = localStorage.getItem('access_token');

    if(accessToken) {
        config.headers.authorization = 'Bearer ' + accessToken;
    }
    return config;
})

interface PendingTask {
    config: AxiosRequestConfig
    resolve: Function
  }
let refreshing = false;
const queue: PendingTask[] = [];

axiosInstance.interceptors.response.use(
    (response) => {
        return response;
    },
    async (error) => {
        if(!error.response) {
            return Promise.reject(error);
        }
        let { data, config } = error.response;

        if(refreshing) {
            return new Promise((resolve) => {
                queue.push({
                    config,
                    resolve
                });
            });
        }

        if (data.code === 401 && !config.url.includes('/user/refresh')) {
            
            refreshing = true;

            const res = await refreshToken();

            refreshing = false;

            if(res.status === 200) {

                queue.forEach(({config, resolve}) => {
                    resolve(axiosInstance(config))
                })

                return axiosInstance(config);
            } else {
                message.error(res.data);

                setTimeout(() => {
                    window.location.href = '/login';
                }, 1500);
            }
            
        } else {
            return error.response;
        }
    }
)

async function refreshToken() {
    const res = await axiosInstance.get('/user/refresh', {
        params: {
          refresh_token: localStorage.getItem('refresh_token')
        }
    });
    localStorage.setItem('access_token', res.data.access_token || '');
    localStorage.setItem('refresh_token', res.data.refresh_token || '');
    return res;
}
```

这段逻辑就是在每次发请求之前，在 header 里加上 authorization，带上 access_token。

当响应码是 401 的时候，就刷新 token，刷新失败提示错误信息，然后跳到登录页。

并且通过 refreshing 的标记和 task 队列实现了并发请求只刷新一次。

这部分看不明白的同学建议回头看下 access_token 和 refresh_token 无感刷新那节。

其中，这代码代码可能有同学有疑问：

```javascript
if(!error.response) {
    return Promise.reject(error);
}
```
是为了请求没有发送成功的情况的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c41c4d9c700f445b85f3601c68678587~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=662&h=316&s=62598&e=png&b=fefcfc)

请求没有发送成功时，错误对象没有 response 属性。

接下来，我们先登录下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bf746fc8f0642e98fc19e06296bfe38~tplv-k3u1fbpfcp-watermark.image?)

给用户图标添加跳到 /update_info 的链接：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0658c70cd3c49b89f3a6d813e1a54e6~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b78070db300d4fbd88996ef93453fa86~tplv-k3u1fbpfcp-watermark.image?)

然后可以看到控制台打印了当前登录用户的信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b4ae58579434d4b87bed572d378d1f1~tplv-k3u1fbpfcp-watermark.image?)

然后我们做下回显：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/647af8a7d2ec487ca1a2d729f7deef55~tplv-k3u1fbpfcp-watermark.image?)

```javascript
form.setFieldValue('headPic', data.headPic);
form.setFieldValue('nickName', data.nickName);
form.setFieldValue('email', data.email);
```
这样，回显的数据就有了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b695dd92e940a9becc6d5b75f4c821~tplv-k3u1fbpfcp-watermark.image?)

然后实现发送验证码：
 
```javascript
const sendCaptcha = useCallback(async function () {
    const res = await updateUserInfoCaptcha();
    if(res.status === 201 || res.status === 200) {
        message.success(res.data.data);
    } else {
        message.error('系统繁忙，请稍后再试');
    }
}, []);
```
这里不需要填邮箱地址，服务端会从 jwt 里取。

那这里的邮箱也是不应该修改的，给它加个 disabled：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e3d089323254c90b0eb987530dd96f3~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a63f00139e74ad4b2b407ddb2f54a0d~tplv-k3u1fbpfcp-watermark.image?)

点击发送验证码。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f29f4a159b954c9588debf275f4472ec~tplv-k3u1fbpfcp-watermark.image?)

提示发送成功，邮箱里也收到了这个验证码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75b13b47b52c4a0a8a1888ec6e6c85a4~tplv-k3u1fbpfcp-watermark.image?)

接下来就差更新接口了，我们调用下：

```javascript
const onFinish = useCallback(async (values: UserInfo) => {
    const res = await updateInfo(values);

    if(res.status === 201 || res.status === 200) {
        const { message: msg, data} = res.data;
        if(msg === 'success') {
            message.success('用户信息更新成功');
        } else {
            message.error(data);
        }
    } else {
        message.error('系统繁忙，请稍后再试');
    }
}, []);
```
测试下：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74811a6e760a4ec08cf0ff594d54d308~tplv-k3u1fbpfcp-watermark.image?)

修改信息，点击发送验证码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5df16c92cf374852ad591081f178d3a0~tplv-k3u1fbpfcp-watermark.image?)

填入验证码，点击修改，提示用户信息更新成功。

去数据库里看一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e39625951d2a400bb2a2531afb1bd2d5~tplv-k3u1fbpfcp-watermark.image?)

确实修改成功了。

这样，修改用户信息的流程就走完了。

不过现在的头像是直接填的路径，这里应该做成图片的展示，以及图片的上传。

我们需要添加个上传图片的接口：

在 UserController 里添加这个 handler：

```javascript
@Post('upload')
@UseInterceptors(FileInterceptor('file', {
  dest: 'uploads'
}))
uploadFile(@UploadedFile() file: Express.Multer.File) {
  console.log('file', file);
  return file.path;
}
```
安装用到的类型包：

```
npm install @types/multer
```
在 postman 里测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c5535eb022a4874a3a9d1307be98bcb~tplv-k3u1fbpfcp-watermark.image?)

选择 form-data 类型，然后添加 file 字段，选择一个文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8888eda3c5f64d628b8ed40a0bf9792f~tplv-k3u1fbpfcp-watermark.image?)

返回了服务端保存路径，并且打印了文件信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43eb068644aa4b3aa04084a55ba402db~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86545f1efc5e47dc8dbee5141909de92~tplv-k3u1fbpfcp-watermark.image?)

我们限制下只能上传图片：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3982c612db4432a3b258df289b25e2~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import * as path from 'path';
```
```javascript
@Post('upload')
@UseInterceptors(FileInterceptor('file', {
  dest: 'uploads',
  fileFilter(req, file, callback) {
    const extname = path.extname(file.originalname);        
    if(['.png', '.jpg', '.gif'].includes(extname)) {
      callback(null, true);
    } else {
      callback(new BadRequestException('只能上传图片'), false);
    }
  }
}))
uploadFile(@UploadedFile() file: Express.Multer.File) {
  console.log('file', file);
  return file.path;
}
```
callback 的第一个参数是 error，第二个参数是是否接收文件。

然后我们上传一个非图片文件试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0332f1eb9211425d94f78858a7354da2~tplv-k3u1fbpfcp-watermark.image?)

返回了错误信息。

上传图片是正常的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d17889cafa914f54bfe63cf6ef51af5a~tplv-k3u1fbpfcp-watermark.image?)

然后限制下图片大小，最大 3M:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ef1ff5f40f64038b578eda8f1fa919e~tplv-k3u1fbpfcp-watermark.image?)

```javascript
limits: {
    fileSize: 1024 * 1024 * 3
}
```
当你上传超过 3M 的图片时，会提示错误：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380ffe4dc0d3457783e491c345cbf6fc~tplv-k3u1fbpfcp-watermark.image?)

然后我们改下保存的文件名，这需要自定义 storage。

前面讲 multer 文件上传那节讲过，直接拿过来（忘了的同学可以回头看一下）：

添加 src/my-file-storage.ts

```javascript
import * as multer from "multer";
import * as fs from 'fs';

const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        try {
            fs.mkdirSync('uploads');
        }catch(e) {}

        cb(null, 'uploads')
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9) + '-' + file.originalname
        cb(null, uniqueSuffix)
    }
});

export { storage };
```
这个就是自己指定怎么存储，multer.distkStorage 是磁盘存储，通过 destination、filename 的参数分别指定保存的目录和文件名。

指定 storage：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f76955ccbf489bb08b956b92d4099a~tplv-k3u1fbpfcp-watermark.image?)

然后测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/700b94fd0877437bb5f4efa31909e9dd~tplv-k3u1fbpfcp-watermark.image?)

这样路径就能看出来是什么文件了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01a3717e55134216b78f876000106c9f~tplv-k3u1fbpfcp-watermark.image?)

我们把这个目录设置为静态文件目录，这样能直接访问上传的图片。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7716506af9f4739a0a35984c561472a~tplv-k3u1fbpfcp-watermark.image?)

在 main.ts 里添加 uploads 目录为静态目录：

```javascript
app.useStaticAssets('uploads', {
    prefix: '/uploads'
});
```
指定通过 /uploads 的前缀访问。

然后我们把路径复制，在浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/147e219987f94e4c994d564f2a9c3f3a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7463c2dc1729452ea90b1aa1e4bfcccc~tplv-k3u1fbpfcp-watermark.image?)

这样就可以访问到上传的文件了。

也就是说，上传头像之后，可以直接拿到图片的 url。

我们在页面里加一下：

在 src/page/update_info  下增加一个 HeadPicUpload.tsx

```javascript
import { Button, Input } from "antd";

interface HeadPicUploadProps {
    value?: string;
    onChange?: Function
}

export function HeadPicUpload(props: HeadPicUploadProps) {
    return props?.value ? <div>
        {props.value}
        <Button>上传</Button>
    </div>: <div>
        <Button>上传</Button>
    </div>
}
```
在上传头像的地方引入下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8272e7c2fc754d329d77373d38364249~tplv-k3u1fbpfcp-watermark.image?)

为什么是 value 和 onChange 两个参数呢？

因为 antd 的 Form.Item 在渲染时会给子组件传这两个参数。

现在渲染出来的是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56a0a3a955734d82a9361a3313f729f4~tplv-k3u1fbpfcp-watermark.image?)

我们在 postman 里上传个图片，比如这个：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9c242a826a444619535b8cfb8614c3d~tplv-k3u1fbpfcp-watermark.image?)

拿到它的路径：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1bf760e5a84746bb7a5d47b4de9e97~tplv-k3u1fbpfcp-watermark.image?)

然后手动去数据库里改一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b5dd0a198d2446a8aaffc3baaad8e57~tplv-k3u1fbpfcp-watermark.image?)

点击 apply。

刷新下页面，可以看到确实变了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0cd941956f6455a95978cfb0d78241e~tplv-k3u1fbpfcp-watermark.image?)

然后把它改成图片：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/108e51eccfbf4c7aa6acc901b2efb115~tplv-k3u1fbpfcp-watermark.image?)

```javascript
<img src={'http://localhost:3005/' + props.value} alt="头像" width="100" height="100"/>
```

头像就显示出来了：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6829ffd78434cfa8eb8cd2acc128eb5~tplv-k3u1fbpfcp-watermark.image?)

然后我们把后面的上传按钮改为 antd 的拖拽上传组件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49ad6db7b8694b6cafae27daaa78620e~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { InboxOutlined } from "@ant-design/icons";
import { Button, Input, message } from "antd";
import Dragger, { DraggerProps } from "antd/es/upload/Dragger";

interface HeadPicUploadProps {
    value?: string;
    onChange?: Function
}

const props: DraggerProps = {
    name: 'file',
    action: 'http://localhost:3005/user/upload',
    onChange(info) {
        const { status } = info.file;
        if (status === 'done') {
            console.log(info.file.response);    
            message.success(`${info.file.name} 文件上传成功`);
        } else if (status === 'error') {
            message.error(`${info.file.name} 文件上传失败`);
        }
    }
};

const dragger = <Dragger {...props}>
    <p className="ant-upload-drag-icon">
        <InboxOutlined />
    </p>
    <p className="ant-upload-text">点击或拖拽文件到这个区域来上传</p>
</Dragger>

export function HeadPicUpload(props: HeadPicUploadProps) {
    return props?.value ? <div>
        <img src={'http://localhost:3005/' + props.value} alt="头像" width="100" height="100"/>
        {dragger}
    </div>: <div>
        {dragger}
    </div>
}
```
测试下，提示上传成功：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e21936ea6b5e433fa5b1b74436c4861e~tplv-k3u1fbpfcp-watermark.image?)

控制台打印了文件路径：

![i](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/192498e410e24ce1a8f3fe1c4f7644b1~tplv-k3u1fbpfcp-watermark.image?)

服务端也确实有了这个文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e2f4ca504549bdac0b8c100c7484ff~tplv-k3u1fbpfcp-watermark.image?)

我们浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec77983568eb4b919bd849312ded7841~tplv-k3u1fbpfcp-watermark.image?)

能够正常访问。

接下来就通过 onChange 回调传给 Form 就好了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34ba8ebd1b9642e0b01880b5b8cf552e~tplv-k3u1fbpfcp-watermark.image?)

这样表单的值就会改，触发重新渲染，就可以看到新的头像：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcfca0ff2ed244af8e87050526af89e2~tplv-k3u1fbpfcp-watermark.image?)

不过现在还没更新到数据库。

点击发送验证码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a08cc00eca4e66997aa43111f07701~tplv-k3u1fbpfcp-watermark.image?)

填入验证码，点击修改：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aee31ed40a7d43ddbbf99b2bd254a071~tplv-k3u1fbpfcp-watermark.image?)

提示更新成功。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0450d9a3cf24a57acb3ce2454392887~tplv-k3u1fbpfcp-watermark.image?)

数据库里确实更新了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18a48ee2c16c44849e09d048dbb159f5~tplv-k3u1fbpfcp-watermark.image?)

刷新下页面，可以看到依然是这个头像：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16ce3e93ca4b4c44a79d5bb43a710073~tplv-k3u1fbpfcp-watermark.image?)

代表修改成功了。

至此，我们完成了用户信息修改的前后端。

案例代码在小册仓库：

[用户端前端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_user)

[后端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)

## 总结

这节我们实现了修改密码和修改个人信息这两个页面。

修改密码页面不需要登录，但我们当时的接口是需要登录的，所以改了一下。

并且给 username 加上了唯一约束，通过 username 来查询用户，然后修改。

修改个人信息页面是登录后的，我们通过 React Router 的路由嵌套写了多级页面。

实现了用户信息的回显和更新的功能。

之后实现了头像上传，上传的目录作为静态文件目录，这样可以直接访问。

这样，用户端的用户相关功能就都完成了。


## 11.ExecutionContext：切换不同上下文

Nest 支持创建 HTTP 服务、WebSocket 服务，还有基于 TCP 通信的微服务。

这些不同类型的服务都需要 Guard、Interceptor、Exception Filter 功能。

那么问题来了：

不同类型的服务它能拿到的参数是不同的，比如 http 服务可以拿到 request、response 对象，而 ws 服务就没有，如何让 Guard、Interceptor、Exception Filter 跨多种上下文复用呢？

Nest 的解决方法是 ArgumentHost 和 ExecutionContext 类。

我们来看一下：

创建个项目：

    nest new argument-host -p npm

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b471adbf830411ca1d354bcefc432e2~tplv-k3u1fbpfcp-watermark.image?)

然后创建一个 filter：

    nest g filter aaa --flat --no-spec

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b12f151047c149cfafaf56008050eaa7~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/688c6a8866094f4fb3c856388f55afad~tplv-k3u1fbpfcp-watermark.image?)

Nest 会 catch 所有未捕获异常，如果是 Exception Filter 声明的异常，那就会调用 filter 来处理。

那 filter 怎么声明捕获什么异常的呢？

我们创建一个自定义的异常类：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e06805576cf454cb1c7bbeaf32d6071~tplv-k3u1fbpfcp-watermark.image?)

在 @Catch 装饰器里声明这个 filter 处理该异常：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df934d51ad8a4c28a7fc508aa03b8eb7~tplv-k3u1fbpfcp-watermark.image?)

然后需要启用它：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b42c9ea42d48c589a94c54b2086692~tplv-k3u1fbpfcp-watermark.image?)

路由级别启用 AaaFilter，并且在 handler 里抛了一个 AaaException 类型的异常。

也可以全局启用：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c9aef7430854839806205caf1d527ba~tplv-k3u1fbpfcp-watermark.image?)

访问 <http://localhost:3000> 就可以看到 filter 被调用了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b2a85e711034ecc9cae601116e9c6de~tplv-k3u1fbpfcp-watermark.image?)

filter 的第一个参数就是异常对象，那第二个参数呢？

可以看到，它有这些方法：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eb7cc19228e43eaae03c74224247c21~tplv-k3u1fbpfcp-watermark.image?)

我们用调试的方式跑一下：

点击 create launch.json file 创建一个调试配置文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e241308c2aec4d089b1e37952c1d4266~tplv-k3u1fbpfcp-watermark.image?)

在 .vscode/launch.json 添加这样的调试配置：

```json
{
    "type": "pwa-node",
    "request": "launch",
    "name": "debug nest",
    "runtimeExecutable": "npm",
    "args": [
        "run",
        "start:dev",
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "console": "integratedTerminal",
}
```

点击调试启动：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4804c8349c1c479490bbb7858c89e5cf~tplv-k3u1fbpfcp-watermark.image?)

打个断点：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ff48d4d155f4093955a5530a9bd5735~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问 <http://localhost:3000> 就可以看到它断住了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eaf214cf7f14265b83e75706d3b10ca~tplv-k3u1fbpfcp-watermark.image?)

我们分别调用下这些方法试试：

在 debug console 输入 host，可以看到它有这些属性方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89e79c3bd5c34093abdfee81d444b356~tplv-k3u1fbpfcp-watermark.image?)

host.getArgs 方法就是取出当前上下文的 reqeust、response、next 参数。

因为当前上下文是 http。

host.getArgByIndex 方法是根据下标取参数：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aa128775aa14c1cb7bcb9d3de8e3944~tplv-k3u1fbpfcp-watermark.image?)

这种按照下标取参数的写法不太建议用，因为不同上下文参数不同，这样写就没法复用到 ws、tcp 等上下文了。

一般是这样来用：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cc5c684064b433db5786b18c9d31841~tplv-k3u1fbpfcp-watermark.image?)

如果是 ws、基于 tcp 的微服务等上下文，就分别调用 host.swtichToWs、host.switchToRpc 方法。

这样，就可以在 filter 里处理多个上下文的逻辑，跨上下文复用 filter了。

比如这样：

```javascript
import { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common';
import { Response } from 'express';
import { AaaException } from './AaaException';

@Catch(AaaException)
export class AaaFilter implements ExceptionFilter {
  catch(exception: AaaException, host: ArgumentsHost) {
    if(host.getType() === 'http') {
      const ctx = host.switchToHttp();
      const response = ctx.getResponse<Response>();
      const request = ctx.getRequest<Request>();

      response
        .status(500)
        .json({
          aaa: exception.aaa,
          bbb: exception.bbb
        });
    } else if(host.getType() === 'ws') {

    } else if(host.getType() === 'rpc') {

    }
  }
}
```

刷新页面，就可以看到 filter 返回的响应：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16b17a64564744f4bf483d2684ab2ff2~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf77ed4a38a143118ca53d1f0209d86f~tplv-k3u1fbpfcp-watermark.image?)

所以说，**ArgumentHost 是用于切换 http、ws、rpc 等上下文类型的，可以根据上下文类型取到对应的 argument**。

那 guard 和 interceptor 里呢？

我们创建个 guard 试一下：

    nest g guard aaa --no-spec --flat

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c417e73986894a6ea688b65babb67731~tplv-k3u1fbpfcp-watermark.image?)

可以看到它传入的是 ExecutionContext：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7339271b8da4772a7cfe62711b7155a~tplv-k3u1fbpfcp-watermark.image?)

有这些方法：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6037df49c67f4984bcb038a2a7d91cb4~tplv-k3u1fbpfcp-watermark.image?)

是不是很眼熟？

没错，ExecutionContext 是 ArgumentHost 的子类，扩展了 getClass、getHandler 方法。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1678748b78284271a2df863bdd62f113~tplv-k3u1fbpfcp-watermark.image?)

多加这两个方法是干啥的呢？

我们调试下看看：

路由级别启用 Guard：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc63d408105453582745a23633c0b3c~tplv-k3u1fbpfcp-watermark.image?)

在 Guard 里打个断点：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/556eb91f23804c26a7de45b7e36300e4~tplv-k3u1fbpfcp-watermark.image?)

调用下 context.getClass 和 getHandler：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47d6d34aba214e9ea09298244d36c70f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d152e0fdd124481b98dee5f82993112~tplv-k3u1fbpfcp-watermark.image?)

会发现这俩分别是要调用的 controller 的 class 以及要调用的方法。

为什么 ExecutionContext 里需要多出这俩方法呢？

因为 Guard、Interceptor 的逻辑可能要根据目标 class、handler 有没有某些装饰而决定怎么处理。

比如权限验证的时候，我们会先定义几个角色：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/926acc6954eb44279599761e1e31eafd~tplv-k3u1fbpfcp-watermark.image?)

然后定义这样一个装饰器：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6452d250fba04ffbbc81564bb431761e~tplv-k3u1fbpfcp-watermark.image?)

它的作用是往修饰的目标上添加 roles 的 metadata。

然后在 handler 上添加这个装饰器，参数为 admin，也就是给这个 handler 添加了一个 roles 为 admin 的metadata。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8220fc247254968bea2fe0c94d1695e~tplv-k3u1fbpfcp-watermark.image?)

这样在 Guard 里就可以根据这个 metadata 决定是否放行了：

```javascript
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';
import { Role } from './role';

@Injectable()
export class AaaGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {

    const requiredRoles = this.reflector.get<Role[]>('roles', context.getHandler());

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user && user.roles?.includes(role));
  }
}
```

这里我需要 Nest 注入 reflector，但并不需要在模块的 provider 声明。

guard、interceptor、middleware、pipe、filter 都是 Nest 的特殊 class，当你通过 @UseXxx 使用它们的时候，Nest 就会扫描到它们，创建对象它们的对象加到容器里，就已经可以注入依赖了。

刷新页面，可以看到返回的是 403：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fc0c88d1a384b0ba006fced5c2676f7~tplv-k3u1fbpfcp-watermark.image?)

这说明 Guard 生效了。

这就是 Guard 里的 ExecutionContext 参数的用法。

同样，在 interceptor 里也有这个：

    nest g interceptor aaa --no-spec --flat

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf2342f7ce0c4a58a0660673da273f73~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/988f8f637d1f4328815c6ffb9d9a859b~tplv-k3u1fbpfcp-watermark.image?)

同样可以通过 reflector 取出 class 或者 handler 上的 metdadata。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/argument-host)。

## 总结

为了让 Filter、Guard、Exception Filter 支持 http、ws、rpc 等场景下复用，Nest 设计了 ArgumentHost 和 ExecutionContext 类。

ArgumentHost 可以通过 getArgs 或者 getArgByIndex 拿到上下文参数，比如 request、response、next 等。

更推荐的方式是根据 getType 的结果分别 switchToHttp、switchToWs、swtichToRpc，然后再取对应的 argument。

而 ExecutionContext 还提供 getClass、getHandler 方法，可以结合 reflector 来取出其中的 metadata。

在写 Filter、Guard、Exception Filter 的时候，是需要用到这些 api 的。


## 110.会议室预订系统：用户管理模块-- 管理端用户列表页面

前面我们写了用户端的一些页面，这节继续来写管理端的。

涉及到这些页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f4f48617f204906a5cf3379936518fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=1050&s=57943&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da8c422c3e2848ef86b1f77027b79ee8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1278&h=890&s=91964&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7922e5d4e24a2ea5457075866b19e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=852&s=54200&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f037c80960cf4a20b04283fc4c454578~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1474&h=1006&s=64942&e=png&b=ffffff)

这节我们来写前两个。

先新建个 react 项目：

```
npx create-react-app --template=typescript meeting_room_booking_system_frontend_admin
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf5645fda44641acb503ec5ade74b1dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1118&h=202&s=59282&e=png&b=000000)

进入项目目录，把开发服务跑起来：

```
npm run start
```
浏览器访问 http://localhost:3000 可以看到这个界面：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e578f28f353c488c8426699af3896f48~tplv-k3u1fbpfcp-watermark.image?)

就说明 react 项目成功跑起来了。

然后我们添加 router：

```
npm install --save react-router-dom
```
在 index.tsx 加上路由的配置：

```javascript
import ReactDOM from 'react-dom/client';
import './index.css';
import { RouterProvider, createBrowserRouter, Link, Outlet } from 'react-router-dom';

function Index() {
  return <div>index<Outlet></Outlet></div>
}
function ErrorPage() {
  return <div>Error Page</div>
}

function UserManage() {
  return <div>user manage</div>
}

function Login() {
  return <div>login</div>
}

const routes = [
  {
    path: "/",
    element: <Index></Index>,
    errorElement: <ErrorPage />,
    children: [
      {
        path: 'user_manage',
        element: <UserManage/>
      }
    ]
  },
  {
    path: "login",
    element: <Login />,
  }
];
const router = createBrowserRouter(routes);

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(<RouterProvider router={router}/>);
```

配置了 4 个路由：

访问 /login 的时候，渲染 Login 组件。

访问 / 的时候，渲染 Index 组件。

访问 /user_manage 的时候，渲染 / 和 user_manage 的二级路由，也就是 Index + UserManage 组件。

以及出错的时候，渲染 ErrorPage 组件。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d7b5b0240f94d73aa0cba2cbcc1c830~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894&h=462&s=441246&e=gif&f=61&b=fcfcfc)

都没问题。

把 src 目录下其余文件去掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e73f7432c44e23bde08e1de692533f~tplv-k3u1fbpfcp-watermark.image?)

然后创建 4 个组件：

src/pages/Login/Login.tsx

```javascript
export function Login() {
    return <div>login</div>   
}
```

src/pages/Index/Index.tsx

```javascript
import { Outlet } from "react-router-dom";

export function Index() {
    return <div>Index<Outlet></Outlet></div>   
}
```

src/pages/UserManage/UserManage.tsx
```javascript
export function UserManage() {
    return <div>UserManage</div>
}
```

src/pages/ErrorPage/ErrorPage.tsx

```javascript
export function ErrorPage() {
    return <div>Error Page</div>
}
```
改下 index.tsx 配置对应的路由：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/338b09b3452a47a08b2a6c794d967344~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1278&h=1132&s=205581&e=png&b=1f1f1f)

```javascript
import ReactDOM from 'react-dom/client';
import './index.css';
import { RouterProvider, createBrowserRouter, Link, Outlet } from 'react-router-dom';
import { Index } from './pages/Index/Index';
import { ErrorPage } from './pages/ErrorPage/ErrorPage';
import { UserManage } from './pages/UserManage/UserManage';
import { Login } from './pages/Login/Login';

const routes = [
  {
    path: "/",
    element: <Index></Index>,
    errorElement: <ErrorPage />,
    children: [
      {
        path: 'user_manage',
        element: <UserManage/>
      }
    ]
  },
  {
    path: "login",
    element: <Login />,
  }
];
const router = createBrowserRouter(routes);

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(<RouterProvider router={router}/>);
```
测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46eb44289c8b469eb87729ac9f0a9d9d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=534&h=164&s=14881&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/871a1b02f26145dc85037751119a15c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=724&h=208&s=24314&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9691fb4812e4df99162de835d4d3230~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=622&h=200&s=17219&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e838778ff8849f19bf2dcc90cf4620f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=190&s=18502&e=png&b=ffffff)
都没啥问题。

然后来写 Login 页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f4f48617f204906a5cf3379936518fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=1050&s=57943&e=png&b=ffffff)

引入 Ant Design 组件库：

```
npm install antd --save
```
在 Login 组件引入 DatePicker 组件：

```javascript
import { DatePicker } from "antd";

export function Login() {
    return <div><DatePicker/></div>   
}
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9c984c744ec49a1a24e5b9c8bab3b94~tplv-k3u1fbpfcp-watermark.image?)

没啥问题，说明 antd 引入成功了。

然后我们把登录页面写一下：

```javascript
import { Button, Checkbox, Form, Input } from 'antd';
import './login.css';
import { useCallback } from 'react';

interface LoginUser {
    username: string;
    password: string;
}

const layout1 = {
    labelCol: { span: 4 },
    wrapperCol: { span: 20 }
}

export function Login() {

    const onFinish = useCallback((values: LoginUser) => {
        console.log(values);
    }, []);

    return <div id="login-container">
        <h1>会议室预订系统</h1>
        <Form
            {...layout1}
            onFinish={onFinish}
            colon={false}
            autoComplete="off"
        >
            <Form.Item
                label="用户名"
                name="username"
                rules={[{ required: true, message: '请输入用户名!' }]}
            >
                <Input />
            </Form.Item>

            <Form.Item
                label="密码"
                name="password"
                rules={[{ required: true, message: '请输入密码!' }]}
            >
                <Input.Password />
            </Form.Item>

            <Form.Item label=" ">
                <Button className='btn' type="primary" htmlType="submit">
                    登录
                </Button>
            </Form.Item>
        </Form>
    </div>   
}
```

这里和用户端差不多.

login.css 如下：

```css
#login-container {
    width: 400px;
    margin: 100px auto 0 auto;
    text-align: center;
}
#login-container .links {
    display: flex;
    justify-content: space-between;
}
#login-container .btn {
    width: 100%;
}
```
访问 /login，可以看到现在的登录页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aafe778501fb48d0ba4d4a581cbd1a2d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1402&h=860&s=68708&e=png&b=ffffff)

然后看一下接口文档 http://localhost:3005/api-doc

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6c732fe2b634bb28d2697b5be2bf715~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=682&h=670&s=55233&e=png&b=f1f8f4)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d47c5ffcf1474b8f8a8b3103bac84011~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=1230&s=148643&e=png&b=ecf6f0)

传入用户名、密码、返回用户信息和 token。

在 postman 里测试下登录接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daaefa943b8040f79b6e479439013388~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=966&h=1216&s=141059&e=png&b=fdfdfd)

然后在点击登录按钮之后，用 axios 调用它：

安装 axios：

```
npm install axios
```

在前端项目创建个 src/interfaces/interfaces.ts

```javascript
import axios from "axios";

const axiosInstance = axios.create({
    baseURL: 'http://localhost:3005/',
    timeout: 3000
});

export async function login(username: string, password: string) {
    return await axiosInstance.post('/user/admin/login', {
        username, password
    });
}
```

在这里集中管理接口。

然后 onFinish 里调用：

```javascript
const navigate = useNavigate();

const onFinish = useCallback(async (values: LoginUser) => {
    const res = await login(values.username, values.password);

    const { code, message: msg, data} = res.data;
    if(res.status === 201 || res.status === 200) {
        message.success('登录成功');

        localStorage.setItem('access_token', data.accessToken);
        localStorage.setItem('refresh_token', data.refreshToken);
        localStorage.setItem('user_info', JSON.stringify(data.userInfo));

        setTimeout(() => {
            navigate('/');
        }, 1000);
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}, []);
```

这里和用户端一摸一样。

登录下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804cf14e55ba417cb8bb5e19c46f8965~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2136&h=1022&s=222720&e=gif&f=22&b=fdfdfd)

提示 400 错误没处理。

因为接口返回 400 的时候，axios 会抛异常：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/058a8b97c445448fa244edad97db13b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=208&s=43281&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c548038fe146d3b3380e4f64f33bae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=678&h=178&s=31645&e=png&b=ffffff)

我们加一个响应的 interceptor，返回 error.response 而不是 Promise.reject(error.response)

```javascript
axiosInstance.interceptors.response.use(
    (response) => {
        return response;
    },
    async (error) => {
        return error.response;
    }
);
```
再测试下：

当用户不存在时：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4b71e3cbe84c449f2a1f1f2a0734b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=962&h=628&s=49391&e=png&b=fefefe)

当密码错误时：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5207dce8428a4e5b8ecd3562aee99786~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=634&s=52906&e=png&b=ffffff)

登录成功时：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58eef93c68ca4cc0b79b7a42e4ed3b4d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1498&h=838&s=112885&e=gif&f=22&b=fefefe)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d1f95e2a5bd4c5f805e726b448f2e64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=442&s=131911&e=png&b=fdfdfd)

都没啥问题。

这样，管理员登录的前后端功能就都完成了。

然后是用户管理的页面： 

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c2d3c95f2d640fc9e7a785d5c5c5ef6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1278&h=890&s=96530&e=png&b=ffffff)

修改下 Index.tsx

```javascript
import { UserOutlined } from "@ant-design/icons";
import { Outlet } from "react-router-dom";
import './index.css';

export function Index() {
    return <div id="index-container">
        <div className="header">
            <h1>会议室预定系统-后台管理</h1>
            <UserOutlined className="icon"/>
        </div>
        <div className="body">
            <Outlet></Outlet>
        </div>
    </div>
}
```

这里用到了 antd 的 icon 组件，需要安装用到的包：

```
npm install @ant-design/icons --save
```

css 如下：

```css
#index-container{
    height: 100vh;
    display: flex;
    flex-direction: column;
}
#index-container .header{
    height: 80px;
    border-bottom: 1px solid #aaa;
    line-height: 80px;
    display: flex;
    justify-content: space-between;
    padding: 0 20px;
}
#index-container h1{
    margin: 0;
}

#index-container .icon {
    font-size: 40px;
    margin-top: 20px;
}
#index-container .body{
    flex: 1;
}
```

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/014c671b804445e7aca8981ad5e5a2f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1402&h=448&s=63498&e=png&b=ffffff)

没啥问题。

不知道同学们有没有发现，其实这个页面应该是三级路由：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e4b045cfbcd461d86ea38484c217930~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=682&s=101354&e=png&b=fefefe)

因为左边这部分也是要多个页面共用的。

我们改一下路由配置：

```javascript
const routes = [
  {
    path: "/",
    element: <Index></Index>,
    errorElement: <ErrorPage />,
    children: [
      {
        path: "/",
        element: <Menu></Menu>,
        children: [
          {
            path: 'user_manage',
            element: <UserManage/>
          }
        ]
      }
    ]
  },
  {
    path: "login",
    element: <Login />,
  }
];
```
添加 src/pages/Menu/Menu.tsx

```javascript
import { Outlet } from "react-router-dom";

export function Menu() {
    return <div>
        menu <Outlet></Outlet>
    </div>
}
```

渲染出来是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3dbde68dfa40b4be6fda4c762d861b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=874&h=432&s=43399&e=png&b=ffffff)

我们来写一下 Menu 组件：
```javascript
import { Outlet } from "react-router-dom";
import { Menu as AntdMenu, MenuProps } from 'antd';
import './menu.css';

const items: MenuProps['items'] = [
    {
        key: '1',
        label: "会议室管理"
    },
    {
        key: '2',
        label: "预定管理"
    },
    {
        key: '3',
        label: "用户管理"
    },
    {
        key: '4',
        label: "统计"
    }
];

export function Menu() {
    return <div id="menu-container">
        <div className="menu-area">
            <AntdMenu
                defaultSelectedKeys={['3']}
                items={items}
            />
        </div>
        <div className="content-area">
            <Outlet></Outlet>
        </div>
    </div>
}
```
menu.css 如下：

```css
#menu-container {
    display: flex;
    flex-direction: row;
}
#menu-container .menu-area {
    width: 200px;
}
```
渲染出来是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/440b72a63ccc4a0fbf895d7f7d43addc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=584&s=57621&e=png&b=ffffff)

然后来写 UserManage 组件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b27b7789cfa45778f51a82786c8a969~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=678&s=84160&e=png&b=fefefe)

可以分为 2 部分，上面的搜索表单、下面的结果表格。

我们来写一下：

```javascript
import { Button, Form, Input, Table } from "antd";
import { useCallback } from "react";
import './UserManage.css';

interface SearchUser {
    username: string;
    nickName: string;
    email: string;
}

export function UserManage() {

    const searchUser = useCallback(async (values: SearchUser) => {
        console.log(values);
    }, []);

    return <div id="userManage-container">
        <div className="userManage-form">
            <Form
                onFinish={searchUser}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="用户名" name="username">
                    <Input />
                </Form.Item>

                <Form.Item label="昵称" name="nickName">
                    <Input />
                </Form.Item>

                <Form.Item label="邮箱" name="email" rules={[
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}>
                    <Input/>
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索用户
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="userManage-table">
                
        </div>
    </div>
}
```
UserManage.css

```css
#userManage-container {
    padding: 20px;
}
```
先把 form 部分写完。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c3707b563af4426ad2255623c101c1d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1968&h=1004&s=130495&e=png&b=fefefe)

然后再写 table 部分：
```javascript
import { Button, Form, Input, Table } from "antd";
import { useCallback } from "react";
import './UserManage.css';
import { ColumnsType } from "antd/es/table";

interface SearchUser {
    username: string;
    nickName: string;
    email: string;
}

interface UserSearchResult {
    username: string;
    nickName: string;
    email: string;
    headPic: string;
    createTime: Date;
}
const columns: ColumnsType<UserSearchResult> = [
    {
        title: '用户名',
        dataIndex: 'username'
    },
    {
        title: '头像',
        dataIndex: 'headPic'
    },
    {
        title: '昵称',
        dataIndex: 'nickName'
    },
    {
        title: '邮箱',
        dataIndex: 'email'
    },
    {
        title: '注册时间',
        dataIndex: 'createTime'
    }   
];

const data = [
    {
        key: '1',
        username: 'xx',
        headPic: 'xxx.png',
        nickName: 'xxx',
        email: 'xx@xx.com',
        createTime: new Date()
    },
    {
        key: '12',
        username: 'yy',
        headPic: 'yy.png',
        nickName: 'yyy',
        email: 'yy@yy.com',
        createTime: new Date()
    }
]


export function UserManage() {

    const searchUser = useCallback(async (values: SearchUser) => {
        console.log(values);
    }, []);

    return <div id="userManage-container">
        <div className="userManage-form">
            <Form
                onFinish={searchUser}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="用户名" name="username">
                    <Input />
                </Form.Item>

                <Form.Item label="昵称" name="nickName">
                    <Input />
                </Form.Item>

                <Form.Item label="邮箱" name="email" rules={[
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}>
                    <Input/>
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索用户
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="userManage-table">
            <Table columns={columns} dataSource={data} pagination={ {
                pageSize: 10
            }}/>
        </div>
    </div>
}
```

渲染出来是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eefc673345d496795397ccd86a49a01~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2010&h=854&s=109808&e=png&b=fefefe)

然后我们调用下搜索接口。

看下接口文档：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21fffa8c553f4ce69bd55ac2352bfcba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1210&h=1362&s=130120&e=png&b=eef4fa)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cd4d8a033ae4606902aa5233a38278d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=1046&s=113974&e=png&b=eef4fa)

在 postman 里调用下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32716e1400494b7eb6d295cf5bc83272~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=816&h=798&s=69140&e=png&b=fcfcfc)

这个接口是需要登录的。

我们先登录一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9f0c889d45040febc88194d2fe674b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1070&h=1060&s=203948&e=png&b=fdfdfd)

带上 access_token 再访问：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44803be273644d6fa7f733ac7d7c7082~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=958&h=540&s=67937&e=png&b=fafafa)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ffb2c9d9bf74ad887167df002b9702c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=1306&s=151975&e=png&b=fdfdfd)

返回了 8 条数据。

然后我们在页面里调用下：

先把之前写的 axios 的 interceptors 自动添加 authorization 的 header，自动 refresh token 的逻辑拿过来：

```javascript
axiosInstance.interceptors.request.use(function (config) {
    const accessToken = localStorage.getItem('access_token');

    if(accessToken) {
        config.headers.authorization = 'Bearer ' + accessToken;
    }
    return config;
})

axiosInstance.interceptors.response.use(
    (response) => {
        return response;
    },
    async (error) => {
        let { data, config } = error.response;

        if (data.code === 401 && !config.url.includes('/user/admin/refresh')) {
            
            const res = await refreshToken();

            if(res.status === 200) {
                return axiosInstance(config);
            } else {
                message.error(res.data);

                setTimeout(() => {
                    window.location.href = '/login';
                }, 1500);
            }
            
        } else {
            return error.response;
        }
    }
)

async function refreshToken() {
    const res = await axiosInstance.get('/user/admin/refresh', {
        params: {
          refresh_token: localStorage.getItem('refresh_token')
        }
    });
    localStorage.setItem('access_token', res.data.access_token);
    localStorage.setItem('refresh_token', res.data.refresh_token);
    return res;
}
```
然后添加一个接口：

```javascript
export async function userSearch(username: string, nickName: string, email: string, pageNo: number, pageSize: number) {
    return await axiosInstance.get('/user/list', {
        params: {
            username,
            nickName,
            email,
            pageNo,
            pageSize
        }
    });
}
```
在页面调用下：

```javascript
const [pageNo, setPageNo] = useState<number>(1);
const [pageSize, setPageSize] = useState<number>(10);
const [userResult, setUserResult] = useState<UserSearchResult[]>();

const searchUser = useCallback(async (values: SearchUser) => {
    const res = await userSearch(values.username,values.nickName, values.email, pageNo, pageSize);

    const { data } = res.data;
    if(res.status === 201 || res.status === 200) {
        setUserResult(data.users.map((item: UserSearchResult) => {
            return {
                key: item.username,
                ...item
            }
        }))
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}, []);
```

使用 useState 创建 pageNo、pageSize、userResult 这三个状态。

请求接口，成功后把数据设置到 userResult。

然后修改下 table 的 dataSource：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/352e52da46824f8d8e092e19fb6064fc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1338&h=262&s=53708&e=png&b=1f1f1f)

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11e582d769334d4db1b00a30d3f32eba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=968&h=668&s=52543&e=png&b=ffffff)

先登录。

然后访问 http://localhost:3000/user_manage

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53f6b7670ed74ba685a2a5c43493fee2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2174&h=1458&s=565540&e=gif&f=44&b=fefefe)

搜索接口对接成功。

然后再对接下分页：

```javascript
<Table columns={columns} dataSource={userResult} pagination={ {
    current: pageNo,
    pageSize: pageSize,
    onChange: changePage
}}/>
```
设置 pageNo 和 pageSize，并监听 onChange 事件

```javascript
useEffect(() => {
    searchUser({
        username: '',
        email: '',
        nickName: ''
    });
}, [pageNo, pageSize]);

const changePage = useCallback(function(pageNo: number, pageSize: number) {
    setPageNo(pageNo);
    setPageSize(pageSize);
}, []);
```

分页设置改变的时候，设置 pageNo 和 pageSize。

并且 useEffect 监听这两个 state，在变化的时候，重新发送请求。
 
这样，刚进入页面的时候，就会触发一次渲染，并且在分页设置改变时也会触发：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6907a31e61ba47dc8c3ef28f1ab6e7c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2286&h=1364&s=240312&e=png&b=fefefe)

然后修改下 headPic，改为图片：
```javascript
const columns: ColumnsType<UserSearchResult> = [
    {
        title: '用户名',
        dataIndex: 'username'
    },
    {
        title: '头像',
        dataIndex: 'headPic',
        render: value => {
            return value ? <Image
                    width={50}
                    src={`http://localhost:3005/${value}`}
            /> : '';
        }
    },
    {
        title: '昵称',
        dataIndex: 'nickName'
    },
    {
        title: '邮箱',
        dataIndex: 'email'
    },
    {
        title: '注册时间',
        dataIndex: 'createTime'
    }   
];
```
这里用的是 antd 的 Image 组件，有预览的功能：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc7cd1e6208e4126b4f3fb6ccc8fb912~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2242&h=1462&s=1757690&e=gif&f=25&b=fdfdfd)

原型图还有个冻结功能：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bb94645e5b249a8b86c2f42611771c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=658&s=80389&e=png&b=fefefe)

看下接口文档：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9e005983431492daa6a07da88c36716~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1010&h=1238&s=92277&e=png&b=eff5fa)

很简单，就是个 get 接口。

我们在表格里加一列：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/806b06492b3346a98f7059b7fa785294~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1484&h=782&s=123594&e=png&b=1f1f1f)

```javascript
{
    title: '操作',
    render: (_, record) => (
        <a href="#" onClick={() => {freezeUser(record.id)}}>冻结</a>
    )
}
```
这里用到了 id，我们在类型里加一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d56c083fcc46d89fad7219c5f2a81a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=584&h=372&s=45796&e=png&b=1f1f1f)

然后在 interfaces.tsx 添加这个接口：

```javascript
export async function freeze(id: number) {
    return await axiosInstance.get('/user/freeze', {
        params: {
            id
        }
    });
}
```
在组件里创建 freezeUser 方法：

```javascript
async function freezeUser(id: number) {
    const res = await freeze(id);

    const { data } = res.data;
    if(res.status === 201 || res.status === 200) {
        message.success('冻结成功');
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}
```

测试下：

![2023-09-12 11.31.21.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7335c9dd95b44b299ae1b3d31b1407b5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2018&h=1258&s=332106&e=gif&f=17&b=fdfdfd)

然后我们还要把冻结状态显示出来：

这部分数据是返回了的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c269f7c7154d7d8224d583e50aaa4f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1112&h=886&s=186990&e=png&b=ffffff)

需要添加一列：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c04e56c3e894ffe9e9689e080bf6a69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1434&h=966&s=160836&e=png&b=1f1f1f)

```javascript
{
    title: '状态',
    dataIndex: 'isFrozen',
    render: (_, record) => (
        record.isFrozen ? <Badge status="success">已冻结</Badge> : ''
    )
},
```

在类型部分也要添加下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/258e00bdf2f84d6dae979280a4ba4b14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=602&h=416&s=52472&e=png&b=1f1f1f)

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/614e0be8869049fb85a050a93f06d113~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2180&h=1218&s=601737&e=gif&f=30&b=fdfdfd)

冻结之后，刷新页面，会显示已冻结。

这里我们在冻结之后自动刷新下。

这需要把逻辑移到组件内：

把 columns 移到组件内，用 useMemo 包裹，这样只会创建一次：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5cab0f177b4456d91a7d94d8ca2aee7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1182&h=816&s=66791&e=png&b=1f1f1f)

freeezeUser 也是：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba05e989eca54d48874454ffd34b81d4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1138&h=578&s=114251&e=png&b=1f1f1f)

```javascript
const freezeUser = useCallback(async (id: number) => {
    const res = await freeze(id);

    const { data } = res.data;
    if(res.status === 201 || res.status === 200) {
        message.success('冻结成功');
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}, []);
```
添加一个 num 的 state，冻结之后设置一个随机值：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66aac163138c42b192a60cca73446347~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1154&h=898&s=201454&e=png&b=1f1f1f)

把它添加到 useEffect 的依赖里，这样就能触发重新搜索：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e60613c7fcae48cf821a44425d513c84~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=598&h=348&s=36848&e=png&b=202020)

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5014ff49d8944873831d0316e1cc2879~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2046&h=1072&s=586595&e=gif&f=23&b=fdfdfd)

但其实现在这个重新搜索有问题：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/001d50c483ff48cfb4d12a04476a74b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2090&h=992&s=455959&e=gif&f=34&b=fdfdfd)

我搜索之后再冻结，然后刷新就丢失了搜索条件了。

这里需要搜索的时候带上当前的条件：

用 useForm 拿到 form 的 api：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fd64bc4f30b4c10af7b8d88f62682f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=902&h=492&s=69611&e=png&b=1f1f1f)

然后在搜索的时候拿到最新的表单值：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d84eb1a8c7d45e4be20a600512d9615~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=964&h=476&s=78143&e=png&b=1f1f1f)

```javascript
useEffect(() => {
    searchUser({
        username: form.getFieldValue('username'),
        email: form.getFieldValue('email'),
        nickName: form.getFieldValue('nickName')
    });
}, [pageNo, pageSize, num]);
```
这样就可以了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a0846d2def40c79f567fedb07ffeb6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2086&h=1192&s=508769&e=gif&f=38&b=fdfdfd)

这样，用户管理页面就写完了。
 
全部代码如下：

```javascript
import { Badge, Button, Form, Image, Input, Table, message } from "antd";
import { useCallback, useEffect, useMemo, useState } from "react";
import './UserManage.css';
import { ColumnsType } from "antd/es/table";
import { freeze, userSearch } from "../../interfaces/interfaces";
import { useForm } from "antd/es/form/Form";

interface SearchUser {
    username: string;
    nickName: string;
    email: string;
}

interface UserSearchResult {
    id: number,
    username: string;
    nickName: string;
    email: string;
    headPic: string;
    createTime: Date;
    isFrozen: boolean;
}


export function UserManage() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);
    const [userResult, setUserResult] = useState<UserSearchResult[]>();
    const [num, setNum] = useState(0);

    const columns: ColumnsType<UserSearchResult> = useMemo(() => [
        {
            title: '用户名',
            dataIndex: 'username'
        },
        {
            title: '头像',
            dataIndex: 'headPic',
            render: value => {
                return value ? <Image
                        width={50}
                        src={`http://localhost:3005/${value}`}
                /> : '';
            }
        },
        {
            title: '昵称',
            dataIndex: 'nickName'
        },
        {
            title: '邮箱',
            dataIndex: 'email'
        },
        {
            title: '注册时间',
            dataIndex: 'createTime'
        },
        {
            title: '状态',
            dataIndex: 'isFrozen',
            render: (_, record) => (
                record.isFrozen ? <Badge status="success">已冻结</Badge> : ''
            )
        },
        {
            title: '操作',
            render: (_, record) => (
                <a href="#" onClick={() => {freezeUser(record.id)}}>冻结</a>
            )
        }
    ], []);
    
    const freezeUser = useCallback(async (id: number) => {
        const res = await freeze(id);
    
        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            message.success('冻结成功');
            setNum(Math.random())
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }
    }, []);

    const searchUser = useCallback(async (values: SearchUser) => {
        const res = await userSearch(values.username,values.nickName, values.email, pageNo, pageSize);

        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            setUserResult(data.users.map((item: UserSearchResult) => {
                return {
                    key: item.username,
                    ...item
                }
            }))
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }
    }, []);

    const [form ]  = useForm();

    useEffect(() => {
        searchUser({
            username: form.getFieldValue('username'),
            email: form.getFieldValue('email'),
            nickName: form.getFieldValue('nickName')
        });
    }, [pageNo, pageSize, num]);

    const changePage = useCallback(function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }, []);


    return <div id="userManage-container">
        <div className="userManage-form">
            <Form
                form={form}
                onFinish={searchUser}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="用户名" name="username">
                    <Input />
                </Form.Item>

                <Form.Item label="昵称" name="nickName">
                    <Input />
                </Form.Item>

                <Form.Item label="邮箱" name="email" rules={[
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}>
                    <Input/>
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索用户
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="userManage-table">
            <Table columns={columns} dataSource={userResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```
案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_admin)。

## 总结

这节我们实现了管理端的登录和用户管理页面。

和用户端的一样，都是通过 axios interceptor 自动添加 header 和自动 refresh token。

这里涉及到三级路由，第一级展示上面的 header，第二级展示左侧的 menu，第三级才是具体的页面。

使用 table 组件来渲染列表，通过 useEffect 在 pageNo、pageSize 改变的时候自动重发请求。

这样，这两个页面的前后端代码都完成了。


## 111.会议室预订系统：用户管理模块-- 管理端信息修改页面

这节，我们来写管理端的这两个页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7922e5d4e24a2ea5457075866b19e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=852&s=54200&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f037c80960cf4a20b04283fc4c454578~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1474&h=1006&s=64942&e=png&b=ffffff)

很明显，它们是和这几个管理页面平级的，点击用户图标的时候打开：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15459f904c474be0bad3403a96f70a48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1388&h=732&s=74362&e=png&b=ffffff)

所以，我们在它平级添加个路由：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2506a3eb7242efbeb48f99547d6b92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=1174&s=149599&e=png&b=1f1f1f)

```javascript
{
    path: "/user",
    element: <ModifyMenu></ModifyMenu>,
    children: [
      {
        path: 'info_modify',
        element: <InfoModify/>
      },
      {
        path: 'password_modify',
        element: <PasswordModify/>
      },
    ]
},
```

然后创建这几个对应的组件：

src/pages/ModifyMenu/ModifyMenu.stx

```javascript
import { Outlet } from "react-router-dom";
import { Menu as AntdMenu, MenuProps } from 'antd';
import './menu.css';

const items: MenuProps['items'] = [
    {
        key: '1',
        label: "信息修改"
    },
    {
        key: '2',
        label: "密码修改"
    }
];

export function ModifyMenu() {
    return <div id="menu-container">
        <div className="menu-area">
            <AntdMenu
                defaultSelectedKeys={['1']}
                items={items}
            />
        </div>
        <div className="content-area">
            <Outlet></Outlet>
        </div>
    </div>
}
```
用到的 menu.css：

```css
#menu-container {
    display: flex;
    flex-direction: row;
}
#menu-container .menu-area {
    width: 200px;
}
```
然后是 

src/pages/InfoModify/InfoModify.tsx

```javascript
export function InfoModify() {
    return <div>InfoModify</div>
}
```
src/pages/PasswordModify/PasswordModify.tsx

```javascript
export function PasswordModify() {
    return <div>PasswordModify</div>
}
```

在 index.tsx 引入，然后跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a7db8f6e4bb42fe9ce1cc80a2717030~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932&h=484&s=50494&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc82e80a42f4ee38f1da6fe343df5ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=886&h=434&s=51776&e=png&b=ffffff)

没啥问题。

但是现在点击菜单是没反应的，我们给它加上 click 事件。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89b884cc9b6046d7a704f7126f00e9bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=920&s=168602&e=png&b=1f1f1f)

```javascript
const handleMenuItemClick: MenuClickEventHandler = (info) => {
    if(info.key === '1') {
        router.navigate('/user/info_modify')
    } else {
        router.navigate('/user/password_modify')
    }
}
```

这里用到的 router 要在 index.tsx 里导出：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9ded1b38cb8469b9143e8813f25fe61~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=408&s=76242&e=png&b=1f1f1f)

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fec33aa11a6744bb9d79d20fcec4143a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1054&h=546&s=202089&e=gif&f=22&b=fcfcfc)

点击菜单可以切换路由了。

但现在有个问题，页面一刷新，选中的菜单项就变了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e09f174def714d518a05059d7e04fde9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&h=424&s=194471&e=gif&f=46&b=fbfbfb)

我们需要根据当前路由来决定选中哪个：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e009f117f5e7487fa65ba8b12031cd04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1584&h=654&s=137817&e=png&b=1f1f1f)

这里用到了 react-router 的 useLocation 的 hook 来拿到当前地址：

```javascript
location.pathname === '/user/info_modify' ? ['1'] : ['2']
```
这样，刷新之后选中的菜单项也是对的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa8eef339a8042608b13f3a193907dcb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=952&h=450&s=136464&e=gif&f=31&b=fdfdfd)

改下 Index 组件，添加两个链接：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/469a065b6e34465eb09ff68739091b87~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=916&h=720&s=139314&e=png&b=202020)

```html
<div className="header">
    <Link to="/" className="sys_name">
        <h1>会议室预定系统-后台管理</h1>
    </Link>
    <Link to="/user/info_modify">
        <UserOutlined className="icon"/>
    </Link>
</div>
```

并且添加它的样式：

```css
#index-container .sys_name {
    text-decoration: none;
    color: #000;
}
```
这样就可以方便跳转对应的路由了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/430f8f5b14164a4fa809285c57313d22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1750&h=826&s=178938&e=gif&f=32&b=fdfdfd)

然后，我们来实现信息修改页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce7922e5d4e24a2ea5457075866b19e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=852&s=54200&e=png&b=ffffff)

之前用户端修改信息页面也是类似的，我们直接拿过来就行：

```javascript
import { Button, Form, Input, message } from 'antd';
import { useForm } from 'antd/es/form/Form';
import { useCallback, useEffect, useState } from 'react';
import './info_modify.css';
import { useNavigate } from 'react-router-dom';
import { HeadPicUpload } from './HeadPicUpload';

export interface UserInfo {
    username: string;
    headPic: string;
    nickName: string;
    email: string;
    captcha: string;
}

const layout1 = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}

export function InfoModify() {
    const [form] = useForm();
    const navigate = useNavigate();

    const onFinish = useCallback(async (values: UserInfo) => {

    }, []);

    const sendCaptcha = useCallback(async function () {
        
    }, []);

    useEffect(() => {
        async function query() {
            
        }
        query();
    }, []);

    return <div id="updateInfo-container">
        <Form
            form={form}
            {...layout1}
            onFinish={onFinish}
            colon={false}
            autoComplete="off"
        >
            <Form.Item
                label="头像"
                name="headPic"
                rules={[
                    { required: true, message: '请输入头像!' },
                ]}
                shouldUpdate
            >
                <HeadPicUpload></HeadPicUpload>
            </Form.Item>

            <Form.Item
                label="昵称"
                name="nickName"
                rules={[
                    { required: true, message: '请输入昵称!' },
                ]}
            >
                <Input />
            </Form.Item>

            <Form.Item
                label="邮箱"
                name="email"
                rules={[
                    { required: true, message: '请输入邮箱!' },
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}
            >
                <Input disabled/>
            </Form.Item>

            <div className='captcha-wrapper'>
                <Form.Item
                    label="验证码"
                    name="captcha"
                    rules={[{ required: true, message: '请输入验证码!' }]}
                >
                    <Input />
                </Form.Item>
                <Button type="primary" onClick={sendCaptcha}>发送验证码</Button>
            </div>

            <Form.Item
                {...layout1}
                label=" "
            >
                <Button className='btn' type="primary" htmlType="submit">
                    修改
                </Button>
            </Form.Item>
        </Form>
    </div>   
}
```
css 部分如下：

```css
#updateInfo-container {
    width: 400px;
    margin: 50px auto 0 auto;
    text-align: center;
}
#updateInfo-container .btn {
    width: 100%;
}
#updateInfo-container .captcha-wrapper {
    display: flex;
    justify-content: flex-end;
}
```
用到的 HeadPicUpload 组件如下：

```javascript
import { InboxOutlined } from "@ant-design/icons";
import { message } from "antd";
import Dragger, { DraggerProps } from "antd/es/upload/Dragger";

interface HeadPicUploadProps {
    value?: string;
    onChange?: Function
}

let onChange: Function;

const props: DraggerProps = {
    name: 'file',
    action: 'http://localhost:3005/user/upload',
    onChange(info) {
        const { status } = info.file;
        if (status === 'done') {
            onChange(info.file.response.data);
            message.success(`${info.file.name} 文件上传成功`);
        } else if (status === 'error') {
            message.error(`${info.file.name} 文件上传失败`);
        }
    }
};

const dragger = <Dragger {...props}>
    <p className="ant-upload-drag-icon">
        <InboxOutlined />
    </p>
    <p className="ant-upload-text">点击或拖拽文件到这个区域来上传</p>
</Dragger>

export function HeadPicUpload(props: HeadPicUploadProps) {

    onChange = props.onChange!

    return props?.value ? <div>
        <img src={'http://localhost:3005/' + props.value} alt="头像" width="100" height="100"/>
        {dragger}
    </div>: <div>
        {dragger}
    </div>
}
```
这些都是我们前面写过一遍的。

渲染出来是这样的：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc66ffc5c02b4f25ba19dfcb3781fdb1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1390&h=1062&s=105257&e=png&b=fefefe)

上传功能也是可用的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ea12f22f364ce8bb2e4048a5b45386~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1508&h=1102&s=2554441&e=gif&f=44&b=fdfdfd)

然后我们还要加上回显接口、发送验证码接口、更新接口。

在 interfaces.tsx 加上这三个接口：

```javascript
export async function getUserInfo() {
    return await axiosInstance.get('/user/info');
}

export async function updateInfo(data: UserInfo) {
    return await axiosInstance.post('/user/admin/update', data);
}

export async function updateUserInfoCaptcha() {
    return await axiosInstance.get('/user/update/captcha');
}
```
然后先调用下回显接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a80c3ba613348729abaac5cb91caa74~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1088&h=650&s=118529&e=png&b=1f1f1f)

```javascript
async function query() {
    const res = await getUserInfo();

    const { data } = res.data;

    if(res.status === 201 || res.status === 200) {

        form.setFieldValue('headPic', data.headPic);
        form.setFieldValue('nickName', data.nickName);
        form.setFieldValue('email', data.email);
    }
}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d99f772765944ffb6996f9ecf570082~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1296&h=1038&s=105185&e=png&b=fefefe)

可以看到，正确回显了数据。

然后是发送验证码接口：

```javascript
const sendCaptcha = useCallback(async function () {
    const res = await updateUserInfoCaptcha();
    if(res.status === 201 || res.status === 200) {
        message.success(res.data.data);
    } else {
        message.error('系统繁忙，请稍后再试');
    }
}, []);
```
不过现在的邮箱地址不是真实的，我们手动去数据库里改一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be0d70d50be54ec684302156fbd29e25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1278&h=690&s=291331&e=png&b=f7f7f7)

改完点击 apply。

然后需要重新登录一遍，因为现在后端会直接从 jwt 里取邮箱地址，重新登录才会更新。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d168bfc253124caeba8d900348eb8813~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1610&h=1042&s=123252&e=png&b=fefefe)

邮箱收到了验证码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4617abb6cff64ca7baa9d7a461e8cfc0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=246&s=29191&e=png&b=f6f6f6)

然后加上更新用户信息的接口：
```javascript
const onFinish = useCallback(async (values: UserInfo) => {
    const res = await updateInfo(values);

    if(res.status === 201 || res.status === 200) {
        const { message: msg, data} = res.data;
        if(msg === 'success') {
            message.success('用户信息更新成功');
        } else {
            message.error(data);
        }
    } else {
        message.error('系统繁忙，请稍后再试');
    }
}, []);
```
上传头像，点击发送验证码，填入收到的验证码，点击修改：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3126a2b302f4cbf992cd7923afb945b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1658&h=1224&s=182721&e=png&b=fefefe)

修改成功后，刷新页面，可以看到依然是修改后的数据，就代表修改成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f230d255cfaf4c78be46a32c38d16e23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1458&h=1306&s=250001&e=gif&f=21&b=fdfdfd)

接下来是密码修改页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f037c80960cf4a20b04283fc4c454578~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1474&h=1006&s=64942&e=png&b=ffffff)

代码如下：

```javascript
import { Button, Form, Input, message } from 'antd';
import { useForm } from 'antd/es/form/Form';
import './password_modify.css';
import { useCallback } from 'react';
import { Link, useNavigate } from 'react-router-dom';

export interface UpdatePassword {
    email: string;
    captcha: string;
    password: string;
    confirmPassword: string;
}

const layout1 = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}

const layout2 = {
    labelCol: { span: 0 },
    wrapperCol: { span: 24 }
}

export function PasswordModify() {
    const [form] = useForm();
    const navigate = useNavigate();

    const onFinish = useCallback(async (values: UpdatePassword) => {

    }, []);

    const sendCaptcha = useCallback(async function () {

    }, []);

    return <div id="updatePassword-container">
        <Form
            form={form}
            {...layout1}
            onFinish={onFinish}
            colon={false}
            autoComplete="off"
        >
            <Form.Item
                label="密码"
                name="password"
                rules={[{ required: true, message: '请输入密码!' }]}
            >
                <Input.Password />
            </Form.Item>

            <Form.Item
                label="确认密码"
                name="confirmPassword"
                rules={[{ required: true, message: '请输入确认密码!' }]}
            >
                <Input.Password />
            </Form.Item>
            <Form.Item
                label="邮箱"
                name="email"
                rules={[
                    { required: true, message: '请输入邮箱!' },
                    { type: "email", message: '请输入合法邮箱地址!'}
                ]}
            >
                <Input />
            </Form.Item>

            <div className='captcha-wrapper'>
                <Form.Item
                    label="验证码"
                    name="captcha"
                    rules={[{ required: true, message: '请输入验证码!' }]}
                >
                    <Input />
                </Form.Item>
                <Button type="primary" onClick={sendCaptcha}>发送验证码</Button>
            </div>

            <Form.Item
                {...layout1}
                label=" "
            >
                <Button className='btn' type="primary" htmlType="submit">
                    修改密码
                </Button>
            </Form.Item>
        </Form>
    </div>   
}
```

用到的 password_modify.css：

```css
#updatePassword-container {
    width: 400px;
    margin: 40px auto;
    text-align: center;
}
#updatePassword-container .btn {
    width: 100%;
}
#updatePassword-container .captcha-wrapper {
    display: flex;
    justify-content: flex-end;
}
```
渲染出来是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155046bc2a764dd89853348757faa5c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1250&h=844&s=88595&e=png&b=ffffff)

然后在 interfaces.ts 加上用到的发送验证码、修改密码这两个接口：

```javascript
export async function updatePasswordCaptcha(email: string) {
    return await axiosInstance.get('/user/update_password/captcha', {
        params: {
            address: email
        }
    });
}

export async function updatePassword(data: UpdatePassword) {
    return await axiosInstance.post('/user/admin/update_password', data);
}
```
然后先在页面调用下回显接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40e41b22a624401a95b04490b7a63ea5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168&h=620&s=120954&e=png&b=202020)
```javascript
useEffect(() => {
    async function query() {
        const res = await getUserInfo();

        const { data } = res.data;

        if(res.status === 201 || res.status === 200) {  
            form.setFieldValue('username', data.username);              
            form.setFieldValue('email', data.email);
        }
    }
    query();
}, []);
```
并把邮箱 Input 设置为 disabled

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e97e4f7b3d0640f58308fb5d22c5804c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=728&s=139128&e=png&b=1f1f1f)

这样邮箱地址就会回显，并且只读：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24c626f1aa240b0a8535128c7124e4d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=808&s=89414&e=png&b=fefefe)

然后调用发送验证码接口：

```javascript
const sendCaptcha = useCallback(async function () {
    const address = form.getFieldValue('email');
    if(!address) {
        return message.error('邮箱地址为空');
    }

    const res = await updatePasswordCaptcha(address);
    if(res.status === 201 || res.status === 200) {
        message.success(res.data.data);
    } else {
        message.error('系统繁忙，请稍后再试');
    }
}, []);
```
点击发送验证码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aecd500776594a43bda17a6a642a02ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1902&h=1042&s=138378&e=gif&f=24&b=fdfdfd)

邮箱收到了对应的验证码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/114b7251e9d04bfca1d1a7e235c92368~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=538&h=284&s=29654&e=png&b=f8f8f8)
然后加上修改密码接口：

```javascript
const onFinish = useCallback(async (values: UpdatePassword) => {
    if(values.password !== values.confirmPassword) {
        return message.error('两次密码不一致');
    }

    const res = await updatePassword({
        ...values,
        username: form.getFieldValue('username')
    });

    const { message: msg, data} = res.data;

    if(res.status === 201 || res.status === 200) {
        message.success('密码修改成功');
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}, []);
```
提示密码修改成功：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54aaa08d41224c8492bf05d3ba3f6738~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1642&h=848&s=116278&e=png&b=fefefe)

我们可以去登录页面，用老密码试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a27cef8f52944f95b160d28cb9d11db8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=614&s=51523&e=png&b=fefefe)

再用新密码试试：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a4449dc50da4036b7fa36678fe1df61~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=658&s=54442&e=png&b=fefefe)

这样，管理端的用户相关的页面就完成了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_admin)。

## 总结

这节我们实现了管理端的用户信息修改和密码修改的页面。

首先添加了一个和管理页面平级的二级路由，然后添加了两个组件。

这两个页面都是表单，涉及到回显数据、发送验证码、上传文件、更新接口。

这也是管理系统的常见功能。

下节开始，我们就开始写会议室管理的功能了。


## 112.会议室预订系统：会议室管理模块-后端开发

用户相关的功能，后端代码、用户端前端代码、管理端前端代码都写完了。

这节我们开始写下一个模块：会议室管理。

看下当时分析的需求：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115207b6183243f59cc82845e5445c86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1010&h=1058&s=148539&e=png&b=fefcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0a7cba91eb247e9bd39ed629fd70b62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=946&h=950&s=119536&e=png&b=fcf3f2)

以及我们分析出来的接口：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /meeting_room/list | GET | 会议室列表 |
| /meeting_room/delete/:id | DELETE | 会议室删除 |
| /meeting_room/update/:id | PUT |会议室更新|
| /meeting_room/create | POST |会议室新增|
| /meeting_room/search | GET |会议室搜索|

一共 5 个接口。

在后端项目下创建一个 meeting-room 模块：

```
nest g resource meeting-room
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf1ad89dd5f47fa950659e70567d6d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=966&h=294&s=84812&e=png&b=191919)

修改下 meeting-room.entity.ts

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class MeetingRoom {
    
    @PrimaryGeneratedColumn({
        comment: '会议室ID'
    })
    id: number;

    @Column({
        length: 50,
        comment: '会议室名字'
    })
    name: string;

    @Column({
        comment: '会议室容量'
    })
    capacity: number;

    @Column({
        length: 50,
        comment: '会议室位置'
    })
    location: string;

    @Column({
        length: 50,
        comment: '设备',
        default: ''
    })
    equipment: string;

    @Column({
        length: 100,
        comment: '描述',
        default: ''
    })
    description: string;

    @Column({
        comment: '是否被预订',
        default: false
    })
    isBooked: boolean;

    @CreateDateColumn({
        comment: '创建时间'
    })
    createTime: Date;

    @UpdateDateColumn({
        comment: '更新时间'
    })
    updateTime: Date;
}
```
这个是根据当时我们的数据库设计来的：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 会议室ID |
| name | VARCHAR(50) |会议室名字 |
| capacity | INT |会议室容量 |
| location | VARCHAR(50) |会议室位置 |
| equipment | VARCHAR(50) | 设备 |
| description | VARCHAR(100) | 描述 |
| is_booked | BOOLEAN | 是否被预订 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

在 entities 里引入下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ffa26231ef4cf18ee0f331f81ba36c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982&h=770&s=172196&e=png&b=1f1f1f)

把服务跑起来：

```
npm run start:dev
```
会生成建表语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a87904e493334385997e055d7f07483f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1334&h=234&s=108356&e=png&b=191919)

在 mysql workbench 里点击刷新就可以看到这个表：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2be653160249403fb11d05c374ad06c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=638&h=798&s=185766&e=png&b=e9e6e4)

点击第二个图标，查看表定义：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb744168fda14063ad2398f30f829435~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1508&h=912&s=379688&e=png&b=f1efee)

没啥问题。

然后我们先来初始化下数据：

在 MeetingRoomModule 引入 MeetingRoom 的 Repository：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f734b6574d34024953429d945284b25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=856&h=612&s=128891&e=png&b=1f1f1f)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6c741167d54474ca28e9a22aa0b9f73~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=852&h=586&s=134636&e=png&b=202020)

```javascript
@InjectRepository(MeetingRoom)
private repository: Repository<MeetingRoom>;

initData() {
}
```
然后来写初始化数据的逻辑：

```javascript
initData() {
    const room1 = new MeetingRoom();
    room1.name = '木星';
    room1.capacity = 10;
    room1.equipment = '白板';
    room1.location = '一层西';

    const room2 = new MeetingRoom();
    room2.name = '金星';
    room2.capacity = 5;
    room2.equipment = '';
    room2.location = '二层东';

    const room3 = new MeetingRoom();
    room3.name = '天王星';
    room3.capacity = 30;
    room3.equipment = '白板，电视';
    room3.location = '三层东';

    this.repository.save([room1, room2, room3])
}
```
还需要像 user 模块那样，添加一个 init-data 的路由，浏览器访问么？

不用，可以用 repl 的模式来跑：

添加 src/repl.ts

```javascript
import { repl } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
    const replServer = await repl(AppModule);
    replServer.setupHistory(".nestjs_repl_history", (err) => {
        if (err) {
            console.error(err);
        }
    });
}
bootstrap();
```
然后在 package.json 里添加一个 scripts

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/423669d0353c43d596659e1b511271f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=634&s=124531&e=png&b=1f1f1f)

```
"repl": "nest start --watch --entryFile repl",
```
把服务停掉，执行：

```
npm run repl
```
先查看下 MeetingRoomService 的方法：
```
methods(MeetingRoomService)
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e148a8e246e4e3095f2bb40c9f55533~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=300&s=24746&e=png&b=181818)

然后调用下：

```
get(MeetingRoomService).initData()
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9629d5c039764ed5ab462e1475548f4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1332&h=702&s=214502&e=png&b=191919)

打印了 3 条 insert 语句，之后又把它 select 出来返回：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43c01e0314a14bda9896cf917ae9408b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1304&h=674&s=213150&e=png&b=191919)

数据库里也可以看到插入的三条数据：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/585a7e05e6e3433d98f0f3aa24640324~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1524&h=384&s=192008&e=png&b=e8e6e5)

我们很多地方都是用的 repository.save，但如果你确定是 insert 或者 update 的时候，直接用 repository.insert  或者 repository.update 更好。

先 truncate table 清空数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9acecd774ac5460c9c88fe60503026f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=738&s=220332&e=png&b=e7e3e0)

刷新可以看到，确实清空了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/402250c636c64892b68da07a7ea591be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168&h=366&s=119566&e=gif&f=15&b=f6f6f6)

把 save 换成 insert：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36878901246f48448439f3f2bee87c32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=864&s=176152&e=png&b=1f1f1f)

重新跑一下：
```
get(MeetingRoomService).initData()
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c3e91ec7ef44fc5a15d87fde8f4f798~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1190&h=356&s=88343&e=png&b=191919)

现在是批量插入了 3 条数据。

所以说确定是 insert 的时候 用 insert 比用 save 更好，能够批量插入数据。

同理，确定是 update 的时候，也不要用 save，因为它会先 select 一次，再确定是 udpate 还是 insert。

然后我们写一下 CRUD 的接口：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /meeting_room/list | GET | 会议室列表 |
| /meeting_room/delete/:id | DELETE | 会议室删除 |
| /meeting_room/update/:id | PUT |会议室更新|
| /meeting_room/create | POST |会议室新增|
| /meeting_room/search | GET |会议室搜索|

在 MeetingRoomtController 增加一个 list 接口：

```javascript
import { Controller, Get, Post, Body, Patch, Param, Delete, Query, DefaultValuePipe } from '@nestjs/common';
import { MeetingRoomService } from './meeting-room.service';
import { generateParseIntPipe } from 'src/utils';

@Controller('meeting-room')
export class MeetingRoomController {
  constructor(private readonly meetingRoomService: MeetingRoomService) {}

  @Get('list')
  async list(
    @Query('pageNo', new DefaultValuePipe(1), generateParseIntPipe('pageNo')) pageNo: number,
    @Query('pageSize', new DefaultValuePipe(2), generateParseIntPipe('pageSize')) pageSize: number,
  ) {
    return await this.meetingRoomService.find(pageNo, pageSize);
  }
}
```

然后在 MeetingRoomService 添加 find 方法：
```javascript
async find(pageNo: number, pageSize: number) {
    if(pageNo < 1) {
      throw new BadRequestException('页码最小为 1');
    }
    const skipCount = (pageNo - 1) * pageSize;

    const [meetingRooms, totalCount] = await this.repository.findAndCount({
        skip: skipCount,
        take: pageSize
    });

    return {
        meetingRooms,
        totalCount
    }
}
```
重新跑下服务：

```
npm run start:dev
```
测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd271cb6c1a4949b63170ff6f4d45e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1196&h=1314&s=161636&e=png&b=fdfdfd)

没啥问题。

然后是 create 接口：

```javascript
@Post('create')
async create(@Body() meetingRoomDto: CreateMeetingRoomDto) {
    return await this.meetingRoomService.create(meetingRoomDto);
}
```

修改下 create-meeting-room.dto.ts
```javascript
import { IsNotEmpty, MaxLength } from "class-validator";

export class CreateMeetingRoomDto {

    @IsNotEmpty({
        message: '会议室名称不能为空'
    })
    @MaxLength(10, {
        message: '会议室名称最长为 10 字符'
    })
    name: string;

    @IsNotEmpty({
        message: '容量不能为空'
    })
    capacity: number;

    @IsNotEmpty({
        message: '位置不能为空'
    })
    @MaxLength(50, {
        message: '位置最长为 50 字符'
    })
    location: string;

    @IsNotEmpty({
        message: '设备不能为空'
    })
    @MaxLength(50, {
        message: '设备最长为 50 字符'
    })
    equipment: string;

    @IsNotEmpty({
        message: '描述不能为空'
    })
    @MaxLength(100, {
        message: '描述最长为 100 字符'
    })
    description: string;

}
```
 
在 MeetingRoomService 里添加 create 方法：

```javascript
async create(meetingRoomDto: CreateMeetingRoomDto) {
    return await this.repository.insert(meetingRoomDto);
}
```
测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7e323cbb0c746efb2a3448de89c9695~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1286&h=824&s=105682&e=png&b=fdfdfd)

这个错误的格式是我们在 exception filter 里自定义的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3199d99f01d40f0b0aa658f7bfa4970~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1028&h=1164&s=169979&e=png&b=fdfdfd)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64e7fcbf75e74ca98b43b72bc3fb9f17~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1138&h=320&s=142031&e=png&b=f6f6f6)

创建成功时会返回创建成功的会议室信息。

这个会议室名其实应该保持唯一，我们加一下校验逻辑：
```javascript
async create(meetingRoomDto: CreateMeetingRoomDto) {
    const room = await this.repository.findOneBy({
      name: meetingRoomDto.name
    });

    if(room) {
      throw new BadRequestException('会议室名字已存在');
    }

    return await this.repository.save(meetingRoomDto);
}
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aca9a4d8ae7f42fb89f6b64342a340b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=878&h=846&s=99750&e=png&b=fcfcfc)

这样就能保证会议室名字不会重复。

然后实现下 update 接口：

```javascript
@Put('update')
async update(@Body() meetingRoomDto: UpdateMeetingRoomDto) {
    return await this.meetingRoomService.update(meetingRoomDto);
}
```

这里的 UpdateMeetingRoomDto 和 CreateMeetingRoomDto 基本一样，只是多了个 id。

所以直接用 PartialType 继承，然后添加一个 id 即可：

```javascript
import { PartialType } from '@nestjs/swagger';
import { CreateMeetingRoomDto } from './create-meeting-room.dto';
import { IsNotEmpty } from 'class-validator';

export class UpdateMeetingRoomDto extends PartialType(CreateMeetingRoomDto) {

    @IsNotEmpty({
        message: 'id 不能为空'
    })
    id: number;
}
```

然后在 MeetingRoomService 实现 update 方法：

```javascript
async update(meetingRoomDto: UpdateMeetingRoomDto) {
    const meetingRoom = await this.repository.findOneBy({
      id: meetingRoomDto.id
    })

    if(!meetingRoom) {
      throw new BadRequestException('会议室不存在');
    }

    meetingRoom.capacity = meetingRoomDto.capacity;
    meetingRoom.location = meetingRoomDto.location;
    meetingRoom.name = meetingRoomDto.name;

    if(meetingRoomDto.description) {
      meetingRoom.description = meetingRoomDto.description;
    }
    if(meetingRoomDto.equipment) {
      meetingRoom.equipment = meetingRoomDto.equipment;
    }

    await this.repository.update({
      id: meetingRoom.id
    } , meetingRoom);
    return 'success';
}
```
先查询一下，如果查不到就返回会议室不存在。

否则，更新会议室信息。

这里的 description 和 equipment 因为可以不传，所以要判断下，传了才更新。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4f165d9ab2549fcb4730cac355d7905~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=958&s=108864&e=png&b=fcfcfc)

服务端打印了 select 和 update 的 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac34c9ae875a4ec28fdaa922867611bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1448&h=446&s=172611&e=png&b=191919)

数据库中也更新了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5d39d84588044fdb48a9a7dbb803f86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=318&s=101912&e=png&b=fafafa)

然后还需要一个回显的接口，用在修改的时候回显数据：

添加一个 :id 接口：

```javascript
@Get(':id')
async find(@Param('id') id: number) {
    return await this.meetingRoomService.findById(id);
}
```

然后在 service 实现这个方法：

```javascript
async findById(id: number) {
    return this.repository.findOneBy({
      id
    }); 
}
```
测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c41d45c2aa4330b695eb20a6026ad8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=1064&s=132865&e=png&b=fdfdfd)

然后是 delete 接口：

```javascript
@Delete(':id')
async delete(@Param('id') id: number) {
    return await this.meetingRoomService.delete(id);
}
```
在 service 实现 delete 方法：

```javascript
async delete(id: number) {
    await this.repository.delete({
      id
    });
    return 'success';
}
```
测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4be53c3459543339ebce76afbc92750~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=910&h=710&s=71020&e=png&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6fa1601b92f40d599857b36fd4f80f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1392&h=346&s=171960&e=png&b=181818)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c24e456169e44df0a5f992939c27ac17~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=336&s=166150&e=gif&f=17&b=f6f6f6)

确实删除了。

最后，还有个搜索接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3958d95537d4168854dc34688604afe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=844&s=78981&e=png&b=ffffff)

我们没必要单独新建个接口，直接改下 list 接口就行：

```javascript
@Get('list')
async list(
    @Query('pageNo', new DefaultValuePipe(1), generateParseIntPipe('pageNo')) pageNo: number,
    @Query('pageSize', new DefaultValuePipe(2), generateParseIntPipe('pageSize')) pageSize: number,
    @Query('name') name: string,
    @Query('capacity') capacity: number,
    @Query('equipment') equipment: string
) {
    return await this.meetingRoomService.find(pageNo, pageSize, name, capacity, equipment);
}
```
添加 3 个参数。

service 里的 find 方法也要添加 3 个参数：

```javascript
async find(pageNo: number, pageSize: number, name: string, capacity: number, equipment: string) {
    if(pageNo < 1) {
      throw new BadRequestException('页码最小为 1');
    }
    const skipCount = (pageNo - 1) * pageSize;

    const condition: Record<string, any> = {};

    if(name) {
        condition.name = Like(`%${name}%`);   
    }
    if(equipment) {
        condition.equipment = Like(`%${equipment}%`); 
    }
    if(capacity) {
        condition.capacity = capacity;
    }

    const [meetingRooms, totalCount] = await this.repository.findAndCount({
        skip: skipCount,
        take: pageSize,
        where: condition
    });

    return {
        meetingRooms,
        totalCount
    }
}
```

如果传了这三个参数，就添加查询的 where 条件。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b047abe26248a6a760218ab1c4ecda~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=1208&s=149733&e=png&b=fdfdfd)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e20405c6737b408b935212701ad615b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=1236&s=153829&e=png&b=fdfdfd)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8eff66048ac4590a86d92517e6e8443~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1114&h=1256&s=150921&e=png&b=fdfdfd)

没啥问题。

这样，会议室管理模块的接口就写完了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。
## 总结

这节，我们实现了会议室管理模块。

首先添加了 entity，然后实现了 CRUD 方法。

其中，我们在 list 接口实现了分页和搜索。

这些接口我们在用户模块都写过。

其实很多模块的功能都是差不多的，都是 CRUD 的复合。


## 113.会议室预订系统：会议室管理模块-管理端前端开发

后端接口写完了，这节我们来实现下前端页面。

先写管理端的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1794ecbb9564d5fb3fe5daee2fc6f9a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3114dba5c0d49ac8b24936c8115f7da~tplv-k3u1fbpfcp-watermark.image?)

把管理端项目跑起来：

```
npm run start
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f8ce55ab4d64245b41c0afbdf814dcd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1474&h=604&s=58621&e=png&b=ffffff)

我们已经添加了对应的路由，但是还没做点击菜单时的切换。

加一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8724997b0b15470dae4287ede9f06ea3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&h=1144&s=190245&e=png&b=1f1f1f)
```javascript
const handleMenuItemClick: MenuClickEventHandler = (info) => {
    let path = '';
    switch(info.key) {
        case '1':
            path = '/meeting_room_manage';
            break;
        case '2':
            path = '/booking_manage';
            break;    
        case '3':
            path = '/user_manage';
            break;
        case '4':
            path = '/statistics';
            break;                    
    }
    router.navigate(path);
}

```
然后写下这 3 个路由的组件：

src/pages/MeetingRoomManage/MeetingRoomManage.tsx
```javascript
export function MeetingRoomManage() {
    return <div>MeetingRoomManage</div>
}
```
src/pages/BookingManage/BookingManage.tsx
```javascript
export function BookingManage() {
    return <div>BookingManage</div>
}
```
src/pages/Statistics/Statistics.tsx
```javascript
export function Statistics() {
    return <div>Statistics</div>
}
```
注册这三个组件对应的路由：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/995d49bde91740d48aef4e8e1a182d58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=1206&s=166155&e=png&b=202020)

```javascript
{
    path: '/',
    element: <MeetingRoomManage/>
},
{
    path: 'user_manage',
    element: <UserManage/>
},
{
    path: 'meeting_room_manage',
    element: <MeetingRoomManage/>
},
{
    path: 'booking_manage',
    element: <BookingManage/>
},
{
    path: 'statistics',
    element: <Statistics/>
}
```
测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f96bcdbcc548d19d1f697f552d2d55~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1696&h=1058&s=358284&e=gif&f=39&b=fefefe)

然后还要加上页面刷新时选中对应菜单项的逻辑：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae4b1d66356e49ab8f886296e87debe9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=982&s=168638&e=png&b=1f1f1f)

```javascript
const location = useLocation();

function getSelectedKeys() {
    if(location.pathname === '/user_manage') {
        return ['3']
    } else if(location.pathname === '/booking_manage') {
        return ['2']
    } else if(location.pathname === '/meeting_room_manage') {
        return ['1']
    } else if(location.pathname === '/statistics') {
        return ['4']
    } else {
        return ['1']
    }
}
```
这样，刷新后也会选中对应的菜单项：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9ca939b7c247b3ae0fdb8451b81526~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1288&h=772&s=210113&e=gif&f=39&b=fcfcfc)

然后来实现会议室管理页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1794ecbb9564d5fb3fe5daee2fc6f9a~tplv-k3u1fbpfcp-watermark.image?)

和我们前面写过的用户列表差不多：

```javascript
import { Badge, Button, Form, Image, Input, Table, message } from "antd";
import { useCallback, useEffect, useMemo, useState } from "react";
import './meeting_room_manage.css';
import { ColumnsType } from "antd/es/table";
import { useForm } from "antd/es/form/Form";

interface SearchMeetingRoom {
    name: string;
    capacity: number;
    equipment: string;
}

interface MeetingRoomSearchResult {
    id: number,
    name: string;
    capacity: number;
    location: string;
    equipment: string;
    description: string;
    isBooked: boolean;
    createTime: Date;
    updateTime: Date;
}


export function MeetingRoomManage() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);
    const [meetingRoomResult, setMeetingRoomResult] = useState<Array<MeetingRoomSearchResult>>([]);

    const columns: ColumnsType<MeetingRoomSearchResult> = useMemo(() => [
        {
            title: '名称',
            dataIndex: 'name'
        },
        {
            title: '容纳人数',
            dataIndex: 'capacity',
        },
        {
            title: '位置',
            dataIndex: 'location'
        },
        {
            title: '设备',
            dataIndex: 'equipment'
        },
        {
            title: '描述',
            dataIndex: 'description'
        },
        {
            title: '添加时间',
            dataIndex: 'createTime'
        },
        {
            title: '上次更新时间',
            dataIndex: 'updateTime'
        },
        {
            title: '预定状态',
            dataIndex: 'isBooked',
            render: (_, record) => (
                record.isBooked ? <Badge status="error">已被预订</Badge> : <Badge status="success">可预定</Badge>
            )
        },
        {
            title: '操作',
            render: (_, record) => (
                <a href="#" onClick={() => {}}>删除</a>
            )
        }
    ], []);

    const searchMeetingRoom = useCallback(async (values: SearchMeetingRoom) => {
        
    }, []);

    const [form ]  = useForm();

    const changePage = useCallback(function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }, []);


    return <div id="meetingRoomManage-container">
        <div className="meetingRoomManage-form">
            <Form
                form={form}
                onFinish={searchMeetingRoom}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="会议室名称" name="name">
                    <Input />
                </Form.Item>

                <Form.Item label="容纳人数" name="capacity">
                    <Input />
                </Form.Item>

                <Form.Item label="位置" name="location">
                    <Input/>
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索会议室
                    </Button>
                    <Button type="primary" style={{background: 'green'}}>
                        添加会议室
                    </Button>

                </Form.Item>
            </Form>
        </div>
        <div className="meetingRoomManage-table">
            <Table columns={columns} dataSource={meetingRoomResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```
css 部分如下：

```css
#meetingRoomManage-container {
    padding: 20px;
}
#meetingRoomManage-container .meetingRoomManage-form {
    margin-bottom: 40px;
}
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d1a062e0ae7431c9d6f380922780a43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2342&h=826&s=125953&e=png&b=fefefe)

然后我们在 interfaces.ts 添加 list 接口：

```javascript
export async function meetingRoomList(name: string, capacity: number, equipment: string, pageNo: number, pageSize: number) {
    return await axiosInstance.get('/meeting-room/list', {
        params: {
            name,
            capacity,
            equipment,
            pageNo,
            pageSize
        }
    });
}
```
在页面调用下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40438a251bb64c80b5e448392f4857d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1454&h=970&s=258407&e=png&b=1f1f1f)

```javascript
const searchMeetingRoom = useCallback(async (values: SearchMeetingRoom) => {
    const res = await meetingRoomList(values.name, values.capacity, values.equipment, pageNo, pageSize);

    const { data } = res.data;
    if(res.status === 201 || res.status === 200) {
        setMeetingRoomResult(data.meetingRooms.map((item: MeetingRoomSearchResult) => {
            return {
                key: item.id,
                ...item
            }
        }))
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}, []);
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b3b4e387944c8893e47cc856bc95c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2324&h=982&s=196826&e=gif&f=20&b=fcfcfc)

按名称搜索：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fa819c3070e44c7a43188a3fd2b85a4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2300&h=762&s=137368&e=png&b=fefefe)
按容量搜索：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eda249542e914c2580a8b541bcf49ca9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2242&h=730&s=133129&e=png&b=fefefe)
按设备搜索：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c28ee1967c7648f1a229604f396d143c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2294&h=774&s=149778&e=png&b=fefefe)

然后，最开始进入页面的时候也得搜索一次：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc660f43cb5b40d999e97e8d207823ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1318&h=748&s=171967&e=png&b=1f1f1f)

```javascript
useEffect(() => {
    searchMeetingRoom({
        name: form.getFieldValue('name'),
        capacity: form.getFieldValue('capacity'),
        equipment: form.getFieldValue('equipment')
    });
}, [pageNo, pageSize]);
```
最开始搜索一次，并且分页信息变了也重新搜索。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bd408655f574dda83164405f61f0534~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2254&h=1036&s=277659&e=gif&f=23&b=fdfdfd)

这样，刚进入页面就会触发一次搜索。

然后我们处理删除：

在 interfaces.ts 里添加 delete 接口：

```javascript
export async function deleteMeetingRoom(id: number) {
    return await axiosInstance.delete('/meeting-room/' + id);
}
```

然后添加删除按钮的处理逻辑：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1798fa0512c42f6be7d5838bbbf5c5f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1194&h=656&s=128749&e=png&b=202020)

```javascript
<a href="#" onClick={() => handleDelete(record.id)}>删除</a>
```
```javascript
const handleDelete = useCallback(async (id: number) => {
    try {
        await deleteMeetingRoom(id);
        message.success('删除成功');
    } catch(e) {
        console.log(e);
        message.error('删除失败');
    }
}, []);
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/032baf5b1ad64b2cafce036cd66fdce7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2322&h=1084&s=462345&e=gif&f=32&b=fdfdfd)

提示删除成功，刷新后也确实没有了。

不过应该是删除后自动刷新的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8170f3b591d469b993074b456fb0cb6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1320&h=1174&s=260346&e=png&b=1f1f1f)

我们添加一个状态，删除后设置一个随机数，然后把它作为 useEffect 的依赖，这样就能触发重新搜索。

```javascript
const [num, setNum] = useState<number>();
```

```javascript
setNum(Math.random());
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/022e8697a73f4c058f8240c3d8c52fe4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2302&h=948&s=315490&e=gif&f=23&b=fdfdfd)

不过，删除操作最好加上个二次确认。

这个把按钮抱一下就好了：

```javascript
{
    title: '操作',
    render: (_, record) => (
        <Popconfirm
            title="会议室删除"
            description="确认删除吗？"
            onConfirm={() => handleDelete(record.id)}
            okText="Yes"
            cancelText="No"
        >  
            <a href="#">删除</a>
        </Popconfirm>
    )
}
```

这样，点击后就会出现一个确认框，确认后才会删除：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6747000bbf44fb3bffdd128423fae70~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=850&h=508&s=60368&e=png&b=fdfdfd)

然后实现添加会议室：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3114dba5c0d49ac8b24936c8115f7da~tplv-k3u1fbpfcp-watermark.image?)

我们在 MeetingRoomManage 的同级添加一个 CreateMeetingRoomModal 组件：

```javascript
import { Modal } from "antd";
import { useCallback } from "react";

interface CreateMeetingRoomModalProps {
    isOpen: boolean;
    handleClose: Function
}

export function CreateMeetingRoomModal(props: CreateMeetingRoomModalProps) {

    const handleOk = useCallback(async function() {
        props.handleClose();
    }, []);

    return <Modal title="创建会议室" open={props.isOpen} onOk={handleOk} onCancel={() => props.handleClose()}>
        <p>xxxx</p>
    </Modal>
}
```
组件里有一个 Modal，通过参数 isOpen 控制是否显示。

当点击取消的时候，或者确认的时候，都会调用 props.handleClose 方法。

然后在 MeetingRoomManage 引入它：

先添加一个状态代表 modal 是否打开：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9df0fc3c2f24eb2be4377a5a964db6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234&h=346&s=116053&e=png&b=1f1f1f)

```javascript
const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
```

然后添加 Modal 组件，并且点击按钮的时候 open：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24bd2799151c45789b52e3a3ab594a9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1392&h=948&s=223724&e=png&b=1f1f1f)

```javascript
<Button type="primary" style={{background: 'green'}} onClick={
    () => setIsCreateModalOpen(true)
}>
    添加会议室
</Button>

```

```javascript
<CreateMeetingRoomModal isOpen={isCreateModalOpen} handleClose={() => {
    setIsCreateModalOpen(false);
}}></CreateMeetingRoomModal>
```

这样，modal 就添加成功了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c461d0f83e0740ac82fdd7e786ec841d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2056&h=1014&s=990477&e=gif&f=32&b=fdfdfd)

然后实现 modal 的具体逻辑，创建会议室：

```javascript
import { Button, Form, Input,InputNumber, Modal } from "antd";
import { useForm } from "antd/es/form/Form";
import TextArea from "antd/es/input/TextArea";
import { useCallback } from "react";

interface CreateMeetingRoomModalProps {
    isOpen: boolean;
    handleClose: Function
}
const layout = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}
export interface CreateMeetingRoom {
    name: string;
    capacity: number;
    location: string;
    equipment: string;
    description: string;
}

export function CreateMeetingRoomModal(props: CreateMeetingRoomModalProps) {

    const [form] = useForm();

    const handleOk = useCallback(async function() {
        const values = form.getFieldsValue();
        console.log(values);

        props.handleClose();
    }, []);

    return <Modal title="创建会议室" open={props.isOpen} onOk={handleOk} onCancel={() => props.handleClose()} okText={'创建'}>
        <Form
            form={form}
            colon={false}
            {...layout}
        >
            <Form.Item
                label="会议室名称"
                name="name"
                rules={[
                    { required: true, message: '请输入会议室名称!' },
                ]}
            >
                <Input />
            </Form.Item>
            <Form.Item
                label="位置"
                name="location"
                rules={[
                    { required: true, message: '请输入会议室位置!' },
                ]}
            >
                <Input />
            </Form.Item>
            <Form.Item
                label="容纳人数"
                name="capacity"
                rules={[
                    { required: true, message: '请输入会议室容量!' },
                ]}
            >
                <InputNumber />
            </Form.Item>
            <Form.Item
                label="设备"
                name="equipment"
            >
                <Input />
            </Form.Item>
            <Form.Item
                label="描述"
                name="description"
            >
                <TextArea />
            </Form.Item>
        </Form>
    </Modal>
}
```
在 modal 里添加一个表单，点击创建按钮的时候打印表单值。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24d81c5e8ef04636b52c13c5077f38be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1648&h=1264&s=203734&e=png&b=ffffff)

我们在 interfaces.ts 添加创建会议室的接口：

```javascript
export async function createMeetingRoom(meetingRoom: CreateMeetingRoom) {
    return await axiosInstance.post('/meeting-room/create', meetingRoom);
}
```
在组件里调用下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71166d4c140b47b99c62b8752aad2d0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=668&s=147888&e=png&b=1f1f1f)
```javascript
const [form] = useForm<CreateMeetingRoom>();

const handleOk = useCallback(async function() {
    const values = form.getFieldsValue();

    values.description = values.description || '';
    values.equipment = values.equipment || '';

    const res = await createMeetingRoom(values);

    if(res.status === 201 || res.status === 200) {
        message.success('创建成功');
        form.resetFields();
        props.handleClose();
    } else {
        message.error(res.data.data);
    }
}, []);
```
如果没有填 description 或者 equipment 就设置个空字符串。

测试下：

创建失败时：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b4bd79f88cd4dc6841d8c84110d1b28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1896&h=1126&s=216434&e=gif&f=19&b=969696)

创建成功时：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aedbcbf0b7004c55acc6f1143ef310c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2226&h=1060&s=630734&e=gif&f=41&b=969696)

创建成功后，手动刷新页面，就看到了新的会议室。

然后我们在关掉弹窗的时候设置下 num。

这样就会触发列表数据的刷新：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6fb387eb6db4015972e96b12025627a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=452&s=117163&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd129212c13d4201956394f5ce6acec1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&h=460&s=109464&e=png&b=1f1f1f)

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/010c397e23d74607b7c2c6f82352da77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2052&h=986&s=536818&e=gif&f=17&b=969696)

最后，加上更新会议室的功能：

创建 UpdateMeetingRoom.tsx

内容和 create 的基本一样：

```javascript
import { Button, Form, Input, InputNumber, Modal, message } from "antd";
import { useForm } from "antd/es/form/Form";
import TextArea from "antd/es/input/TextArea";
import { useCallback } from "react";
import { updateMeetingRoom } from "../../interfaces/interfaces";

interface UpdateMeetingRoomModalProps {
    isOpen: boolean;
    handleClose: Function
}
const layout = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}

export interface UpdateMeetingRoom {
    name: string;
    capacity: number;
    location: string;
    equipment: string;
    description: string;
}

export function UpdateMeetingRoomModal(props: UpdateMeetingRoomModalProps) {

    const [form] = useForm<UpdateMeetingRoom>();

    const handleOk = useCallback(async function() {
        props.handleClose();
    }, []);

    return <Modal title="更新会议室" open={props.isOpen} onOk={handleOk} onCancel={() => props.handleClose()} okText={'更新'}>
        <Form
            form={form}
            colon={false}
            {...layout}
        >
            <Form.Item
                label="会议室名称"
                name="name"
                rules={[
                    { required: true, message: '请输入会议室名称!' },
                ]}
            >
                <Input />
            </Form.Item>
            <Form.Item
                label="位置"
                name="location"
                rules={[
                    { required: true, message: '请输入会议室位置!' },
                ]}
            >
                <Input />
            </Form.Item>
            <Form.Item
                label="容纳人数"
                name="capacity"
                rules={[
                    { required: true, message: '请输入会议室容量!' },
                ]}
            >
                <InputNumber />
            </Form.Item>
            <Form.Item
                label="设备"
                name="equipment"
            >
                <Input />
            </Form.Item>
            <Form.Item
                label="描述"
                name="description"
            >
                <TextArea/>
            </Form.Item>
        </Form>
    </Modal>
}
```

在 interfaces.ts里创建会用到的接口：

```javascript
export async function updateMeetingRoom(meetingRoom: UpdateMeetingRoom) {
    return await axiosInstance.put('/meeting-room/update', meetingRoom);
}

export async function findMeetingRoom(id: number) {
    return await axiosInstance.get('/meeting-room/' + id);
}
```
然后在 MeetingRoomManage 组件引入：

先创建两个 state：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17b96f6f6bf04ecca604cac431b5e3bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1124&h=342&s=122932&e=png&b=1f1f1f)

```javascript
const [isUpdateModalOpen, setIsUpdateModalOpen] = useState(false);
const [updateId, setUpdateId] = useState<number>();
```
一个是 update 弹窗是否打开，一个是当前的 id。

然后添加一个更新按钮，点击的时候打开弹出弹窗，设置 id：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24bed2dffe4e4cb8bcba896b8e159d5b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1026&h=804&s=137317&e=png&b=1f1f1f)

```javascript
{
    title: '操作',
    render: (_, record) => (
        <div>
            <Popconfirm
                title="会议室删除"
                description="确认删除吗？"
                onConfirm={() => handleDelete(record.id)}
                okText="Yes"
                cancelText="No"
            >  
                <a href="#">删除</a>
            </Popconfirm>
            <br/>
            <a href="#" onClick={() => {
                setIsUpdateModalOpen(true);
                setUpdateId(record.id);
            }}>更新</a>
        </div>
    )
}
```

在下面加上弹窗：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c59b24a46f7b4932997a00ebc67c442f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=524&s=127330&e=png&b=1f1f1f)

```javascript
<UpdateMeetingRoomModal isOpen={isUpdateModalOpen} handleClose={() => {
    setIsUpdateModalOpen(false);
    setNum(Math.random());
}}></UpdateMeetingRoomModal>
```
这样更新弹窗就加上了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/353b73b58db547d9ab662522a1190adf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1966&h=990&s=1561529&e=gif&f=36&b=fdfdfd)

然后我们要把 id 传过去：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b80d3d07bab748f48247c6d5ad44946c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1084&h=256&s=81925&e=png&b=202020)

updateId 的默认值是 undefined，可能为空，加上 ! 代表非空。

然后在组件里添加这个参数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2727b87815e843f294a8a3c059eccb20~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=682&h=392&s=81006&e=png&b=1f1f1f)

并且调用查询接口，查询 id 对应的数据来回显：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04366194b9c84a368c61e2e565cb38e3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1190&h=960&s=207490&e=png&b=1f1f1f)

```javascript
useEffect(() => {
    async function query() {
        if(!props.id) {
            return;
        }
        const res = await findMeetingRoom(props.id);

        const { data } = res;
        if(res.status === 200 || res.status === 201) {
            form.setFieldValue('id', data.data.id);
            form.setFieldValue('name', data.data.name);
            form.setFieldValue('location', data.data.location);
            form.setFieldValue('capacity', data.data.capacity);
            form.setFieldValue('equipment', data.data.equipment);
            form.setFieldValue('description', data.data.description);
        } else {
            message.error(res.data.data);
        }
    }

    query();
}, [props.id]);
```
现在就能回显数据了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35364c988d8445b09a70628b5ebe46bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2064&h=1100&s=1571260&e=gif&f=42&b=fdfdfd)

然后再加上更新数据的接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/441e992f6e5848c09048d12b3c2d1451~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894&h=748&s=145567&e=png&b=1f1f1f)

```javascript
const handleOk = useCallback(async function() {
    const values = form.getFieldsValue();

    values.description = values.description || '';
    values.equipment = values.equipment || '';

    const res = await updateMeetingRoom({
        ...values,
        id: form.getFieldValue('id')
    });

    if(res.status === 201 || res.status === 200) {
        message.success('更新成功');
        props.handleClose();
    } else {
        message.error(res.data.data);
    }
}, []);
```
这里要的参数要额外带上 id。

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac548b59d5964adbbdd7aa5b0cd2f903~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1932&h=1076&s=789169&e=gif&f=45&b=fefefe)

更新成功了。

这样，会议室管理的页面就完成了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_admin)。

## 总结

这节我们实现了会议室管理的前端页面。

实现了列表、分页和搜索，添加会议室、更新会议室、删除会议室。

其中添加和更新会议室需要创建 Modal，我们把它拆分成了单独的组件。

更新会议室的时候，传入 id，根据 id 回显数据，然后修改完以后再更新数据。

至此，会议室管理的后端和前端代码就都完成了。


## 114.会议室预订系统：会议室管理模块-用户端前端开发

这节来写用户端的会议室列表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a6f760e036d49bab8ff8191b8c5a8ff~tplv-k3u1fbpfcp-watermark.image?)

现在，用户端首页是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fcfd2a1c94b4a2299380e024f721234~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1858&h=1090&s=79837&e=png&b=ffffff)

需要在 / 下添加一个二级路由：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2686beddeddc481a928da0208d7bd2b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=1082&s=137849&e=png&b=202020)

```javascript
{
    path: '/',
    element: <Menu/>,
    children: [
      {
        path: '/',
        element: <MeetingRoomList/>
      },
      {
        path: 'meeting_room_list',
        element: <MeetingRoomList/>
      },
      {
        path: 'booking_history',
        element: <BookingHistory/>
      }
    ]
}
```
然后分别实现这三个组件：

src/page/menu/Menu.tsx

```javascript
import { Outlet, useLocation } from "react-router-dom";
import { Menu as AntdMenu, MenuProps } from 'antd';
import './menu.css';
import { MenuClickEventHandler } from "rc-menu/lib/interface";
import { router } from "../..";

const items: MenuProps['items'] = [
    {
        key: '1',
        label: "会议室列表"
    },
    {
        key: '2',
        label: "预定历史"
    }
];

const handleMenuItemClick: MenuClickEventHandler = (info) => {
    let path = '';
    switch(info.key) {
        case '1':
            path = '/meeting_room_list';
            break;
        case '2':
            path = '/booking_history';
            break;              
    }
    router.navigate(path);
}


export function Menu() {

    const location = useLocation();

    function getSelectedKeys() {
        if(location.pathname === '/meeting_room_list') {
            return ['1']
        } else if(location.pathname === '/booking_history') {
            return ['2']
        } else {
            return ['1']
        }
    }

    return <div id="menu-container">
        <div className="menu-area">
            <AntdMenu
                defaultSelectedKeys={getSelectedKeys()}
                items={items}
                onClick={handleMenuItemClick}
            />
        </div>
        <div className="content-area">
            <Outlet></Outlet>
        </div>
    </div>
}
```
引入 antd 的 Menu 实现菜单。

渲染的时候根据 useLocation 拿到的 pathname 来设置选中的菜单项。

点击菜单项的时候用 router.push 修改路径。

这里用到的 router 需要在 index.tsx 导出：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ca0768b34944f0998bf1ac57f3a2d4f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=474&s=92107&e=png&b=1f1f1f)


这些我们前面写过一遍。

menu.css 如下：

```css
#menu-container {
    display: flex;
    flex-direction: row;
}
#menu-container .menu-area {
    width: 200px;
}
```
然后是 src/pages/meeting_room_list/MeetingRoomList.tsx

```javascript
export function MeetingRoomList() {
    return <div>MeetingRoomList</div>
}
```
还有 src/pages/booking_history/BookingHistory.tsx

```javascript
export function BookingHistory() {
    return <div>BookingHistory</div>
}
```
在 index.tsx 里导入这些组件后，我们跑起来看看：

```
npm run start:dev
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/446fb7e3ff6a47ecacba283b2a8a1a96~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1262&h=612&s=179976&e=gif&f=28&b=fefefe)

点击菜单项的路由切换，以及刷新选中对应菜单项，都没问题。

然后来写下列表页面，其实这个和管理端的会议室列表差不多：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a6f760e036d49bab8ff8191b8c5a8ff~tplv-k3u1fbpfcp-watermark.image?)

我们把那个复制过来改改。

首先，在 interfaces.ts 添加用到的接口：

```javascript
export async function searchMeetingRoomList(name: string, capacity: number, equipment: string, pageNo: number, pageSize: number) {
    return await axiosInstance.get('/meeting-room/list', {
        params: {
            name,
            capacity,
            equipment,
            pageNo,
            pageSize
        }
    });
}
```
然后写下列表：

```javascript
import { Badge, Button, Form, Input, Popconfirm, Table, message } from "antd";
import { useCallback, useEffect, useMemo, useState } from "react";
import './meeting_room_list.css';
import { ColumnsType } from "antd/es/table";
import { useForm } from "antd/es/form/Form";
import { searchMeetingRoomList } from "../../interface/interfaces";

interface SearchMeetingRoom {
    name: string;
    capacity: number;
    equipment: string;
}

interface MeetingRoomSearchResult {
    id: number,
    name: string;
    capacity: number;
    location: string;
    equipment: string;
    description: string;
    isBooked: boolean;
    createTime: Date;
    updateTime: Date;
}

export function MeetingRoomList() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);

    const [meetingRoomResult, setMeetingRoomResult] = useState<Array<MeetingRoomSearchResult>>([]);

    const columns: ColumnsType<MeetingRoomSearchResult> = useMemo(() => [
        {
            title: '名称',
            dataIndex: 'name'
        },
        {
            title: '容纳人数',
            dataIndex: 'capacity',
        },
        {
            title: '位置',
            dataIndex: 'location'
        },
        {
            title: '设备',
            dataIndex: 'equipment'
        },
        {
            title: '描述',
            dataIndex: 'description'
        },
        {
            title: '添加时间',
            dataIndex: 'createTime'
        },
        {
            title: '上次更新时间',
            dataIndex: 'updateTime'
        },
        {
            title: '预定状态',
            dataIndex: 'isBooked',
            render: (_, record) => (
                record.isBooked ? <Badge status="error">已被预订</Badge> : <Badge status="success">可预定</Badge>
            )
        },
        {
            title: '操作',
            render: (_, record) => (
                <div>
                    <a href="#">预定</a>
                </div>
            )
        }
    ], []);

    const searchMeetingRoom = useCallback(async (values: SearchMeetingRoom) => {
        const res = await searchMeetingRoomList(values.name, values.capacity, values.equipment, pageNo, pageSize);

        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            setMeetingRoomResult(data.meetingRooms.map((item: MeetingRoomSearchResult) => {
                return {
                    key: item.id,
                    ...item
                }
            }))
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }
    }, []);

    const [form ]  = useForm();

    useEffect(() => {
        searchMeetingRoom({
            name: form.getFieldValue('name'),
            capacity: form.getFieldValue('capacity'),
            equipment: form.getFieldValue('equipment')
        });
    }, [pageNo, pageSize]);

    const changePage = useCallback(function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }, []);

    return <div id="meetingRoomList-container">
        <div className="meetingRoomList-form">
            <Form
                form={form}
                onFinish={searchMeetingRoom}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="会议室名称" name="name">
                    <Input />
                </Form.Item>

                <Form.Item label="容纳人数" name="capacity">
                    <Input />
                </Form.Item>

                <Form.Item label="设备" name="equipment">
                    <Input/>
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索会议室
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="meetingRoomList-table">
            <Table columns={columns} dataSource={meetingRoomResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```
上面是 form、下面是 table。

调用搜索接口来搜索列表数据，然后设置到 table 的 dataSource。

每次分页变化的时候重新搜索。

然后 css 部分如下：

```css
#meetingRoomList-container {
    padding: 20px;
}
#meetingRoomList-container .meetingRoomList-form {
    margin-bottom: 40px;
}
```

这样，列表页就完成了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e03f191acba548c080c6df79d6ba12ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2282&h=996&s=369175&e=gif&f=28&b=fdfdfd)

其实写这个模块的时候偷懒了，应该是写完后端接口，还要写 swager 文档。

然后前端根据 swagger 接口文档才能知道传啥参数，有啥返回值。

当时我们没写 swagger 文档，现在补一下：

打开后端项目，在 MeetingRoomController 里加一下 swagger 相关的装饰器：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0a9c5aea2d54195a5782aca77447257~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=876&h=488&s=82012&e=png&b=1f1f1f)

首先加一下 delete 接口的：

```javascript
@ApiParam({
    name: 'id',
    type: Number,
    description: 'id'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: 'success'
})
```

访问 [http://localhost:3005/api-doc](http://localhost:3005/api-doc#/default/MeetingRoomController_delete) 可以看到这个接口的文档：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b963c048bf443e960e6bf9a57ed815~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=730&h=920&s=57129&e=png&b=f9eeed)

其实会议室的接口都是需要登录才能访问的，当时为了测试方便没有加，现在加一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/120d7fdaeeda4067af9c813137c518f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=772&h=600&s=83483&e=png&b=1f1f1f)

添加 @RequireLogin 装饰器，标识接口需要登录。

并且添加对应的 @ApiBearerAuth 的 swagger 装饰器，代表需要添加 Bearer 的 header。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2e9f334c1dc4d49b597ae390b8ed7d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1768&h=808&s=210740&e=gif&f=28&b=fbf0ed)

我们现在 postman 里测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2647600e3294667988d07e60f10a32d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1008&h=710&s=73376&e=png&b=fcfcfc)

这时候直接调用 delete 接口就会提示需要先登录了。

然后我们登录下，拿到 token。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1878903a2706490ab7549b401dac94b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1280&h=964&s=192034&e=png&b=fdfdfd)

把它复制到 swagger 文档这里： 

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e84ac199636344dda2096a6781adea5b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1880&h=708&s=98312&e=png&b=312f2e)

然后点击这个 try it out：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c710fcb942834328ad86aefbe95abdcf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1966&h=630&s=58947&e=png&b=f9eeec)

数据库中现在有 3 条记录：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94cfeff6d31b4265abb2a106531b8591~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=994&h=262&s=85140&e=png&b=f9f9f9)

把 id 为 10 那条删掉。

点击 execute：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72aeb9819eb54d2987759687846b06c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1584&h=730&s=60955&e=png&b=f9eeed)

swagger 会发送请求，下面会打印响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4b1c8cba1fb48bdb045d18c14ca6aa3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=1018&s=172362&e=png&b=333333)

这时数据库里就没有这条记录了：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fd6d061c25244e6b180dfd939c05adf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=772&h=282&s=71192&e=png&b=f7f7f7)

可以直接在 swagger 文档里测试接口，不用 postman 也行。

然后继续写下个接口的 swagger 文档：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20d1107d67f743139c2c218b7a90194d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=820&h=156&s=31995&e=png&b=1f1f1f)

这个接口的参数也是用 @ApiParam 标识，但它的响应不是 string，而是 MeetingRoom。

而我们现在并没有 vo，没地方标识属性：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b87f13f1aafb4e5a8af14f89143f37bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=200&s=25174&e=png&b=1f1f1f)

所以要创建个 vo：

新建 src/meeting-room/vo/meeting-room.vo.ts

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class MeetingRoomVo {
    
    @ApiProperty()
    id: number;

    @ApiProperty()
    name: string;

    @ApiProperty()
    capacity: number;

    @ApiProperty()
    location: string;

    @ApiProperty()
    equipment: string;

    @ApiProperty()
    description: string;

    @ApiProperty()
    isBooked: boolean;

    @ApiProperty()
    createTime: Date;

    @ApiProperty()
    updateTime: Date;
}
```
然后加一下 swagger 的装饰器：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403bf1d50ff2435cb173313a7e33db2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=884&h=526&s=86522&e=png&b=1f1f1f)
```javascript
@ApiBearerAuth()
@ApiParam({
    name: 'id',
    type: Number,
})
@ApiResponse({
    status: HttpStatus.OK,
    description: 'success',
    type: MeetingRoomVo
})
```
试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37136786e63d4977b0de06c030d9a91a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1200&h=1430&s=159801&e=png&b=eef4fa)

接下来是 update 接口：

他有两种响应：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be0633b63e4f4b81971024b773fdb6b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=900&s=169239&e=png&b=1f1f1f)

分别写一下：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef54451d60544fd7b16a6cf32db46bd1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=608&s=111879&e=png&b=1f1f1f)

```javascript
@ApiBearerAuth()
@ApiBody({
    type: UpdateMeetingRoomDto,
})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '会议室不存在'
})
@ApiResponse({
    status: HttpStatus.OK,
    description: 'success'
})
```
然后在 dto 里标注下属性：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0912339cf2d4a3a84550b6e1f64483e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=468&s=109922&e=png&b=1f1f1f)

因为 update 的 dto 继承了 create 的 dto，所以那里也要加一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e565e7676c00472b842aeb9ce9b36623~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=1268&s=205871&e=png&b=1f1f1f)

这样 swagger 文档就对了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c2adc8415da42868092c8ee1b4fed81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=952&h=1296&s=110208&e=png&b=faf4ee)

然后是 create 接口：

postman 里调用下是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5339becd99cd4d6ebe127cef968e1c8c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=916&h=1128&s=146290&e=png&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df30ee02c0cb46509d4adcee93299775~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=858&h=878&s=96535&e=png&b=fcfcfc)

所以 swagger 装饰器这样写：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cd2bb760ccd4d0f8ada447247032729~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=978&h=620&s=113340&e=png&b=1f1f1f)
```javascript
@ApiBearerAuth()
@ApiBody({
    type: CreateMeetingRoomDto,
})
@ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '会议室名字已存在'
})
@ApiResponse({
    status: HttpStatus.OK,
    type: MeetingRoomVo
})
```
这样 swagger 文档显示的就对了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22530084774640bc95d5bddce063347b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=968&h=1484&s=169359&e=png&b=eff7f3)

然后还有最后一个 list 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/786fa3b2fb2c4245a782810e3c853f2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1342&h=410&s=117414&e=png&b=1f1f1f)

它的响应是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5d0a05f5ba42c5bcb165a5284042bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1196&h=1280&s=152984&e=png&b=fdfdfd)

首先创建响应数据的 vo：

src/meeting-room/vo/meeting-room-list.vo.ts
```javascript
import { ApiProperty } from "@nestjs/swagger";
import { MeetingRoomVo } from "./meeting-room.vo";

export class MeetingRoomListVo {

    @ApiProperty({
        type: [MeetingRoomVo]
    })
    users: Array<MeetingRoomVo>;

    @ApiProperty()
    totalCount: number;
}
```
然后加一下 swagger 的装饰器：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/675a8cca8ac94b0089e77dbc4cab6cd2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1170&h=1174&s=171865&e=png&b=1f1f1f)

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'pageNo',
    type: Number,
    required: false
})
@ApiQuery({
    name: 'pageSize',
    type: Number,
    required: false
})
@ApiQuery({
    name: 'name',
    type: String,
    required: false
})
@ApiQuery({
    name: 'capacity',
    type: String,
    required: false
})
@ApiQuery({
    name: 'equipment',
    type: String,
    required: false
})
@ApiResponse({
    type: MeetingRoomListVo
})
```
有同学说，不用把 service 里的返回值改成 MeetingRoomListVo 对象么？

不用，只要结构对上就行。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ce922e32a7473096d86a179df7bdbc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=938&h=934&s=81975&e=png&b=eef4fa)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1707ae9b1ad9415e8f62f5eaa10670c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=882&s=103636&e=png&b=eef4fa)

最后，在 controller 上加上个 @ApiTags，把下面的接口分到单独一组：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8ffeb13d85243c0b69015d3a0241ed0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=626&h=170&s=41061&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31ce4c320acc4e4f86df0cc125983104~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=780&h=608&s=59113&e=png&b=f8f4f4)

这样，用户端的会议室列表页面，swagger 文档就都完成了。

案例代码上传了小册仓库：

[前端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_user)

[后端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)

## 总结

这节我们写了用户端的会议室列表页，并且补了 swagger 文档。

用户端列表页就是调用 list 接口，通过 form 来填写参数，通过 table 展示结果。

swagger 文档部分就是分别通过 @ApiPram @ApiQuery @ApiBody @ApiResponse 标识接口，通过 @ApiProperty 标识 dto 和 vo 的属性。

这样，会议室模块的前端后端就都完成了。

## 115.会议室预订系统：预定管理模块-后端开发

这节我们来实现预定管理模块的后端。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/042ccf36141a473f868e40c115db73c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1010&h=1012&s=145901&e=png&b=fefcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f9ef4e312e941b0bc7ab4ea9f7e1d59~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932&h=1014&s=128397&e=png&b=fdf5f4)

涉及到这些接口：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /booking/list | GET | 预订列表 |
| /booking/approve | POST| 审批预订申请 |
| /booking/add | POST |申请预订|
| /booking/apply/:id | GET |通过预订|
| /booking/reject/:id | GET |取消预订|
| /booking/unbind/:id | GET |解除预订|
| /booking/history | GET|预订历史 |
| /booking/urge | GET |催办 |

我们来写一下。

先创建 Booking 的 entity。

在后端项目下创建一个 meeting-room 模块：

```
nest g resource booking
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c86e5a75b22e49f4a82b7d8afc2e7f5f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=282&s=77313&e=png&b=191919)

然后修改 booking.entity.ts

根据当时设计的表来写：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 预订ID |
| user_id | INT |预订用户ID |
| room_id | INT |会议室ID |
| start_time | DATETIME | 会议开始时间 |
| end_time | DATETIME | 会议结束时间 |
| status | VARCHAR(20) | 状态（申请中、审批通过、审批驳回、已解除） |
| note | VARCHAR(100) | 备注 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

```javascript
import { MeetingRoom } from "src/meeting-room/entities/meeting-room.entity";
import { User } from "src/user/entities/user.entity";
import { Column, CreateDateColumn, Entity, JoinColumn, ManyToOne, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class Booking {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        comment: '会议开始时间'
    })
    startTime: Date;

    @Column({
        comment: '会议结束时间'
    })
    endTime: Date;

    @Column({
        length: 20,
        comment: '状态（申请中、审批通过、审批驳回、已解除）',
        default: '申请中'
    })
    status: string;

    @Column({
        length: 100,
        comment: '备注',
        default: ''
    })
    note: string;

    @ManyToOne(() => User)
    user: User;

    @ManyToOne(() => MeetingRoom)
    room: MeetingRoom;

    @CreateDateColumn({
        comment: '创建时间'
    })
    createTime: Date;

    @UpdateDateColumn({
        comment: '更新时间'
    })
    updateTime: Date;
}
```

这里 Booking 和 User、MeetingRoom 是多对一的关系：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ce5525d99274999b65f24e9aafe8658~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&h=926&s=117455&e=png&b=fcf8f8)

我们在 entities 引入：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23764ebbdca246b391385c0097757285~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1122&h=928&s=208639&e=png&b=202020)

typeorm 会自动建表和创建外键：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb7ed06f9e6d4d7bb85fd5e5ce93f855~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1426&h=334&s=136162&e=png&b=191919)

在 mysql workbench 里可以看到这个表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25a051cae54e4f0db0e36de5ee857ebb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1268&h=664&s=273300&e=png&b=f2efee)

这两个外键都是 restrict 的约束：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0ef7d08a86b49ea8ac4ae3c84fae41e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1650&h=532&s=148042&e=png&b=f9f8f8)

restrict 是只有从表没有相关记录，才可以删除主表记录。

但我们会议室是支持删除的，怎么办呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faca1dd8a66c4ada88748a4b6af44ac7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=534&h=242&s=54380&e=png&b=fcfcfc)

可以在删除失败时提示有预定记录，然后手动取消预订后再删除。

这个后面再处理。

我们先插入一些数据：

在 BookingService 增加一个 initData 方法：

```javascript
@InjectEntityManager()
private entityManager: EntityManager;

async initData() {
    const user1 = await this.entityManager.findOneBy(User, {
      id: 1
    });
    const user2 = await this.entityManager.findOneBy(User, {
      id: 2
    });

    const room1 = await this.entityManager.findOneBy(MeetingRoom, {
      id: 3
    });
    const room2 = await await this.entityManager.findOneBy(MeetingRoom, {
      id: 6
    });

    const booking1 = new Booking();
    booking1.room = room1;
    booking1.user = user1;
    booking1.startTime = new Date();
    booking1.endTime = new Date(Date.now() + 1000 * 60 * 60);

    await this.entityManager.save(Booking, booking1);

    const booking2 = new Booking();
    booking2.room = room2;
    booking2.user = user2;
    booking2.startTime = new Date();
    booking2.endTime = new Date(Date.now() + 1000 * 60 * 60);

    await this.entityManager.save(Booking, booking2);

    const booking3 = new Booking();
    booking3.room = room1;
    booking3.user = user2;
    booking3.startTime = new Date();
    booking3.endTime = new Date(Date.now() + 1000 * 60 * 60);

    await this.entityManager.save(Booking, booking3);

    const booking4 = new Booking();
    booking4.room = room2;
    booking4.user = user1;
    booking4.startTime = new Date();
    booking4.endTime = new Date(Date.now() + 1000 * 60 * 60);

    await this.entityManager.save(Booking, booking4);
}
```
我们先查询出 2 个 User ，2 个 MeetingRoom，然后创建 4 个 Booking。

用 save 把 4 条记录保存到数据库。

用 repl 的方式跑起来：

```
npm run repl
```
调用 initData 方法：
```
await get(BookingService).initData()
```
会有一系列 insert 语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6873b0d2476047758201688b78025212~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1434&h=1158&s=322145&e=png&b=191919)

在数据库的 booking 表可以看到插入了 4 条记录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/843cfb4558e441549b88d708fc480718~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1812&h=372&s=213892&e=png&b=f0eeed)

然后来写 booking 模块的接口：

首先是 list 接口。

它支持根据条件搜索，并且可以分页：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b6228a200f64202b0203a6f779a71a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1628&h=1126&s=174963&e=png&b=ffffff)

我们来写一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53ab55853c58452e807a9c92a9b261af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1416&h=732&s=235976&e=png&b=1f1f1f)

```javascript
@Get('list')
async list(
    @Query('pageNo', new DefaultValuePipe(1), generateParseIntPipe('pageNo')) pageNo: number,
    @Query('pageSize', new DefaultValuePipe(10), generateParseIntPipe('pageSize')) pageSize: number,
    @Query('username') username: string,
    @Query('meetingRoomName') meetingRoomName: string,
    @Query('meetingRoomPosition') meetingRoomPosition: string,
    @Query('bookingTimeRangeStart') bookingTimeRangeStart: number,
    @Query('bookingTimeRangeEnd') bookingTimeRangeEnd: number,
) {
    return this.bookingService.find(pageNo, pageSize, username, meetingRoomName, meetingRoomPosition, bookingTimeRangeStart, bookingTimeRangeEnd);
}
```
这种列表接口我们写过，就是传入分页参数、搜索参数，然后在 service 里把它们查出来返回。

这里的时间用 number 来接收。

我们去 BookingService 里实现下这个方法：

```javascript
async find(pageNo: number, pageSize: number, username: string, meetingRoomName: string, meetingRoomPosition: string, bookingTimeRangeStart: number, bookingTimeRangeEnd: number ) {
    const skipCount = (pageNo - 1) * pageSize;

    const [bookings, totalCount] = await this.entityManager.findAndCount(Booking, {
      where: {
        user: {
          username: Like(`%${username}%`)
        },
        room: {
          name: Like(`%${meetingRoomName}%`),
          location: Like(`%${meetingRoomPosition}%`)
        },
        startTime: Between(new Date(bookingTimeRangeStart), new Date(bookingTimeRangeEnd))
      },
      relations: {
        user: true,
        room: true,
      },
      skip: skipCount,
      take: pageSize
    });

    return {
      bookings,
      totalCount
    }
}
```
很容易看懂，就是接个 where 条件，还有分页。

要注意下日期的范围查询使用 between and 语法，这里使用 Between 操作符。

先测试下。

停掉服务，我们用 repl 的方式测：

```
npm run repl
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c0b199130a49159048e6f249688373~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=810&s=193210&e=png&b=191919)

先看下有啥数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f0745b3aa334c13bd7e825185e90a8f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1808&h=500&s=250575&e=png&b=f3f1f0)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c6d4c0efca4b9a9d7adc470fce4768~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1596&h=506&s=289766&e=png&b=ebe9e8)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56e4d750cc6e408f8fb30d74146da8dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1370&h=526&s=199313&e=png&b=f1efee)

然后测试下：

在 repl 拿到两个时间戳：

```javascript
new Date('2023-09-29').getTime()
```
```javascript
new Date('2023-09-30').getTime()
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c0a9c7af4794c979a84fce5acfb1706~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=172&s=22866&e=png&b=181818)

调用下这个方法：

```javascript
await get(BookingService).find(1, 10, 'guang', '天王', '三层', 1695945600000, 1696032000000)
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b18ee8e248343cfb529d0a17a78e90a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=644&s=192491&e=png&b=1a1a1a)

打印了一堆 sql，下面有查询的结果：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10cbfd103e7744f6b1d7886b2c0ad2ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=862&h=944&s=148203&e=png&b=181818)

查询出来的是 id 为 1 和 3 的记录。

因为条件是 user.name 包含 guang：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ec8364a4fa44ae5bc5f633f944dd4f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=964&h=212&s=99906&e=png&b=f8f8f8)

room.name 包含天王：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19e492b053b74f84b0cc655397ff7ca7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=966&h=238&s=85084&e=png&b=f9f9f9)

所以查出这两条是对的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c458434016047c09cb7cb998d13d740~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1222&h=256&s=112303&e=png&b=fbfbfb)

查询逻辑写完了，我们还得优化下。

因为这些参数是可选的，我们要处理下没有传入的情况：

```javascript
async find(pageNo: number, pageSize: number, username: string, meetingRoomName: string, meetingRoomPosition: string, bookingTimeRangeStart: number, bookingTimeRangeEnd: number ) {
    const skipCount = (pageNo - 1) * pageSize;

    const condition: Record<string, any> = {};

    if(username) {
      condition.user = {
        username: Like(`%${username}%`)
      }
    }

    if(meetingRoomName) {
      condition.room =  {
        name: Like(`%${meetingRoomName}%`)
      }
    }

    if(meetingRoomPosition) {
      if (!condition.room) {
        condition.room = {}
      }
      condition.room.location = Like(`%${meetingRoomPosition}%`)
    }

    if(bookingTimeRangeStart) {
      if(!bookingTimeRangeEnd) {
        bookingTimeRangeEnd = bookingTimeRangeStart + 60 * 60 * 1000
      }
      condition.startTime = Between(new Date(bookingTimeRangeStart), new Date(bookingTimeRangeEnd))
    }

    const [bookings, totalCount] = await this.entityManager.findAndCount(Booking, {
      where: condition,
      relations: {
        user: true,
        room: true,
      },
      skip: skipCount,
      take: pageSize
    });

    return {
      bookings,
      totalCount
    }
}
```
就是如果传入了，就加到 condition 上。

其中，如果 endTime 没传入，那就用 startTime + 一小时 来搜索。

此外，这里查询出来 user 信息是包含密码的，其实应该把它去掉：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ec75ba46ee4028ab8cda12ddc01104~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=620&h=320&s=47688&e=png&b=181818)

可以在这里指定 select 的字段：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a0454d125eb488dbc819af1fad47e82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=394&s=42350&e=png&b=202020)

但这样有点麻烦。

我们直接查出来之后把它删掉就好了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0b84c310fa24d4c844f005527a8e72d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=672&h=644&s=71783&e=png&b=1f1f1f)

```javascript
bookings.map(item => {
    delete item.user.password;
    return item;
})
```

把 repl 停掉，把服务跑起来：

```
npm run start:dev
```
我们在 postman 里测试下：

```
http://localhost:3005/booking/list?meetingRoomName=天王&username=guang
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b594883ca9614d5dbdb4e598aa6ed477~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1196&h=1248&s=188012&e=png&b=fdfdfd)

没啥问题。

接下来是申请预定的接口

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /booking/list | GET | 预订列表 |
| /booking/add | POST |申请预订|

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/436d2d7f602845598785593260ad4742~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1368&h=968&s=74070&e=png&b=d7d7d7)

在 BookingController 添加一个接口：

```javascript
@Post('add')
async add(@Body() booking: CreateBookingDto, @UserInfo('userId') userId: number) {
    await this.bookingService.add(booking, userId);
    return 'success'
}
```
这里需要用 @UserInfo 拿到 userId。

创建用到的 dto：

```javascript
import { IsNotEmpty, IsNumber } from "class-validator";

export class CreateBookingDto {
    @IsNotEmpty({ message: '会议室名称不能为空'})
    @IsNumber()
    meetingRoomId: number;

    @IsNotEmpty({ message: '开始时间不能为空' })
    @IsNumber()
    startTime: number;

    @IsNotEmpty({ message: '结束时间不能为空' })
    @IsNumber()
    endTime: number;

    note: string;
}
```
然后在 BookingService 实现下 add 方法：

```javascript
async add(bookingDto: CreateBookingDto, userId: number) {
    const meetingRoom = await this.entityManager.findOneBy(MeetingRoom, {
      id: bookingDto.meetingRoomId
    });

    if(!meetingRoom) {
      throw new BadRequestException('会议室不存在');
    }

    const user = await this.entityManager.findOneBy(User, {
      id: userId
    });

    const booking = new Booking();
    booking.room = meetingRoom;
    booking.user = user;
    booking.startTime = new Date(bookingDto.startTime);
    booking.endTime = new Date(bookingDto.endTime);

    await this.entityManager.save(Booking, booking);
}
```
就是根据 id 查询出 meeetingRoom 和 user，然后创建 booking，保存。

测试下：

先登录拿到 token：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/429fd7f4eed94ca295c4cb61dc3843ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1130&h=1110&s=179496&e=png&b=fdfdfd)

带在 Aothrization 的 header 上访问 add 接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bd96c8f23244ce4b25f0d8ecfff3437~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1416&h=496&s=74638&e=png&b=f9f9f9)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48feddfb140f41a58d9a086d44a3ad59~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=850&h=854&s=93099&e=png&b=fcfcfc)
```json
{
    "meetingRoomId": 3,
    "startTime": 1703986859333,
    "endTime": 1703987859333
}
```

在 mysql workbench 查询下，可以看到记录成功插入了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebdd0963347447f684a66ae7e05330db~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1440&h=470&s=299324&e=png&b=fbfbfb)

当然，现在的接口还是有问题的，我们得限制下，同一个会议室一段时间内只能被预定一次。

那怎么保证预定的时间不会冲突呢？

其实一般的会议室预订系统都是这样做的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53461a04dd6a4c7b9f29aa729e09c050~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1744&h=1198&s=205957&e=png&b=ffffff)

在右边列出来会议室在一天之内哪些时间可用，哪些时间被预定了。

然后只能在没有被预定的时间内选择。

这里我们就简化一下，查询下已经预定的记录里有没有包含这段时间的就好了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bccdacb437e3480cb9d8cf79c9f387bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&h=1150&s=270729&e=png&b=1f1f1f)

```javascript
async add(bookingDto: CreateBookingDto, userId: number) {
    const meetingRoom = await this.entityManager.findOneBy(MeetingRoom, {
      id: bookingDto.meetingRoomId
    });

    if(!meetingRoom) {
      throw new BadRequestException('会议室不存在');
    }

    const user = await this.entityManager.findOneBy(User, {
      id: userId
    });

    const booking = new Booking();
    booking.room = meetingRoom;
    booking.user = user;
    booking.startTime = new Date(bookingDto.startTime);
    booking.endTime = new Date(bookingDto.endTime);

    const res = await this.entityManager.findOneBy(Booking, {
      room: {
        id: meetingRoom.id
      },
      startTime: LessThanOrEqual(booking.startTime),
      endTime: MoreThanOrEqual(booking.endTime)
    });

    if(res) {
      throw new BadRequestException('该时间段已被预定');
    }
    
    await this.entityManager.save(Booking, booking);
  }
```
测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7d4fd3a8cde41a0a83dbdb173bf4dd4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=716&h=788&s=88366&e=png&b=fcfcfc)

```json
{
    "meetingRoomId": 3,
    "startTime": 1703986959333,
    "endTime": 1703986859333
}
```
当预定一个已经被预定的时间段时，会提示已被预定。

然后继续写后面接口：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /booking/list | GET | 预订列表 |
| /booking/add | POST |申请预订|
| /booking/apply/:id | GET |通过预订|
| /booking/reject/:id | GET |取消预订|
| /booking/unbind/:id | GET |解除预订|

接下来写修改预定状态的这三个接口。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/593bc2412c174809b19888fefe54554f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1024&h=700&s=116315&e=png&b=fefefe)

状态有这 4 种：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d0f0af1a9654811a5868a55c3db2ee7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=946&h=472&s=74897&e=png&b=1f1f1f)

在 BookingController 添加三个路由：

```javascript
@Get("apply/:id")
async apply(@Param('id') id: number) {
    return this.bookingService.apply(id);
}

@Get("reject/:id")
async reject(@Param('id') id: number) {
    return this.bookingService.reject(id);
}

@Get("unbind/:id")
async unbind(@Param('id') id: number) {
    return this.bookingService.unbind(id);
}
```
然后在 BookingService 里实现这三个方法：

```javascript
async apply(id: number) {
    await this.entityManager.update(Booking, {
      id
    }, {
      status: '审批通过'      
    });
    return 'success'
}

async reject(id: number) {
    await this.entityManager.update(Booking, {
      id
    }, {
      status: '审批驳回'      
    });
    return 'success'
}

async unbind(id: number) {
    await this.entityManager.update(Booking, {
      id
    }, {
      status: '已解除'      
    });
    return 'success'
}
```
postman 里测试下：

```
http://localhost:3005/booking/apply/1
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0612aeebd6c442d49b1a5d78680f56e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=704&s=63886&e=png&b=fcfcfc)

```
http://localhost:3005/booking/reject/2
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb615fe172d341578ff636ed48a0f7c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=652&s=59278&e=png&b=fcfcfc)

```
http://localhost:3005/booking/reject/3
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d195e2cd06f4784bf5fb6bfd3e300aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790&h=622&s=58757&e=png&b=fbfbfb)

在 mysql workbench 里可以看到状态成功被修改了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf2ce3b8cce641d0b89c7c196d6d6f28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1202&h=322&s=140258&e=png&b=f6f6f6)

接下来是催办的接口：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /booking/list | GET | 预订列表 |
| /booking/apply/:id | GET |通过预订|
| /booking/reject/:id | GET |取消预订|
| /booking/unbind/:id | GET |解除预订|
| /booking/urge | GET |催办 |

按当时的设计，催办要发送邮件和短信，不过我们没买短信服务，这里就发邮件好了。

但也不是每次催办都会发邮件，我们在 redis 里加个标识，半小时内只发一次邮件。

我们在 BookingController 添加一个 urge 接口：

```javascript
@Get('urge/:id')
async urge(@Param('id') id: number) {
    return this.bookingService.urge(id);
}
```
然后在 BookingService 添加实现逻辑：

```javascript
@Inject(RedisService)
private redisService: RedisService;

@Inject(EmailService)
private emailService: EmailService;

async urge(id: number) {
    const flag = await this.redisService.get('urge_' + id);

    if(flag) {
      return '半小时内只能催办一次，请耐心等待';
    }

    let email = await this.redisService.get('admin_email');

    if(!email) { 
      const admin = await this.entityManager.findOne(User, {
        select: {
          email: true
        },
        where: {
          isAdmin: true
        }
      });

      email = admin.email

      this.redisService.set('admin_email', admin.email);
    }

    this.emailService.sendMail({
      to: email,
      subject: '预定申请催办提醒',
      html: `id 为 ${id} 的预定申请正在等待审批`
    });
    
    this.redisService.set('urge_' + id, 1, 60 * 30);
}
```

我们注入了 EmailService 和 RedisService。

先用 redisService 查询 flag，查到的话就提醒半小时内只能催办一次。

然后用 redisService 查询 admin 的邮箱，没查到的话到数据库查，然后存到 redis。

之后发催办邮件，并且在 redis 里存一个 30 分钟的 flag。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b323c02e3dc43a486a9e8b4abca837b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=598&s=54092&e=png&b=fcfcfc)

第一次催办，管理员会收到邮件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595528fe560d4bda82b78af295a47e99~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=510&h=270&s=28591&e=png&b=f7f7f7)

第二次催办，会提示半小时只能催办一次：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb30b489a7bd4905afc02727c1de6738~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=624&s=65832&e=png&b=fcfcfc)

在 RedisInsight 里可以看到这两个 key：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58d86bb56ea64ebc8836aaec345a4179~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1334&h=542&s=70661&e=png&b=141414)

这样，催办接口就完成了。

当然，这里最好是在邮件里带一个具体的链接，点击可以直接打开对应的页面来处理申请。

等后面写完这个页面再改。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)

## 总结

这节我们完成了预定管理模块的后端代码，包括列表、添加预定、审批、催办等。

后端代码完成了，下节我们来写前端部分的代码。

## 116.会议室预订系统：预定管理模块-管理端前端开发

这节写下预定管理模块管理端的前端部分：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/036dff2b321c429e8b584ce61ce7916f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1628&h=1126&s=174963&e=png&b=ffffff)

对应的路由我们前面写过了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ab57c76c05496e89dd88b85b3bc0a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1028&h=636&s=64854&e=png&b=ffffff)

这节来填充下内容。

首先是 table 部分：

```javascript
import { Badge, Button, DatePicker, Form, Input, Popconfirm, Table, TimePicker, message } from "antd";
import { useEffect, useState } from "react";
import { ColumnsType } from "antd/es/table";
import { UserSearchResult } from "../UserManage/UserManage";
import { MeetingRoomSearchResult } from "../MeetingRoomManage/MeetingRoomManage";
import dayjs from "dayjs";

interface BookingSearchResult {
    id: number;
    startTime: string;
    endTime: string;
    status: string;
    note: string;
    createTime: string;
    updateTime: string;
    user: UserSearchResult,
    room: MeetingRoomSearchResult
}

export function BookingManage() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);
    const [bookingSearchResult] = useState<Array<BookingSearchResult>>([]);

    const columns: ColumnsType<BookingSearchResult> = [
        {
            title: '会议室名称',
            dataIndex: 'room',
            render(_, record) {
                return record.room.name
            }
        },
        {
            title: '会议室位置',
            dataIndex: 'room',
            render(_, record) {
                return record.room.location
            }
        },
        {
            title: '预定人',
            dataIndex: 'user',
            render(_, record) {
                return record.user.username
            }
        },
        {
            title: '开始时间',
            dataIndex: 'startTime',
            render(_, record) {
                return dayjs(new Date(record.startTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '结束时间',
            dataIndex: 'endTime',
            render(_, record) {
                return dayjs(new Date(record.endTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '审批状态',
            dataIndex: 'status'
        },
        {
            title: '预定时间',
            dataIndex: 'createTime',
            render(_, record) {
                return dayjs(new Date(record.createTime)).format('YYYY-MM-DD hh:mm:ss')
            }
        },
        {
            title: '备注',
            dataIndex: 'note'
        },
        {
            title: '描述',
            dataIndex: 'description'
        },
        {
            title: '操作',
            render: (_, record) => (
                <div>
                </div>
            )
        }
    ];


    const changePage = function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }

    return <div id="bookingManage-container">
        <div className="bookingManage-table">
            <Table columns={columns} dataSource={bookingSearchResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```

列表接口是这样的：


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fdc24e7926c4ff3831cb18819c6b171~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2046&h=686&s=100916&e=png&b=fefefe)

根据这个指定表格列的定义，并且添加分页的处理。

其中涉及到的 User 和 Room 的类型从其他页面导入：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac4968dc0a34abc95e01c4690118a72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=860&h=526&s=91934&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e005d4ccd5420bb158a3f3d32c914d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=752&h=584&s=78976&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db8c1caa203456b97dadea90667da71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=606&s=100385&e=png&b=1f1f1f)

这里用到 dayjs 来格式化日期，安装下：

```
npm install dayjs
```

然后加上上面的表单：

```javascript
import { Button, DatePicker, Form, Input, Popconfirm, Table, TimePicker, message } from "antd";
import { useEffect, useState } from "react";
import { ColumnsType } from "antd/es/table";
import { useForm } from "antd/es/form/Form";
import './booking_manage.css';
import { UserSearchResult } from "../UserManage/UserManage";
import { MeetingRoomSearchResult } from "../MeetingRoomManage/MeetingRoomManage";
import dayjs from "dayjs";

export interface SearchBooking {
    username: string;
    meetingRoomName: string;
    meetingRoomPosition: string;
    rangeStartDate: Date;
    rangeStartTime: Date;
    rangeEndDate: Date;
    rangeEndTime: Date;
}

interface BookingSearchResult {
    id: number;
    startTime: string;
    endTime: string;
    status: string;
    note: string;
    createTime: string;
    updateTime: string;
    user: UserSearchResult,
    room: MeetingRoomSearchResult
}

export function BookingManage() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);
    const [bookingSearchResult, setBookingSearchResult] = useState<Array<BookingSearchResult>>([]);
    const [num, setNum] = useState(0);

    const columns: ColumnsType<BookingSearchResult> = [
        {
            title: '会议室名称',
            dataIndex: 'room',
            render(_, record) {
                return record.room.name
            }
        },
        {
            title: '会议室位置',
            dataIndex: 'room',
            render(_, record) {
                return record.room.location
            }
        },
        {
            title: '预定人',
            dataIndex: 'user',
            render(_, record) {
                return record.user.username
            }
        },
        {
            title: '开始时间',
            dataIndex: 'startTime',
            render(_, record) {
                return dayjs(new Date(record.startTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '结束时间',
            dataIndex: 'endTime',
            render(_, record) {
                return dayjs(new Date(record.endTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '审批状态',
            dataIndex: 'status'
        },
        {
            title: '预定时间',
            dataIndex: 'createTime',
            render(_, record) {
                return dayjs(new Date(record.createTime)).format('YYYY-MM-DD hh:mm:ss')
            }
        },
        {
            title: '备注',
            dataIndex: 'note'
        },
        {
            title: '描述',
            dataIndex: 'description'
        },
        {
            title: '操作',
            render: (_, record) => (
                <div>
                </div>
            )
        }
    ];

    const searchBooking = async (values: SearchBooking) => {

    }

    const [form ]  = useForm();

    useEffect(() => {
        searchBooking({
            username: form.getFieldValue('username'),
            meetingRoomName: form.getFieldValue('meetingRoomName'),
            meetingRoomPosition: form.getFieldValue('meetingRoomPosition'),
            rangeStartDate: form.getFieldValue('rangeStartDate'),
            rangeStartTime: form.getFieldValue('rangeStartTime'),
            rangeEndDate: form.getFieldValue('rangeEndDate'),
            rangeEndTime: form.getFieldValue('rangeEndTime')
        });
    }, [pageNo, pageSize, num]);

    const changePage = function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }

    return <div id="bookingManage-container">
        <div className="bookingManage-form">
            <Form
                form={form}
                onFinish={searchBooking}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="预定人" name="username">
                    <Input />
                </Form.Item>

                <Form.Item label="会议室名称" name="meetingRoomName">
                    <Input />
                </Form.Item>

                <Form.Item label="预定开始日期" name="rangeStartDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定开始时间" name="rangeStartTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="预定结束日期" name="rangeEndDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定结束时间" name="rangeEndTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="位置" name="meetingRoomPosition">
                    <Input />
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索预定申请
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="bookingManage-table">
            <Table columns={columns} dataSource={bookingSearchResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```
涉及到的 css 如下：

```css
#bookingManage-container {
    padding: 20px;
}
#bookingManage-container .bookingManage-form {
    margin-bottom: 40px;
}
#bookingManage-container .ant-form-item {
    margin: 10px;
}

```

渲染出来是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7975fd6c491e495a906a8d5c111ab25d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2450&h=1108&s=174544&e=png&b=fefefe)

这里要注意的是日期和时间分别要用 DatePicker 和 TimePicker，所以分为 2 个字段。

接下来实现下用到的接口，改下 interfaces.ts

```javascript
export async function bookingList(searchBooking: SearchBooking, pageNo: number, pageSize: number) {

    let bookingTimeRangeStart;
    let bookingTimeRangeEnd;
    
    if(searchBooking.rangeStartDate && searchBooking.rangeStartTime) {
        const rangeStartDateStr = dayjs(searchBooking.rangeStartDate).format('YYYY-MM-DD');
        const rangeStartTimeStr = dayjs(searchBooking.rangeStartTime).format('HH:mm');
        bookingTimeRangeStart = dayjs(rangeStartDateStr + ' ' + rangeStartTimeStr).valueOf()
    }

    if(searchBooking.rangeEndDate && searchBooking.rangeEndTime) {
        const rangeEndDateStr = dayjs(searchBooking.rangeEndDate).format('YYYY-MM-DD');
        const rangeEndTimeStr = dayjs(searchBooking.rangeEndTime).format('HH:mm');
        bookingTimeRangeEnd = dayjs(rangeEndDateStr + ' ' + rangeEndTimeStr).valueOf()
    }

    return await axiosInstance.get('/booking/list', {
        params: {
            username: searchBooking.username,
            meetingRoomName: searchBooking.meetingRoomName,
            meetingRoomPosition: searchBooking.meetingRoomPosition,
            bookingTimeRangeStart,
            bookingTimeRangeEnd,
            pageNo: pageNo,
            pageSize: pageSize
        }
    });
}

export async function apply(id: number) {
    return await axiosInstance.get('/booking/apply/' + id);
}

export async function reject(id: number) {
    return await axiosInstance.get('/booking/reject/' + id);
}

export async function unbind(id: number) {
    return await axiosInstance.get('/booking/unbind/' + id);
}
```

apply、reject、unbind 接口比较简单，列表接口相对麻烦一些。

因为现在日期和时间分为了 2 个字段，而接口只接收一个字段，所以要把它们合并。

用 dayjs 分别把日期和时间 format 成 YYYY-MM-DD 和 HH:mm 的格式。

然后拼接成一个字符串之后，再创建 dayjs 实例，这样时间就合并成一个了。

在页面里调用下列表接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2905a09abab4077bfbb60e5245dec7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1348&h=604&s=113612&e=png&b=1f1f1f)

```javascript
import { Button, DatePicker, Form, Input, Popconfirm, Table, TimePicker, message } from "antd";
import { useEffect, useState } from "react";
import { ColumnsType } from "antd/es/table";
import { useForm } from "antd/es/form/Form";
import { apply, bookingList, reject, unbind } from "../../interfaces/interfaces";
import './booking_manage.css';
import { UserSearchResult } from "../UserManage/UserManage";
import { MeetingRoomSearchResult } from "../MeetingRoomManage/MeetingRoomManage";
import dayjs from "dayjs";

export interface SearchBooking {
    username: string;
    meetingRoomName: string;
    meetingRoomPosition: string;
    rangeStartDate: Date;
    rangeStartTime: Date;
    rangeEndDate: Date;
    rangeEndTime: Date;
}

interface BookingSearchResult {
    id: number;
    startTime: string;
    endTime: string;
    status: string;
    note: string;
    createTime: string;
    updateTime: string;
    user: UserSearchResult,
    room: MeetingRoomSearchResult
}

export function BookingManage() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);
    const [bookingSearchResult, setBookingSearchResult] = useState<Array<BookingSearchResult>>([]);
    const [num, setNum] = useState(0);

    const columns: ColumnsType<BookingSearchResult> = [
        {
            title: '会议室名称',
            dataIndex: 'room',
            render(_, record) {
                return record.room.name
            }
        },
        {
            title: '会议室位置',
            dataIndex: 'room',
            render(_, record) {
                return record.room.location
            }
        },
        {
            title: '预定人',
            dataIndex: 'user',
            render(_, record) {
                return record.user.username
            }
        },
        {
            title: '开始时间',
            dataIndex: 'startTime',
            render(_, record) {
                return dayjs(new Date(record.startTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '结束时间',
            dataIndex: 'endTime',
            render(_, record) {
                return dayjs(new Date(record.endTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '审批状态',
            dataIndex: 'status',
        },
        {
            title: '预定时间',
            dataIndex: 'createTime',
            render(_, record) {
                return dayjs(new Date(record.createTime)).format('YYYY-MM-DD hh:mm:ss')
            }
        },
        {
            title: '备注',
            dataIndex: 'note'
        },
        {
            title: '描述',
            dataIndex: 'description'
        },
        {
            title: '操作',
            render: (_, record) => (
                <div>
                    
                </div>
            )
        }
    ];

    const searchBooking = async (values: SearchBooking) => {
        const res = await bookingList(values, pageNo, pageSize);

        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            setBookingSearchResult(data.bookings.map((item: BookingSearchResult) => {
                return {
                    key: item.id,
                    ...item
                }
            }))
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }
    }

    const [form ]  = useForm();

    useEffect(() => {
        searchBooking({
            username: form.getFieldValue('username'),
            meetingRoomName: form.getFieldValue('meetingRoomName'),
            meetingRoomPosition: form.getFieldValue('meetingRoomPosition'),
            rangeStartDate: form.getFieldValue('rangeStartDate'),
            rangeStartTime: form.getFieldValue('rangeStartTime'),
            rangeEndDate: form.getFieldValue('rangeEndDate'),
            rangeEndTime: form.getFieldValue('rangeEndTime')
        });
    }, [pageNo, pageSize, num]);

    const changePage = function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }

    return <div id="bookingManage-container">
        <div className="bookingManage-form">
            <Form
                form={form}
                onFinish={searchBooking}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="预定人" name="username">
                    <Input />
                </Form.Item>

                <Form.Item label="会议室名称" name="meetingRoomName">
                    <Input />
                </Form.Item>

                <Form.Item label="预定开始日期" name="rangeStartDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定开始时间" name="rangeStartTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="预定结束日期" name="rangeEndDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定结束时间" name="rangeEndTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="位置" name="meetingRoomPosition">
                    <Input />
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索预定申请
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="bookingManage-table">
            <Table columns={columns} dataSource={bookingSearchResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```

没带参数的搜索没问题：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f93d610987f44426a704609874d8e6e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2466&h=1184&s=242353&e=png&b=fefefe)

数据库里就这 4 条记录：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99eac5103d52465f863a3ea7afa254ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1792&h=482&s=238462&e=png&b=f2f0ef)

然后带上参数搜索下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7262447f994b508aba2b98e351113c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2428&h=878&s=175924&e=png&b=fefefe)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38bd171dc44a49b1b07b704d41279a93~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2318&h=944&s=192886&e=png&b=fefefe)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c0b454303ec4c259616681a49ffd4b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2120&h=868&s=157744&e=png&b=fefefe)

开始时间在 2023-9-29 的 10 点到 11 点的预定有 3 条：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c2efb545f44a8a9ed43dd76d79b3da~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2348&h=994&s=187375&e=png&b=fefefe)

11 点到 12 点的有 1 条：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c1408c333154bea89e476ca494f087f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2364&h=836&s=170075&e=png&b=fefefe)

这样，列表功能就完成了。

可以再加上个按照状态过滤，这个是 antd 的功能：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafb59aae484465c9758a75d19f282f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1358&h=906&s=140771&e=png&b=1f1f1f)

```javascript
{
    title: '审批状态',
    dataIndex: 'status',
    onFilter: (value, record) => record.status.startsWith(value as string),
    filters: [
        {
          text: '审批通过',
          value: '审批通过',
        },
        {
          text: '审批驳回',
          value: '审批驳回',
        },
        {
            text: '申请中',
            value: '申请中',
        },
        {
            text: '已解除',
            value: '已解除'
        },
      ],
},
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c402b1fffa904b7f8afe14bf65b2608f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2300&h=1260&s=203341&e=png&b=fefefe)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196a7bc2137d45d285937014f65aaa27~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2190&h=872&s=147630&e=png&b=fdfdfd)

然后加上右边的按钮：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c79f1e767abe4cda85452405837e5b95~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1380&h=1200&s=243855&e=png&b=1f1f1f)

```javascript
{
    title: '操作',
    render: (_, record) => (
        <div>
            <Popconfirm
                title="通过申请"
                description="确认通过吗？"
                onConfirm={() => changeStatus(record.id, 'apply')}
                okText="Yes"
                cancelText="No"
            >  
                <a href="#">通过</a>
            </Popconfirm>
            <br/>
            <Popconfirm
                title="驳回申请"
                description="确认驳回吗？"
                onConfirm={() => changeStatus(record.id, 'reject')}
                okText="Yes"
                cancelText="No"
            >  
                <a href="#">驳回</a>
            </Popconfirm>
            <br/>
            <Popconfirm
                title="解除申请"
                description="确认解除吗？"
                onConfirm={() => changeStatus(record.id, 'unbind')}
                okText="Yes"
                cancelText="No"
            >  
                <a href="#">解除</a>
            </Popconfirm>
            <br/>
        </div>
    )
}
```

```javascript
async function changeStatus(id: number, status: 'apply' | 'reject' | 'unbind') {
    const methods = {
        apply,
        reject,
        unbind
    }
    const res = await methods[status](id);

    if(res.status === 201 || res.status === 200) {
        message.success('状态更新成功');
        setNum(Math.random());
    } else {
        message.error(res.data.data);
    }
}
```
更新完状态之后要触发列表的重新渲染，所以这里用 setNum 触发：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8447351d611745bc830cb92864da93bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1100&h=406&s=120675&e=png&b=202020)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/462d2673706749b197e1711ef581f279~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2808&h=1382&s=1799861&e=gif&f=37&b=fdfdfd)

这样，预定管理的功能就完成了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_admin)

## 总结

这节我们实现了预订管理的管理端的前端页面，主要是列表和修改状态的接口。

要注意的是时间相关的处理，antd 只有 DatePicker 和 TimePicker，我们要添加 2 个字段接收，然后调用接口的时候把它们合并成一个字段。

下节我们来写用户端的部分。



## 117.会议室预订系统：预定管理模块-用户端前端开发

这节我们来写下预订管理模块的用户端。

把用户端代码跑起来，首先写下预订历史页面：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c48a82b4211498baaddbbb3547fca63~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1476&h=884&s=66779&e=png&b=ffffff)

这个页面就是一个列表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5243f2fa51946f192575f88c0baa822~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1136&h=796&s=82250&e=png&b=fefefe)

我们先写上面的 form：

```javascript
import { Button, DatePicker, Form, Input, TimePicker } from "antd";
import { useEffect } from "react";
import { useForm } from "antd/es/form/Form";
import './booking_history.css';

export interface SearchBooking {
    username: string;
    meetingRoomName: string;
    meetingRoomPosition: string;
    rangeStartDate: Date;
    rangeStartTime: Date;
    rangeEndDate: Date;
    rangeEndTime: Date;
}

export function BookingHistory() {
    const searchBooking = async (values: SearchBooking) => {
        
    }

    const [form ]  = useForm();

    useEffect(() => {
        searchBooking({
            username: '',
            meetingRoomName: form.getFieldValue('meetingRoomName'),
            meetingRoomPosition: form.getFieldValue('meetingRoomPosition'),
            rangeStartDate: form.getFieldValue('rangeStartDate'),
            rangeStartTime: form.getFieldValue('rangeStartTime'),
            rangeEndDate: form.getFieldValue('rangeEndDate'),
            rangeEndTime: form.getFieldValue('rangeEndTime')
        });
    }, []);

    return <div id="bookingHistory-container">
        <div className="bookingHistory-form">
            <Form
                form={form}
                onFinish={searchBooking}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="会议室名称" name="meetingRoomName">
                    <Input />
                </Form.Item>

                <Form.Item label="预定开始日期" name="rangeStartDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定开始时间" name="rangeStartTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="预定结束日期" name="rangeEndDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定结束时间" name="rangeEndTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="位置" name="meetingRoomPosition">
                    <Input />
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索预定历史
                    </Button>
                </Form.Item>
            </Form>
        </div>
    </div>
}
```
```css
#bookingHistory-container {
    padding: 20px;
}
#bookingHistory-container .bookingHistory-form {
    margin-bottom: 40px;
}
#bookingHistory-container .ant-form-item {
    margin: 10px;
}

```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d271754a30e8442285335cc2236ed77a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2620&h=838&s=92270&e=png&b=fefefe)

和后台管理的页面差不多，只不过这里没有 user 的搜索。

我们登录的时候把它放到了 localStorage 里，所以这里从 localStorage 取就行：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe82c514ecbe40bead2566a06ae1512b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1370&h=442&s=110671&e=png&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad99206ec65d40b0af9e3e7032c6dd91~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1198&h=964&s=199462&e=png&b=1f1f1f)

```javascript
function getUserInfo() {
    const userInfoStr = localStorage.getItem('user_info');

    if(userInfoStr) {
        return JSON.parse(userInfoStr);
    }
}
```
然后在 interface.ts 写下用到的接口：

```javascript
export async function bookingList(searchBooking: SearchBooking, pageNo: number, pageSize: number) {

    let bookingTimeRangeStart;
    let bookingTimeRangeEnd;
    
    if(searchBooking.rangeStartDate && searchBooking.rangeStartTime) {
        const rangeStartDateStr = dayjs(searchBooking.rangeStartDate).format('YYYY-MM-DD');
        const rangeStartTimeStr = dayjs(searchBooking.rangeStartTime).format('HH:mm');
        bookingTimeRangeStart = dayjs(rangeStartDateStr + ' ' + rangeStartTimeStr).valueOf()
    }

    if(searchBooking.rangeEndDate && searchBooking.rangeEndTime) {
        const rangeEndDateStr = dayjs(searchBooking.rangeEndDate).format('YYYY-MM-DD');
        const rangeEndTimeStr = dayjs(searchBooking.rangeEndTime).format('HH:mm');
        bookingTimeRangeEnd = dayjs(rangeEndDateStr + ' ' + rangeEndTimeStr).valueOf()
    }

    return await axiosInstance.get('/booking/list', {
        params: {
            username: searchBooking.username,
            meetingRoomName: searchBooking.meetingRoomName,
            meetingRoomPosition: searchBooking.meetingRoomPosition,
            bookingTimeRangeStart,
            bookingTimeRangeEnd,
            pageNo: pageNo,
            pageSize: pageSize
        }
    });
}
```
这个就是当时后台管理的接口，没啥区别。

然后在页面调用下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca1c9bbf016a412194147807a8c7e690~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1610&h=1460&s=338451&e=png&b=1f1f1f)

```javascript
interface BookingSearchResult {
    id: number;
    startTime: string;
    endTime: string;
    status: string;
    note: string;
    createTime: string;
    updateTime: string;
    room: MeetingRoomSearchResult
}
```
```javascript
const [pageNo, setPageNo] = useState<number>(1);
const [pageSize, setPageSize] = useState<number>(10);
const [bookingSearchResult, setBookingSearchResult] = useState<Array<BookingSearchResult>>([]);

const searchBooking = async (values: SearchBooking) => {
    const res = await bookingList(values, pageNo, pageSize);

    const { data } = res.data;
    if(res.status === 201 || res.status === 200) {
        setBookingSearchResult(data.bookings.map((item: BookingSearchResult) => {
            return {
                key: item.id,
                ...item
            }
        }))
    } else {
        message.error(data || '系统繁忙，请稍后再试');
    }
}
 ```
接口调用没啥问题：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee4234bf1f574c4584c585860a20d0d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1416&h=1098&s=160749&e=png&b=fefefe)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eaf74fa453c466180a4ca918d48b294~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1836&h=1258&s=243903&e=png&b=ffffff)

然后加上下面的表格：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c01c0cb2a8bf4b3e9c32b5fe0d6fd87d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1352&h=1370&s=205280&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc9445b2049b444fac0b17e86fd07f91~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=294&s=60838&e=png&b=1f1f1f)

这些和后台管理一样，直接复制过来就行：

```javascript
import { Button, DatePicker, Form, Input, Table, TimePicker, message } from "antd";
import { useEffect, useState } from "react";
import { useForm } from "antd/es/form/Form";
import './booking_history.css';
import { bookingList } from "../../interface/interfaces";
import { MeetingRoomSearchResult } from "../meeting_room_list/MeetingRoomList";
import { ColumnsType } from "antd/es/table";
import dayjs from 'dayjs';

export interface SearchBooking {
    username: string;
    meetingRoomName: string;
    meetingRoomPosition: string;
    rangeStartDate: Date;
    rangeStartTime: Date;
    rangeEndDate: Date;
    rangeEndTime: Date;
}

interface BookingSearchResult {
    id: number;
    startTime: string;
    endTime: string;
    status: string;
    note: string;
    createTime: string;
    updateTime: string;
    room: MeetingRoomSearchResult
}

function getUserInfo() {
    const userInfoStr = localStorage.getItem('user_info');

    if(userInfoStr) {
        return JSON.parse(userInfoStr);
    }
}

export function BookingHistory() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);
    const [bookingSearchResult, setBookingSearchResult] = useState<Array<BookingSearchResult>>([]);

    const searchBooking = async (values: SearchBooking) => {
        const res = await bookingList(values, pageNo, pageSize);

        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            setBookingSearchResult(data.bookings.map((item: BookingSearchResult) => {
                return {
                    key: item.id,
                    ...item
                }
            }))
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }
    }

    const [form ]  = useForm();

    const changePage = function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }

    useEffect(() => {
        searchBooking({
            username: getUserInfo().username,
            meetingRoomName: form.getFieldValue('meetingRoomName'),
            meetingRoomPosition: form.getFieldValue('meetingRoomPosition'),
            rangeStartDate: form.getFieldValue('rangeStartDate'),
            rangeStartTime: form.getFieldValue('rangeStartTime'),
            rangeEndDate: form.getFieldValue('rangeEndDate'),
            rangeEndTime: form.getFieldValue('rangeEndTime')
        });
    }, [pageNo, pageSize]);

    const columns: ColumnsType<BookingSearchResult> = [
        {
            title: '会议室名称',
            dataIndex: 'room',
            render(_, record) {
                return record.room.name
            }
        },
        {
            title: '开始时间',
            dataIndex: 'startTime',
            render(_, record) {
                return  dayjs(new Date(record.startTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '结束时间',
            dataIndex: 'endTime',
            render(_, record) {
                return dayjs(new Date(record.endTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '审批状态',
            dataIndex: 'status',
            onFilter: (value, record) => record.status.startsWith(value as string),
            filters: [
                {
                  text: '审批通过',
                  value: '审批通过',
                },
                {
                  text: '审批驳回',
                  value: '审批驳回',
                },
                {
                    text: '申请中',
                    value: '申请中',
                },
                {
                    text: '已解除',
                    value: '已解除'
                },
              ],
        },
        {
            title: '预定时间',
            dataIndex: 'createTime',
            render(_, record) {
                return dayjs(new Date(record.createTime)).format('YYYY-MM-DD hh:mm:ss')
            }
        },
        {
            title: '备注',
            dataIndex: 'note'
        },
        {
            title: '描述',
            dataIndex: 'description'
        },
        {
            title: '操作',
            render: () => (
                <div>
                    
                </div>
            )
        }
    ];

    return <div id="bookingHistory-container">
        <div className="bookingHistory-form">
            <Form
                form={form}
                onFinish={searchBooking}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="会议室名称" name="meetingRoomName">
                    <Input />
                </Form.Item>

                <Form.Item label="预定开始日期" name="rangeStartDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定开始时间" name="rangeStartTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="预定结束日期" name="rangeEndDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定结束时间" name="rangeEndTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="位置" name="meetingRoomPosition">
                    <Input />
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索预定历史
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="bookingHistory-table">
            <Table columns={columns} dataSource={bookingSearchResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```

这样，列表就完成了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146dc4bf86ba458d845ae22118eb8b60~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2766&h=964&s=192334&e=png&b=fefefe)

然后实现解除预定功能：

在 interface.ts 添加 unbind 接口：

```javascript
export async function unbind(id: number) {
    return await axiosInstance.get('/booking/unbind/' + id);
}
```
然后在页面调用下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af9043095494b9382971e73d3b01ff2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=950&h=578&s=82790&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3e54efc16424180b22c7231d4ecf4e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=812&h=428&s=66227&e=png&b=1f1f1f)

```javascript
import { Button, DatePicker, Form, Input, Popconfirm, Table, TimePicker, message } from "antd";
import { useEffect, useState } from "react";
import { useForm } from "antd/es/form/Form";
import './booking_history.css';
import { bookingList, unbind } from "../../interface/interfaces";
import { MeetingRoomSearchResult } from "../meeting_room_list/MeetingRoomList";
import { ColumnsType } from "antd/es/table";
import dayjs from 'dayjs';

export interface SearchBooking {
    username: string;
    meetingRoomName: string;
    meetingRoomPosition: string;
    rangeStartDate: Date;
    rangeStartTime: Date;
    rangeEndDate: Date;
    rangeEndTime: Date;
}

interface BookingSearchResult {
    id: number;
    startTime: string;
    endTime: string;
    status: string;
    note: string;
    createTime: string;
    updateTime: string;
    room: MeetingRoomSearchResult
}

function getUserInfo() {
    const userInfoStr = localStorage.getItem('user_info');

    if(userInfoStr) {
        return JSON.parse(userInfoStr);
    }
}

export function BookingHistory() {
    const [pageNo, setPageNo] = useState<number>(1);
    const [pageSize, setPageSize] = useState<number>(10);
    const [bookingSearchResult, setBookingSearchResult] = useState<Array<BookingSearchResult>>([]);
    const [num, setNum] = useState(0);

    const searchBooking = async (values: SearchBooking) => {
        const res = await bookingList(values, pageNo, pageSize);

        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            setBookingSearchResult(data.bookings.map((item: BookingSearchResult) => {
                return {
                    key: item.id,
                    ...item
                }
            }))
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }
    }

    const [form ]  = useForm();

    const changePage = function(pageNo: number, pageSize: number) {
        setPageNo(pageNo);
        setPageSize(pageSize);
    }

    useEffect(() => {
        searchBooking({
            username: getUserInfo().username,
            meetingRoomName: form.getFieldValue('meetingRoomName'),
            meetingRoomPosition: form.getFieldValue('meetingRoomPosition'),
            rangeStartDate: form.getFieldValue('rangeStartDate'),
            rangeStartTime: form.getFieldValue('rangeStartTime'),
            rangeEndDate: form.getFieldValue('rangeEndDate'),
            rangeEndTime: form.getFieldValue('rangeEndTime')
        });
    }, [pageNo, pageSize, num]);

    async function changeStatus(id: number) {

        const res = await unbind(id);

        if(res.status === 201 || res.status === 200) {
            message.success('状态更新成功');
            setNum(Math.random());
        } else {
            message.error(res.data.data);
        }
    }

    const columns: ColumnsType<BookingSearchResult> = [
        {
            title: '会议室名称',
            dataIndex: 'room',
            render(_, record) {
                return record.room.name
            }
        },
        {
            title: '开始时间',
            dataIndex: 'startTime',
            render(_, record) {
                return  dayjs(new Date(record.startTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '结束时间',
            dataIndex: 'endTime',
            render(_, record) {
                return dayjs(new Date(record.endTime)).format('YYYY-MM-DD HH:mm:ss')
            }
        },
        {
            title: '审批状态',
            dataIndex: 'status',
            onFilter: (value, record) => record.status.startsWith(value as string),
            filters: [
                {
                  text: '审批通过',
                  value: '审批通过',
                },
                {
                  text: '审批驳回',
                  value: '审批驳回',
                },
                {
                    text: '申请中',
                    value: '申请中',
                },
                {
                    text: '已解除',
                    value: '已解除'
                },
              ],
        },
        {
            title: '预定时间',
            dataIndex: 'createTime',
            render(_, record) {
                return dayjs(new Date(record.createTime)).format('YYYY-MM-DD hh:mm:ss')
            }
        },
        {
            title: '备注',
            dataIndex: 'note'
        },
        {
            title: '描述',
            dataIndex: 'description'
        },
        {
            title: '操作',
            render: (_, record) => (
                record.status === '申请中' ? <div>
                    <Popconfirm
                        title="解除申请"
                        description="确认解除吗？"
                        onConfirm={() => changeStatus(record.id)}
                        okText="Yes"
                        cancelText="No"
                    >  
                        <a href="#">解除预定</a>
                    </Popconfirm>
                </div> : null
            )
        }
    ];

    return <div id="bookingHistory-container">
        <div className="bookingHistory-form">
            <Form
                form={form}
                onFinish={searchBooking}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="会议室名称" name="meetingRoomName">
                    <Input />
                </Form.Item>

                <Form.Item label="预定开始日期" name="rangeStartDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定开始时间" name="rangeStartTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="预定结束日期" name="rangeEndDate">
                    <DatePicker/>
                </Form.Item>

                <Form.Item label="预定结束时间" name="rangeEndTime">
                    <TimePicker/>
                </Form.Item>

                <Form.Item label="位置" name="meetingRoomPosition">
                    <Input />
                </Form.Item>

                <Form.Item label=" ">
                    <Button type="primary" htmlType="submit">
                        搜索预定历史
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="bookingHistory-table">
            <Table columns={columns} dataSource={bookingSearchResult} pagination={ {
                current: pageNo,
                pageSize: pageSize,
                onChange: changePage
            }}/>
        </div>
    </div>
}
```

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/581c84cabc1d48929aed4f248c2b6d2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2358&h=1074&s=420561&e=gif&f=61&b=fcfcfc)

没啥问题。

如果没有合适的数据，就手动去数据库里改一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8803f967b9c4f6e89ea40b202320bc4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1834&h=600&s=453785&e=png&b=f5f5f5)

接下来，还有一个添加预定的功能：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ab95474f0be488cbde34e4a7975f5e1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1368&h=968&s=74070&e=png&b=d7d7d7)

当点击会议室列表的预定按钮的时候，会弹出这个窗口。

添加 src/meeting_room_list/CreateBookingModal.tsx

```javascript
import { DatePicker, Form, Input, InputNumber, Modal, Select, TimePicker, message } from "antd";
import { useForm } from "antd/es/form/Form";
import { bookingAdd } from "../../interface/interfaces";
import { MeetingRoomSearchResult } from "./MeetingRoomList";

interface CreateBookingModalProps {
    isOpen: boolean;
    handleClose: Function;
    meetingRoom: MeetingRoomSearchResult;
}

const layout = {
    labelCol: { span: 6 },
    wrapperCol: { span: 18 }
}

export interface CreateBooking {
    meetingRoomId: number;
    rangeStartDate: Date;
    rangeStartTime: Date;
    rangeEndDate: Date;
    rangeEndTime: Date;
    note: string;
}

export function CreateBookingModal(props: CreateBookingModalProps) {

    const [form] = useForm<CreateBooking>();

    const handleOk = async function() {
      
    }

    return <Modal title="创建会议室" open={props.isOpen} onOk={handleOk} onCancel={() => props.handleClose()} okText={'创建'}>
        <Form
            form={form}
            colon={false}
            {...layout}
        >
            <Form.Item
                label="会议室名称"
                name="meetingRoomId"
            >
                {props.meetingRoom.name}
            </Form.Item>
            <Form.Item
                label="预定开始日期"
                name="rangeStartDate"
                rules={[
                    { required: true, message: '请输入预定开始日期!' },
                ]}
            >
                <DatePicker/>
            </Form.Item>
            <Form.Item
                label="预定开始时间"
                name="rangeStartTime"
                rules={[
                    { required: true, message: '请输入预定开始日期!' },
                ]}
            >
                <TimePicker/>
            </Form.Item>
            <Form.Item
                label="预定结束日期"
                name="rangeEndDate"
                rules={[
                    { required: true, message: '请输入预定结束日期!' },
                ]}
            >
                <DatePicker/>
            </Form.Item>
            <Form.Item
                label="预定结束时间"
                name="rangeEndTime"
                rules={[
                    { required: true, message: '请输入预定结束日期!' },
                ]}
            >
                <TimePicker/>
            </Form.Item>
            <Form.Item
                label="备注"
                name="note"
            >
                <Input />
            </Form.Item>
        </Form>
    </Modal>
}
```
然后点击预定按钮的时候，显示这个弹窗：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b996e8ab9a48209d994b28b7637b9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2210&h=894&s=157484&e=png&b=fefefe)

添加 isCreateModalOpen 的 state 来标识弹窗是否打开，并且记录点击的是哪个会议室：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fdaa471d1374fb9b90428f14fc86f03~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1464&h=276&s=111904&e=png&b=1f1f1f)

```javascript
const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
const [currentMeetingRoom, setCurrentMeetingRoom] =  useState<MeetingRoomSearchResult>();
```
点击预定按钮的时候，打开弹窗，记录当前会议室：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b46e523254347939475a12646a22f41~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=730&h=414&s=50866&e=png&b=1f1f1f)

```javascript
{
    title: '操作',
    render: (_, record) => (
        <div>
            <a href="#" onClick={() => {
                setIsCreateModalOpen(true);
                setCurrentMeetingRoom(record);
            }}>预定</a>
        </div>
    )
}
```
然后弹窗传入当前的会议室，并且点击关闭的时候关闭弹窗：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc351559c9f646ae83d4828e49c7138d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606&h=294&s=62449&e=png&b=1f1f1f)

```javascript
{
    currentMeetingRoom ? 
        <CreateBookingModal meetingRoom={currentMeetingRoom} isOpen={isCreateModalOpen} handleClose={() => {
            setIsCreateModalOpen(false);
        }}></CreateBookingModal>
    : null
}
```

没啥问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/787ac7eaea2d44a4884ad4aa09022f1b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2058&h=1128&s=2202931&e=gif&f=69&b=fdfdfd)


然后在 interface.ts 添加用到的接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbc7c06400174b0a80ff8f076d4da6ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=890&s=96887&e=png&b=fcfcfc)

```javascript
export async function bookingAdd(booking: CreateBooking) {
    const rangeStartDateStr = dayjs(booking.rangeStartDate).format('YYYY-MM-DD');
    const rangeStartTimeStr = dayjs(booking.rangeStartTime).format('HH:mm');
    const startTime = dayjs(rangeStartDateStr + ' ' + rangeStartTimeStr).valueOf()

    const rangeEndDateStr = dayjs(booking.rangeEndDate).format('YYYY-MM-DD');
    const rangeEndTimeStr = dayjs(booking.rangeEndTime).format('HH:mm');
    const endTime = dayjs(rangeEndDateStr + ' ' + rangeEndTimeStr).valueOf()

    return await axiosInstance.post('/booking/add', {
        meetingRoomId: booking.meetingRoomId,
        startTime,
        endTime,
        note: booking.note            
    });
}
```
这里需要把日期时间做合并。

然后在组件里调用下：
```javascript
const handleOk = async function() {
    const values = form.getFieldsValue();
    values.meetingRoomId = props.meetingRoom.id;

    const res = await bookingAdd(values);

    if(res.status === 201 || res.status === 200) {
        message.success('预定成功');
        form.resetFields();
        props.handleClose();
    } else {
        message.error(res.data.data);
    }
}
```
没啥问题：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b24c0df2a973408cbacdc3ac389be261~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1866&h=1204&s=423594&e=gif&f=33&b=808080)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a7e98af7a04241a198881d232da89e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2602&h=810&s=314162&e=png&b=fefefe)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6106641ee4e443eca6d7e76a89f65fd5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1866&h=1204&s=423594&e=gif&f=33&b=808080)

这样，预定、预订历史、取消预订就都完成了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_user)

## 总结

这节我们完成了预订历史、添加预定、取消预订的功能。

就是涉及到时间日期需要两个表单做合并处理，其余的倒是没啥难度。

至此，预订管理模块就完成了。




## 118.会议室预订系统：统计管理模块-后端开发

写完用户模块、会议室模块、预定模块之后，就只剩下统计模块了，这节我们就来写下这个模块。

这个模块只有 2 个统计的功能：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad9645b6ba914e35a7adece8551676cd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=652&h=252&s=37584&e=png&b=ffffff)

分别是统计会议室的使用频率、用户的预定频率：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0df7c49dbb84b33a6589816a68e619a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e83c09ddcd54e2a997f083784154baa~tplv-k3u1fbpfcp-watermark.image?)

没有新的实体，只是对已有数据的统计。

在 [echarts 官网](https://echarts.apache.org/handbook/zh/how-to/chart-types/bar/basic-bar)可以看到柱形图和饼图都只需要一个二维的数据，也就是 [[a, b], [a, b], [a, b]] 这样的形式的数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/867f6fc03c094a059bce82f8b0003d3b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1662&h=1098&s=94292&e=png&b=283237)


![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f51ef332d09464294d0bd001b15383f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1544&h=1338&s=108806&e=png&b=283237)

我们先在数据库里写下这个 sql：

```sql
select u.username 用户名, count(*) 预定次数
from booking b
left join users u
on b.userId = u.id
where b.startTime between '2023-09-24' and '2023-09-30'
group by b.userId;

```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c1dda931b1549069cef4838eb7cec21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1068&h=728&s=223590&e=png&b=fafafa)

关联 users 和 booking 表，过滤出在这段日期内的预定记录，根据用户分组，统计每组的预定数量。

这样查询出来的就是这段时间内每个用户预定了多少次会议室。

同理，也可以很轻松的统计处会议室被预定的频率：

```sql
select m.name 会议室名字, count(*) 预定次数
from booking b
left join meeting_room m
on b.roomId = m.id
where b.startTime between '2023-09-24' and '2023-09-30'
group by b.roomId;
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/725717c6ab094fbf8d1bee6af1fd8b07~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1070&h=686&s=223232&e=png&b=fafafa)

把关联的表换成 meeting_room 就好了。

当然，现在的数据不是很多，我们添加一些数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beb02e7dd67c42c6bfcd4e1bb5aafd17~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1330&h=748&s=316611&e=png&b=efeeee)

直接通过 mysql workbench 的 copy row 和 paste row 快速复制一些数据就好了。

复制出来的数据要改下 id，以及其他一些信息。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d06eeed8c4ec4c6080a1958c266d4521~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1788&h=610&s=373166&e=png&b=f5f5f5)

我添加了 4 条数据，并且指定了不同的 userId 和 roomId，点击 apply 应用修改。

然后再跑下那两个统计 sql

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd1609fd5314b3b89e03d6546fdb479~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=738&s=226804&e=png&b=fafafa)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d56f91a310640c7a645d6072f8735a1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&h=724&s=215222&e=png&b=f9f9f9)

没啥问题。

接下来在 nest 里把这个统计 sql 实现就好了。

```
nest g module statistic
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/109321f3e3ac41048e63c553c170185f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=110&s=25163&e=png&b=191919)

生成一个新的 module。

```
nest g service statistic
nest g controller statistic
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/004d17b0362542539f708ca907fad1ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=860&h=224&s=59481&e=png&b=191919)

之后生成 controller 和 service。

然后在 service 里实现下上面两个统计。

```javascript
import { Injectable } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { Booking } from 'src/booking/entities/booking.entity';
import { User } from 'src/user/entities/user.entity';
import { EntityManager } from 'typeorm';

@Injectable()
export class StatisticService {

    @InjectEntityManager()
    private entityManager: EntityManager;

    async userBookingCount() {
        const res = await this.entityManager
            .createQueryBuilder(Booking, 'b')
            .select('u.id', '用户id')
            .addSelect('u.username', '用户名')
            .leftJoin(User, 'u', 'b.userId = u.id')
            .addSelect('count(1)', '预定次数')
            .where('b.startTime between :time1 and :time2', {
                time1: '2023-09-24', 
                time2: '2023-09-30'
            })
            .addGroupBy('b.user')
            .getRawMany();
        return res;
    }


    async meetingRoomUsedCount() {

    }
}
```
注入 entityManager 来查询。

统计相关的 sql 比较复杂，我们使用 queryBuilder 的 api。

queryBuilder 的 api 和写 sql 的体验差不多。

我们用 repl 的方式跑下试试：

```
npm run repl
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc0e0a67851842958b5ef76c51f1d10a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1570&h=408&s=99920&e=png&b=181818)

```javascript
await get(StatisticService).userBookingCount()
```

仔细观察下这个打印的 sql，其实和我们前面在 mysql workbench 里写的是一样的。

用 typeorm 的 query buidler 的 api 可以写各种 sql。

然后我们加上参数，并且改下别名：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/365cc744f1984df084fea382f5c06d26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=936&h=532&s=107383&e=png&b=1f1f1f)

```javascript
async userBookingCount(startTime: string, endTime: string) {
    const res = await this.entityManager
        .createQueryBuilder(Booking, 'b')
        .select('u.id', 'userId')
        .addSelect('u.username', 'username')
        .leftJoin(User, 'u', 'b.userId = u.id')
        .addSelect('count(1)', 'bookingCount')
        .where('b.startTime between :time1 and :time2', {
            time1: startTime, 
            time2: endTime
        })
        .addGroupBy('b.user')
        .getRawMany();
    return res;
}
```
再跑下：

```javascript
await get(StatisticService).userBookingCount('2023-09-23', '2023-09-30')
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59496b629abd45e786d048c2960d0cd9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1532&h=380&s=92898&e=png&b=181818)

没啥问题。

然后在 controller 里加个接口：

```javascript
import { Controller, Get, Inject, Query } from '@nestjs/common';
import { StatisticService } from './statistic.service';

@Controller('statistic')
export class StatisticController {

    @Inject(StatisticService)
    private statisticService: StatisticService;

    @Get('userBookingCount')
    async userBookignCount(@Query('startTime') startTime: string, @Query('endTime') endTime) {
        return this.statisticService.userBookingCount(startTime, endTime);
    }
}
```
把 repl 的模式停掉，重新跑服务：

```
npm run start:dev
```
用 postman 访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e80eff4384814de5bffa2d70142e39e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1206&h=1234&s=154841&e=png&b=fdfdfd)

```
http://localhost:3005/statistic/userBookingCount?startTime=2023-09-23&endTime=2023-09-30
```

可以看到，返回了这段时间的统计数据。

这样，加个 echarts 就可以实现饼图、柱形图了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f51ef332d09464294d0bd001b15383f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1544&h=1338&s=108806&e=png&b=283237)

然后，我们再写另一个接口。

和用户预定次数的统计差不多：

```javascript
async meetingRoomUsedCount(startTime: string, endTime: string) {
    const res = await this.entityManager
        .createQueryBuilder(Booking, 'b')
        .select('m.id', 'meetingRoomId')
        .addSelect('m.name', 'meetingRoomName')
        .leftJoin(MeetingRoom, 'm', 'b.roomId = m.id')
        .addSelect('count(1)', 'usedCount')
        .where('b.startTime between :time1 and :time2', {
            time1: startTime, 
            time2: endTime
        })
        .addGroupBy('b.roomId')
        .getRawMany();
    return res;
}
```
上面是 service 部分。

然后是 controller：

```javascript
@Get('meetingRoomUsedCount')
async meetingRoomUsedCount(@Query('startTime') startTime: string, @Query('endTime') endTime) {
    return this.statisticService.meetingRoomUsedCount(startTime, endTime);
}
```
postman 里测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/301ce91fc00d4f0696c3a9df6afb69d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1214&h=1286&s=162093&e=png&b=fdfdfd)

```
http://localhost:3005/statistic/meetingRoomUsedCount?startTime=2023-09-23&endTime=2023-09-30
```
也没啥问题，和我们在 mysql workbench 里自己写 sql 统计的结果一样。

这样，统计模块的后端部分就完成了。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们实现了统计模块的后端代码。

就两个统计 sql，我们先在 mysql workbench 里写了这个统计 sql，然后在 typeorm 里用 query builder 的方式实现。

query builder 的 api 和直接写 sql 差不多。

前端部分拿到统计的数据，就可以用 echarts 展示饼图或者柱形图了。



## 119.会议室预订系统：统计管理模块-前端开发

上节写了统计用的两个接口，这节来加一下 swagger 文档，然后写下前端部分。

这个接口有 2 个 query 参数，返回值是一个对象，所以这样写：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5624c518ca6a4ab2abbe6aa2caa349f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1496&h=1146&s=279944&e=png&b=1f1f1f)

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'startTime',
    type: String,
    description: '开始时间'
})
@ApiQuery({
    name: 'endTime',
    type: String,
    description: '结束时间'
})
@ApiResponse({
    status: HttpStatus.OK,
    type: UserBookignCount
})
```
涉及到的 vo 在 src/statistic/vo/UserBookignCount.vo.ts

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class UserBookignCount {

    @ApiProperty()
    userId: string;

    @ApiProperty()
    username: string;

    @ApiProperty()
    bookingCount: string;
}
```

访问下 http://localhost:3005/api-doc

可以看到这个接口的文档：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc291426918c4c8c9fc36fa457e2a349~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1192&h=1446&s=141310&e=png&b=eef4fa)

没啥问题。

然后添加另一个接口的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df8f0a9c36eb492c99a5457c1b0e53ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1404&h=704&s=135804&e=png&b=1f1f1f)

```javascript
@ApiBearerAuth()
@ApiQuery({
    name: 'startTime',
    type: String,
    description: '开始时间'
})
@ApiQuery({
    name: 'endTime',
    type: String,
    description: '结束时间'
})
@ApiResponse({
    status: HttpStatus.OK,
    type: MeetingRoomUsedCount
})
```
src/statistic/MeetingRoomUsedCount.vo.ts

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class MeetingRoomUsedCount {

    @ApiProperty()
    meetingRoomId: string;

    @ApiProperty()
    meetingRoomName: string;

    @ApiProperty()
    usedCount: string;
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee2de6a6bd654fd8a2b7f355d1f433aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1230&h=1432&s=143834&e=png&b=eef4fa)

然后再加个 @ApiTags 把这俩接口文档分成一组：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14cbe2e9d58a4f99a56279dffe060f3f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1136&h=928&s=212482&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ea48596bdec438d83099408c4647e8d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790&h=344&s=38018&e=png&b=f9f9f9)

这样，swagger 文档就完成了。

然后来写前端代码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b4da8015f294391b3954d09bce2ee10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1050&h=672&s=60291&e=png&b=fefefe)

统计的路由我们已经写过了，只要填内容就行。

原型图是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0df7c49dbb84b33a6589816a68e619a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e83c09ddcd54e2a997f083784154baa~tplv-k3u1fbpfcp-watermark.image?)

加个 antd 的 Form，然后再用 echarts 的图表展示下数据就好了。

先加下 form：

```javascript
import { Button, DatePicker, Form, Select } from "antd";
import "./statistics.css";

export function Statistics() {

    function getStatisticData(values: { startTime: string; endTime: string; }) {
        console.log(values);
    }

    return <div id="statistics-container">
        <div className="statistics-form">
            <Form
                onFinish={getStatisticData}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="开始日期" name="startTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="结束日期" name="endTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="图表类型" name="chartType" initialValue={"bar"}>
                    <Select>
                        <Select.Option value="pie">饼图</Select.Option>
                        <Select.Option value="bar">柱形图</Select.Option>
                    </Select>
                </Form.Item>

                <Form.Item>
                    <Button type="primary" htmlType="submit">
                        查询
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="statistics-chart">
            图表
        </div>
    </div>
}
```
css：

```css
#statistics-container {
    padding: 20px;
}
#statistics-container .statistics-form {
    margin-bottom: 40px;
}
#statistics-container .statistics-chart {
    width: 800px;
    height: 600px;
}
```

点击查询，会打印 form 的值：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43ed1fdde14491784d46ba90330a6eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1670&h=746&s=163197&e=png&b=fefefe)

然后安装 echarts：

```
npm install echarts --save
```

然后通过 useRef 拿到 dom 元素，再初始化下 echarts 的柱状图：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21c7978d25046baa7923415b0b10a84~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1352&h=1234&s=216224&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55153338166427cad63c4a81f518484~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1058&h=386&s=56361&e=png&b=1f1f1f)

```javascript
import { Button, DatePicker, Form, Select } from "antd";
import "./statistics.css";
import * as echarts from 'echarts';
import { useEffect, useRef } from "react";

export function Statistics() {

    const containerRef = useRef<HTMLDivElement>(null);

    function getStatisticData(values: { startTime: string; endTime: string; }) {
        console.log(values);
    }


    useEffect(() => {
        const myChart = echarts.init(containerRef.current);
        myChart.setOption({
            title: {
                text: 'ECharts 入门示例'
            },
            tooltip: {},
            xAxis: {
                data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
            },
            yAxis: {},
            series: [
                {
                    name: '销量',
                    type: 'bar',
                    data: [5, 20, 36, 10, 10, 20]
                }
            ]
        });
    }, []);

    return <div id="statistics-container">
        <div className="statistics-form">
            <Form
                onFinish={getStatisticData}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="开始日期" name="startTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="结束日期" name="endTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="图表类型" name="chartType" initialValue={"bar"}>
                    <Select>
                        <Select.Option value="pie">饼图</Select.Option>
                        <Select.Option value="bar">柱形图</Select.Option>
                    </Select>
                </Form.Item>

                <Form.Item>
                    <Button type="primary" htmlType="submit">
                        查询
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="statistics-chart" ref={containerRef}></div>
    </div>
}
```
这样 echarts 就成功引入了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/283d9d2235a94a5e925053b53dc1a572~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1876&h=1428&s=141212&e=png&b=ffffff)

然后我们加一下接口：

在 src/interface/interfaces.ts 里加一下：

```javascript
export async function meetingRoomUsedCount(startTime: string, endTime: string) {
    return await axiosInstance.get('/statistic/meetingRoomUsedCount', {
        params: {
            startTime,
            endTime
        }
    });
}

export async function userBookingCount(startTime: string, endTime: string) {
    return await axiosInstance.get('/statistic/userBookingCount', {
        params: {
            startTime,
            endTime
        }
    });
}
```
我们加一个 state 来存储返回的数据，然后点击查询的时候请求接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca37c9b8cc0b4030bccb8cea6c8f53f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1366&h=1216&s=297927&e=png&b=1f1f1f)

当数据变化的时候，渲染图表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c393f117d93430aadb585638d2877c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=1140&s=134857&e=png&b=1f1f1f)

```javascript
import { Button, DatePicker, Form, Select, message } from "antd";
import "./statistics.css";
import * as echarts from 'echarts';
import { useEffect, useRef, useState } from "react";
import { userBookingCount } from "../../interfaces/interfaces";
import dayjs from "dayjs";

interface UserBookingData {
    userId: string;
    username: string;
    bookingCount: string;
}
export function Statistics() {

    const [userBookingData, setUserBookingData] = useState<Array<UserBookingData>>();

    const containerRef = useRef<HTMLDivElement>(null);

    async function getStatisticData(values: { startTime: string; endTime: string; }) {

        const startTime = dayjs(values.startTime).format('YYYY-MM-DD');
        const endTime = dayjs(values.endTime).format('YYYY-MM-DD');

        const res = await userBookingCount(startTime, endTime);
        
        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            setUserBookingData(data);
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }
    }

    useEffect(() => {
        const myChart = echarts.init(containerRef.current);

        if(!userBookingData) {
            return;
        }
    
        myChart.setOption({
            title: {
                text: '用户预定情况'
            },
            tooltip: {},
            xAxis: {
                data: userBookingData?.map(item => item.username)
            },
            yAxis: {},
            series: [
                {
                    name: '预定次数',
                    type: 'bar',
                    data: userBookingData?.map(item => {
                        return {
                            name: item.username,
                            value: item.bookingCount
                        }
                    })
                }
            ]
        });
    }, [userBookingData]);

    return <div id="statistics-container">
        <div className="statistics-form">
            <Form
                onFinish={getStatisticData}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="开始日期" name="startTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="结束日期" name="endTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="图表类型" name="chartType" initialValue={"bar"}>
                    <Select>
                        <Select.Option value="pie">饼图</Select.Option>
                        <Select.Option value="bar">柱形图</Select.Option>
                    </Select>
                </Form.Item>

                <Form.Item>
                    <Button type="primary" htmlType="submit">
                        查询
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="statistics-chart" ref={containerRef}></div>
    </div>
}
```
这样，点击查询的时候就会根据返回的数据渲染柱形图：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b118a65729a4d8485ad331c93015f21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1890&h=1464&s=139440&e=png&b=ffffff)

然后我们再加上饼图的部分：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5d56c3366d44c6ade673537d80cf02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=742&h=416&s=57784&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29d3c56e45464a88a11d5ef6149fda49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=1114&s=141511&e=png&b=1f1f1f)

这样，统计的图表就完成了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a162af31ba9846b98043d89106ef1d9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2102&h=1458&s=598705&e=gif&f=44&b=fefefe)

我们在下面再加一个会议室使用情况的图表。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a907dbf321584b8485ab8e88c876b9f5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1048&h=192&s=42998&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acbd23471ffa4adfa20c94b39f594d18~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1504&h=1312&s=355658&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10566b4ab89b4053ad344fc4e7c53c9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1150&h=1106&s=151394&e=png&b=1f1f1f)

过程一摸一样。

```javascript
import { Button, DatePicker, Form, Select, message } from "antd";
import "./statistics.css";
import * as echarts from 'echarts';
import { useEffect, useRef, useState } from "react";
import { meetingRoomUsedCount, userBookingCount } from "../../interfaces/interfaces";
import dayjs from "dayjs";
import { useForm } from "antd/es/form/Form";

interface UserBookingData {
    userId: string;
    username: string;
    bookingCount: string;
}
interface MeetingRoomUsedData {
    meetingRoomName: string;
    meetingRoomId: number;
    usedCount: string;
}

export function Statistics() {

    const [userBookingData, setUserBookingData] = useState<Array<UserBookingData>>();
    const [meetingRoomUsedData, setMeetingRoomUsedData] = useState<Array<MeetingRoomUsedData>>();

    const containerRef = useRef<HTMLDivElement>(null);
    const containerRef2 = useRef<HTMLDivElement>(null);

    async function getStatisticData(values: { startTime: string; endTime: string; }) {

        const startTime = dayjs(values.startTime).format('YYYY-MM-DD');
        const endTime = dayjs(values.endTime).format('YYYY-MM-DD');

        const res = await userBookingCount(startTime, endTime);
        
        const { data } = res.data;
        if(res.status === 201 || res.status === 200) {
            setUserBookingData(data);
        } else {
            message.error(data || '系统繁忙，请稍后再试');
        }

        const res2 = await meetingRoomUsedCount(startTime, endTime);
        
        const { data: data2 } = res2.data;
        if(res2.status === 201 || res2.status === 200) {
            setMeetingRoomUsedData(data2);
        } else {
            message.error(data2 || '系统繁忙，请稍后再试');
        }
    }

    useEffect(() => {
        const myChart = echarts.init(containerRef.current);

        if(!userBookingData) {
            return;
        }
    
        myChart.setOption({
            title: {
                text: '用户预定情况'
            },
            tooltip: {},
            xAxis: {
                data: userBookingData?.map(item => item.username)
            },
            yAxis: {},
            series: [
                {
                    name: '预定次数',
                    type: form.getFieldValue('chartType'),
                    data: userBookingData?.map(item => {
                        return {
                            name: item.username,
                            value: item.bookingCount
                        }
                    })
                }
            ]
        });
    }, [userBookingData]);

    useEffect(() => {
        const myChart = echarts.init(containerRef2.current);

        if(!meetingRoomUsedData) {
            return;
        }
    
        myChart.setOption({
            title: {
                text: '会议室使用情况'
            },
            tooltip: {},
            xAxis: {
                data: meetingRoomUsedData?.map(item => item.meetingRoomName)
            },
            yAxis: {},
            series: [
                {
                    name: '使用次数',
                    type: form.getFieldValue('chartType'),
                    data: meetingRoomUsedData?.map(item => {
                        return {
                            name: item.meetingRoomName,
                            value: item.usedCount
                        }
                    })
                }
            ]
        });
    }, [meetingRoomUsedData]);

    const [form] = useForm();

    return <div id="statistics-container">
        <div className="statistics-form">
            <Form
                form={form}
                onFinish={getStatisticData}
                name="search"
                layout='inline'
                colon={false}
            >
                <Form.Item label="开始日期" name="startTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="结束日期" name="endTime">
                    <DatePicker />
                </Form.Item>

                <Form.Item label="图表类型" name="chartType" initialValue={"bar"}>
                    <Select>
                        <Select.Option value="pie">饼图</Select.Option>
                        <Select.Option value="bar">柱形图</Select.Option>
                    </Select>
                </Form.Item>

                <Form.Item>
                    <Button type="primary" htmlType="submit">
                        查询
                    </Button>
                </Form.Item>
            </Form>
        </div>
        <div className="statistics-chart" ref={containerRef}></div>
        <div className="statistics-chart" ref={containerRef2}></div>
    </div>
}
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e58b11e720e04887b90311a4df5a4912~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1970&h=1438&s=1854764&e=gif&f=38&b=fdfdfd)

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们加了 swagger 文档并且写了统计管理模块的前端代码。

前端部分主要是 echarts 的图表，这个根据返回的数据调整下格式，然后设置到 echarts 的 options 就行。

至此，所有模块的钱后端代码就都完成了。


## 12.Nest 如何自定义装饰器

Nest 内置了很多装饰器，大多数功能都是通过装饰器来使用的。

但当这些装饰器都不满足需求的时候，能不能自己开发呢？

装饰器比较多的时候，能不能把多个装饰器合并成一个呢？

自然是可以的。

很多内置装饰器我们都可以自己实现。

我们来试试看：

    nest new custom-decorator -p npm

创建个 nest 项目。

执行

    nest g decorator aaa --flat

创建个 decorator。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34a2f8ed60a3463dbfacdae8bc18db87~tplv-k3u1fbpfcp-watermark.image?)

这个装饰器就是自定义的装饰器。

之前我们是这样用的 @SetMetadata

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85dbbd4a45b4c5a8bcf7993164a8d2a~tplv-k3u1fbpfcp-watermark.image?)

然后加个 Guard 取出来做一些判断：

    nest g guard aaa --flat --no-spec

guard 里使用 reflector 来取 metadata：

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable } from 'rxjs';

@Injectable()
export class AaaGuard implements CanActivate {
  @Inject(Reflector)
  private reflector: Reflector;

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {

    console.log(this.reflector.get('aaa', context.getHandler()));

    return true;
  }
}
```
加到路由上：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f5dbc7b8aa46669f37d0663c2f4219~tplv-k3u1fbpfcp-watermark.image?)

把服务跑起来：

```
npm run start:dev
```
然后访问 http://localhost:3000 可以看到打印的 metadata

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b0dafaa775240379f7cdd3547f8c8bf~tplv-k3u1fbpfcp-watermark.image?)

但是不同 metadata 有不同的业务场景，有的是用于权限的，有的是用于其他场景的。

但现在都用 @SetMetadata 来设置太原始了。

这时候就可以这样封装一层：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7af839f85a644f0d9b534f316cdc8305~tplv-k3u1fbpfcp-watermark.image?)

装饰器就可以简化成这样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5596734fbcbc442f92d5b91c7ae98984~tplv-k3u1fbpfcp-watermark.image?)

还有，有没有觉得现在装饰器太多了，能不能合并成一个呢？

当然也是可以的。

这样写：

```javascript
import { applyDecorators, Get, UseGuards } from '@nestjs/common';
import { Aaa } from './aaa.decorator';
import { AaaGuard } from './aaa.guard';

export function Bbb(path, role) {
  return applyDecorators(
    Get(path),
    Aaa(role),
    UseGuards(AaaGuard)
  )
}
```

在自定义装饰器里通过 applyDecorators 调用其他装饰器。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f6aba8b0b4d46ceb3e8ce4ca699d136~tplv-k3u1fbpfcp-watermark.image?)

这三个 handler 的装饰器都是一样的效果。

这就是自定义方法装饰器。

此外，也可以自定义参数装饰器：

```javascript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const Ccc = createParamDecorator(
  (data: string, ctx: ExecutionContext) => {
    return 'ccc';
  },
);
```

先用用看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/049a351152e84649ac59ac1794270c09~tplv-k3u1fbpfcp-watermark.image?)

大家猜这个 c 参数的值是啥？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eca5013dd2a4353aa056f8cf6738b34~tplv-k3u1fbpfcp-watermark.image?)

没错，就是 ccc，也就是说参数装饰器的返回值就是参数的值。

回过头来看看这个装饰器：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1e24d56299b4fcc8016633dbaeb5f84~tplv-k3u1fbpfcp-watermark.image?)

data 很明显就是传入的参数，而 ExecutionContext 前面用过，可以取出 request、response 对象。

这样那些内置的 @Param、@Query、@Ip、@Headers 等装饰器，我们是不是能自己实现了呢？

我们来试试看：

```javascript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Request } from 'express';

export const MyHeaders = createParamDecorator(
  (key: string, ctx: ExecutionContext) => {
    const request: Request = ctx.switchToHttp().getRequest();
    return key ? request.headers[key.toLowerCase()] : request.headers;
  },
);
```

通过 ExecutionContext 取出 request 对象，然后调用 getHeader 方法取到 key 对应的请求头返回。

效果如下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06295629b23d4ce5a0f6b6266053e607~tplv-k3u1fbpfcp-watermark.image?)

分别通过内置的 @Headers 装饰器和我们自己实现的 @MyHeaders 装饰器来取请求头，结果是一样的。

再来实现下 @Query 装饰器：

```javascript
export const MyQuery = createParamDecorator(
    (key: string, ctx: ExecutionContext) => {
        const request: Request = ctx.switchToHttp().getRequest();
        return request.query[key];
    },
);
```

用一下试试看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/170ee0fa7c6e4b93925fe4ae529c0920~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eefd9211413d47ba88eb35460e5a97bb~tplv-k3u1fbpfcp-watermark.image?)

和内置的 Query 用起来一毛一样！

同理，其他内置参数装饰器我们也能自己实现。

而且这些装饰器和内置装饰器一样，可以使用 Pipe 做参数验证和转换：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff3a66af71ed46de86c271f18fe05b4f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01487cf59b00422f94731a9324394e59~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8deb7674a4324d15b62043305dbca6c5~tplv-k3u1fbpfcp-watermark.image?)

知道了如何自定义方法和参数的装饰器，那 class 的装饰器呢？

其实这个和方法装饰器的定义方式一样：

比如单个装饰器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9262db3b20574da3a40c8d30b88401e6~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fc1008f19e747ab8d1be64a1b504276~tplv-k3u1fbpfcp-watermark.image?)

可以看到自定义装饰器生效了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee94a6fa7bca460cb6a646bab2a5302e~tplv-k3u1fbpfcp-watermark.image?)

也可以通过 applyDecorators 组合多个装饰器：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae3041a6f8d74fa3aa193dee0f928818~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acbc270d31214cf0b70a159e2ee34426~tplv-k3u1fbpfcp-watermark.image?)

在 guard 里加一条打印：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e84006ac2134962b02300ed11c18430~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a472090a5a442aa4d999c99051bff9~tplv-k3u1fbpfcp-watermark.image?)

可以看到 metadata 也设置成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73a3a453c06c4510853ca290d76c5c08~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/custom-decorator)

## 总结

内置装饰器不够用的时候，或者想把多个装饰器合并成一个的时候，都可以自定义装饰器。

方法的装饰器就是传入参数，调用下别的装饰器就好了，比如对 @SetMetadata 的封装。

如果组合多个方法装饰器，可以使用 applyDecorators api。

class 装饰器和方法装饰器一样。

还可以通过 createParamDecorator 来创建参数装饰器，它能拿到 ExecutionContext，进而拿到 reqeust、response，可以实现很多内置装饰器的功能，比如 @Query、@Headers 等装饰器。

通过自定义方法和参数的装饰器，可以让 Nest 代码更加的灵活。


## 120.会议室预订系统：后端项目部署到阿里云

项目写完了，本地跑没啥问题，我们最终是要把它部署到服务器上，跑起来。

我们会用到 mysql、redis、nginx，它们是这样的关系：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe3aa0c61f374ccaa7f0d99750fc82e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1260&h=552&s=42643&e=png&b=fffefe)

前端代码由 nginx 托管，处理静态请求。

并且后端服务也会经过 nginx 做反向代理，这样可以做多个 Nest 服务的负载均衡。

Nginx、Mysql、Redis、Nest 服务等都是通过 docker 来跑。

当然，不用一个个的跑，可以通过 Docker Compose 把它们组合成一个整体，一起跑。

开发完之后，本地把代码 push 到 github、gitlab 等代码仓库。

之后服务器上把代码 pull 下来，然后用 docker compose 跑就行。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f000e3d6eb7419390b031e7dfbcadf1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1282&h=726&s=66116&e=png&b=fffefe)

有了 docker，根本不用考虑 mysql、redis、node 等在 linux 下怎么装，直接跑 docker 镜像就行。

是不是再次感受到了 docker 的好处？

此外，还有一点要注意，线上不能开启 typeorm 的 synchronize，这样代码一改就同步修改了表结构，容易导致数据丢失。

线上会用 migration 迁移来做。

详细的 migration 介绍看[这节](https://juejin.cn/book/7226988578700525605/section/7336184436872085531)。

我们一步步来做，首先，在本地用 docker compose 跑一下:

在后端项目的根目录添加 docker-compose.yml 文件：

```yml
version: '3.8'
services:
  nest-app:
    build:
      context: ./
      dockerfile: ./Dockerfile
    depends_on:
      - mysql-container
      - redis-container
    ports:
      - 3005:3005
    networks:
      - common-network
  mysql-container:
    image: mysql
    volumes:
      - /Users/guang/mysql-data:/var/lib/mysql
    environment:
      MYSQL_DATABASE: meeting_room_booking_system
      MYSQL_ROOT_PASSWORD: guang
    networks:
      - common-network
  redis-container:
    image: redis
    volumes:
      - /Users/guang/redis-data:/data
    networks:
      - common-network
networks:
  common-network:
    driver: bridge
```
有 3 个 docker 容器，nest-app、mysql-container、redis-container

nest-app 是通过 Dockerfile 构建出来的，暴露 3005 端口。

nest-app 依赖 redis-container 和 mysql-container

redis-container 指定挂载的 volume 数据卷，以及 MYSQL_DATABASE（自动创建的 database） 和 MYSQL_ROOT_PASSWORD（root 用户密码） 的环境变量

mysql-container 指定挂载的 volume 数据卷

然后这是三个容器放到同一个桥接网络里。

在根目录添加 Dockerfile：

```docker
FROM node:18.0-alpine3.14 as build-stage

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18.0-alpine3.14 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install --production

EXPOSE 3005

CMD ["node", "/app/main.js"]
```
Nest 如何写 Dockerfile [前面](https://juejin.cn/book/7226988578700525605/section/7236247409871814714)也讲过。

就是用多阶段构建，第一个镜像先复制 package.json，然后安装依赖。

之后执行 npm run build 生成 dist 目录。

接下来第二个镜像复制第一个镜像的 dist 目录和 package.json，然后执行  npm install 并且用 node 跑起来。

改下 .env 文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac5e45d0698c4c4fa875e3f1daaaaf82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=968&s=167617&e=png&b=1f1f1f)

把 localhost 改为 redis-container 和 mysql-container。

还要改一个地方：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1e38d5fd2f4d53aa30507d641d3118~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=844&s=146482&e=png&b=1f1f1f)

加载配置文件的目录要改成拼接 __dirname 和 .env 的路径。

```javascript
ConfigModule.forRoot({
  isGlobal: true,
  envFilePath: path.join(__dirname, '.env')
}),
```
因为 build 出来的代码没有 src 目录，是直接放在 dist 下的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e83d5c264db24c80bf53002843c71a9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=472&h=766&s=69916&e=png&b=191919)

加一下 .dockerignore，也就是不会被复制到容器内的文件

```ignore
node_modules/
.vscode/
.git/
```

接下来把它跑起来（最好把本地的 mysql 和 redis 容器停掉再跑）：

```
docker compose up
```

它会首先根据 Dockerfile 生成 nest-app 的镜像：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e31ab5319ee243cbbd2ddd7fe9d0b86b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1292&h=588&s=144301&e=png&b=181818)

然后分别跑 mysql-container 和 redis-container 容器：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/383d1f3ed26c44ae9cb09f3b152302eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1664&h=810&s=320500&e=png&b=191919)

最后可以看到 nest-app 也跑起来了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06405d52491744fdb36f96fd75c65339~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1700&h=878&s=398265&e=png&b=181818)

访问下接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24df2ea25df04a888e7a217764b0fadb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=680&h=324&s=33329&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1879e54c72049c68ab1ac091ef2f6ee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1122&h=1012&s=141972&e=png&b=fdfdfd)

可以看到，接口也是没问题的。

如果你改了 Dockerfile 或者 docker-compose.yml 想重新跑的话，需要先把之前的镜像和容器删掉再跑：

```
docker-compose down --rmi all
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1acfc6d3c6f9489486a71ef28a7dbf75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1376&h=274&s=80009&e=png&b=191919)

接下来把本地代码 push 到 gitlab 或者 github：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a2d0a7ac80e4a05806d7f54c133d3b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1648&h=488&s=140440&e=png&b=191919)

然后在服务器上把它拉下来跑下 docker compose up 就行了。

我们买个服务器：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bfd9524b6584e9e930b1fd144979915~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1700&h=794&s=790536&e=png&b=fbfbfb)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ce783f7dfdc4399b16efe446e60408c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2098&h=1248&s=259234&e=png&b=fefefe)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58b39e04ada347caa3cc1f520a41bfba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2162&h=858&s=156740&e=png&b=ffffff)

我选的是 1 核、1G 的买了一周，大家可以根据自己的需要买。

注意要勾选公网 ipv4 地址，不然访问不了公网。

之后进入控制台就可以看到这台服务器了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22358f10142542e6b251b89205552e7e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2298&h=792&s=191408&e=png&b=fefefe)

点击远程连接：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b9dafecb31a4a848f70ebcac6af1d23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1480&h=960&s=205326&e=png&b=fdfdfd)

点立即登录。

我们用 ssh 密钥的方式登录，这里需要一个密钥文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce5b3659cb96422eb888a39c5b9a3cfe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1868&h=1180&s=230897&e=png&b=333333)

在这里创建：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d5f5c552bbe4ce79ebc3598bdd5e196~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2008&h=1030&s=190407&e=png&b=fefefe)

创建完会自动下载密钥文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b2734a2081432db9660e4cd8fb99bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=612&h=248&s=26054&e=png&b=fcfcfc)

然后点击绑定密钥对，也就是用这个密钥来登录的服务器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fe54fb3206f4143855c2ab5b0ae32b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2240&h=1044&s=217121&e=png&b=fefafa)

这一步会重启服务器。

然后再次远程连接，就可以用这个密钥文件来登录了:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed6a8b042737473c9000caf9c232163e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1872&h=1192&s=2334830&e=gif&f=48&b=2a2a2a)

我们需要安装 git 和 docker，用 git 下载代码，然后用 docker compose 来跑代码。

安装 git：

```
yum install git -y
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df714fa30eb94418a6df4c4816e6fd71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1468&h=1076&s=305578&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbd0e48ddcad43da93c00d43d8ecf67b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668&h=132&s=30296&e=png&b=1f1f1f)

把 github 的代码下下来：

```
git clone 你自己的git仓库
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d69ef2e1c264972b439e5301e4b111c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1552&h=316&s=129403&e=png&b=1e1e1e)

进入项目目录，跑下 docker compose 就行：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74e559eee59e47899a64601c65743ce1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1142&h=328&s=126010&e=png&b=1e1e1e)

和我们本地跑一样。

我们安装下 docker：

怎么安装直接看[阿里云的文档](https://help.aliyun.com/zh/ecs/use-cases/deploy-and-use-docker-on-alibaba-cloud-linux-2-instances)就行。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4224141942048e88d1634528300844c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2590&h=698&s=342039&e=png&b=1e1e1e)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c37257d8e8bb4f7c811d9bcdf93532e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2416&h=1230&s=299825&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b70cec7e87049fd8080cdd3baf045f5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1334&h=170&s=51853&e=png&b=1e1e1e)

docker 安装好了，设置下开机启动，也是复制文档的命令就行：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffcf6b83e4794250b045f2f01a14c566~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1806&h=994&s=440130&e=png&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9d595720bbc420fb373fcc4b46d1da4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1880&h=658&s=415105&e=png&b=1f1f1f)

然后安装 docker compose，同样是直接复制：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ca9f018b434f96a44bf8d77f2ff86f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1852&h=854&s=162100&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22373952a3774c70a4a34fbcf79b1325~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1482&h=464&s=311827&e=png&b=1f1f1f)

docker compose 安装好了，就把服务跑起来：

```
docker-compose up
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1f07127d1164798ac9f145dea870ea8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1686&h=1168&s=474119&e=png&b=1e1e1e)

会先 pull mysql 和 redis 的镜像，然后 build nest 的镜像。

之后就把服务跑起来了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36d84091c7f54b83a8bf0741d151d0f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2306&h=1218&s=1326175&e=png&b=1e1e1e)

过程中可以看到，会自动创建一系列的 table：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f0b84e6595d45f086b2245421fd8ec7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2098&h=976&s=819593&e=png&b=1f1f1f)

因为我们现在还没关掉 synchronize。

因为我们服务跑在 3005 端口，需要在安全组添加一下这个端口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d95ea9897ce4e5db0a7cc5c85a071be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2166&h=1038&s=189656&e=png&b=fefefe)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a620e94d576e47c691d95d4af7507788~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2380&h=880&s=181867&e=png&b=ffffff)

然后就可以用公网 ip 访问了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a55fe2e53e24b4a8915df102fc306fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1864&h=1216&s=250031&e=png&b=fefefe)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b432875abd474bf28681d98370a4a80e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=866&h=340&s=39432&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e3f9b20997f417a849ebe110e9ba6bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=752&h=720&s=76118&e=png&b=fbfbfb)

当然现在的初始化数据还没加，并且创建表也不是用的 migration，用 synchronize 不够安全，这些我们下节再继续搞。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

## 总结

这节我们完成了阿里云的部署。

写了 docker-compose.yml 和 Nest 应用的 Dockerfile，在本地用 docker compose 跑没问题。

然后服务器上也是用同样的方式跑。

买了一台阿里云服务器，安装 git 来下载项目代码，然后安装 docker compose 把服务跑起来就行了。

部署成功之后，我们的服务就可以在世界各地访问了。


## 121.会议室预订系统：前端项目部署到阿里云

上节把后端项目部署到了阿里云，可以在任意电脑上访问。

这节来部署下前端项目。

项目跑起来是这样的架构：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe3aa0c61f374ccaa7f0d99750fc82e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1260&h=552&s=42643&e=png&b=fffefe)

在之前 docker compose 的基础上加上 nginx 容器就好了。

我们进入 frontend-admin 项目，加一下 nginx 配置文件：

```
upstream nest-server {
    server 192.168.31.56:3005;
}

server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    location ^~ /api {
        rewrite ^/api/(.*)$ /$1 break;
        proxy_pass http://nest-server;
    }

    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
```

nginx 的两个核心功能就是静态资源托管、反向代理。

我们配置了 /api 下的请求走反向代理，转发请求到 nest 服务。

/ 下的静态资源请求返回 index.html。

这里的 ip 是我宿主机的，你可以换成你本地的。

用 nginx 做了反向代理之后，访问的 url 要改一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/621be561851949bd9c07ac735a699bde~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=550&s=166009&e=png&b=1d1d1d)

不再是直接访问 nest 服务了，而是通过 nginx 反向代理到 nest 服务。

然后加一下 Dockerfile

```docker
# build stage
FROM node:18 as build-stage

WORKDIR /app

COPY package.json ./

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM nginx:stable as production-stage

COPY --from=build-stage /app/build /usr/share/nginx/html

COPY --from=build-stage /app/nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```
用多阶段构建，第一个阶段把代码复制到容器，执行 npm run build，第二个阶段把上个阶段的产物还有 nginx 配置文件复制过来，把 nginx 服务跑起来。

这里的 CMD 启动命令看别的 nginx 镜像的启动命令就行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0fce8c6aca94250899340fa45c069c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=1276&s=177253&e=png&b=f3f3f7)

加一下 .dockerignore

```
node_modules/
.vscode/
.git/
build/
```

然后 build 下镜像：

```
docker build -t fe-container:first .
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9b27429cc344a258dd2a83442d6db9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1626&h=806&s=268987&e=png&b=181818)

然后在 docker desktop 里搜索这个镜像，点击 run：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6167efa4feb4f738ae72ba91db5dfc6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2308&h=1042&s=204366&e=png&b=f7f7f8)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf5b00d55e8469dadd5096bcfa42dee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=1364&s=125064&e=png&b=ffffff)

进入 backend 项目，把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33bb2f5fefef49b9a2cae6934e5979dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672&h=1248&s=513213&e=png&b=1c1c1c)

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e24368e41b340e1877680f710b7c01b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2608&h=1272&s=246696&e=png&b=fefefe)

界面正常渲染，访问接口的 url 也换成了 nginx 的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95611b2b70e34ba1954be289b8b1fcea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1618&h=426&s=184498&e=png&b=ffffff)

接口也正常返回了数据。

说明 nginx 的反向代理和静态资源托管都成功了。

但是，当你切换到修改信息界面，会跳到 /login 的 url，这时候返回了 404:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b888a4b61905461ca85582a9c25e11a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1344&h=586&s=41299&e=png&b=ffffff)

因为我们用的是 browser 路由，也就是 /xxx 的方式，而不是 hash 路由，也就是 ?#/xxx 的方式。

需要在 nginx 里面支持下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/054e32cc4f8440b982d0512449c3d370~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=780&h=464&s=66113&e=png&b=1f1f1f)

```
location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
}
```
加上这条 try_files，当访问 /login 的时候会先匹配 /login 然后是 /login/ 然后是 /index.html

这样就交给了前端页面来处理 /login 路由。

重新 build 一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cef01f83e8f74fb9a8e57833d4ff6a30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1604&h=762&s=258599&e=png&b=181818)

把之前的 container 停止、删除，然后重新跑。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8a294530e434b4b88021fa660d51417~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1898&h=664&s=202480&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d99d6b2d75f748e48d7cf92399da0769~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1206&h=1354&s=119900&e=png&b=ffffff)

现在你就会发现所有的路由都能正常访问了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51d0565a0def487bbc8d8eaa9c6b0fea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2574&h=1258&s=248376&e=png&b=fefefe)


![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95990c5b7d9f4852b32dca75b5a91845~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2026&h=974&s=83767&e=png&b=ffffff)

当然，我们现在是单独跑的 nginx 的容器，而且反向代理 nest 服务时用的是 ip。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/161f113a3bcd43bfad05f70f3714f18c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=718&h=520&s=67717&e=png&b=1f1f1f)

这样肯定是不好的。

我们希望可以把它也放到 docker-compose.yml 的配置文件里。

直接 docker compose up 一起跑。

我们知道，docker compose 跑的多个容器之间可以通过容器名相互访问。

改一下 nginx 配置，把 ip 换成 nest 服务的容器名：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0edda2a787c74d738cefb5007a2f7f10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=636&h=340&s=40325&e=png&b=202020)

重新 build：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f71ec7cab5f74943bfde11d30db7fc80~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1632&h=820&s=279674&e=png&b=181818)

然后在 backend 项目的 docker-compose.yml 里配置下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e7660af084e449a9de58da7942369a4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=694&h=638&s=77388&e=png&b=1f1f1f)

```yml
version: '3.8'
services:
  fe-app:
    image: fe-container:first
    ports:
      - 80:80
    depends_on:
      - nest-app
    networks:
      - common-network
  nest-app:
    build:
      context: ./
      dockerfile: ./Dockerfile
    depends_on:
      - mysql-container
      - redis-container
    networks:
      - common-network
  mysql-container:
    image: mysql
    volumes:
      - /Users/guang/mysql-data:/var/lib/mysql
    environment:
      MYSQL_DATABASE: meeting_room_booking_system
      MYSQL_ROOT_PASSWORD: guang
    networks:
      - common-network
  redis-container:
    image: redis
    volumes:
      - /Users/guang/redis-data:/data
    networks:
      - common-network
networks:
  common-network:
    driver: bridge
```
把 env 里的 url 改回来：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15864c560b0940f5ba5d5b8cfbf41378~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894&h=672&s=123224&e=png&b=1f1f1f)

然后跑一下（最好把本地的其他 mysql 和 redis 容器停掉再跑）：

```
docker-compose up
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66a2239f5b234fe2873646015fc33ad1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1864&h=860&s=364397&e=png&b=181818)

跑起来之后，浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f86b50f3e224418b2a2e109cc6b0017~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2626&h=1282&s=252051&e=png&b=fefefe)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c80918852034d28ab88e98f56a35432~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1992&h=842&s=71017&e=png&b=ffffff)

这样，我们就通过 docker compose 一次性跑了 nest、nginx 还有 mysql 和 redis 服务。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23a789fa4abb43d7b4895b6ec47e7be0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1258&h=916&s=137538&e=png&b=f9f9fa)

但是 fe-container 这个镜像只存在于本地，在阿里云跑 docker compose 的话会找不到这个镜像。

所以我们需要这个镜像上传到阿里云的镜像仓库。

阿里云的[容器镜像服务](https://www.aliyun.com/product/acr)个人用是免费的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfcd0403a56e44e48a618fcaa982f049~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1718&h=736&s=232247&e=png&b=fbfbfb)

进入管理控制台：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a2a7f739d114be9a8ea049937c4139e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1542&h=894&s=115904&e=png&b=fefefe)

点击创建镜像仓库。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e717e7250b34aeab807bf33622c31db~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1736&h=1406&s=145462&e=png&b=fefefe)

它会让你先创建命名空间。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70457195066243e4b27c2323ff03a57a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1676&h=1366&s=131558&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec19a3a9e68b4ef3adcd8de242c7d288~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1732&h=820&s=94486&e=png&b=fefefe)

直接说明了如何登陆阿里云镜像仓库和 push 镜像上去：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87fdc280d06c441f8865c5c4ffd99a7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1542&h=1150&s=221715&e=png&b=fefefe)

我们在本地 build 下镜像。

复制下你买的服务器的公网 ip：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaff78c36d9944f9a606d7fe58e7277a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2554&h=826&s=236303&e=png&b=fefefe)

改一下项目里的 baseURL，改成服务器的 ip：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a86c605329c54475a1a8323f84727ded~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1434&h=616&s=221687&e=png&b=1d1d1d)

然后 build 出镜像：
```
docker build -t fe-container:first .
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc3e2d675d05452a8c9b1d07077fca87~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1644&h=834&s=261009&e=png&b=181818)

然后分别执行 docker login、docker tag、docker push 把镜像 push 到镜像仓库（直接复制命令就行）：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3106710a454c4815a4f96b6a7ee2f55d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1768&h=1408&s=266343&e=png&b=fefefe)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4a36fd45e7c4b74b018b505de0a61ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1834&h=606&s=145423&e=png&b=181818)

上传之后，点击镜像版本就可以看到这个版本号的镜像：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f08e75ce7b64b69abd4a7a906b73257~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1640&h=860&s=124003&e=png&b=fefefe)

然后改一下 backend 项目里的 docker-compose.yml 文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ff94da2ba5a47c29b5a40b58f80a6fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1140&h=592&s=84815&e=png&b=1f1f1f)

image 改成阿里云镜像仓库里的。

接下来我们在服务器上把它跑起来就行。

保存代码，然后 git push 到代码仓库：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6902c3ea29a44cdbaf0c8852b8c7e3f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&h=532&s=127114&e=png&b=191919)

然后登录服务器，把最新代码 clone 下来（如果你clone 过了，只要 git pull 就行）。

然后跑一下：

```
docker login --username=用户名 registry.cn-qingdao.aliyuncs.com
 
docker-compose up
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08fbf9608fc04ef08d8b6d784bfd050b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2076&h=602&s=300407&e=png&b=1e1e1e)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ef6499431014157bc32f7b6ab63401e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2168&h=1208&s=1280365&e=png&b=1e1e1e)

之后在安全组添加 80 端口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7210168f32e9486590c99aa6c959572c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2066&h=580&s=126076&e=png&b=ffffff)

但是这时你用 ip 访问，会发现没返回东西：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/964a98d35d61489d99421f77c1043213~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1538&h=838&s=67980&e=png&b=ffffff)

为什么呢？

往上翻一下日志，可能会有这个报错：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d02af888ef8b4f4cab1bd9a0972b7778~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2464&h=332&s=251741&e=png&b=1e1e1e)

说是 docker 镜像的 platform 不匹配。

因为我本地是 m1 芯片的 mac ，build 出来的镜像在 linux 上跑不了。

当然，你不一定遇到这个问题，如果没遇到这个问题下面的步骤可以跳过。

如果遇到这个问题，那就需要 build 的时候加上 platform 了：

```
docker build -t fe-container:first --platform linux/amd64 .
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f0ae4064bd43d7a17d0c52cf38e62c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1414&h=758&s=245246&e=png&b=181818)

我重新 build 了一下镜像，指定了目标 platform。

然后重新 docker login、docker tag、docker push 来上传镜像：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59ce6659873f46ddaca6de6096db4f5e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1436&h=606&s=153083&e=png&b=191919)

上传之后在服务器把之前镜像删掉，重新跑：

```
docker-compose down --rmi all

docker login --username=用户名 registry.cn-qingdao.aliyuncs.com

docker-compose up
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47f5e850848d41d6ac00e1abea3d456b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1628&h=878&s=350525&e=png&b=1e1e1e)

这时浏览器就可以看到页面正常渲染了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/131478553ffc4561853d6fa2f0266432~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2306&h=888&s=132535&e=png&b=fefefe)

如果你没遇到 platform 的问题，那直接就可以在浏览器看到结果。

请求的 url 也是对的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46a10f04fdd845e98870a70a3d6d9323~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1844&h=1020&s=190943&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d2bed0ed89d4355b1a5dfc9a0c8ebee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1520&h=1038&s=166348&e=png&b=fefefe)

只是现在没有数据，后面加一下初始数据就好了。

这样，我们前端部分也部署完成了。

代码在小册仓库：

[backend](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_backend)。

[frontend-admin](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/meeting_room_booking_system_frontend_admin)。

## 总结

我们通过 nginx 部署了前端项目，用它来做静态资源托管和 nest 服务的反向代理。

通过 Dockerfile 的多阶段构建，第一个阶段 npm run build 出产物，第二个阶段把产物和 nginx 配置文件复制过去跑 nginx 服务。

之后用 docker build 构建出镜像，把它上传到阿里云镜像仓库。

在另一边的 docker compose 配置文件里添加这个 nginx 的容器配置。

这样服务端那边就可以用 docker compose up 一次性跑起 nginx、nest、mysql、redis 等容器，前后端服务一键启动。

这就是 docker compose 的作用。

过程中如果遇到 platform 不一致的问题，那就 build 的时候指定下 platform 再上传就好了。

这样，我们就通过 docker-compose 把前后端项目都部署到了阿里云：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d3b6ac6adbd4ef792a32b6262dff434~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1260&h=552&s=39173&e=png&b=fffefe)


## 122.Nest 如何创建微服务？

前面我们写了很多 Http 服务了，这些服务都是单体架构的。

单体架构就是所有业务逻辑都在一个服务里实现。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830419e960a54d1ca4db3ac89ba420ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=774&h=794&e=png&b=ffffff)

这样有个问题：

项目越来越大之后，模块越来越多，代码会越来越难以维护。

并且因为代码都在一个项目里，不好扩展。比如有的业务模块想多部署几个节点就做不到，只能整体扩展。

所以就有了拆分的需求，把业务模块拆成单独的微服务：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1f870b65ea44fbfacd8cd06f0b909eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=956&e=png&b=ffffff)

拆分也很简单，就是把之前放在不同目录的业务模块放到不同的服务里，再加上通信就好了。

不过微服务和微服务之间一般不是用 http 来通信的。

为什么呢？

因为 http 的请求响应会携带大量的 header：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00bcd216b19845629c02485bae927a69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=676&h=604&e=png&b=fdfdfd)

这些增大了通信的开销。

所以服务和服务之间没必要用 http，直接用 tcp 就好了。

nest 里实现微服务以及之间的 tcp 通信也很简单，下面我们来写一下。

创建个 nest 项目:

```
nest new microservice-test-main
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/291d66159b534975baeb09f76b562a39~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=532&e=png&b=fefefe)

再创建一个：

```
nest new microservice-test-user
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f47abb372f4740839261ffacb846594e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=994&h=588&e=png&b=fefefe)

前面那个作为 http 服务向外提供接口，后面这个是微服务，提供 tcp 的微服务通信端口。

进入 microservice-test-user

安装微服务的包：

```
npm install @nestjs/microservices --save
```
然后修改下应用启动方式：

之前这个是启动 http 服务的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/588bf56a1a62431d9020fc793fca53a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=902&h=364&e=png&b=1f1f1f)

微服务不需要暴露 http 接口，只需要支持微服务的通信就行。

改成这样：

```javascript
import { NestFactory } from '@nestjs/core';
import { Transport, MicroserviceOptions } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<MicroserviceOptions>(
    AppModule,
    {
      transport: Transport.TCP,
      options: {
        port: 8888,
      },
    },
  );
  app.listen();
}
bootstrap();
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe23539083134470bcdd44d868eac8ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1208&h=652&e=png&b=1f1f1f)

这就是启动一个微服务，通信端口在 8888，用 TCP 方式通信。

然后暴露个方法出去。

这里暴露接口不再是 http 时的 @Get、@Post 了，而是这样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4959d5d420b45bc8ce25fbb01b88327~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=542&e=png&b=1f1f1f)

```javascript
@MessagePattern('sum')
sum(numArr: Array<number>): number {
    return numArr.reduce((total, item) => total + item, 0);
}
```
很容易理解，就是消息匹配什么模式，然后调用这个方法，处理参数，返回结果。

我们接收一个数字数组，返回所有数字的和。

这样，我们就创建了一个微服务：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edaa87f16aaa461997bf904fd64ed2ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=572&h=458&e=png&b=ffffff)

然后在 microservice-test-main 这个服务里连上它。

进入 microservice-test-main

安装微服务相关的包：

```
npm install @nestjs/microservices --save
```
然后做什么呢？

很明显，要引入连接微服务的客户端对不对？

在 AppModule 引入 ClientsModule 动态模块：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29b6d5cd83c244178e86108006c8acdc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1192&h=822&e=png&b=1f1f1f)

ClientsModule 的动态模块有 register、registerAsync 方法。

我们之前用过的 JwtModule 也是 register、registerAsync，这是动态模块的方法名规范。（忘记的同学回过头看下动态模块那一节）

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ClientsModule, Transport } from '@nestjs/microservices';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'USER_SERVICE',
        transport: Transport.TCP,
        options: {
          port: 8888,
        },
      },
    ])
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
这里的 register 参数是一个数组，也就是说你有多个微服务的时候，都依次写在这里就行。

引入了 ClientsModule 模块，就可以注入其中的 provider 来用了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02ba31dcf71449588cd7df3b8a874ac3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082&h=910&e=png&b=1f1f1f)

```javascript
@Inject('USER_SERVICE')
private userClient: ClientProxy;

@Get('sum')
calc(@Query('num') str) {
    const numArr = str.split(',').map((item) => parseInt(item));

    return this.userClient.send('sum', numArr);
}
```
注入的时候指定 token 为前面我们声明的微服务名字：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e58a073b00e497daa1e0cb3a537a0b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=558&e=png&b=1f1f1f)

注入的对象就是连接这个微服务的客户端代理：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de10892867af4b6e97f7f934055702eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=976&h=370&e=png&b=1f1f1f)

调用它的 send 方法，第一个是消息的名字，第二个是参数。

这里的 sum 就是微服务那边声明的这个消息，而参数就是那边声明的参数:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7896d30517534a8a9986768a181dfef7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1024&h=536&e=png&b=1f1f1f)

把两个服务都跑起来：

```
npm run start:dev
```
微服务那边跑起来的提示是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52b1145556dd45589d5cf58ebccb145e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1554&h=316&e=png&b=181818)

http 服务跑起来的提示是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9251c230e0264e398995fb1dc3b1d07a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1560&h=430&e=png&b=181818)

然后浏览器访问下 http://localhost:3000/sum?num=3,5,6：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6b9c6799b7f4ceb93c7e5d7d1d6a6ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=192&e=png&b=ffffff)

返回了 14，是 3 + 5 + 6 的结果。

浏览器把 3、5、6 的参数传递给 http 服务，然后它给微服务发送消息，把参数带过去，微服务计算后返回了 14 给 http 服务，它再返回给浏览器：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89612c96b2474f3c8b9af3a0ba4f3e37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=778&h=932&e=png&b=ffffff)

前面在微服务里是用 @MessagePattern 声明的要处理的消息。

如果并不需要返回消息的话，可以用 @EventPattern 声明：

比如我们在 microservice-test-user 的 AppController 再添加一个方法：

```javascript
@EventPattern('log')
log(str: string) {
    console.log(str);
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85528b826ed144309616f028e4f93cfa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1016&h=684&e=png&b=1f1f1f)

然后在 microservice-test-main 里调用下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8effb86985004bbc87be067de6ed951d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1132&h=594&e=png&b=1f1f1f)

```javascript
this.userClient.emit('log', '求和')
```

注意，如果那边是 @MessagePattern 声明的方法，这边要用 send 方法调用。而 @EventPattern 声明的方法，这边要用 emit 方法调用。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66403cbe75d44d02bf8507defcdf2142~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=188&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cb10001b3194bc6b91fab5838e826e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=390&e=png&b=181818)

可以看到，微服务收到了这边发送的消息，并打印了日志。

那微服务之间具体传输了什么消息呢？我们抓包看一下。

想抓 tcp 层的包需要用到 wireshark。

在 [wireshark 官网](https://www.wireshark.org/)下载安装包：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc7ab892b6114efe832d5f78b8275cbd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1796&h=1138&e=png&b=081121)

安装后把它跑起来：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3345ccfb87f644bf9be1b3b3c1da5869~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=292&h=290&e=png&b=971900)

选择 loopback 这个网卡，本地回环地址，可以抓到 localhost 的包：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/257aaa3fdf54410b9a232f5e9078997c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1214&h=876&e=png&b=f7f7f7)

输入过滤器 port 8888，也就是过滤 8888 端口的数据包。

然后回车就会进入抓包界面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a012fc36cbe14b5faa434c295ed8df6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1436&h=508&e=png&b=f2f2f2)

这时候再访问下 http://localhost:3000/sum?num=1,2,3

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbed16a791a1486681fcfe41cb5f648e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=756&h=228&e=png&b=ffffff)

可以看到抓到了几个 tcp 的包：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac9aaa51b434bbeaa18a143646a85fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1864&h=466&e=png&b=e6e5fe)

点开这几个 PSH 的包看一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc65f3e62714def9fa9003277e7b45e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1868&h=1032&e=png&b=f2f2f2)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d600605935147c4a981a5ac7e95b6d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1776&h=1064&e=png&b=f2f2f2)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13e697d4e0fd4ce1bb1545d3213c3de3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1780&h=1052&e=png&b=f2f2f2)

内容如下：

```
{"pattern": "log", "data": "求和"}
```
```
{"pattern": "sum", data: [1, 2, 3], "id": "3b4a92305a76109bf0e79"}
```
```
{"response": 6, "isDisposed": true, "id": "3b4a92305a76109bf0e79"}
```

前两个是主服务发送给微服务的，后面那个是微服务返回的。

从抓包我们可以得出结论：

- 微服务之间的 tcp 通信的消息格式是 json
- 如果是 message 的方式，需要两边各发送一个 tcp 包，也就是一问一答的方式
- 如果是 event 的方式，只需要客户端发送一个 tcp 的包

案例代码在小册仓库：

[microservice-test-main](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/microservice-test-main)

[microservice-test-user](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/microservice-test-user)

## 总结

之前我们一直写的都是单体的 http 服务，这样项目大了以后会难以维护和扩展。

这时候可以通过微服务的方式把业务逻辑拆分到不同的微服务里。

微服务之间通过 tcp 方式通信，在 nest 里需要用到 @nestjs/microservices 这个包。

微服务启动的时候不再调用 NestFactory.create 而是调用 NestFactory.createMicroservice 方法，指定 tcp 的端口。

然后另一个服务里通过 ClientsModule 来注入连接这个微服务的代理对象。

之后分别用 send、emit 方法来调用微服务的 @MessagePattern、@EventPattern 声明的方法。

这就是微服务的创建和通信方式。

我们还通过 wireshark 抓包分析了 tcp 通信的内容，发现微服务之间的通信是基于 json 的。

项目大了之后，为了维护和扩展方便，拆分微服务是很自然的事情。


## 123.Nest 的 Monorepo 和 Library

上节我们学习微服务时创建了 2 个 Nest 项目，如果微服务多了，可能会创建更多项目。

那问题来了，如果有 10 个微服务，我们就创建 10 个 Nest 项目的 git 仓库么？

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c50354b29bd43c1885e10f853e9a230~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1352&h=480&s=31451&e=png&b=c1e9ea)

那肯定不行，太难维护了。

这时候我们就需要 monorepo 了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485e2975f5c441239ff98ca55a304bbf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=568&h=692&s=30029&e=png&b=c1e9ea)

这样，同一个 git 仓库中存放多个 Nest 项目，外层叫做 workspace。

这样就算是 10 个微服务项目，也能在一个 Git 仓库里管理起来。

Nest 是支持这种 monorepo 的方式的，我们来试试看：

```
nest new monorepo-test
```
创建个 nest 项目

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/509055e23a7a4a5eb323b92e40372c50~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&h=676&s=155805&e=png&b=020202)

我们添加一个 aaa 的路由：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/887580bb9b3f4b93b48d7ff4a267852d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=968&h=804&s=130131&e=png&b=1f1f1f)

```javascript
@Get('aaa')
aaa() {
    return 'aaa';
}
```
改下端口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eab8edaa0b3a4e12a554d191c6e21797~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1032&h=452&s=87986&e=png&b=1f1f1f)

然后把它跑起来：

```
npm run start:dev
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/694d944758ca48748fb4660984b71db6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1894&h=460&s=167567&e=png&b=181818)

浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c54da729af0946fb998408f62b602cc9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=652&h=208&s=16627&e=png&b=ffffff)

没啥问题。

然后我们再添加一个 nest 项目：

```
nest g app app2
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49af249c6f764eca80243f8ec3eb4ae5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=846&s=211525&e=png&b=191919)

它删除了 src 和 test，并创建了 apps 目录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5bf48f685ce41ba88b6cd236aa31c11~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=572&h=482&s=42033&e=png&b=181818)

这里的 apps/monorepo-test 就是之前的 src、test 代码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7abba8b98d140ec9d16349c788194be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1436&h=888&s=214468&e=png&b=1d1d1d)

而 apps/app2 就是新创建的 nest 项目，或者叫 nest app。
 
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1699aa400b4ca6a60ba81968e6dac7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1448&h=736&s=185960&e=png&b=1d1d1d)

把之前的服务停掉，重新跑:

```
npm run start:dev
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22871a4e71754ce388ebf8ef9de2220d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1764&h=934&s=249914&e=png&b=191919)

可以看到，跑的还是之前的那个 nest 项目，只不过换成了 webpack 编译。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50e94a5238cb4e978b5bdc54e1f1bbe9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=658&h=198&s=17148&e=png&b=ffffff)

为什么同样都是 nest start --watch，换成 monorepo 的形式之后，还是跑之前项目呢？

答案在 nest-cli.json 里：

之前 nest-cli.json 是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b2b62687bf94d66a54460659ebd2e16~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1066&h=444&s=68057&e=png&b=1f1f1f)

现在变成了这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0c226e68b5d4186a862ad6069dbb268~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1304&h=1366&s=266063&e=png&b=1f1f1f)

projects 下保存着多个 nest 项目的信息，比如根目录、入口文件、src 目录、编译配置文件。

然后 sourceRoot 和 root 分别指向了默认项目的 src 目录和根目录。

所以跑 nest start 的时候，才会依然跑的是之前的项目。

很明显，如果想跑另一个项目，就要这样：

```
npm run start:dev app2
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06e37d79826d4bc8bbc75a5d5b69cc93~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1480&h=798&s=175902&e=png&b=181818)

比如我在 app2 添加一个 bbb 的路由：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2fb216793434186b534427ae0bf69c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1292&h=788&s=185951&e=png&b=1c1c1c)

```javascript
@Get('bbb')
bbb() {
    return 'bbb';
}
```
浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bdef33b72164fcbb17f4ad5533f85d4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=626&h=198&s=16754&e=png&b=ffffff)

这样，app2 的服务就跑起来了。

原理也很简单，就是 nest cli 会根据 app 名字去读取对应的 tscofnig 文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3503f74db06641a1a534a255b1ec8b48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1326&h=1106&s=213741&e=png&b=1f1f1f)

这就是 nest 的 monorepo。

项目多了以后，难免有一些公共代码，这种公共代码怎么复用呢？

这就涉及到 nest 的另一个特性了：library。

创建一个 library：

```
nest g lib lib1
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49b1d50449ef4d7ba1ac13e180afd7b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234&h=396&s=96189&e=png&b=191919)

它会让你指定一个前缀，这里用默认的 @app。

然后会生成 libs/lib1 目录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc85b2cfdb6e4d1780f5db6fc2a0e7fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1304&h=586&s=92926&e=png&b=1d1d1d)

在 src 下生成了 module、service 并把它们导出了。

还在 tsconfig.json 的 paths 下添加了对应的别名配置：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65e093fd914a45c293a7702ac5c744ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=676&s=97366&e=png&b=1f1f1f)

在 nest-cli.json 里也多了这样一个 projects 配置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6496bf51d674055aa2f8bc6d23da43a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1148&h=918&s=156978&e=png&b=1f1f1f)

我们在 LibService 添加一个 xxx 方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/401546a3c9aa451790c90113e5a4e690~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=866&h=510&s=60476&e=png&b=1f1f1f)

```javascript
xxx() {
    return 'xxx';
}
```
然后在 monorepo-test 的 app 里导入 Lib1Module：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae011985dee44305b102e2df75404b34~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1572&h=676&s=188533&e=png&b=1d1d1d)

在 controller 里注入 Lib1Service 并调用它的方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5357798f81f4fc7a7d3b914ec970133~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1614&h=786&s=210199&e=png&b=1d1d1d)

```javascript
@Inject(Lib1Service)
private lib : Lib1Service;

@Get('aaa')
aaa() {
    return 'aaa' + this.lib.xxx();
}
```
同样的方式，在 app2 里也导入并使用它：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0459887a4f5485a9083655ef5a3c2f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=666&s=197081&e=png&b=1d1d1d)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c668b077f1ec4b339f4d844fdfb457e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=950&s=266470&e=png&b=1d1d1d)

```javascript
@Inject(Lib1Service)
private lib : Lib1Service;

@Get('bbb')
bbb() {
    return 'bbb' + this.lib.xxx();
}
```
然后分别把两个服务跑起来：

```
npm run start:dev

npm run start:dev app2
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2378603a90cf476d8e7fbd41fd6f5846~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1364&h=698&s=155656&e=png&b=181818)


![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47663802877d4306b8c0436b485eb717~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1270&h=630&s=135041&e=png&b=181818)

浏览器访问下 http://localhost:3001/aaa 和 http://localhost:3000/bbb

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4d825a40b004fb1b3e07de876617bed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=626&h=222&s=17257&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ca530ffee57409182d3c8884282031d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=660&h=220&s=18192&e=png&b=ffffff)

可以看到，引入的 library 中的模块生效了。

如果你只是改 lib 下的代码，不想跑服务时，可以单独编译 lib 代码：

```
npm run start:dev lib1
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b60d9515ba641eaa083605031fa49bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=848&h=422&s=54784&e=png&b=181818)

nest 的 monorepo 和 libray 用起来都挺简单的。

还有个问题，现在 build 之后的代码是什么样的呢？

删掉 dist，然后执行：

```
npm run build
```
产生了一个 apps/monorepo-test/main.js，因为现在换成 webpack 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b54681678942495184bc6b12731006b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=868&s=208114&e=png&b=1b1b1b)

然后执行：

```
npm run build app2
```
现在就多了 apps/app2/main.js 
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feb447010568441fa69dac32862bb9b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1470&h=942&s=223794&e=png&b=1b1b1b)

lib1 也是同理：
```
npm run build lib1
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f6b7dc50f3e4b78b5c6a60c40afea46~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=888&s=219571&e=png&b=1b1b1b)

之所以 application 或者 library 都能知道输出目录在哪，是因为在 tsconfig.json 里配了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d60553e174cc469d871c315808c672f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=484&s=85117&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b142a8ce08414bd6a1de0dd1e8a1b167~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1116&h=460&s=79436&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dc1a1537d1a4d35a8ac79eb13f0ae29~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1012&h=458&s=74691&e=png&b=1f1f1f)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/monorepo-test)

## 总结

微服务项目可能会有很多个项目，为了方便管理，我们会使用 monorepo 的方式。

monorepo 就是在一个 git 仓库里管理多个项目。

nest cli 支持 monorepo，只要执行 nest g app xxx 就会把项目变为 monorepo 的，在 apps 下保存多个 nest 应用。

nest-cli.json 里配置了多个 projects 的信息，以及默认的 project。

npm run start:dev 或者 npm run build 可以加上应用名来编译对应的 app。

此外，多个项目可能有公共代码，这时候可以用 nest g lib xxx 创建 library。

library 保存在 libs 目录下，和 apps 一样可以有多个。

nest 会为 libs 创建别名，可以在其他 app 或者 lib 里用别名引入。

这就是 nest 里创建 monorepo 以及通过 library 复用代码的方式，用起来还是比较简单的。


## 124.用 Etcd 实现微服务配置中心和注册中心

微服务架构的系统都会有配置中心和注册中心。

为什么呢？

比如说配置中心：

系统中会有很多微服务，它们会有一些配置信息，比如环境变量、数据库连接信息等。

这些配置信息散落在各个服务中，以配置文件的形式存在。

这样你修改同样的配置需要去各个服务下改下配置文件，然后重启服务。

就很麻烦。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa6b5b10705a4be0a7f108b79847ac25~tplv-k3u1fbpfcp-watermark.image?)

如果有一个服务专门用来集中管理配置信息呢？

这样每个微服务都从这里拿配置，可以统一的修改，并且配置更改后也会通知各个微服务。

这个集中管理配置信息的服务就叫配置中心。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f6b92aa3e2648e3ba90bc7af6d7c9a5~tplv-k3u1fbpfcp-watermark.image?)

再就是注册中心：

微服务之间会相互依赖，共同完成业务逻辑的处理。

如果某个微服务挂掉了，那所有依赖它的服务就都不能工作了。

为了避免这种情况，我们会通过集群部署的方式，每种微服务部署若干个节点，并且还可能动态增加一些节点。

那么问题来了：

微服务 A 依赖了微服务 B，写代码的时候 B 只有 3 个节点，但跑起来以后，某个节点挂掉了，并且还新增了几个微服务 B 的节点。

这时候微服务 A 怎么知道微服务 B 有哪些节点可用呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fcd834120742ef941b28ca0e13f995~tplv-k3u1fbpfcp-watermark.image?)

答案也是需要一个单独的服务来管理，这个服务就是注册中心：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c180f988cb840288424905da566215b~tplv-k3u1fbpfcp-watermark.image?)

微服务在启动的时候，向注册中心注册，销毁的时候向注册中心注销，并且定时发心跳包来汇报自己的状态。

在查找其他微服务的时候，去注册中心查一下这个服务的所有节点信息，然后再选一个来用，这个叫做服务发现。

这样微服务就可以动态的增删节点而不影响其他微服务了。

微服务架构的后端系统中，都会有这两种服务。

下面是我网上找的几张微服务系统的架构图：

这个：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15609f623c0c44009df7d3284b7f9a7f~tplv-k3u1fbpfcp-watermark.image?)

这个：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2b768386dd2418cb5f2151192e5a4c3~tplv-k3u1fbpfcp-watermark.image?)

或者这个：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f770edc3fd2141529e3577b6c688a6c1~tplv-k3u1fbpfcp-watermark.image?)

可以看到，配置中心和注册中心是必备组件。

但是，虽然这是两种服务，功能确实很类似，完全可以在一个服务里实现。

可以做配置中心、注册中心的中间件还是挺多的，比如 nacos、apollo、etcd 等。

今天我们来学下 etcd 实现注册中心和配置中心。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941ab3dab7044dd18a5fe296914531f0~tplv-k3u1fbpfcp-watermark.image?)

它其实是一个 key-value 的存储服务。

k8s 就是用它来做的注册中心、配置中心：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f1d1abce9f145b7bd2701338ac460e6~tplv-k3u1fbpfcp-watermark.image?)

我们通过 docker 把它跑起来。

在 docker desktop 搜索 etcd 的镜像，点击 run:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3948e16896f0403ba70b11c338488925~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca10560779549cd872067dd5c82e3b5~tplv-k3u1fbpfcp-watermark.image?)

输入容器名，映射 2379 端口到容器内的 2379 端口，设置 ETCD_ROOT_PASSWORD 环境变量，也就是指定 root 的密码。

然后就可以看到 etcd server 的 docker 镜像成功跑起来了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1ad2cdd32684332b6c90a6d221f89f3~tplv-k3u1fbpfcp-watermark.image?)

它带了一个 etcdctl 的命令行工具，可以作为客户端和 etcd server 交互。

常用的命令有这么几个：

```
etcdctl put key value
etcdctl get key
etcdctl del key
etcdctl watch key
```

就是对 key value 的增删改查和 watch 变动，还是比较容易理解的。

但是现在执行命令要加上 --user、--password 的参数才可以：

```
etcdctl get --user=root --password=guang key
```
如果不想每次都指定用户名密码，可以设置环境变量：
```
export ETCDCTL_USER=root
export ETCDCTL_PASSWORD=guang
```
这里的 password 就是启动容器的时候指定的那个环境变量：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdc8e53306c64742b114c9a5e94d37d9~tplv-k3u1fbpfcp-watermark.image?)

我们设置几个 key：

```
etcdctl put /services/a xxxx
etcdctl put /services/b yyyy
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa05ba6afe5c4b07bb95887a12e2de7a~tplv-k3u1fbpfcp-watermark.image?)

之后可以 get 来查询他们的值：

```
etcdctl get /services/a
etcdctl get /services/b
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91b55706406044a39f3ea18a9aa63aa1~tplv-k3u1fbpfcp-watermark.image?)

也可以通过 --prefix 查询指定前缀的 key 的值：

```
etcdctl get --prefix /services 
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b429c8a9ace4b3893f01cb8d4f593ef~tplv-k3u1fbpfcp-watermark.image?)

删除也是可以单个删和指定前缀批量删：

```
etcdctl del /servcies/a
etcdctl del --prefix /services
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753a2c8bc2bd43d2960f6c4cfada005d~tplv-k3u1fbpfcp-watermark.image?)

这样的 key-value 用来存储 服务名-链接信息，那就是注册中心，用来存储配置信息，那就是配置中心。

我们在 node 里面连接下 etcd 服务试试看：

创建个项目：

```
mkdir etcd-test
cd etcd-test
npm init -y
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b3cb7782d694b108d0de0c775ec5d96~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=874&h=708&s=83915&e=png&b=000000)

安装 etcd 的包：
```
npm install --save etcd3
```

创建 index.js

使用 etcd 官方提供的 npm 包 etcd3:

```javascript
const { Etcd3 } = require('etcd3');
const client = new Etcd3({
    hosts: 'http://localhost:2379',
    auth: {
        username: 'root',
        password: 'guang'
    }
});
 
(async () => { 
  const services = await client.get('/services/a').string();
  console.log('service A:', services);

  const allServices = await client.getAll().prefix('/services').keys();
  console.log('all services:', allServices);
 
  const watcher = await client.watch().key('/services/a').create();
  watcher.on('put', (req) => {
    console.log('put', req.value.toString())
  })
  watcher.on('delete', (req) => {
    console.log('delete')
  })
})();
```
get、getAll、watch 这些 api 和 ectdctl 命令行差不多，很容易搞懂。

get(xx) 是查询某个 key 的值。

getAll().prefix(xx).keys() 是查询某个字符串开头的 key。

watch().key(xx).create 则是创建某个 key 的监听器，监听他的 put 和 delete 事件。

我们再 put 几个 key：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d316bf244a964ee2ba07db0cd3be564e~tplv-k3u1fbpfcp-watermark.image?)

```
etcdctl put /services/a xxx

etcdctl put /services/b yyy
```

然后执行上面的 node 脚本：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4da4735375374a7292f3bfaf577227b6~tplv-k3u1fbpfcp-watermark.image?)

确实取到了 etcd server 中的值。

然后在 etcdctl 里 put 修改下 /services/a 的值：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93065110d73e41a5be6c24872ce4d5c5~tplv-k3u1fbpfcp-watermark.image?)

```
etcdctl put /services/a zzz
```

在 node 脚本这里收到了通知：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/797ea9ce0a9344088876d94a3f5a3aaf~tplv-k3u1fbpfcp-watermark.image?)

再 del 试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/221cc28977014d5a990bf3875f1aeab1~tplv-k3u1fbpfcp-watermark.image?)
```
etcdctl del /services/a
```

也收到了通知：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92759c06e45e465eb0fbbcb6674160d7~tplv-k3u1fbpfcp-watermark.image?)

这样，在 node 里操作 etcd server 就跑通了。

然后我们封装下配置中心和注册中心的工具函数：

配置中心的实现比较简单，就是直接 put、get、del 对应的 key：

```javascript
// 保存配置
async function saveConfig(key, value) {
    await client.put(key).value(value);
}

// 读取配置
async function getConfig(key) {
    return await client.get(key).string();
}

// 删除配置
async function deleteConfig(key) {
    await client.delete().key(key);
}
```
使用起来也很简单；

```javascript
(async function main() {
    await saveConfig('config-key', 'config-value');
    const configValue = await getConfig('config-key');
    console.log('Config value:', configValue);
})();
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/211c869679104233b0332e188726c829~tplv-k3u1fbpfcp-watermark.image?)

你可以在这里存各种数据库连接信息、环境变量等各种配置。

然后是注册中心：

服务注册：

```javascript
// 服务注册
async function registerService(serviceName, instanceId, metadata) {
    const key = `/services/${serviceName}/${instanceId}`;
    const lease = client.lease(10);
    await lease.put(key).value(JSON.stringify(metadata));
    lease.on('lost', async () => {
        console.log('租约过期，重新注册...');
        await registerService(serviceName, instanceId, metadata);
    });
}
```
注册的时候我们按照 /services/服务名/实例id 的格式来指定 key。

也就是一个微服务可以有多个实例。

设置了租约 10s，这个就是过期时间的意思，然后过期会自动删除。

我们可以监听 lost 事件，在过期后自动续租。

当不再续租的时候，就代表这个服务挂掉了。

然后是服务发现：

```javascript
// 服务发现
async function discoverService(serviceName) {
    const instances = await client.getAll().prefix(`/services/${serviceName}`).strings();
    return Object.entries(instances).map(([key, value]) => JSON.parse(value));
}
```
服务发现就是查询 /services/服务名 下的所有实例，返回它的信息。

```javascript
// 监听服务变更
async function watchService(serviceName, callback) {
    const watcher = await client.watch().prefix(`/services/${serviceName}`).create();
    watcher .on('put', async event => {
        console.log('新的服务节点添加:', event.key.toString());
        callback(await discoverService(serviceName));
    }).on('delete', async event => {
        console.log('服务节点删除:', event.key.toString());
        callback(await discoverService(serviceName));
    });
}
```
通过 watch 监听 /services/服务名下所有实例的变动，包括添加节点、删除节点等，返回现在的可用节点。

我们来测试下：

```javascript
(async function main() {
    const serviceName = 'my_service';
    
    await registerService(serviceName, 'instance_1', { host: 'localhost', port:3000 });
    await registerService(serviceName, 'instance_2', { host: 'localhost', port:3002 });

    const instances = await discoverService(serviceName);
    console.log('所有服务节点:', instances);

    watchService(serviceName, updatedInstances => {
        console.log('服务节点有变动:', updatedInstances);
    });
})();
```

跑起来确实能获得服务的所有节点信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fb8d55626864779954044b428567303~tplv-k3u1fbpfcp-watermark.image?)

当在 etcdctl 里 del 一个服务节点的时候，这里也能收到通知：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b40e451ddd9647bcb64a099e8a860c9c~tplv-k3u1fbpfcp-watermark.image?)
```
etcdctl del /services/my_service/instance_2
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/106f53cf1a134802a417406ac3c789e9~tplv-k3u1fbpfcp-watermark.image?)

这样，我们就实现了服务注册、服务发现功能。

有的同学可能问了：redis 不也是 key-value 存储的么？为什么不用 redis 做配置中心和注册中心？

因为 redis 没法监听不存在的 key 的变化，而 etcd 可以，而配置信息很多都是动态添加的。

当然，还有很多别的原因，毕竟 redis 只是为了缓存设计的，不是专门的配置中心、注册中心的中间件。

专业的事情还是交给专业的中间件来干。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/etcd-test)

也在这里贴一份：

```javascript
const { Etcd3 } = require('etcd3');
const client = new Etcd3({
    hosts: 'http://localhost:2379',
    auth: {
        username: 'root',
        password: 'guang'
    }
});

// 保存配置
async function saveConfig(key, value) {
    await client.put(key).value(value);
}

// 读取配置
async function getConfig(key) {
    return await client.get(key).string();
}

// 删除配置
async function deleteConfig(key) {
    await client.delete().key(key);
}
   
// 服务注册
async function registerService(serviceName, instanceId, metadata) {
    const key = `/services/${serviceName}/${instanceId}`;
    const lease = client.lease(10);
    await lease.put(key).value(JSON.stringify(metadata));
    lease.on('lost', async () => {
        console.log('租约过期，重新注册...');
        await registerService(serviceName, instanceId, metadata);
    });
}

// 服务发现
async function discoverService(serviceName) {
    const instances = await client.getAll().prefix(`/services/${serviceName}`).strings();
    return Object.entries(instances).map(([key, value]) => JSON.parse(value));
}

// 监听服务变更
async function watchService(serviceName, callback) {
    const watcher = await client.watch().prefix(`/services/${serviceName}`).create();
    watcher.on('put', async event => {
        console.log('新的服务节点添加:', event.key.toString());
        callback(await discoverService(serviceName));
    }).on('delete', async event => {
        console.log('服务节点删除:', event.key.toString());
        callback(await discoverService(serviceName));
    });
}

// (async function main() {
//     await saveConfig('config-key', 'config-value');
//     const configValue = await getConfig('config-key');
//     console.log('Config value:', configValue);
// })();

(async function main() {
    const serviceName = 'my_service';
    
    await registerService(serviceName, 'instance_1', { host: 'localhost', port:3000 });
    await registerService(serviceName, 'instance_2', { host: 'localhost', port:3002 });

    const instances = await discoverService(serviceName);
    console.log('所有服务节点:', instances);

    watchService(serviceName, updatedInstances => {
        console.log('服务节点有变动:', updatedInstances);
    });
})();
```
## 总结

微服务架构的系统中少不了配置中心和注册中心。

不同服务的配置需要统一管理，并且在更新后通知所有的服务，所以需要配置中心。

微服务的节点可能动态的增加或者删除，依赖他的服务在调用之前需要知道有哪些实例可用，所以需要注册中心。

服务启动的时候注册到注册中心，并定时续租期，调用别的服务的时候，可以查一下有哪些服务实例可用，也就是服务注册、服务发现功能。

注册中心和配置中心可以用 etcd 来做，它就是一个专业做这件事的中间件，k8s 就是用的它来做的配置和服务注册中心。

我们用 docker 跑了 etcd server，它内置了命令行工具 etcdctl 可以用来和 server 交互。

常用的命令有 put、get、del、watch 等。

在 node 里可以通过 etcd3 这个包来操作 etcd server。

稍微封装一下就可以实现配置管理和服务注册、发现的功能。

在微服务架构的后端系统中，配置中心、注册中心是必不可少的组件，不管是 java、go 还是 Node.js。


## 125.Nest 集成 Etcd 做注册中心、配置中心

我们学了 etcd 来做配置中心和注册中心，它比较简单，就是 key 的 put、get、del、watch 这些。

虽然简单，它却是微服务体系必不可少的组件：
 
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6322f6ce49c4a678f7119cff32ef5d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=696&s=248707&e=png&b=fffeff)

服务注册、发现、配置集中管理，都是用它来做。

那 Nest 里怎么集成它呢？

其实和 Redis 差不多。

集成 Redis 的时候我们就是写了一个 provider 创建连接，然后注入到 service 里调用它的方法。

还可以像 TypeOrmModule、JwtModule 等这些，封装一个动态模块：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e9c2c3d18de473b9760326a22e4d877~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=836&h=768&s=140728&e=png&b=1f1f1f)

下面我们就来写一下：

```
nest new nest-etcd
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/277c8bd4717443fbbfb62a81c40c927c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=868&h=694&s=152075&e=png&b=010101)

进入项目，把服务跑起来：

```
npm run start:dev
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e994ec48ccf54b52bb25aa9bc4c931df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1602&h=388&s=119095&e=png&b=181818)

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68f1c3bd5cb94ce283f8353f51919e9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=622&h=222&s=17274&e=png&b=ffffff)

nest 服务跑起来了。

按照上节的步骤把 etcd 服务跑起来：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c208ffbf2ca14a4fbab8344e4cd95830~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2050&h=1216&s=386967&e=png&b=ffffff)

然后我们加一个 etcd 的 provider：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee264b363caf4bdcb8f107cee23e2f2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=950&h=944&s=138700&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { Etcd3 } from 'etcd3';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: 'ETCD_CLIENT',
      useFactory() {
        const client = new Etcd3({
            hosts: 'http://localhost:2379',
            auth: {
                username: 'root',
                password: 'guang'
            }
        });
        return client;
      }
    }
  ],
})
export class AppModule {}

```
在 AppController 里注入下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89499d3806904d369d4a246ce0814f10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1116&h=1088&s=196153&e=png&b=1f1f1f)

```javascript
import { Controller, Get, Inject, Query } from '@nestjs/common';
import { AppService } from './app.service';
import { Etcd3 } from 'etcd3';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Inject('ETCD_CLIENT')
  private etcdClient: Etcd3;

  @Get('put')
  async put(@Query('value') value: string) {
    await this.etcdClient.put('aaa').value(value);
    return 'done';
  }

  @Get('get')
  async get() {
    return await this.etcdClient.get('aaa').string();
  }

  @Get('del')
  async del() {
    await this.etcdClient.delete().key('aaa');
    return 'done';
  }
}
```

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc5558c78a87488f902c87b0b4f83d88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=754&h=190&s=19755&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cb5a2d707634d208ff32e490b9e4ee1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=190&s=17445&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ab42f19a2a4a5a86d5ae5b54b1e984~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=630&h=180&s=16336&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5139f23a6bd9481eafd8ae3d96055805~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=614&h=174&s=15476&e=png&b=ffffff)

这样 etcd 就集成好了，很简单。

然后我们封装一个动态模块。

创建一个 module 和 service：

```
nest g module etcd
nest g service etcd
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ce66ee48f84718b213e59ce3241b16~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=310&s=74417&e=png&b=191919)

在 EtcdModule 添加 etcd 的 provider：

```javascript
import { Module } from '@nestjs/common';
import { EtcdService } from './etcd.service';
import { Etcd3 } from 'etcd3';

@Module({
  providers: [
    EtcdService,
    {
      provide: 'ETCD_CLIENT',
      useFactory() {
        const client = new Etcd3({
            hosts: 'http://localhost:2379',
            auth: {
                username: 'root',
                password: 'guang'
            }
        });
        return client;
      }
    }
  ],
  exports: [
    EtcdService
  ]
})
export class EtcdModule {}
```
然后在 EtcdService 添加一些方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { Etcd3 } from 'etcd3';

@Injectable()
export class EtcdService {

    @Inject('ETCD_CLIENT')
    private client: Etcd3;

    // 保存配置
    async saveConfig(key, value) {
        await this.client.put(key).value(value);
    }

    // 读取配置
    async getConfig(key) {
        return await this.client.get(key).string();
    }

    // 删除配置
    async deleteConfig(key) {
        await this.client.delete().key(key);
    }
   
    // 服务注册
    async registerService(serviceName, instanceId, metadata) {
        const key = `/services/${serviceName}/${instanceId}`;
        const lease = this.client.lease(10);
        await lease.put(key).value(JSON.stringify(metadata));
        lease.on('lost', async () => {
            console.log('租约过期，重新注册...');
            await this.registerService(serviceName, instanceId, metadata);
        });
    }

    // 服务发现
    async discoverService(serviceName) {
        const instances = await this.client.getAll().prefix(`/services/${serviceName}`).strings();
        return Object.entries(instances).map(([key, value]) => JSON.parse(value));
    }

    // 监听服务变更
    async watchService(serviceName, callback) {
        const watcher = await this.client.watch().prefix(`/services/${serviceName}`).create();
        watcher.on('put', async event => {
            console.log('新的服务节点添加:', event.key.toString());
            callback(await this.discoverService(serviceName));
        }).on('delete', async event => {
            console.log('服务节点删除:', event.key.toString());
            callback(await this.discoverService(serviceName));
        });
    }

}
```
配置的管理、服务注册、服务发现、服务变更的监听，这些我们都写过一遍，就不细讲了。

然后再创建个模块，引入它试一下：
```
nest g resource aaa
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/775e971d6759492a984504d3a97a52c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=794&h=410&s=100568&e=png&b=191919)

引入 EtcdModule：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8427b98b647944fc8bfb3d2523bcc460~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=850&h=548&s=100368&e=png&b=1f1f1f)

然后在 AaaController 注入 EtcdService，添加两个 handler：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8acb83c8db4a41d3bb41f96cd389dfe9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1046&h=798&s=177018&e=png&b=1f1f1f)

```javascript
@Inject(EtcdService)
private etcdService: EtcdService;

@Get('save')
async saveConfig(@Query('value') value: string) {
    await this.etcdService.saveConfig('aaa', value);
    return 'done';
}

@Get('get')
async getConfig() {
    return await this.etcdService.getConfig('aaa');
}
```
测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58f96e3d52ef45d686a88801d6da1350~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=848&h=202&s=20615&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c323f4e4fdc4457901a7b3220f1f632~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=670&h=184&s=16756&e=png&b=ffffff)

没啥问题。

不过现在 EtcdModule 是普通的模块，我们改成动态模块：

```javascript
import { DynamicModule, Module, ModuleMetadata, Type } from '@nestjs/common';
import { EtcdService } from './etcd.service';
import { Etcd3, IOptions } from 'etcd3';

export const ETCD_CLIENT_TOKEN = 'ETCD_CLIENT';

export const ETCD_CLIENT_OPTIONS_TOKEN = 'ETCD_CLIENT_OPTIONS';

@Module({})
export class EtcdModule {

  static forRoot(options?: IOptions): DynamicModule {
    return {
      module: EtcdModule,
      providers: [
        EtcdService,
        {
          provide: ETCD_CLIENT_TOKEN,
          useFactory(options: IOptions) {
            const client = new Etcd3(options);
            return client;
          },
          inject: [ETCD_CLIENT_OPTIONS_TOKEN]
        },
        {
          provide: ETCD_CLIENT_OPTIONS_TOKEN,
          useValue: options
        }
      ],
      exports: [
        EtcdService
      ]
    };
  }
}
```
把 EtcdModule 改成动态模块的方式，加一个 forRoot 方法。

把传入的 options 作为一个 provider，然后再创建 etcd client 作为一个 provider。

然后 AaaModule 引入 EtcdModule 的方式也改下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dcdbf96285245e28eb0459535d97690~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=904&h=766&s=131351&e=png&b=1f1f1f)

用起来是一样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4590b470565548ae94ce34172aaf6278~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=192&s=16946&e=png&b=ffffff)

但是现在 etcd 的参数是动态传入的了，这就是动态模块的好处。

当然，一般动态模块都有 forRootAsync，我们也加一下：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a58a209fac1c4f4fab7c61c59995c41c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1210&h=638&s=126562&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1052f7899939435f86ba3733263b3663~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1308&h=1128&s=169282&e=png&b=1f1f1f)

```javascript
export interface EtcdModuleAsyncOptions  {
  useFactory?: (...args: any[]) => Promise<IOptions> | IOptions;
  inject?: any[];
}
```
```javascript
static forRootAsync(options: EtcdModuleAsyncOptions): DynamicModule {
    return {
      module: EtcdModule,
      providers: [
        EtcdService,
        {
          provide: ETCD_CLIENT_TOKEN,
          useFactory(options: IOptions) {
            const client = new Etcd3(options);
            return client;
          },
          inject: [ETCD_CLIENT_OPTIONS_TOKEN]
        },
        {
          provide: ETCD_CLIENT_OPTIONS_TOKEN,
          useFactory: options.useFactory,
          inject: options.inject || []
        }
      ],
      exports: [
        EtcdService
      ]
    };
}
```
和 forRoot 的区别就是现在的 options 的 provider 是通过 useFactory 的方式创建的，之前是直接传入。

现在就可以这样传入 options 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58eade20a864400bac7b82086e8e173f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=1052&s=148689&e=png&b=1f1f1f)

```javascript
EtcdModule.forRootAsync({
  async useFactory() {
      await 111;
      return {
          hosts: 'http://localhost:2379',
          auth: {
              username: 'root',
              password: 'guang'
          }
      }
  }
})
```

我们安装下 config 的包

```
npm install @nestjs/config
```
在 AppModule 引入 ConfigModule：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8686012ed5b482ab0d821d8f2a8fc18~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=682&s=127643&e=png&b=1f1f1f)

```javascript
ConfigModule.forRoot({
  isGlobal: true,
  envFilePath: 'src/.env'
})
```
添加对应的 src/.env

```env
etcd_hosts=http://localhost:2379
etcd_auth_username=root
etcd_auth_password=guang
```
然后在引入 EtcdModule 的时候，从 ConfigService 拿配置：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f9496d8f4a4de99d1c7c775f1fa77b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1220&h=790&s=141984&e=png&b=1f1f1f)

```javascript
EtcdModule.forRootAsync({
  async useFactory(configService: ConfigService) {
      await 111;
      return {
          hosts: configService.get('etcd_hosts'),
          auth: {
              username: configService.get('etcd_auth_username'),
              password: configService.get('etcd_auth_password')
          }
      }
  },
  inject: [ConfigService]
})
```
测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d740ced107e4353a7b310828cbde6c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=636&h=216&s=17078&e=png&b=ffffff)

功能正常。

这样，EtcdModule.forRootAsync 就成功实现了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-etcd)。
## 总结

这节我们做了 Nest 和 etcd 的集成。

或者加一个 provider 创建连接，然后直接注入 etcdClient 来 put、get、del、watch。

或者再做一步，封装一个动态模块来用，用的时候再传入连接配置 

和集成 Redis 的时候差不多。

注册中心和配置中心是微服务体系必不可少的组件，后面会大量用到。


## 126.基于 gRPC 实现跨语言的微服务通信

后端系统大多都是微服务的架构，而且还可能同时有多种语言实现的微服务，比如 java、go、python、c++、node 等。

那么问题来了，多种语言实现的微服务之间如何通信呢？

有的同学会说 http 不就行？

但 http 是文本传输，通信效率低。更重要的是这些微服务并不会提供 http 接口，因为它们又不是直接面向客户端的。

跨语言调用服务一般会用 gRPC，它是 google 出的一种跨语言的远程方法调用的方案。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8744e0820c3b4e55bb58cbf2d4224dec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=764&h=250&s=13642&e=png&b=ffffff)

其中，RPC 是 Remote Procedure Call，远程过程调用。

比如 java 微服务有个方法 aaa，node 微服务想调用它，就可以通过 gRPC 来实现。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/960c5ba9f121468489a373ba8df71872~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=344&s=16534&e=png&b=ffffff)

这节我们就来用一下 gRPC。

当然，我们不会真的创建 java 的微服务，而是会用两个 nest 的微服务之间实现 gRPC 通信。

在 java、phthon、go 等语言的微服务里，接入 gRPC 都是类似的。

我们创建个 nest 项目：

```
nest new grpc-client
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/465121afc9454f7987fdba406856e69c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=674&s=255412&e=png&b=010101)

我们用 monorepo 的形式来放 client 和 server 的代码。

执行：
```
nest g app grpc-server
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93202f1629dc4df093718fbe7e14b23b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1032&h=630&s=173185&e=png&b=191919)

这样，就有了两个 nest 的 application：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a0baac2ec35411eb79810b56e45a47b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=372&h=280&s=21852&e=png&b=1c1c1c)

改下 grpc-server 的启动端口号为 3001:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4e9eb098344ce4b9f9232baa9cdb76~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1090&h=520&s=117192&e=png&b=1c1c1c)

分别把两个 nest 应用跑起来：

```
npm run start:dev grpc-client

npm run start:dev grpc-server
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd8725a610614134afcced48055da1d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=900&h=468&s=107964&e=png&b=181818)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/889173b7f3cc4bec81783fba5d343191~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=906&h=456&s=105741&e=png&b=181818)

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e716b0a98d24a8fa3e62afc3ff4eb61~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=570&h=198&s=16375&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3c63728610e4df2aa29e20643bf1e57~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=502&h=178&s=15931&e=png&b=ffffff)

这就代表两个 nest 应用都跑起来了。

然后我们把 grpc-server 改造成 grpc 的微服务。

安装用到的微服务的包：

```
npm install --save @nestjs/microservices
```

grpc 的包：

```
npm install --save @grpc/grpc-js @grpc/proto-loader
```

修改下 grpc-server 的 main.ts

```javascript
import { NestFactory } from '@nestjs/core';
import { GrpcOptions, Transport } from '@nestjs/microservices';
import { GrpcServerModule } from './grpc-server.module';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<GrpcOptions>(GrpcServerModule, {
    transport: Transport.GRPC,
    options: {
      url: 'localhost:8888',
      package: 'book',
      protoPath: join(__dirname, 'book/book.proto'),
    },
  });

  await app.listen();
}
bootstrap();

```
和我们前面创建微服务的方式一样，只不过传输方式 transport 改为 GRPC，然后指定微服务监听端口为 8888。

然后在 options 指定 protoPath。

在 src 下创建这个对应的文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbcc2da7c11a4e119577af90d2bf6b63~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1360&h=696&s=148820&e=png&b=1d1d1d)

```javascript
syntax = "proto3";

package book;

service BookService {
  rpc FindBook (BookById) returns (Book) {}
}

message BookById {
  int32 id = 1;
}

message Book {
  int32 id = 1;
  string name = 2;
  string desc = 3;
}
```
这是一种叫做 protocol buffer 的语法。

我们安装个语法高亮插件 

搜索 ext:proto，也就是处理 .proto 文件的插件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1bb01f9717a4d9d99cd4f3ba088714e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=742&h=256&s=33645&e=png&b=37373c)

安装之后就有语法高亮了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5685d36ce8794e9aa692c51d6d42262e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=672&s=84683&e=png&b=1f1f1f)

为什么要有一种 protocol buffer 的语法呢？

因为要跨语言通信，不同语言的语法又不一样，那怎么通信呢？

定义一种用于通信的语言，各种语言都支持这种语法的解析不就行了？

这就是为什么会有 protocol buffer。

这些语法也很容易看懂：

```
syntax = "proto3"
```
是使用 proto3 版本的语法。

```
package book;
```
是当前包为 book，也就是一种命名空间。

```
service BookService {
  rpc FindBook (BookById) returns (Book) {}
}
```
这个就是定义当前服务可以远程调用的方法。

有一个 FindBook 方法，参数是 BookById，返回值是 Book

然后下面就是参数和返回值的消息格式：

```
message BookById {
  int32 id = 1;
}

message Book {
  int32 id = 1;
  string name = 2;
  string desc = 3;
}
```
book.proto 只是定义了可用的方法和参数返回值的格式，我们还要在 controller 里实现对应的方法：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f4eb5d734494e2fbb8f8f925bf75afb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1130&h=846&s=198478&e=png&b=1f1f1f)

```javascript
@GrpcMethod('BookService', 'FindBook')
findBook(data: { id: number}) {
    const items = [
      { id: 1, name: '前端调试通关秘籍', desc: '网页和 node 调试' },
      { id: 2, name: 'Nest 通关秘籍', desc: 'Nest 和各种后端中间件' },
    ];
    return items.find(({ id }) => id === data.id);
}
```

实现了 findBook 方法，并通过 @GrpcMethod 把它标识为  grpc 的远程调用的方法。

在 nest-cli.json 添加 assets 配置，让 nest 在 build 的时候把 proto 也复制到 dist 目录下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86284c6f816c471eb4c0525c39b55109~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=768&h=360&s=75026&e=png&b=1f1f1f)

```javascript
"assets": ["**/*.proto"],
"watchAssets": true,
```

把它跑起来：

```
npm run start:dev grpc-server
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b87cbb5bb2f412297747c7af07bb251~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1100&h=422&s=90536&e=png&b=181818)

这时 dist 下就有 grpc-server 的代码了： 

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f832c59003d4510aed6ba309f9323e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=422&h=276&s=22634&e=png&b=1d1d1d)

然后我们在 grpc-client 里连上它：

在 AppModule 里添加连接 grpc-server 的微服务的配置：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12030bd8ae8a4c6c85d26214392c64fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1092&h=928&s=177452&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { join } from 'path';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'BOOK_PACKAGE',
        transport: Transport.GRPC,
        options: {
          url: 'localhost:8888',
          package: 'book',
          protoPath: join(__dirname, 'book/book.proto'),
        },
      },
    ]),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
同样，客户端也是需要 proto 文件的，不然不知道怎么解析协议数据。

把 book/book.proto 文件复制过来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3dc9c2b83b6487fa8b37afc7d9ea527~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=442&h=364&s=36430&e=png&b=1b1b1b)

然后在 AppController 里实现调用远程方法的逻辑：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31a3a5b082d44a289f748f9e7a7c83e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1160&h=1224&s=211307&e=png&b=1f1f1f)

注入 BOOK_PACKAGE 的 grpc 客户端对象。

在 onModuleInit 的时候调用 getService 方法，拿到 BookService 的实例。

然后调用它的 findBook 方法。

```javascript
import { Controller, Get, Inject, Param, Query } from '@nestjs/common';
import { AppService } from './app.service';
import { ClientGrpc } from '@nestjs/microservices';

interface FindById {
  id: number;
}
interface Book {
  id: number;
  name: string;
  desc: string;  
}
interface BookService {
  findBook(param: FindById): Book 
}
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject('BOOK_PACKAGE') 
  private client: ClientGrpc;

  private bookService: BookService;

  onModuleInit() {
    this.bookService = this.client.getService('BookService');
  }

  @Get('book/:id')
  getHero(@Param('id') id: number) {
    return this.bookService.findBook({
      id
    });
  }
}
```
把它跑起来：

```
npm run start:dev grpc-client
```
浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2be16550f9a54a1fa884bf1c32b0d716~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=848&h=204&s=28571&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/119e9a214c244c2ab5c00636c21224e1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=890&h=182&s=28557&e=png&b=fefefe)

可以看到，远程方法调用成功了。

这就是基于 grpc 的远程方法调用，用 java、python、go、c++ 等实现的微服务也是这样来通信。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82cd368ae0fb4321a55b01182ff5e08a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=472&s=31177&e=png&b=ffffff)

通过 protocol buffer 的语法定义通信数据的格式，比如 package、service 等。

然后 server 端实现 service 对应的方法，client 端远程调用这个 service。

比如在 java 的 srping 里，需要安装这两个依赖：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95ac4d74e3984ac7bce3ed1e5bdfe21b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1256&h=252&s=60129&e=png&b=f4f6fa)

然后也是定义这样的 proto 文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f27f966938ae4fb798eef7b9a54acc60~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168&h=1030&s=172873&e=png&b=f4f6fa)

之后定义对应的 servie：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f34e2518db424f65af445e2dfda82e32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1596&h=942&s=190072&e=png&b=f3f5f9)

和 node 里差不多。

这样就能跨语言调用对方的方法了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/grpc-client)
## 总结

这节我们学习了基于 gRPC 的远程方法调用。

不同语言的微服务之间可以基于 gRPC 来相互调用对方的方法。

它的实现方式是通过 protocol buffer 的语法来定义通信数据的格式，定义 package、service。

然后 server 端实现 service 对应的方法，client 端远程调用这些 service。

这样就可以实现在 java、node、go、python 等多种语言之间实现微服务的远程方法调用。


## 127.快速入门 ORM 框架 Prisma 

我们学习了 TypeORM，它是一个传统的 ORM 框架，也就是把表映射到 entity 类，把表的关联映射成 entity 类的属性关联。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a698288293c74bc09e0610f0b40f3ee7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1662&h=632&s=56056&e=png&b=ffffff)

完成 entity 和表的映射之后，你只要调用 userRepository 和 postRepository 的 find、delete、save 等 api，typeorm 会自动生成对应的 sql 语句并执行。

这就是 Object Relational Mapping，也就是对象和关系型数据库的映射的含义。

而 Prisma 不是这样的，它没有 entity 类的存在。

那映射什么呢？

Prisma 创造了一种 DSL（Domain Specific Language，领域特定语言）。

类似这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b8bafec64a54cc6bb13548d5e74c060~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1108&h=596&s=108843&e=png&b=1f1f1f)

它是把表映射成了 DSL 里的 model，然后编译这个 DSL 会生成 prismaClient 的代码，之后就可以调用它的 find、delete、create 等 api 来做 CRUD 了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63dbcba51cca4de4b37da140ea4a5dd7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1666&h=632&s=58044&e=png&b=ffffff)

虽然多了一种 DSL 的语法，但整个流程其实和 typeorm 差不多的。

我们来写下试试：

```
mkdir prisma-test
cd prisma-test
npm init -y
```
首先生成项目：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6dec5117a0f49ecb2bb7266b6fe478d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=638&s=127128&e=png&b=010101)

安装 typescript 相关的包：

```
npm install typescript ts-node @types/node --save-dev
```

typescript 是 tsc 编译器的包，ts-node 可以直接跑 ts 代码，而 @types/node 是 node api 的类型声明。

然后创建 tsconfig.json

```
npx tsc --init
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45cf724166f1491698f7f9b88d069421~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=670&h=374&s=42563&e=png&b=181818)

安装 prisma：

```
npm install prisma --save-dev
```

之后就可以来写代码了。

首先，我们要写 schema 层的代码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63dbcba51cca4de4b37da140ea4a5dd7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1666&h=632&s=58044&e=png&b=ffffff)

这个也是用命令生成：

```
npx prisma init --datasource-provider mysql
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/badf219d44184c7dac738193e223bb53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1118&h=432&s=81961&e=png&b=181818)

这时你会发现项目目录下多了 schema 文件和 env 文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7b66e678ffd4016ab2ed84da51c2067~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=502&s=101501&e=png&b=1d1d1d)

schema 文件里就是定义 model 的地方。

这个文件可以安装 prisma 插件来添加语法高亮等支持：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6adddf3e1d8c4f21b84be5ff7129e5ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=306&s=39728&e=png&b=1d1d1d)

而 .env 文件里存储着连接信息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c38225c9c6d441ea88399f644035b4e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1068&h=378&s=74936&e=png&b=1f1f1f)

我们先去 mysql workbench 里创建个数据库：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cbe9be9ee4e4631be3d99f45f1de85b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1264&h=752&s=186420&e=png&b=e7e5e5)

指定字符集为 utf8mb4，这个支持的字符集是最全的。

或者执行这个 sql：

```sql
CREATE SCHEMA `prisma_test` DEFAULT CHARACTER SET utf8mb4;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b7d55d601d4658a4da7ed0ed1cb896~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=476&h=254&s=37328&e=png&b=e5e0df)

创建完 database 后，我们改下连接信息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e397db8aa7e4920a562d29008ab01ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1006&h=348&s=69452&e=png&b=1f1f1f)

```env
DATABASE_URL="mysql://root:guang@localhost:3306/prisma_test"
```
改下用户名、密码、连接的数据库。

然后来定义 model：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6c6e0ba468b4379b55aaa55caf89bba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1114&h=852&s=140113&e=png&b=1f1f1f)

```prisma
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}
```
有了 mysql 和 typeorm 的基础后，这些很容易能看懂。

@id 是主键

@default(autoincrement()) 是指定默认值是自增的数字

@unique 是添加唯一约束

@relation 是指定多对一的关联关系，通过 authorId 关联 User 的 id

然后只要基于它生成 client 的代码，就可以来 crud 了：

```
npx prisma migrate dev --name aaa
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6e5db92339141d4ba89c278855ae6f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=484&s=77481&e=png&b=191919)

执行 prisma migrate dev，会生成并执行建表 sql 文件，而且在 node_modules 下生成了 client 代码。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c683432eda74c1ea50f1fdcc568e1c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1576&h=1062&s=273442&e=png&b=1d1d1d)

在 mysql workbench 里可以看到生成了 2 个表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24662a1290aa4e478a927adf9f300706~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=442&s=129826&e=png&b=eeebeb)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5acc0cad3ba54e7a92e7755cc3ee8cad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1102&h=580&s=184182&e=png&b=eeebeb)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fbed8200d64b1c903efcc088464e5e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=482&s=99384&e=png&b=f7f6f6)

在 node_modules/.prisma/client 下生成的代码也包含了 user 和 post 的信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce58f0bdb4854f4286e2095facc77745~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1132&h=636&s=142091&e=png&b=1c1c1c)

然后就可以用 @prisma/client 来做 CRUD 了。

创建 src/index.ts

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient();

async function test1() {
    await prisma.user.create({
        data: {
            name: 'guang',
            email: '111@gaung.com'
        }
    });

    await prisma.user.create({
        data: {
            name: 'dong',
            email: '222@dong.com'
        }
    });

    const users = await prisma.user.findMany();
    console.log(users);
}

test1();
```
创建 PrismaClient，用 create 方法创建了 2 个 user，然后查询出来。

跑一下：

```
npx ts-node ./src/index.ts
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/308e5f46852a424f898e27a70d865a47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=160&s=29609&e=png&b=181818)

可以看到，user 表确实插入了 2 条记录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0127e313b7e5480abe0dbfab7445a61a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1050&h=408&s=125597&e=png&b=ece9e8)

然后我们再来插入一个新的 user 和它的两个 post：

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function test2() {
    const user = await prisma.user.create({
        data: {
            name: '东东东',
            email: 'dongdong@dong.com',
            posts: {
                create: [
                    {
                        title: 'aaa',
                        content: 'aaaa'
                    },
                    {
                        title: 'bbb',
                        content: 'bbbb'
                    }
                ]
            },
        },
    })
    console.log(user)
}

test2();
```
这里开启了 prisma 的 log，会打印 sql。

然后用 create 方法创建了 user，并且 create 了两个关联的 post。

执行下：

```
npx ts-node ./src/index.ts
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/984b490b399044068950a07cdae94cd2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1314&h=330&s=92682&e=png&b=181818)

可以看到被事务包裹的三条 insert 语句。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79527c6e92f0409eaaab44a99187dee5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=400&s=132137&e=png&b=ece9e8)
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a702cb205ff45eab22c4da71fb4e192~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1064&h=332&s=108189&e=png&b=ebe8e7)

数据也都插入成功了。

然后是再来试下更新和删除：
```javascript
async function test3() {
    await prisma.post.update({
        where: {
            id: 2
        },
        data: {
            content: 'xxx'
        }
    })
}
test3();
```
更新 id 为 2 的 post 的内容为 xxx：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c275fee3dd45adbb90f208517a62c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1316&h=286&s=80407&e=png&b=191919)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74df2e460a6e4b77957d8197bcdcd4a4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=592&h=252&s=56477&e=png&b=fafafa)

然后把它删掉：

```javascript
async function test4() {
    await prisma.post.delete({
        where: {
            id: 2
        }
    });
}
test4();
```
执行下：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58f9c0b6df584b00ac8dde3569c687f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1258&h=266&s=61733&e=png&b=191919)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34337e18216745aeacbe507b644d43a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=622&h=208&s=47905&e=png&b=fafafa)

这样，基于 prisma 的 model 定义还有 CRUD 我们就都完成了。

回顾下整个流程：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63dbcba51cca4de4b37da140ea4a5dd7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1666&h=632&s=58044&e=png&b=ffffff)

只是把 entity 类变成了 DSL 语法里的 model，然后通过编译的方式生成 client 的代码，之后进行 CRUD。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/prisma-test)

## 总结

我们学习了 ORM 框架 prisma，它和 typeorm 大同小异。

typeorm 是把表映射成 entity 类，然后调用 repository 的 api 来做 CRUD。

prisma 是把条映射成 schema 的 model，然后编译生成 client 代码，之后进行 crud。

用到这两个命令：

primsa init 创建 schema 文件

prisma migrate dev 根据 schema 文件生成 sql 并执行，还会生成 client 代码。

之后就是 CRUD 了，涉及到 findMany、create、delete、update 等 api。

这节只是入了个门，下节来更全面的掌握 prisma。


## 128.Prisma 的全部命令

上节我们入门了 prisma，定义了 model 和表的映射，并且做了 CRUD。

这节来过一遍 Prisma 的全部命令。

```
npx prisma -h
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d4303e562914ed4b5a96c870236f787~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074&h=678&s=89326&e=png&b=181818)

有这些：

- init：创建 schema 文件

- generate： 根据 shcema 文件生成 client 代码

- db：同步数据库和 schema

- migrate：生成数据表结构更新的 sql 文件

- studio：用于 CRUD 的图形化界面

- validate：检查 schema 文件的语法错误

- format：格式化 schema 文件

- version：版本信息


我们一个个来过一遍。

先创建个新项目：

```
mkdir prisma-all-command
cd prisma-all-command
npm init -y
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/141cc568db0b4429983749d95b566e7e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=826&h=652&s=134319&e=png&b=000000)

全局安装 prisma，这个是命令行工具的包：

```
npm install -g prisma
```
## prisma init
首先来试一下 init 命令：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cda9096e9424c8ba9b052b1a8cd6deb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=924&h=784&s=98010&e=png&b=181818)

这个就是创建 schema 文件的，可以指定连接的 database，或者指定 url。

我们试一下：

```
prisma init
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/803a110c492a4c5bbd5320fa958a7a2d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1048&h=578&s=115206&e=png&b=181818)

执行 init 命令后生成了 prisma/shcema.prisma 和 .env 文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1ea30a82f614f0788dcc0f4feb1ef93~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1152&h=480&s=100047&e=png&b=1d1d1d)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab0670632c5d4b9e9dde8b31980f57e1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1880&h=474&s=131957&e=png&b=1e1e1e)

包含了 db provider，也就是连接的数据库，以及连接的 url：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ff37b1eb71845b4954ac732351274fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=662&h=460&s=62932&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9dccf4f98b4482bd99091a38cb9694~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1314&h=348&s=86946&e=png&b=1f1f1f)

删掉这俩文件，重新生成。

```
prisma init --datasource-provider mysql
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c14f5b72f94224b6a097f04db4514d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1276&h=432&s=84377&e=png&b=181818)

这样生成的就是连接 mysql 的 provider 和 url 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9e42e14e6e24405b187215b17f7ffa8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=718&h=448&s=61405&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ca1667c732a49beb7e5b6ef45f3e623~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1056&h=332&s=72335&e=png&b=1f1f1f)

其实就是改这两处的字符串，prisma init 之后自己改也行。

再删掉这俩文件，我们重新生成。

```
prisma init --url mysql://root:guang@localhost:3306/prisma_test
```
这次指定连接字符串。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0958cfc6e85e408f972af7234fe6d06b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1068&h=402&s=71532&e=png&b=181818)

可以看到，provider 会根据你指定的 url 来识别，并且 .env 里的 url 就是我们传入的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58d4c30da19f465a859912b080bea712~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=448&s=59576&e=png&b=1f1f1f)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4a2fc484bcc4410807e8df4f9fdba68~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=360&s=69200&e=png&b=1f1f1f)

## prisma db

创建完 schema 文件，如何定义 model 呢？

其实 init 命令的打印提示了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0686752fafa743b6a8f676d266c09f30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=338&s=113647&e=png&b=191919)

你可以执行 prisma db pull 把数据库里的表同步到 schema 文件。

我们试一下：

```
prisma db pull
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51bf4749e5014463bec0b72e62d4a31d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=254&s=44743&e=png&b=191919)

提示发现了 2 个 model 并写入了 schema 文件。

现在连接的 prisma_test 数据库里是有这两个表的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed443a246eb42cab0d33ffbc8d0260c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&h=346&s=115481&e=png&b=edeae8)

生成的 model 定义是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b66238684b3442a09d700a27016361c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158&h=988&s=165063&e=png&b=1f1f1f)

其中，@@index 是定义索引，这里定义了 authorId 的外键索引。

此外，db 命令还有别的功能：

```
prisma db -h
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a32adf5922464877b0adf1307e880ddd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1222&h=532&s=73319&e=png&b=181818)

试下 prisma db push 命令：

首先在 mysql workbench 里把这两个表删掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71913e8985064aa99ea3b2ef1bc43c67~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=576&h=640&s=190018&e=png&b=ddd8d4)

然后执行 db push：

```
prisma db push
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/677514acfbd848b99bdd602398c6d539~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=420&s=69492&e=png&b=191919)

提示同步到了 database，并且生成了 client 代码。

在 mysql workbench 里可以看到新的表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98b31be7183d4f06a77085b7d6ecc220~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1048&h=396&s=119733&e=png&b=efecea)

seed 命令是执行脚本插入初始数据到数据库。

我们用 ts 来写，先安装相关依赖：

```
npm install typescript ts-node @types/node --save-dev
```
创建 tsconfig.json

```
npx tsc --init
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d143ca746d04f349b0cf5e51c25138b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668&h=388&s=42942&e=png&b=181818)

然后写下初始化脚本 prisma/seed.ts

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function main() {
    const user = await prisma.user.create({
        data: {
            name: '东东东',
            email: 'dongdong@dong.com',
            Post: {
                create: [
                    {
                        title: 'aaa',
                        content: 'aaaa'
                    },
                    {
                        title: 'bbb',
                        content: 'bbbb'
                    }
                ]
            },
        },
    })
    console.log(user)
}

main();
```
在 package.json 添加 seed 命令的配置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87217c1c49bf4913893345662f6f6be5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=266&s=39724&e=png&b=1f1f1f)

```json
"prisma": {
    "seed": "npx ts-node prisma/seed.ts"
},
```
然后执行 seed：

```
prisma db seed
```

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b961266c00740a9919edc4808f23f78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1190&h=462&s=111968&e=png&b=191919)

在 mysql workbench 里可以看到数据被正确插入了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16e1310a2934ddab9d9484737eea28d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1004&h=270&s=74168&e=png&b=ebe8e7)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ce6c95394ab4be2bdd14ec036c50771~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078&h=278&s=87217&e=png&b=ebe8e7)

其实 seed 命令就是把跑脚本的过程封装了一下，和直接用 ts-node 跑没啥区别。

然后是 prisma db execute，这个是用来执行 sql 的。

比如我写一个 prisma/test.sql 的文件：

```sql
delete from Post WHERE id = 2;
```
然后执行 execute：

```
prisma db execute --file prisma/test.sql --schema prisma/schema.prisma
```

这里 --file 就是指定 sql 文件的。

而 --schema 指定 schema 文件，主要是从中拿到数据库连接信息。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/740213f0e2fb44ad872f142604d8153d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=72&s=17399&e=png&b=181818)

然后去 mysql workbench 里看一下，确实 id 为 2 的 Post 数据没有了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd48653b11a34700b6c1004d30133445~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=594&h=196&s=46389&e=png&b=f9f9f9)

这就是 db 的 4 个命令。

## prisma migrate

mirgrate 是迁移的意思，在这里是指表的结构变化。

prisma migrate 有这些子命令：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec74ce5adfa74ac8938f8e25d9785c2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1364&h=780&s=113533&e=png&b=181818)

我们分别来看一下。

首先是 prisma migrate dev。

这个我们前面用过，它会根据 schema 的变化生成 sql 文件，并执行这个 sql，还会生成 client 代码。

```
prisma migrate dev --name init
```

因为之前创建过表，并且有数据。

它会提示是否要 reset：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac08e229620d4630b561324018f442e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=104&s=22468&e=png&b=191919)

选择是，会应用这次 mirgration，生成 sql 文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7fa4cf793f34ea4aa932145689ac945~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1520&h=768&s=162100&e=png&b=181818)

并且会生成 client 代码，而且会自动执行 prisma db seed，插入初始化数据。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/504d374d37e04c2f81527b7f7220af53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=974&h=184&s=57122&e=png&b=e0dcdc)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6da5ff447888459dbb5f9aa2635a5dcd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1040&h=228&s=82594&e=png&b=e1dddd)

这样就既创建了表，又插入了初始数据，还生成了 client。

我们开发的时候经常用这个命令。

在 prisma/migrations 下会保存这次 migration 的 sql 文件。

目录名是 “年月日时分秒_名字” 的格式：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d2e09eb5e92415190ab5d9543cf752c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1350&h=708&s=184394&e=png&b=1d1d1d)

那如果我们改一下 schema 文件，再次执行 migrate dev 呢？

在 Post 的 model 定义里添加 tag 字段：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/966dd7e9f05844f59ec7a21d5a48d0d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=718&h=362&s=66261&e=png&b=202020)

```
tag       String  @default("")
```
然后 migrate dev：

```
prisma migrate dev --name age-field
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60aeda069c8d49e1b6bc4ca96bc34e4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1148&h=482&s=79639&e=png&b=181818)

这次生成的 sql 只包含了修改表结构的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/263be9c0f79642c7bf1ccae880a7e885~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1684&h=482&s=106419&e=png&b=1e1e1e)

在数据库中有个 _prisma_migrations 表，记录着数据库 migration 的历史：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/966c50e637734075885ac7c1d1aa22a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1540&h=374&s=168626&e=png&b=efecec)

如果把这个表删掉，再次 mirgate dev 就会有前面的是否 reset 的提示了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac08e229620d4630b561324018f442e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=104&s=22468&e=png&b=191919)

如果你想手动触发reset，可以用 reset 命令：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25f8c02994ec4444a07c9b6473fa66b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034&h=248&s=27802&e=png&b=181818)

它会清空数据然后执行所有 migration

```
prisma migrate reset
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d073ff389c6e4fe1ab01db0e92ee96ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=250&s=40671&e=png&b=191919)

会提示会丢失数据，确认后就会重置表，然后执行所有 migration：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f8338316afb484a99daf135a8a867d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1396&h=1024&s=199694&e=png&b=181818)

还会生成 client 代码，并且执行 prisma db seed 来初始化数据。

## prisma generate

generate 命令只是用来生成 client 代码的，他并不会同步数据库：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/389524ff126640cc94dba4aa11266dc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1124&h=528&s=98490&e=png&b=191919)

只是根据 schema 定义，在 node_modules/@prisma/client 下生成代码，用于 CRUD。

## prisma studio

这个是可以方便 CRUD 数据的图形界面：

```
prisma studio
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71f520804d274b1885d893700770255a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=698&h=136&s=23271&e=png&b=191919)

选择一个 model：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48c5d2f35a2342c280bb3a89a2316f17~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1002&h=588&s=33259&e=png&b=ffffff)

会展示它的所有数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c465185b0cb470c868e6ed6c39c1e6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2196&h=432&s=65652&e=png&b=fefefe)

可以编辑记录：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fbcdeb5cab47ab86947c781fceef91~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2276&h=466&s=66399&e=png&b=ffffff)

删除记录：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f54d499d21d4c90a4088ee4168568f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1290&h=372&s=47902&e=png&b=ffffff)

新增记录：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c390aa8733ac4bc099a1499962396671~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2490&h=390&s=85642&e=png&b=fef5f3)

不过一般我们都用 mysql workbench 来做。

## prisma validate

这个是用来检查 schema 文件是否有语法错误的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b7ea663f0eb48f4ae030e46d0669fbe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1198&h=152&s=38453&e=png&b=191919)

比如我写错一个类型，然后执行 validate：

```
prisma validate
```
会提示这里有错误：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63ed6335516b4af299f59101ed1f2b38~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1428&h=1064&s=191466&e=png&b=1c1c1c)

当然，我们安装了 prisma 的插件之后，可以直接在编辑器里看到这个错误：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/807848e678334c21b1cf05cd38ad9292~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1540&h=192&s=42469&e=png&b=222222)

就和 eslint 差不多。

## prisma format

这个是用来格式化 prisma 文件的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4efddbf59a4296aa70b850d535e503~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1298&h=756&s=163530&e=gif&f=27&b=1f1f1e)

当然，你安装了 prisma 的 vscode 插件之后，也可以直接用编辑器的 format：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4cedcab3cbc410cb54daf87cbf884bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1536&h=904&s=346763&e=gif&f=22&b=222222)

## prisma version

这个就是展示一些版本信息的，比较简单：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b7848d2360d44a49fa8f513bee2062e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1322&h=340&s=89218&e=png&b=191919)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/prisma-all-command)

## 总结

这节我们学习了 prisma 的全部命令：

- init：创建 schema 文件

- generate： 根据 shcema 文件生成 client 代码

- db：同步数据库和 schema

- migrate：生成数据表结构更新的 sql 文件

- studio：用于 CRUD 的图形化界面

- validate：检查 schema 文件的语法错误

- format：格式化 schema 文件

- version：版本信息

其中，prisma init、prisma migrate dev 是最常用的。

prisma db pull、prisma db push 也可以方便的用来做 schema 和数据库的同步。

常用的命令也没有几个，多拥几遍就熟了。

## 129.Prisma 的全部 schema 语法

这节我们来学习下 Prisma 的 schema 文件的全部语法。

先创建个新项目：

```
mkdir prisma-schema
cd prisma-schema
npm init -y
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ce378d3a0884d45b88594b7f9b755e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=684&s=112366&e=png&b=000000)

全局安装 prisma：

```
npm install -g prisma
```
然后进入项目，执行 init 命令：

```
prisma init
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98e11c3aca8c492b81ab65cf2b2be480~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1028&h=388&s=76003&e=png&b=181818)

生成了 .env 和 schema 文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e65daf9ecb0449188bead9663fa77fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450&h=190&s=23342&e=png&b=181818)

然后改下 .env 文件的数据库连接信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9260844466e7496fa11bdf18a5da4e14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1026&h=348&s=134798&e=png&b=202020)

```
DATABASE_URL="mysql://root:guang@localhost:3306/prisma_test"
```

改一下 db 的 provider 为 mysql，并且添加一个 model

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da4a29a7dca24d628b3f49c672d8a3c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=614&s=156250&e=png&b=1f1f1f)

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```
然后执行 generate 命令：

```
prisma generate
```

会在 node_modules/@prisma/client 下生成客户端代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe2a4e7c9037465a8cb777084a753931~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1112&h=982&s=366163&e=png&b=191919)

这个生成位置是可以改的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/970e707c2b90430cadb65db290aceca6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=826&h=608&s=153883&e=png&b=202020)
在 generator 指定 output 的位置即可：
```
generator client {
  provider = "prisma-client-js"
  output   = "../generated/client"
}
```
然后再次 generate：

```
prisma generate
```

这时候就是在根目录生成的代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19db6a24c35c482695d1f2b57668b1e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074&h=534&s=219731&e=png&b=191919)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5260ed1620f4131823674ed431e54b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=546&h=502&s=108401&e=png&b=191919)

此外，generator 除了可以生成 client 代码外，还可以生成别的东西。

在[文档](https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators)里可以看到有很多社区的 generator：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/787f61d8fd7b434abd7d537640ba24f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=1160&s=637326&e=png&b=ffffff)

我们试一下这个 json 和 docs 的 generator：

```
npm install --save-dev prisma-docs-generator
npm install --save-dev prisma-json-schema-generator
```
先安装相关的包。

然后在 schema 文件里配置 3 个 generator：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ccca2d497f44f6080fc60ab88abbe2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982&h=704&s=222270&e=png&b=1f1f1f)
```
generator client {
  provider = "prisma-client-js"
  output   = "../generated/client"
}

generator docs {
  provider = "node node_modules/prisma-docs-generator"
  output   = "../generated/docs"
}

generator json {
  provider = "prisma-json-schema-generator"
  output   = "../generated/json"
}
```
把 generated 目录删掉，重新生成：

```
npx prisma generate
```
注意，这里要用 npx 执行，因为如果是执行全局命令，会找不到项目目录下安装的 generator。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa75aab2da764e06afb755efcfdbcc76~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=434&s=132905&e=png&b=181818)

提示三个 generator 的产物都输出到了对应目录。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc2dd16688944645a86dbaf44ff472c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=530&h=784&s=156876&e=png&b=1a1a1a)

json schema 的 generator 会把 schema 文件转为 json 版：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26eebdf46e0e42488aa26a8264e32852~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1000&h=1086&s=239381&e=png&b=202020)

而 docs 则是会生成文档。

我们跑起来看看：

```
npx http-server ./generated/docs
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f86f5187be6f432f93cee71b6944c60e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=738&h=504&s=160384&e=png&b=181818)

文档里会列出 model 的所有字段：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cb3242310e140a081abdf4150f9f92e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2234&h=1452&s=652927&e=png&b=ffffff)

还有它的所有 CRUD 方法，每个方法的参数的类型等：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebe58ed1227049ab85480e363d699665~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2010&h=1432&s=794617&e=gif&f=34&b=fdfdfd)

当你想做 crud 的时候，查下这个生成的文档，特别方便。

datasource 部分是配置数据库连接信息的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/956a4ec06c1c47ffb25fd73e94b6597c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=534&h=332&s=80610&e=png&b=212121)

provider 里指定连接的数据库的类型。

url 部分是连接的 url，也就是这个

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a34f5e5f8fbe435e9e56d752a0712f56~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=350&s=131006&e=png&b=202020)

在 schema 文件里可以用这种方式读取某个 env 的变量：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/590c12df2c1049f5a3c4bd989a277644~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=546&h=170&s=37601&e=png&b=20201f)

接下来是 model 部分。

```
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

这部分很容易看懂，第一列是字段名，第二列是类型，第三列是一些其他信息。

首先重置一下：

```
prisma migrate reset
```
我们用 migrate 命令生成 sql：

```
prisma migrate dev --name aaa
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c7c9139f6fb4d8688a63570124746eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1088&h=394&s=74750&e=png&b=191919)

然后创建一个 aaa 的迁移：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c33f3190734ff796f7f87778a76a0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1116&h=532&s=94200&e=png&b=191919)

它会创建对应的 sql 文件并执行：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69a09ceaea3a4033925c65d16075d0e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592&h=566&s=157901&e=png&b=1d1d1d)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1d5139def864805aa3819bfa306327b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078&h=510&s=155241&e=png&b=eeebea)

可以看到 model 的声明和生成的 sql 的对应关系：

```
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```


![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72306bed7f66413bba5662cf722c3788~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=978&h=408&s=74795&e=png&b=1f1f1f)

String 默认是 VARCHAR(191)

@id 会创建主键约束，@default 是默认值，而 autoincrement 是自增。 

@unique 会创建唯一约束。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41761dfd06284b7c88896639a000223f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=910&h=356&s=63744&e=png&b=1f1f1f)

我们再创建一个 model

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6439250bb3b342c78f3fde126bb3512e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=774&h=600&s=103672&e=png&b=1f1f1f)

```
model Test {
  id Int @id @default(autoincrement())
  aaa String @db.Text
  bbb Int @db.TinyInt @map("bbb2")
  ccc String @db.VarChar(50) @unique

  @@map("test_test")
  @@index([bbb, ccc])
}
```
这是 @db.xxx 可以指定具体的 mysql 的数据类型，有括号的是可以填入参数的，比如 VARCHAR 可以指定长度：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cc27fa1b618406e8be88f49d27b273b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=624&h=420&s=66052&e=png&b=212121)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5565b81d774416aa627a46bf9ed4cf6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=656&h=500&s=71951&e=png&b=212121)

@map 是给字段指定另一个名字，@@map 是给表指定另一个名字。

而 @@index 则是创建一个索引，这里创建了 bbb、ccc 的联合索引。

索引就像书的目录一样，可以加快 sql 查询速度，sql 优化的时候我们经常会把高频查询的字段创建索引。

我们测试下：

```
npx prisma migrate dev --name bbb
```
创建 bbb 的数据库迁移。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf66119beba491296863bc5f62d3b0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=972&h=626&s=93174&e=png&b=181818)
生成的 sql 如下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67009848e9514836bbd28a370303b398~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1542&h=568&s=162390&e=png&b=1d1d1d)

对比下 model 语法和生成的 sql：

```
model Test {
  id Int @id @default(autoincrement())
  aaa String @db.Text
  bbb Int @db.TinyInt @map("bbb2")
  ccc String @db.VarChar(50) @unique

  @@map("test_test")
  @@index([bbb, ccc])
}
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a7637b5e4494d77bdf57266f38a4437~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1048&h=550&s=108446&e=png&b=1f1f1f)

可以看到 @db.xxx、@map、@@map、@@index 都生效了

在 mysql workbench 里也可以看到这个表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec84339120ce48bbb19f9bdf2155b9a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1134&h=598&s=188194&e=png&b=edeae9)

那表和表之间的一对多、多对多关系呢？

我们再添加几个 model：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78ba0d7c18f84d65992e8ead9f396980~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1392&h=904&s=194900&e=png&b=1f1f1f)

```
model Department {
  id        Int    @id @default(autoincrement())
  name      String  @db.VarChar(20)
  createTime DateTime @default(now())
  updateTime DateTime @updatedAt
  employees     Employee[]
}

model Employee {
  id         Int       @id @default(autoincrement())
  name      String     @db.VarChar(20)
  phone     String     @db.VarChar(30)

  deaprtmentId Int
  department     Department      @relation(fields: [deaprtmentId], references: [id])
}
```

这里用到了几个新语法：

创建时间我们使用 @default(now()) 的方式指定，这样插入数据的时候会自动填入当前时间。

更新时间使用 @updatedAt，会自动设置当前时间。

员工和部门是多对一关系，在员工那一侧添加一个 departmentId 的列，然后通过 @relation 声明 deaprtmentId 的列引用 department 的 id 列。

测试下：
```
npx prisma migrate dev --name ccc
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c10607651f14ead809f89b3086eaa2d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1056&h=548&s=94094&e=png&b=191919)

可以看到，生成的 sql 是符合预期的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e645152f894a75bb8ba4fd674def09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1872&h=1030&s=225160&e=png&b=1f1f1f)

并且在数据库里可以看到创建了对应的外键：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4b604c1743b49228e781a9056eb3291~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1968&h=526&s=174268&e=png&b=f4f2f2)

然后是多对多：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3cff85632d247a8ba2af2544172e808~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1000&h=936&s=152941&e=png&b=1f1f1f)
```
model Post {
  id        Int          @id @default(autoincrement())
  title     String
  content   String?
  published Boolean      @default(false)
  tags      TagOnPosts[]
}

model Tag {
  id    Int          @id @default(autoincrement())
  name  String
  posts TagOnPosts[]
}

model TagOnPosts {
  post   Post @relation(fields: [postId], references: [id])
  postId Int

  tag    Tag @relation(fields: [tagId], references: [id])
  tagId  Int

  @@id([postId, tagId])
}
```
有 sql 的基础很容易看懂，多对多需要创建一个中间表，中间表里有两个外键分别关联这两个表。

然后用 @@id 创建一个联合主键。

测试下：

```
npx prisma migrate dev --name ddd
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea9888498ab247cd8876e17e3ac0cd0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1184&h=522&s=95743&e=png&b=191919)

生成的 sql 如下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d41fee3e24455da43cd3d3d0bb9ada~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1950&h=1294&s=285317&e=png&b=1f1f1f)

中间表创建了 postId 和 tagId 的联合主键，并且创建了两个外键。

在 mysql 里可以看到这两个外键：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2c0c956df74958b7653a0410678926~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1962&h=830&s=263926&e=png&b=f4f2f2)

这就是一对多、多对多的映射方式。

至于一对一，那个就是在多的那一侧添加一个 unique 约束就好了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/736ff79d04d842e3b653410a6852214e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1276&h=582&s=121715&e=png&b=1f1f1f)

这样就把一对多变成了一对一。

此外，还有一个 enum 的语法，就是可以指定某个字段只能取一些枚举值：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd190610d56c45c4a8912463455dbb9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=904&h=558&s=72300&e=png&b=1f1f1f)

```
model Aaa {
  id      Int      @id @default(autoincrement())
  name    String?
  role    EEE     @default(CCC)
}

enum EEE {
  BBB
  CCC
  DDD
}
```
创建迁移：

```
npx prisma migrate dev --name eee
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/125acd9f027f49d6af94a4afbfb6a8fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1060&h=556&s=95431&e=png&b=191919)

生成的 sql 如下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54bcd4b2064743ab98dac25a4024e7f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1024&h=458&s=84212&e=png&b=1f1f1f)

这个 enum 也是 sql 支持的语法（我们前面貌似没用过）。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a085bbdf8364c67b2d7909cf1e96c52~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1216&h=698&s=205426&e=png&b=edeae9)

这就是 prisma schema 的常用语法了，有一些不常用的没有列出来，大家遇去查[schema 文档](https://www.prisma.io/docs/concepts/components/prisma-schema)就好了。

最后，再看下生成的文档：
```
npx http-server ./generated/docs
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba9877c8b663449280fc05d6ed5929e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=748&h=538&s=91482&e=png&b=181818)

每一个表的字段还有可用的 CRUD 方法都列出来了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fdbc5df3c0248b4b815923b59beeb16~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1854&h=1304&s=240510&e=png&b=ffffff)

确实很方便。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/prisma-schema)

## 总结

这节我们学习了 prisma schema 的常用语法。

generator 部分可以指定多种生成器，比如生成 json 生成 docs 等，可以指定生成代码的位置。

datasource 是配置数据库的类型和连接 url 的。

model 部分定义和数据库表的对应关系：

- **@id** 定义主键
- **@default** 定义默认值
- **@map** 定义字段在数据库中的名字
- **@db.xx** 定义对应的具体类型
- **@updatedAt** 定义更新时间的列 
- **@unique** 添加唯一约束
- **@relation** 定义外键引用
- **@@map** 定义表在数据库中的名字
- **@@index** 定义索引
- **@@id** 定义联合主键

此外，还可以通过 enum 来创建枚举类型。

这些就是常用的 schema 语法了。



## 13.Metadata 和 Reflector

不知道大家有没有感觉很神奇，只是通过装饰器声明了一下，然后启动 Nest 应用，这时候对象就给创建好了，依赖也给注入了。

那它是怎么实现的呢？

大家如果就这样去思考它的实现原理，还真不一定能想出来，因为缺少了一些前置知识。也就是实现 Nest 最核心的一些 api： Reflect 的 metadata 的 api。

有的同学会说，Reflect 的 api 我很熟呀，就是操作对象的属性、方法、构造器的一些 api：

比如 Reflect.get 是获取对象属性值

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5a7ba0e6dc94d0fb842cafc25ac4dd2~tplv-k3u1fbpfcp-watermark.image?)

Reflect.set 是设置对象属性值

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69c386cd587d4b958212a5ee1ee09a96~tplv-k3u1fbpfcp-watermark.image?)

Reflect.has 是判断对象属性是否存在

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/783e8067a805459d9ec0d56292f529a4~tplv-k3u1fbpfcp-watermark.image?)

Reflect.apply 是调用某个方法，传入对象和参数

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7708d7a8c01a4fb6ae10b51b98442921~tplv-k3u1fbpfcp-watermark.image?)

Reflect.construct 是用构造器创建对象实例，传入构造器参数

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed7bde270882465cb9ffdc624bbb4e61~tplv-k3u1fbpfcp-watermark.image?)

这些 api 在 [MDN 文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect)里可以查到，因为它们都已经是 es 标准了，也被很多浏览器实现了。

但是实现 Nest 用到的 api 还没有进入标准，还在草案阶段，也就是 [metadata 的 api](https://rbuckton.github.io/reflect-metadata/)：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9cf799a18794e0a903170b6bf76fa21~tplv-k3u1fbpfcp-watermark.image?)

它有这些 api：

```typescript
Reflect.defineMetadata(metadataKey, metadataValue, target);

Reflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);


let result = Reflect.getMetadata(metadataKey, target);

let result = Reflect.getMetadata(metadataKey, target, propertyKey);
```

Reflect.defineMetadata 和 Reflect.getMetadata 分别用于设置和获取某个类的元数据，如果最后传入了属性名，还可以单独为某个属性设置元数据。

那元数据存在哪呢？

存在类或者对象上呀，如果给类或者类的静态属性添加元数据，那就保存在类上，如果给实例属性添加元数据，那就保存在对象上，用类似 \[\[metadata]] 的 key 来存的。

这有啥用呢？

看上面的 api 确实看不出啥来，但它也支持装饰器的方式使用：

```javascript
@Reflect.metadata(metadataKey, metadataValue)
class C {

  @Reflect.metadata(metadataKey, metadataValue)
  method() {
  }
}

```

Reflect.metadata 装饰器当然也可以再封装一层：

```typescript
function Type(type) {
    return Reflect.metadata("design:type", type);
}
function ParamTypes(...types) {
    return Reflect.metadata("design:paramtypes", types);
}
function ReturnType(type) {
    return Reflect.metadata("design:returntype", type);
}

@ParamTypes(String, Number)
class Guang {
  constructor(text, i) {
  }

  @Type(String)
  get name() { return "text"; }

  @Type(Function)
  @ParamTypes(Number, Number)
  @ReturnType(Number)
  add(x, y) {
    return x + y;
  }
}
```

然后我们就可以通过 Reflect metadata 的 api 获取这个类和对象的元数据了：

```typescript
let obj = new Guang("a", 1);

let paramTypes = Reflect.getMetadata("design:paramtypes", obj, "add"); 
// [Number, Number]
```

这里我们用 Reflect.getMetadata 的 api 取出了 add 方法的参数的类型。

看到这里，大家是否明白 nest 的原理了呢？

我们再看下 nest 的源码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2bb578b9b624bf993aaedc250ec053d~tplv-k3u1fbpfcp-watermark.image?)

上面就是 @Module 装饰器的实现，里面就调用了 Reflect.defineMetadata 来给这个类添加了一些元数据。

所以我们这样用的时候：

    import { Module } from '@nestjs/common';
    import { CatsController } from './cats.controller';
    import { CatsService } from './cats.service';

    @Module({
      controllers: [CatsController],
      providers: [CatsService],
    })
    export class CatsModule {}

其实就是给 CatsModule 添加了 controllers 的元数据和 providers 的元数据。

后面创建 IOC 容器的时候就会取出这些元数据来处理：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12e7eca6e54e4fa1867b16b83237135a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32ea9f7aa5374ce681053a4dcae06723~tplv-k3u1fbpfcp-watermark.image?)

而且 @Controller 和 @Injectable 的装饰器也是这样实现的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd7235bd63374965a7d55c5866471983~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c82a1514a28749668ec631b7e565e466~tplv-k3u1fbpfcp-watermark.image?)

Nest 的实现原理就是通过装饰器给 class 或者对象添加元数据，然后初始化的时候取出这些元数据，进行依赖的分析，然后创建对应的实例对象就可以了。

所以说，nest 实现的核心就是 Reflect metadata 的 api。

当然，现在 metadata 的 api 还在草案阶段，需要使用 reflect-metadata 这个 polyfill 包才行。

其实还有一个疑问，依赖的扫描可以通过 metadata 数据，但是创建的对象需要知道构造器的参数，现在并没有添加这部分 metadata 数据呀：

比如这个 CatsController 依赖了 CatsService，但是并没有添加 metadata 呀：

```typescript
import { Body, Controller, Get, Param, Post } from '@nestjs/common';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}
```

这就不得不提到 TypeScript 的优势了，TypeScript 支持编译时自动添加一些 metadata 数据：

比如这段代码：

    import "reflect-metadata";
     
    class Guang {
      @Reflect.metadata("名字", "光光")
      public say(a: number): string {
        return '加油鸭';
      }
    }

按理说我们只添加了一个元数据，生成的代码也确实是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c525cd38ea542bab80ef31a15719265~tplv-k3u1fbpfcp-watermark.image?)

但是呢，ts 有一个编译选项叫做 emitDecoratorMetadata，开启它就会自动添加一些元数据。

开启之后再试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14d5736bef144a9a6830c7626b15b9f~tplv-k3u1fbpfcp-watermark.image?)

你会看到多了三个元数据：

design:type 是 Function，很明显，这个是描述装饰目标的元数据，这里装饰的是函数

design:paramtypes 是 \[Number]，很容易理解，就是参数的类型

design:returntype 是 String，也很容易理解，就是返回值的类型

所以说，只要开启了这个编译选项，ts 生成的代码会自动添加一些元数据。

然后创建对象的时候就可以通过 design:paramtypes 来拿到构造器参数的类型了，那不就知道怎么注入依赖了么？

所以，nest 源码里你会看到这样的代码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af6a8ad0ce814857881fbf2a7c503e7c~tplv-k3u1fbpfcp-watermark.image?)

就是获取构造器的参数类型的。这个常量就是我们上面说的那个：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6b32199ab1443794f56bdac63a2a5b~tplv-k3u1fbpfcp-watermark.image?)

这也是为什么 nest 会用 ts 来写，因为它很依赖这个 emitDecoratorMetadata 的编译选项。

你用 cli 生成的代码模版里也都默认开启了这个编译选项：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a984d979388a42bbb77bcef2b3c4dc26~tplv-k3u1fbpfcp-watermark.image?)

这就是 nest 的核心实现原理：**通过装饰器给 class 或者对象添加 metadata，并且开启 ts 的 emitDecoratorMetadata 来自动添加类型相关的 metadata，然后运行的时候通过这些元数据来实现依赖的扫描，对象的创建等等功能。**

Nest 的装饰器都是依赖 reflect-metadata 实现的，而且还提供了一个 @SetMetadata 的装饰器让我们可以给 class、method 添加一些 metadata：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ea48d21da6943bfad91b6d81562cafa~tplv-k3u1fbpfcp-watermark.image?)

这个装饰器的底层实现自然是 Reflect.defineMetadata：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0da98c74bf4242fba7e65512d2992a8c~tplv-k3u1fbpfcp-watermark.image?)

Nest 为什么暴露这样一个底层的 metadata api 出来呢？

因为这个 metadata 是可以在代码里取出来用的：

我们创建新项目来测试下：

    nest new metadata-and-reflector -p npm

创建 guard 和 interceptor：

    nest g interceptor aaa --flat --no-spec
    nest g guard aaa --flat --no-spec

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0806331a696341bbacccc66a182fb9c7~tplv-k3u1fbpfcp-watermark.image?)

在路由级别应用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9adde1c019d54639976f3dfdbd98f72a~tplv-k3u1fbpfcp-watermark.image?)

加个打印语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c704ae3bc02047b382cd030fc726b182~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d3db5800377466693337238e4c17ba2~tplv-k3u1fbpfcp-watermark.image?)

然后 nest start --watch 把服务跑起来。

浏览器访问：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8f1ac70d54c45e28dc0d9057599357d~tplv-k3u1fbpfcp-watermark.image?)

可以看到 guard 和 interceptor 成功执行了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86989a513c4b499bbad8ccd87835e13d~tplv-k3u1fbpfcp-watermark.image?)

然后我们用 @SetMetadata 在 controller 上加个 metadata：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e61d10f799764322bb0127432b43604d~tplv-k3u1fbpfcp-watermark.image?)

在 guard 和 interceptor 就就可以这样取出来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cef2879ad7db444289320fa0f1aa05cb~tplv-k3u1fbpfcp-watermark.image?)

通过 ExecutationContext 取到目标 handler，然后注入 reflector，通过 reflector.get 取出 handler 上的 metadata。

interceptor 里也是这样，这里换种属性注入方式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b407535dd6614d9b994f910b1b1d8634~tplv-k3u1fbpfcp-watermark.image?)

刷新下页面，就可以看到已经拿到了 metadata：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10dc4b40265c433bb20e0fd4a1f862e6~tplv-k3u1fbpfcp-watermark.image?)

拿到 metadata 有什么用呢？

可以判断权限呀，比如这个路由需要 admin 角色，那可以取出 request 的 user 对象，看看它有没有这个角色，有才放行。

当然这只是一种用途。

除了能拿到 handler 上的装饰器，也可以拿到 class 上的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12538621a1a74dbd88c0bb20a8ef3e87~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad6a4834d0974b31b6528a3942ed0535~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d46cbf4ac5848c4b303ea0648f30fb2~tplv-k3u1fbpfcp-watermark.image?)

reflector 还有 3 个方法：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c2d3d5f95af42f285627e55f1cc4f70~tplv-k3u1fbpfcp-watermark.image?)

这 4 个方法有啥区别呢？

看下[它们的源码](https://github.com/nestjs/nest/blob/5bba7e9d264319490f142ca5e8099c559fa7e7e3/packages/core/services/reflector.service.ts#L11-L97)就知道了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85d6f8b0a5504b9eaf7099bf6912d8d9~tplv-k3u1fbpfcp-watermark.image?)

get 的实现就是 Reflect.getMetadata。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc0456df139b40998bb735047684b332~tplv-k3u1fbpfcp-watermark.image?)

getAll 是返回一个 metadata 的数组。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/136db1840afc4b44b9f38c555cb0db02~tplv-k3u1fbpfcp-watermark.image?)

getAllAndMerge，会把它们合并为一个对象或者数组。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7081c65ccd744f83ac28df0a43eae4ed~tplv-k3u1fbpfcp-watermark.image?)

getAllAndOverride 会返回第一个非空的 metadata。

我们试一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af05ff6a849642e799db7124c8425ab0~tplv-k3u1fbpfcp-watermark.image?)

可以看到它们结果的区别：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4af40c29df31495eb94d6636f3f1dece~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/metadata-and-reflector)。

## 总结

Nest 的装饰器的实现原理就是 Reflect.getMetadata、Reflect.defineMetadata 这些 api。通过在 class、method 上添加 metadata，然后扫描到它的时候取出 metadata 来做相应的处理来完成各种功能。

Nest 的 Controller、Module、Service 等等所有的装饰器都是通过 Reflect.meatdata 给类或对象添加元数据的，然后初始化的时候取出来做依赖的扫描，实例化后放到 IOC 容器里。

实例化对象还需要构造器参数的类型，这个开启 ts 的 emitDecoratorMetadata 的编译选项之后， ts 就会自动添加一些元数据，也就是 design:type、design:paramtypes、design:returntype 这三个，分别代表被装饰的目标的类型、参数的类型、返回值的类型。

当然，reflect metadata 的 api 还在草案阶段，需要引入 reflect metadata 的包做 polyfill。

Nest 还提供了 @SetMetadata 的装饰器，可以在 controller 的 class 和 method 上添加 metadata，然后在 interceptor 和 guard 里通过 reflector 的 api 取出来。

理解了 metadata，nest 的实现原理就很容易搞懂了。


## 130.Primsa Client 单表 CRUD 的全部 api

我们学了 Prisma 的命令、schema 的语法，这节来过一遍 Prisma Client 的 api。

这节只涉及单个表的 CRUD 的 api。

创建个新项目：

```
mkdir prisma-client-api
cd prisma-client-api
npm init -y
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8927d892bc04c8f95ac37a8fa63ab68~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=870&h=700&s=88483&e=png&b=000000)

进入项目，执行 init 命令：

```
npx prisma init
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29216dde7e8e40be94a8a27f85f0c4af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1010&h=624&s=105602&e=png&b=191919)

生成了 .env 和 schema 文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e97117aa3ef49aabf9227ec19601c79~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=484&h=276&s=27131&e=png&b=181818)

然后改下 .env 文件的数据库连接信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9260844466e7496fa11bdf18a5da4e14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1026&h=348&s=134798&e=png&b=202020)

```
DATABASE_URL="mysql://root:guang@localhost:3306/prisma_test"
```

改一下 datasource 的 provider 为 mysql，并且添加一个 model

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3627436dc9b44b1980c166c9aab0b952~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=820&h=554&s=75992&e=png&b=1f1f1f)

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Aaa {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

然后再添加一个 generator，生成 docs，并且修改下生成代码的位置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aea5f82f5ced4488bd21ef081c19d1c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=926&h=744&s=108104&e=png&b=1f1f1f)

```
generator docs {
  provider = "node node_modules/prisma-docs-generator"
  output   = "../generated/docs"
}
```

安装用到的 generator 包：
```
npm install --save-dev prisma-docs-generator
```
之后执行 migrate reset 重置下：

```
npx prisma migrate reset
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e525d0d9692940caac47a3a05eac11f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072&h=622&s=88219&e=png&b=191919)

之后用 migrate dev 创建新的迁移：

```
npx prisma migrate dev --name aaa
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18cf9ff25e54fe6817d96222111560b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=524&s=82026&e=png&b=191919)

可以看到，生成了 client 代码、docs 文档，还有 sql 文件。

数据库中也多了这个表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2258e881e16492fa0fdf673288e9ce4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082&h=576&s=178048&e=png&b=eeebea)

然后我们写下初始化数据的代码：

首先安装 ts、ts-node 包：

```
npm install typescript ts-node @types/node --save-dev
```
创建 tsconfig.json

```
npx tsc --init
```
把注释删掉，保留这些配置就行：

```json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "types": ["node"],
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}

```
在 package.json 配置下 seed 命令：

```json
"prisma": {
    "seed": "npx ts-node prisma/seed.ts"
},
```
然后写下 prisma/seed.ts

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function main() {
    await prisma.aaa.createMany({
        data: [
            {
                name: 'aaa',
                email: 'aaa@xx.com'
            },
            {
                name: 'bbb',
                email: 'bbb@xx.com'
            },
            {
                name: 'ccc',
                email: 'ccc@xx.com'
            },
            {
                name: 'ddd',
                email: 'ddd@xx.com'
            },
            {
                name: 'eee',
                email: 'eee@xx.com'
            },
        ]
    });
    console.log('done');
}

main();
```
很容易看懂，就是插入了 5 条记录。

执行 seed：

```
npx prisma db seed
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/686017ea7d974af1a6099bd45090b1f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1356&h=276&s=58495&e=png&b=181818)

打印了插入数据的 sql。

去 mysql workbench 里看下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69e797612cdd4212a1870bfcecaca825~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=970&h=510&s=160843&e=png&b=eeeae8)

插入成功了。

然后来写下 client 的 crud 代码。

创建 src/index.ts

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function main() {
    
}

main();
```

client 都有哪些方法呢？

我们不是还用 docs generator 生成了文档么？看下那个就知道了。

```
npx http-server ./generated/docs
```
跑一个静态服务：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/155c61bbec674cb7b3b517a2c94d6263~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=494&s=84095&e=png&b=181818)

访问 http://localhost:8080 可以看到 Aaa 的字段和方法，一共 9 个方法：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/448cbf3c64ea4bbba5af4c24124e4df4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=1112&s=169522&e=png&b=ffffff)

我们依次试一下：

## findUnique

findUnique 是用来查找唯一的记录的，可以根据主键或者有唯一索引的列来查：

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function test1() {
    const aaa = await prisma.aaa.findUnique({
        where: {
            id: 1
        }
    });
    console.log(aaa);

    const bbb = await prisma.aaa.findUnique({
        where: {
            email: 'bbb@xx.com'
        }
    });
    console.log(bbb);
}

test1();
```
所以，这里的 id、email 都可以：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af97ee8cd6824c95a5d0499111c25b4b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=726&h=220&s=31608&e=png&b=1f1f1f)

跑一下试试：

```
npx ts-node ./src/index.ts
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c17ddadffce045acb1d4f36d59812191~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1128&h=222&s=62804&e=png&b=191919)

但是如果指定 name 就不行了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecd8795097a44959ad84f2ffab871bb0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=562&h=242&s=27950&e=png&b=202020)

因为通过 name 来查并不能保证记录唯一。

你还可以通过 select 指定返回的列：

```javascript
async function test1() {
    const aaa = await prisma.aaa.findUnique({
        where: {
            id: 1
        }
    });
    console.log(aaa);

    const bbb = await prisma.aaa.findUnique({
        where: {
            email: 'bbb@xx.com'
        },
        select: {
            id: true,
            email: true
        }
    });
    console.log(bbb);
}
```

比如我通过 select 指定返回 id、email：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c1252b339db4a27a55025ddae309849~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=218&s=56218&e=png&b=191919)

那结果里就只包含这两个字段。

## findUniqueOrThrow

findUniqueOrThrow 和 findUnique 的区别是它如果没找到对应的记录会抛异常，而 findUnique 会返回 null。

先试下 findUnique：

```javascript

import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});


async function test2() {
    const aaa = await prisma.aaa.findUnique({
        where: {
            id: 10
        }
    });
    console.log(aaa);
}

test2();
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87f289e0f283403e992e1c3feb48f517~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1190&h=686&s=105718&e=png&b=1d1d1d)

再换成 findUniqueOrThrow 试试：

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function test2() {
    const aaa = await prisma.aaa.findUniqueOrThrow({
        where: {
            id: 10
        }
    });
    console.log(aaa);
}

test2();
```

如果没找到会抛异常：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9eec40cb4e445bebf8b878abc741d66~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=748&s=128181&e=png&b=1d1d1d)

## findMany

findMany 很明显是查找多条记录的。

比如查找 email 包含 xx 的记录，按照 name 降序排列：

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function test3() {
    const res = await prisma.aaa.findMany({
        where: {
            email: {
                contains: 'xx'
            }
        },
        orderBy: {
            name: 'desc'
        }
    });
    console.log(res);
}

test3();

```

跑一下：
```
npx ts-node ./src/index.ts
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f77efa5cabd4110ac425ce293950368~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=310&s=60018&e=png&b=181818)

然后再加个分页，取从第 2 条开始的 3 条。

```javascript
async function test3() {
    const res = await prisma.aaa.findMany({
        where: {
            email: {
                contains: 'xx'
            }
        },
        orderBy: {
            name: 'desc'
        },
        skip: 2,
        take: 3
    });
    console.log(res);
}
```
下标是从 0 开始的，所以是这三条：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f029c71fc64398a24adcd2cfc3937c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=824&h=272&s=49555&e=png&b=181818)

当然，你可以再加上 select 指定返回的字段：

```javascript
async function test3() {
    const res = await prisma.aaa.findMany({
        where: {
            email: {
                contains: 'xx'
            }
        },
        select: {
            id: true,
            email: true,
        },
        orderBy: {
            name: 'desc'
        },
        skip: 2,
        take: 3
    });
    console.log(res);
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/619979abd71149e9a279a21ce941ccdd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=246&s=47141&e=png&b=181818)

你会发现熟练 sql 之后，这些 api 用起来都很自然，过一遍就会了。

## findFirst

findFirst 和 findMany 的唯一区别是，这个返回第一条记录。

```javascript
async  function test4() {
    const res = await prisma.aaa.findFirst({
        where: {
            email: {
                contains: 'xx'
            }
        },
        select: {
            id: true,
            email: true,
        },
        orderBy: {
            name: 'desc'
        },
        skip: 2,
        take: 3
    });
    console.log(res);
}
test4();
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a3d3aa449a440dfbc5946c0aafd6af2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=714&h=146&s=34628&e=png&b=191919)

此外，where 条件这里可以指定的更细致：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/239d3681eed74917b35e7d0cf38f3926~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=726&h=650&s=59985&e=png&b=1f1f1f)

contains 是包含，endsWith 是以什么结尾

gt 是 greater than 大于，lte 是 less than or equal 大于等于

这些过滤条件都很容易理解，就不展开了。

此外，还有 findFirstOrThrow 方法，那个也是如果没找到，抛异常，参数和 FindFirst 一样。

## create

这个我们用过多次了，用来创建记录：

```javascript
async  function test5() {
    const res = await prisma.aaa.create({
        data: {
            name: 'kk',
            email: 'kk@xx.com'
        },
        select: {
            email: true
        }
    });
    console.log(res);
}
test5();
```
它同样也可以通过 select 指定插入之后再查询出来的字段。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c63f821b7a9845e385f3bb4b74c8ccb7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=224&s=53669&e=png&b=191919)

createMany 我们用过，这里就不测了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c94f7b2748f9498787cd63dd828c6025~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=980&s=92858&e=png&b=1f1f1f)

## update

update 明显是用来更新的。

它可以指定 where 条件，指定 data，还可以指定 select 出的字段：

```javascript
async function test6() {
    const res = await prisma.aaa.update({
        where: { id: 3 },
        data: { email: '3333@xx.com' },
        select: {
            id: true,
            email: true
        }
    });
    console.log(res);
}

test6();
```
跑一下：
```
npx ts-node ./src/index.ts
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b559edb67e0247a78566066a68a39d19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=302&s=66957&e=png&b=191919)

可以看到，打印了 3 条 sql：

首先根据 where 条件查询出这条记录，然后 update，之后再 select 查询出更新后的记录。

updateMany 自然是更新多条记录。

比如你想更新所有邮箱包含 xx.com 的记录为 666@xx.com

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5f1d297acf42f28f220bff549b3442~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=680&h=490&s=51454&e=png&b=1f1f1f)

用 update 会报错，它只是用来更新单条记录的，需要指定 id 或者有唯一索引的列。

这时候改成 udpateMany 就可以了。

```javascript
async function test7() {
    const res = await prisma.aaa.updateMany({
        where: { 
            email: {
                contains: 'xx.com'
            } 
        },
        data: { name: '666' },
    });
    console.log(res);
}

test7();
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ae34da887644228b96e35065eed5b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=766&h=182&s=35654&e=png&b=181818)

在 mysql workbench 里可以看到，确实改了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b450063af6f443cbbe3148db3cab91c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=558&h=362&s=91564&e=png&b=fafafa)

## upsert

upsert 是 update 和 insert 的意思。

当传入的 id 有对应记录的时候，会更新，否则，会创建记录。

```javascript
async function test8() {
    const res = await prisma.aaa.upsert({
        where: { id: 11 },
        update: { email: 'yy@xx.com' },
        create: { 
            id:  11,
            name: 'xxx',
            email: 'xxx@xx.com'
        },
    });
    console.log(res);
}

test8();
```
第一次跑执行的是 insert：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f322a5842c748c6a325970c04f0163e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=884&h=298&s=67052&e=png&b=191919)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a1c34df17d94668988ed26cdf77c744~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=606&h=376&s=101801&e=png&b=f9f9f9)

第二次跑就是 update 了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570a0212a0284695b4941bb4a4d298be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=832&h=306&s=67081&e=png&b=191919)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b69089861bf14b349c213a15fa6e3bca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=542&h=300&s=76891&e=png&b=fcfcfc)

## delete

delete 就比较简单了，我们和 deleteMany 一起测试下：

```javascript
async function test9() {
    await prisma.aaa.delete({
        where: { id: 1 },
    });

    await prisma.aaa.deleteMany({
        where: {
            id: {
                in: [11, 2]
            }
        }
    });
}

test9();
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f00108df717445488fe1cdc11245e0f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1310&h=242&s=72029&e=png&b=191919)

可以看到有两条 delete 语句。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a15026f6da7d4dabb5f9127292d03cee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=736&h=418&s=103698&e=gif&f=17&b=f8f8f8)

可以看到 3 条记录都被删除了。

## count

count 其实和 findMany 参数一样，只不过这里不返回具体记录，而是返回记录的条数。

比如 findMany 是这样的：

```javascript
async function test10() {
    const res = await prisma.aaa.findMany({
        where: {
            email: {
                contains: 'xx'
            }
        },
        orderBy: {
            name: 'desc'
        },
        skip: 2,
        take: 3
    });
    console.log(res);
}
test10();
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57fb1afa9463410eb26ed5daa5b05406~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=730&h=254&s=42719&e=png&b=181818)

把 findMany 改为 count 就是这样了：

```javascript
async function test10() {
    const res = await prisma.aaa.count({
        where: {
            email: {
                contains: 'xx'
            }
        },
        orderBy: {
            name: 'desc'
        },
        skip: 2,
        take: 3
    });
    console.log(res);
}
test10();
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3e688b042c4f6ea6c5ef3bd8e12e5e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=144&s=27187&e=png&b=181818)

## aggregate 

aggregate 是统计相关的。

它除了 where、orderBy、skip、take 这些参数外，还可以指定 _count、_avg、_sum、_min、_max
这些。

不过我们现在的表里没有数字相关的列。

改一下 model：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2661d3c4f5444433972546f4f499e7f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=814&h=510&s=70599&e=png&b=1f1f1f)

```
model Aaa {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  age Int       @default(0)
}
```

然后创建一个新的 migration：

```
npx prisma migrate dev --name bbb
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc6ee6e6538f43b8b850f06d452b21c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1134&h=524&s=87138&e=png&b=181818)

对应的 sql 如下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d282df2c9837454d825e4d8f6d6fc642~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1598&h=372&s=85466&e=png&b=1e1e1e)

然后我们用代码改一下：

```javascript
async function test11() {
    await prisma.aaa.update({
        where: {
            id: 3
        },
        data: {
            age: 3
        }
    });

    await prisma.aaa.update({
        where: {
            id: 5
        },
        data: {
            age: 5
        }
    });
}
test11();
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96087511c92d41aa86ef7457be55fb44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1140&h=522&s=124326&e=png&b=191919)

在 mysql workbench 里刷新下，可以看到确实改了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ff325c8e714542a3e24cac64bde57e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668&h=302&s=78342&e=png&b=f9f9f9)

接下来就可以测试 aggregate 方法了：

```javascript
async function test12() {
    const res = await prisma.aaa.aggregate({
        where: {
            email: {
                contains: 'xx.com'
            }
        },
        _count: {
            _all: true,
        },
        _max: {
            age: true
        },
        _min: {
            age: true
        },
        _avg: {
            age: true
        }
    });
    console.log(res);
}
test12();
```

跑一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba51d2dc388d4765b132bdc9baacc2d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=872&h=272&s=42847&e=png&b=181818)

可以看到返回的最大值、最小值、计数、平均值，都是对的。

## groupBy

最后还有个 groupBy 方法，大家有 sql 基础也很容易搞懂，这个就是分组的。

```javascript
async function test13() {
    const res = await prisma.aaa.groupBy({
        by: ['email'],
        _count: {
          _all: true
        },
        _sum: {
          age: true,
        },
        having: {
          age: {
            _avg: {
              gt: 2,
            }
          },
        },
    })
    console.log(res);
}

test13();

```
就是按照 email 分组，过滤出平均年龄大于 2 的分组，计算年龄总和返回。

结果如下：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9859da852ff044d1bca8e1b2d44b7b12~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=994&h=216&s=48182&e=png&b=181818)

因为 age 大于 2 的就 2 条，然后算平均值、计数，就是上面的结果了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cf5f033140f44cd8132804fa0044d04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702&h=254&s=61142&e=png&b=fcfcfc)

这样，我们就把所有 Prisma Client 的 api 过了一遍。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/prisma-client-api)

## 总结

这节我们过了一遍 Prisma Client 的单个表 CRUD 的 api。

分别包括 create、crateMany、update、updateMany、delete、deleteMany、findMany、findFirst、findFirstOrThrow、findUnique、findUniqueOrThrow。

以及 count、aggregate、groupBy 这些统计相关的。

其实有 sql 的基础的话，学习这些 api 很容易，过一遍就会了。


## 131.Prisma Client 多表 CRUD 的全部 api

上节我们过了一遍 Prisma Client 做 CRUD 的 api，但那只是针对单表的，这节我们把涉及到多表的 CRUD 的 api 过一遍。

创建个新项目：

```bash
mkdir prisma-client-api2 
cd prisma-client-api2 
npm init -y
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2d719a533be44b8968b41c74b03946d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=890&h=702&s=91178&e=png&b=000000)

进入项目，执行 init 命令：

```csharp
npx prisma init
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29216dde7e8e40be94a8a27f85f0c4af~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1010&h=624&s=105602&e=png&b=191919)

生成了 .env 和 schema 文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51cd28df37d6483abc67cffc76b7cc3e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=512&h=192&s=18392&e=png&b=1e1e1e)

然后改下 .env 文件的数据库连接信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9260844466e7496fa11bdf18a5da4e14~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1026&h=348&s=134798&e=png&b=202020)

```ini
DATABASE_URL="mysql://root:guang@localhost:3306/prisma_test"
```

改一下 datasource 的 provider 为 mysql，并且添加 model

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f083c8dc5c741679379620c15723342~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1358&h=956&s=184756&e=png&b=1f1f1f)

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Department {
  id        Int    @id @default(autoincrement())
  name      String  @db.VarChar(20)
  createTime DateTime @default(now())
  updateTime DateTime @updatedAt
  employees     Employee[]
}

model Employee {
  id         Int       @id @default(autoincrement())
  name      String     @db.VarChar(20)
  phone     String     @db.VarChar(30)  

  deaprtmentId Int
  department     Department      @relation(fields: [deaprtmentId], references: [id])
}
```

之后执行 migrate reset 重置下：

```perl
npx prisma migrate reset
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e525d0d9692940caac47a3a05eac11f7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1072&h=622&s=88219&e=png&b=191919)

然后用 migrate dev 创建新的迁移：

```css
npx prisma migrate dev --name aaa
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9a0b116589243d2af8cf1c55ea02d1b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1188&h=560&s=87234&e=png&b=191919)

生成了 client 代码，还有 sql 文件。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a129c832d88b4cd1ae85015353b95a20~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2034&h=1060&s=291405&e=png&b=1e1e1e)

数据库中也多了这 2 个表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55197603cc2d40a089abacdd197abea1~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1070&h=484&s=156945&e=png&b=f0eded)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f087fe832374ad8b88c5f9e684e350c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1012&h=406&s=114606&e=png&b=f0eded)

然后来写下 client 的 crud 代码。

首先安装 ts、ts-node 包：

```sql
npm install typescript ts-node @types/node --save-dev
```

创建 tsconfig.json

```csharp
npx tsc --init
```

把注释删掉，保留这些配置就行：

```json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "types": ["node"],
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```

创建 src/index.ts

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function main() { 
}

main();
```

然后分别做下 CRUD。

首先是插入数据：

```javascript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query'
    },
  ],
});

async function test1() {
   await prisma.department.create({
        data: {
            name: '技术部',
            employees: {
                create: [
                    {
                        name: '小张',
                        phone: '13333333333'
                    },
                    {
                        name: '小李',
                        phone: '13222222222'
                    }
                ]
            }
        }
   })
}

test1();
```

插入关联 model 的数据的时候，也是用 create 指定：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/634ccb2291f44010a91f42fad5191a15~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=922&h=880&s=93789&e=png&b=1f1f1f)

测试下：

```bash
npx ts-node ./src/index.ts
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99422760137c4c939fd32afd811a17b8~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1374&h=242&s=81019&e=png&b=191919)

在 mysql workbench 里看下结果：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e20e8a26e5254d6aadcaea6853bcd75e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1306&h=452&s=146375&e=png&b=f0eded)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/393d9cb0043f4d2eb89d4e90687e6887~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1074&h=454&s=144846&e=png&b=efeceb)

确实，数据都被正确插入了。

当然，你也可以用这种写法：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6fde3edfc2b49e3b2194a0d2ece5e6a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=904&h=868&s=93803&e=png&b=1f1f1f)

```javascript
async function test2() {
    await prisma.department.create({
         data: {
             name: '技术部',
             employees: {
                 createMany: {
                    data: [
                        {
                            name: '小王',
                            phone: '13333333333'
                        },
                        {
                            name: '小周',
                            phone: '13222222222'
                        }
                    ],

                 }
             }
         }
    })
}

test2();
```

跑一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86cba5416ddc402c9d29b8f0d01ceb4a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=912&h=210&s=55131&e=png&b=191919)

效果一样：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/394a883a6ee04d4499305daa12653dac~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=796&h=204&s=75130&e=png&b=fbfbfb)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a4e6050a5af47b3aaafd7820f7959ca~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=580&h=306&s=71258&e=png&b=f8f8f8)

那如何关联查询呢？

可以这样写：

```javascript
async function test3() {
    const res1 = await prisma.department.findUnique({
        where: {
            id: 1
        },
        include: {
            employees: true
        }
    });
    console.log(res1);

    const res2 = await prisma.department.findUnique({
        where: {
            id: 1
        },
        include: {
            employees: {
                where: {
                    name: '小张'
                },
                select: {
                    name: true
                }
            }
        }
    });
    console.log(res2);

    const res3 = await prisma.department.findUnique({
        where: {
            id: 1
        }
    }).employees();
    console.log(res3);
}

test3();
```

查询 department 的时候，通过 include 指定关联查询出 employees。

include 还可以指定 where 等查询的参数，进一步过滤。

此外，你也可以在查出 department 后调用 empolyees() 方法来查询。

可以看到，都能正确查出关联数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/483173bf0da443ada07efb5a0dc36b61~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1164&h=934&s=202146&e=png&b=191919)

再就是关联更新：

```javascript
async function test4() {
    const res1 = await prisma.department.update({
        where: {
            id: 1
        },
        data: {
            name: '销售部',
            employees: {
                create: [
                    {
                        name: '小刘',
                        phone: '13266666666'
                    }
                ]
            }
        }
    });
    console.log(res1);
}

test4();
```

比如我在更新 department 的时候关联插入了一条 employee 的记录。

跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef0fdb1edee04269a19ffe5d9bab87ce~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1078&h=442&s=97332&e=png&b=181818)

在 mysql workbench 里可以看到，id 为 1 的 department 更新了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f714834fc2ee442b8daee35721af79bd~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=824&h=224&s=69443&e=png&b=f7f7f7)

关联插入了一条 employee 的记录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95da0f1b5624d1a84b72e659dbd33d4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=566&h=334&s=79102&e=png&b=f7f7f7)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8fe049ad64a4c53ae8ad7e66705aee9~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=582&h=312&s=86589&e=png&b=f9f9f9)

更新 department 的时候，除了可以插入 empolyee 的数据，也可以和别的 empolyee 建立关联。

比如 id 为 4 的 empolyee：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cbfe2b5b54b4bd48b4aae7306894b6c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=566&h=348&s=87349&e=png&b=f9f9f9)

现在他关联的是 id 为 2 的 department。

我们 update 的时候使用 connect 和它关联：

```javascript
async function test5() {
    const res1 = await prisma.department.update({
        where: {
            id: 1
        },
        data: {
            name: '销售部',
            employees: {
                connect: [
                    {
                        id: 4
                    }
                ]
            }
        }
    });
    console.log(res1);
}
test5();
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45b36288047e45b185047c5913776413~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=848&h=770&s=89854&e=png&b=1f1f1f)

跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/502561f1da854860b6baf9a8159191d7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=828&h=442&s=88252&e=png&b=181818)

刷新可以看到，id 为 4 的 employee 关联的 department 就变了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d001d81bf504470792dd59b534139231~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=570&h=314&s=85581&e=png&b=fafafa)

如果是某个 id 的数据存在就 connect，不存在就 create 呢？

可以这样写：

```javascript
async function test6() {
    const res1 = await prisma.department.update({
        where: {
            id: 1
        },
        data: {
            name: '销售部',
            employees: {
                connectOrCreate: {
                    where: {
                        id: 6
                    },
                    create: {
                        id: 6,
                        name: '小张',
                        phone: '13256665555'
                    }
                }
            }
        }
    });
    console.log(res1);
}
test6();
```

第一次跑，执行的是 insert：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d7ca69a88d64e40bb52bf841560fd2c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=890&h=484&s=99574&e=png&b=181818)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/624fbc54470b4f1fb349cdfc8c13aee0~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=552&h=342&s=95419&e=png&b=fafafa)

第二次跑，就是 update 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d52d7347cdc4d0280cb3a54f30561ba~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1222&h=496&s=112662&e=png&b=181818)

也就是说，update 的时候可以通过 create、connect、connectOrCreate 来插入新的关联 model 的记录或者关联已有的记录。

当然，create 的时候也可以这样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c53b43c1124444939e8ed8bcf99ef7b7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=658&h=386&s=54689&e=png&b=202020)

效果一样，就不一个个测试了。

再就是删除：

如果我们想删除 id 为 1 的 department 的所有 empolyee，可以这样写：

```javascript
async function test7() {
    await prisma.employee.deleteMany({
        where: {
            department: {
                id: 1
            }
        },
    });
}
test7();
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/767766da6f174af2a443da2fdb9a75c7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=892&h=148&s=37877&e=png&b=191919)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f916a94bfa2745648c0b6c3ba2f94e7d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=706&h=378&s=100166&e=gif&f=18&b=f7f7f7)

这就是多个 model 关联时的 CRUD。

此外，Prisma 还可以直接执行 sql：

```javascript
async function test8() {
    await prisma.$executeRaw`TRUNCATE TABLE Employee`;

    const res = await prisma.$queryRaw`select * from Department`;
    console.log(res);
}
test8();
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c7d176c1f8444d0975bc83e700e67a3~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=708&h=502&s=68097&e=png&b=181818)

这样，当上面的 api 都不能满足需求的时候，你就可以直接执行 sql。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/prisma-client-api2)

## 总结

这节我们过了一遍多 model 关联的时候涉及到多个表的 CRUD 方法。

还是 findXxx、updateXxx、deleteXxx、createXxx 那些方法，只不过查询的时候可以通过 include 包含关联记录，新增修改的时候可以通过 create、connect、connectOrCreate 来关联或者插入记录。

此外，你还可以直接执行 sql。

通过这些 api，我们就能完成各种 CRUD 需求了。

## 132.在 Nest 里集成 Prisma

我们学 Prisma，最终还是要和 Nest 结合用的，就像我们学 TypeORM 时那样。

其实也很简单，还是基于 schema 生成 client 的 api，然后调用这些 api 来 CRUD。

只不过 Nest 里的调用方式不大一样。

我们新建个 nest 项目：

```
nest new nest-prisma-test
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/089216ef997c41be989759f60a74b76e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=666&s=266810&e=png&b=020202)

进入项目，安装 prisma

```
npm install prisma --save-dev
```
然后执行 init 创建 schema 文件：

```
npx prisma init
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea10e80f6fd04d7892d98c540a50c1ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1068&h=504&s=98914&e=png&b=181818)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3209bcf5edca44bb8d55d080464cfb3d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1220&h=536&s=111764&e=png&b=1d1d1d)

改下 .env 的配置：

```
DATABASE_URL="mysql://root:guang@localhost:3306/prisma_test"
```
并且修改下 schema 里的 datasource 部分：

```
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

```

然后创建 model：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c549d1d792aa4eb8b177c67ae9a7faee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1406&h=920&s=183023&e=png&b=1f1f1f)

```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Department {
  id        Int    @id @default(autoincrement())
  name      String  @db.VarChar(20)
  createTime DateTime @default(now())
  updateTime DateTime @updatedAt
  employees     Employee[]
}

model Employee {
  id         Int       @id @default(autoincrement())
  name      String     @db.VarChar(20)
  phone     String     @db.VarChar(30)  

  deaprtmentId Int
  department     Department      @relation(fields: [deaprtmentId], references: [id])
}
```

这里就是 Department、Employee 两个 model，之间是一对多的关系。

然后先 migrate reset，重置下数据库：

```
npx prisma migrate reset 
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb18945e33674215bf629c4c44146940~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=584&s=89806&e=png&b=191919)

然后创建新的 migration:

```
npx prisma migrate dev --name init
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dee7c45a681f432596ed1a5e94d49477~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1134&h=498&s=77658&e=png&b=191919)

这时候数据库就就有这两个表了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9dce99f9e864813855eecba63ed88a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1088&h=428&s=135687&e=png&b=eceae9)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c81ec506a8b4421bb748af4c2077f83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020&h=396&s=122940&e=png&b=eeebeb)

外键约束也创建好了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff8151898fa241e3acc44f4964299c6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1822&h=358&s=112063&e=png&b=f2f0f0)

并且 migrate dev 还会生成 client 代码，接下来我们就可以直接来做 CRUD 了。

问题来了：之前我们都是直接 ts-node 跑的一个脚本，里面调用 client 的 api 来做 CRUD，现在和 Nest 集成后怎么做呢？

很简单，创建个 Service 就好了。

```
nest g service prisma --flat --no-spec
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e373e6c5051744d6b466a0cc0af56f12~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=692&h=94&s=27645&e=png&b=191919)

改下 PrismaService，继承 PrismaClient，这样它就有 crud 的 api 了：

```javascript
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {

    constructor() {
        super({
            log: [
                {
                    emit: 'stdout',
                    level: 'query'
                }
            ]
        })
    }

    async onModuleInit() {
        await this.$connect();
    }
}
```
在 constructor 里设置 PrismaClient 的 log 参数，也就是打印 sql 到控制台。

在 onModuleInit 的生命周期方法里调用 $connect 来连接数据库。

然后再创建两个 service：

```
nest g service department --flat --no-spec
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76f386beb84444cdb5a33d6d2905e232~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=736&h=94&s=25816&e=png&b=191919)

```
nest g service employee --flat --no-spec
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ae95fadb1c540c192b28663542c0152~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=686&h=106&s=30956&e=png&b=191919)

这俩 service 里注入 PrismaService，不就可以 CRUD 了么？

改下 DepartmentService：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { Prisma } from '@prisma/client';

@Injectable()
export class DepartmentService {

    @Inject(PrismaService)
    private prisma: PrismaService;

    async create(data: Prisma.DepartmentCreateInput) {
        return await this.prisma.department.create({
            data,
            select: {
                id: true
            }
        });
    }
}
```
插入数据之后，再把 id 查询出来返回。

这里的 data 的 ts 类型不用自己定义，生成的 client 代码里有。

输入 Prisma.Deparment 就会提示出来

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed0d441e0e0648e49f8f22a26e29c1ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1066&h=408&s=104579&e=png&b=202020)

还有 EmployeeService：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { Prisma } from '@prisma/client';

@Injectable()
export class EmployeeService {

    @Inject(PrismaService)
    private prisma: PrismaService;

    async create(data: Prisma.EmployeeCreateInput) {
        return await this.prisma.employee.create({
            data,
            select: {
                id: true
            }
        });
    }
}

```
也定义了 create 方法。

然后在 AppController 里注入这俩 service：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64bbe39372e04d8884c7a31b839ae9c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1112&h=1060&s=180016&e=png&b=1f1f1f)

声明一个 create 的路由，里面创建一个 department，再创建一个 employee。

empolyee 通过 id 关联这个 department。

```javascript
import { Controller, Get, Inject } from '@nestjs/common';
import { AppService } from './app.service';
import { DepartmentService } from './department.service';
import { EmployeeService } from './employee.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Inject(DepartmentService)
  private departmentService: DepartmentService;

  @Inject(EmployeeService)
  private employeeService: EmployeeService;

  @Get('create')
  async create() {
    const department = await this.departmentService.create({
      name: '技术部'
    });

    await this.employeeService.create({
      name: '张三',
      phone: '13222222222',
      department: {
        connect: {
          id: department.id
        }
      }
    });

    return 'done';
  }
}
```
把 nest 项目跑起来：

```
npm run start:dev
```
浏览器访问下 http://localhost:3000/create

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97accd6e7c8844c4a2a108dfe1ed31b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=636&h=212&s=17925&e=png&b=ffffff)

生成了 2 条 insert 语句：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82fe7c328ea74a11919c048fd0c18ebe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1362&h=616&s=209330&e=png&b=181818)

在 mysql workbench 里也可以看到插入的 2 条记录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a32a07bb02346e4ab1746333f0c3f0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=196&s=58378&e=png&b=f8f8f8)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e75179a690674f8ca1cb536ec795c181~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=572&h=226&s=39386&e=png&b=f6f6f6)

这样，prisma 和 nest 的集成就完成了。

当然，我们只是测试了 create 方法，其余的 api 也是一样的，就不展开了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-prisma-test)

## 总结

这节我们做了 Prisma 和 Nest 的集成。

其实还是先用 prisma init 创建 schema 文件，然后修改 model 后用 prisma migrate dev 同步到数据库和生成 client 代码。

只不过之后使用 client 代码的方式不同。

我们创建了个 Service 继承 PrismaClient，在 constructor 里设置初始化参数。

之后把这个 service 的实例注入到别的 service 里，就可以做 CRUD 了。

这样，Prisma 怎么和 Nest 集成，我们就学会了。


## 133.为什么前端监控系统要用 RabbitMQ？

前端监控系统是采集用户端的异常、性能、业务埋点等数据上报，在服务端做存储，并支持可视化分析的平台。

用户量可能很大，采集的数据可能比较多，这时候服务端的并发压力会比较大，要是直接存入数据库，那数据库服务很可能会崩掉。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5ecdcb680cd4014a13e85c2c9b60b00~tplv-k3u1fbpfcp-watermark.image?)

那就用现在的数据库，如何保证面对大量并发请求的时候，服务不崩呢？

答案就是消息队列，比如常用的 RabbitMQ：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbbb2b6a4a8343faaefe616d7106596f~tplv-k3u1fbpfcp-watermark.image?)

第一个 web 服务接收请求，把消息存入 RabbitMQ，然后另一个 web 服务从 MQ 中取出消息存入数据库。

有同学说，这不是一样么？

不一样，MQ 的并发量比数据库高很多。之前 web 服务要等数据库存储完成才能响应，而现在只存入 MQ 就可以响应了。那可以支持的并发量就更多。

而数据库的并发比较低，我们可以通过 MQ 把消费的上限调低，就能保证数据库服务不崩。

比如 10w 的消息进来，每次只从中取出 1000 来消费：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e28327a1056a465ca536e4936352fad2~tplv-k3u1fbpfcp-watermark.image?)

并发量被控制住了，自然就崩不了了，从 MQ 中取出慢慢处理就好了。

这就是 MQ 的流量削峰的功能。

而且完全可以加几个 web 服务来同时消费 MQ 中的消息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/704ce4c856b14477b876c748f6ac05f5~tplv-k3u1fbpfcp-watermark.image?)

知道了 RabbitMQ 能干啥，那我们就来用一下试试吧！

我们通过 docker 来跑 RabbitMQ。

搜索 rabbitmq 的镜像，选择 3.11-management 的版本：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f243a0274dab460e93fca9449bd6eae8~tplv-k3u1fbpfcp-watermark.image?)

这个版本是有 web 管理界面的。

点击 run：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c676b36fe21145a3bd903519638ee17c~tplv-k3u1fbpfcp-watermark.image?)

映射容器内的 5672、15672 这俩端口到本地的端口。

15672 是管理界面的，5672 是 mq 服务的端口。

等 rabbitmq 跑起来之后：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c9bcc0b2bb64207bd019c51880f6669~tplv-k3u1fbpfcp-watermark.image?)

就可以在浏览器访问 http://localhost:15672 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ad9966bc5d54e158ec64a1072108c63~tplv-k3u1fbpfcp-watermark.image?)

这就是它的 web 管理界面。

输入 guest、guest 进入管理页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/473961bfb209489e843f6b3ae9c6db0c~tplv-k3u1fbpfcp-watermark.image?)

可以看到 connection、channel、exchange、queue 的分别的管理页面。

这些都是什么呢？

写个 demo 就理解了：

创建个项目：

```
mkdir rabbitmq-test

cd rabbitmq-test

npm init -y
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1429cd094f614fd7a553457ba79896da~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=660&s=130464&e=png&b=010101)

安装用到的包：

```
npm install amqplib
```
创建 src/producer.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertQueue('aaa');
await channel.sendToQueue('aaa',Buffer.from('hello'))
```
安装 amqplib 的包，这个是 rabbitmq 的 node 客户端（amqp 是 rabbitmq 的协议）。

上面的代码连接了 rabbitmq 服务，创建了一个名字为 aaa 的队列，并向队列中发送了一个消息。

然后 node 跑一下：

```
node ./src/producer.js
```
 （这里要用 es module 语法并且支持顶层 await 需要在 packege.json 里设置 type 为 module）
 
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdfa52e57d014dd6b6513a74485c251d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=674&h=454&s=62197&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/887379f89b7b463dbc5d422874e37dd0~tplv-k3u1fbpfcp-watermark.image?)

之后就可以在管理界面看到这个队列了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a80df3dbbbe2437790c034618ac7a0c3~tplv-k3u1fbpfcp-watermark.image?)

然后我们再写一个消费端 src/consumer.js：

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

const { queue } = await channel.assertQueue('aaa');
channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
assertQueue 是如果没有就创建队列，有的话就直接返回。

这里取到那个队列，就可以从中消费消息了：

```
node src/consumer.js
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ddba08a7bd54fb9bf321201b3b8886d~tplv-k3u1fbpfcp-watermark.image?)

这样，我们就完成了第一次 RabbitMQ 的通信，两个服务之间也是这样通信的。

是不是还挺简单的？

rabbitmq 使用确实挺简单。

那怎么控制并发数呢？

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc4fb3fe4c97488491dfc4dc8e7b7518~tplv-k3u1fbpfcp-watermark.image?)

我们改一下 src/producer.js：

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertQueue('aaa', {durable: false});

let i = 1;
setInterval(async () => {
    const msg = 'hello' + i;
    console.log('发送消息：', msg);
    await channel.sendToQueue('aaa',Buffer.from(msg))
    i++;
}, 500);
```

生产者每 0.5s 发送一次消息。

消费者每 1s 处理一条消息：

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

const { queue } = await channel.assertQueue('aaa');
channel.prefetch(3);

const currentTask = [];
channel.consume(queue, msg => {
    currentTask.push(msg);
    console.log('收到消息：', msg.content.toString());
}, { noAck: false });

setInterval(() => {
    const curMsg = currentTask.pop();
    channel.ack(curMsg);
}, 1000);
```
每条消费者收到的消息要确认之后才会在 MQ 里删除。可以收到消息自动确认，也可以手动确认。

这里我把 noAck 设置为 false 了，也就是不自动确认。

把收到的消息放入一个数组中，每 1s 确认一次。

然后我设置了 prefetch 为 3，也就是每次最多取回 3 条消息来处理。

跑一下试试：

消息生产端：

```
node ./src/producer.js
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cb548997f7b4d96ad512958498d1ba9~tplv-k3u1fbpfcp-watermark.image?)

消息消费端：
```
node ./src/consumer.js
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34b9eaae95154945bec2c4facf9e2878~tplv-k3u1fbpfcp-watermark.image?)

可以看到生产者是每 0.5s 往队列里放一条消息。

消费者一开始取出 3 条，然后每处理完一条取一条，保证最多并发处理 3 条。

这就是流量削峰的功能。

不同服务之间的速度差异可以通过 MQ 来缓冲。

大概了解了 rabbitmq 之后，我们来看看它的整体架构图：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a89ebbdbe9054f698d926b10a1476e0b~tplv-k3u1fbpfcp-watermark.image?)

Producer 和 Consumer 分别是生产者和消费者。

Connection 是连接，但我们不会每用一次 rabbitmq 就创建一个单独的 Connection，而是在一个 Connection 里做一下划分，叫做 Channel，每个 Channel 做自己的事情。

而 Queue 就是两端存取消息的地方了。

整个接收消息和转发消息的服务就叫做 Broker。

至于 Exchange，我们前面的例子没有用到，这个是把消息放到不同的队列里用的，叫做交换机。

我们前面生产者和消费者都是直接指定了从哪个队列存取消息，那如果是一对多的场景呢？

总不能一个个的调用 sendQueue 发消息吧？

这时候就要找一个 Exchange（交换机） 来帮我们完成把消息按照规则放入不同的 Queue 的工作了。

Exchange 主要有 4 种：

- fanout：把消息放到这个交换机的所有 Queue
- direct：把消息放到交换机的指定 key 的队列
- topic：把消息放到交换机的指定 key 的队列，支持模糊匹配
- headers：把消息放到交换机的满足某些 header 的队列

一个个来试下：

首先是 direct，生产者端 src/direct.js：

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange', 'direct');

channel.publish('direct-test-exchange', 'aaa',  Buffer.from('hello1'));
channel.publish('direct-test-exchange', 'bbb',  Buffer.from('hello2'));
channel.publish('direct-test-exchange', 'ccc',  Buffer.from('hello3'));
```

不再是直接 sendToQueue 了，而是创建一个 exchange，然后调用 publish 往这个 exchange 发消息。

其中第二个参数是 routing key，也就是消息路由到哪个队列。

然后创建两个消费者：

src/direct-consumer1.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

const { queue } = await channel.assertQueue('queue1');
await channel.bindQueue(queue,  'direct-test-exchange', 'aaa');

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
src/direct-consumer2.js
```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

const { queue } = await channel.assertQueue('queue2');
await channel.bindQueue(queue,  'direct-test-exchange', 'bbb');

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });

```

分别创建 queue1 和 queue2 两个队列，绑定到前面创建的 direct-test-exchange 这个交换机上，指定了路由 key 分别是 aaa 和 bbb。

然后把生产者和两个消费者跑起来。

```
node src/direct.js
```
```
node src/direct-consumer1.js
```
```
node src/direct-consumer2.js
```
就可以看到队列 queue1 和 queue2 分别接收到了对应的消息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bda9d30c18004d9db0f96e146725f2f6~tplv-k3u1fbpfcp-watermark.image?)

这就是通过 direct 交换机发送消息的过程。

在管理页面上也可以看到这个交换机的信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3258c8cf6c824ffcbe2e7a67f1436fce~tplv-k3u1fbpfcp-watermark.image?)

包括 exchange 下的两个 queue 以及各自的 routing key。

再来试下 topic 类型的 Exchange。

src/topic.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange2', 'topic');

channel.publish('direct-test-exchange2', 'aaa.1',  Buffer.from('hello1'));
channel.publish('direct-test-exchange2', 'aaa.2',  Buffer.from('hello2'));
channel.publish('direct-test-exchange2', 'bbb.1',  Buffer.from('hello3'));
```

生产者端创建叫 direct-test-exchange2 的 topic 类型的 Exchange，然后发三条消息。

创建两个消费端：

src/topic-consumer1.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange2', 'topic');

const { queue } = await channel.assertQueue('queue1');
await channel.bindQueue(queue,  'direct-test-exchange2', 'aaa.*');

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
src/topic-consumer2.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange2', 'topic');

const { queue } = await channel.assertQueue('queue2');
await channel.bindQueue(queue,  'direct-test-exchange2', 'bbb.*');

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
两个消费者端分别创建 queue1 和 queue2 两个队列，绑定到 direct-test-exchange2 的交换机下。

指定路由 key 分别为 aaa.* 和 bbb.*，这里的 * 是模糊匹配的意思。

消费者端也 assertExchange 了，如果不存在就创建，保证 exchange 一定存在。

然后跑一下：
```
node src/topic.js
```
```
node src/topic-consumer1.js
```
```
node src/topic-consumer2.js
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69749640c4944b69a3a35c8ab507dee6~tplv-k3u1fbpfcp-watermark.image?)

可以看到，两个消费者分别收到了不同 routing key 对应的消息。

当然，在管理界面这里也是可以发消息的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc3ba57519b544e2b634fb9587147d72~tplv-k3u1fbpfcp-watermark.image?)

消费者端同样可以收到：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e84f01e1f3d4f0592b698411b203845~tplv-k3u1fbpfcp-watermark.image?)

这就是 topic 类型的交换机，可以根据模糊匹配 routing key 来发消息到不同队列。

再来试下 fanout 类型的 exchange：

生产者：

src/fanout.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange3', 'fanout');

channel.publish('direct-test-exchange3', '',  Buffer.from('hello1'));
channel.publish('direct-test-exchange3', '',  Buffer.from('hello2'));
channel.publish('direct-test-exchange3', '',  Buffer.from('hello3'));
```
消费者：

src/fanout-consumer1.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange3', 'fanout');

const { queue } = await channel.assertQueue('queue1');
await channel.bindQueue(queue,  'direct-test-exchange3', 'aaa');

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
src/fanout-consumer2.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange3', 'fanout');

const { queue } = await channel.assertQueue('queue2');
await channel.bindQueue(queue,  'direct-test-exchange3', 'bbb');

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
fanout 是广播消息到 Exchange 下的所有队列，不需要指定 routing key，计算指定了也会忽略。

跑起来可以看到，两个消费者都收到了消息：
```
node src/fanout.js
```
```
node src/fanout-consumer1.js
```
```
node src/fanout-consumer2.js
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dbb1165aa5f441eaf7056f6dc39b762~tplv-k3u1fbpfcp-watermark.image?)

这就是 fanout 类型交换机的特点，广播消息到所有绑定到它的 queue。

最后再来看下 headers 类型的 Exchange，这个不是根据 routing key 来匹配了，而是根据 headers：

生产者端：

src/headers.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange4', 'headers');

channel.publish('direct-test-exchange4', '',  Buffer.from('hello1'), {
    headers: {
        name: 'guang'
    }
});
channel.publish('direct-test-exchange4', '',  Buffer.from('hello2'), {
    headers: {
        name: 'guang'
    }
});
channel.publish('direct-test-exchange4', '',  Buffer.from('hello3'), {
    headers: {
        name: 'dong'
    }
});
```
消费者端：

src/headers-consumer1.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange4', 'headers');

const { queue } = await channel.assertQueue('queue1');
await channel.bindQueue(queue,  'direct-test-exchange4', '', {
    name: 'guang'
});

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
src/headers-consumer2.js

```javascript
import * as amqp from 'amqplib'

const connect = await amqp.connect(`amqp://localhost:5672`);
const channel = await connect.createChannel();

await channel.assertExchange('direct-test-exchange4', 'headers');

const { queue } = await channel.assertQueue('queue2');
await channel.bindQueue(queue,  'direct-test-exchange4', '', {
    name: 'dong'
});

channel.consume(queue, msg => {
    console.log(msg.content.toString())
}, { noAck: true });
```
跑起来是这样的：
```
node src/headers.js
```
```
node src/headers-consumer1.js
```
```
node src/headers-consumer2.js
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73fd42e8ba24443198296501984c1d76~tplv-k3u1fbpfcp-watermark.image?)

很容易理解，只是从匹配 routing key 变成了匹配 header。

这就是 Exchange，当你需要一对多发消息的时候，就可以选择这些类型的交换机。

回过头来，我们来总结下 rabbitmq 解决了什么问题：

- **流量削峰**：可以把很大的流量放到 mq 种按照一定的流量上限来慢慢消费，这样虽然慢一点，但不至于崩溃。
- **应用解耦**：应用之间不再直接依赖，就算某个应用挂掉了，也可以再恢复后继续从 mq 中消费消息。并不会一个应用挂掉了，它关联的应用也挂掉。

比如前端监控系统的后端服务，就很适合使用 mq 来做流量削峰。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/rabbitmq-test)

## 总结
前端监控系统会收到很多来自用户端的请求，如果直接存入数据库很容易把数据库服务搞挂掉，所以一般会加一个 RabbitMQ 来缓冲。

它是生产者往 queue 里放入消息，消费者从里面读消息，之后确认消息收到的流程。

当一对多的时候，还要加一个 Exchange 交换机来根据不同的规则转发消息：

- direct 交换机：根据 routing key 转发消息到队列
- topic 交换机：根据 routing key 转发消息到队列，支持模糊匹配
- headers 交换机：根据 headers 转发消息到队列
- fanout 交换机：广播消息到交换机下的所有队列

而且消费者可以设置一个消费的并发上限，这样就可以保证服务不会因并发过高而崩溃。

这就是流量削峰的功能。

RabbitMQ 在后端系统中经常能见到，是很常用的中间件。


## 14.Module 和 Provider 的循环依赖怎么处理？

Nest 实现了一套模块系统，模块可以通过 imports 声明对其他模块的引用。

那 Module 和 Module 如果相互引用、形成循环依赖了怎么办？

这节我们就来学习下循环依赖的处理方式。

执行

```
nest new module-test -p npm
```
创建一个 nest 项目。

然后执行
```
nest g module aaa
nest g module bbb
```
创建两个 Module。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b145b0bb0e9b4f859c9d75d048a659bd~tplv-k3u1fbpfcp-watermark.image?)

然后这两个 Module 相互引用。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b52f40029b84469fa53c670856d62fb6~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31b0562d4fa948c18624a0889f2c247b~tplv-k3u1fbpfcp-watermark.image?)

这时候你执行

```
nest start -w
```
把服务跑起来，会报这样的错误：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0894ff37cf7a42cab36ca61ea7cad9bc~tplv-k3u1fbpfcp-watermark.image?)

意思是在解析 BbbModule 的时候，它的第一个 imports 是 undefined。

这有两个原因，一个是这个值本来就是 undefined，第二个就是形成了循环依赖。

因为 Nest 创建 Module 的时候会递归创建它的依赖，而它的依赖又依赖了这个 Module，所以没法创建成功，拿到的就是 undefined。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bda90b0fd1e4f0fbd4f872e2c7ae327~tplv-k3u1fbpfcp-watermark.image?)

那怎么办呢？

其实我们可以先单独创建这两个 Module，然后再让两者关联起来。

也就是用 forwardRef 的方式：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f2e08ce8fb944868db92d7be777331c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae2d5625c504e21a3c5330aabc13231~tplv-k3u1fbpfcp-watermark.image?)

因为我们用了 nest start --watch 的方式启动的，nest 会自动重启，这时候就没有错误了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfaf18c45ea04f99b78f0e82ec140446~tplv-k3u1fbpfcp-watermark.image?)

nest 会单独创建两个 Module，之后再把 Module 的引用转发过去，也就是 forwardRef 的含义。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd11a70d489e49109dd1dbfe472fb733~tplv-k3u1fbpfcp-watermark.image?)

除了 Module 和 Module 之间会循环依赖以外，provider 之间也会。

比如 Service 里可以注入别的 Service，自身也可以用来注入。

所以也会有循环引用。

我们来测试下：

```
nest g service ccc --no-spec --flat
nest g service ddd --no-spec --flat
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c377ed6b535a4a649b65fbaa3258b71c~tplv-k3u1fbpfcp-watermark.image?)

分别创建 ccc 和 ddd 两个 service，--no-spec 是不生成测试文件，--flat 是平铺。

就会创建这两个 service，并在 AppModule 引入了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958176426526409aba5af44f47d7af98~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4455caf154c24001bc67a5a31ada8ae7~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec94f9a9eb849e8bf5011735555a8d8~tplv-k3u1fbpfcp-watermark.image?)

然后我们让两者相互注入：

```javascript
import { Injectable } from '@nestjs/common';
import { CccService } from './ccc.service';

@Injectable()
export class DddService {
    constructor(private cccService: CccService) {}

    ddd() {
        return this.cccService.ccc()  + 'ddd';
    }
}
```

```javascript
import { Injectable } from '@nestjs/common';
import { DddService } from './ddd.service';

@Injectable()
export class CccService {
    constructor(private dddService: DddService) {}

    ccc() {
        return 'ccc';
    }

    eee() {
        return this.dddService.ddd() + 'eee';
    }
}
```

两个 service 分别依赖了对方的方法。

在 AppService 里调用下：

```javascript
import { Injectable } from '@nestjs/common';
import { CccService } from './ccc.service';
import { DddService } from './ddd.service';

@Injectable()
export class AppService {
  constructor(private cccService: CccService, private dddService: DddService){}

  getHello(): string {
    return this.dddService.ddd() + this.cccService.eee();
  }
}
```

这时候 nest start --watch 会报错：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ca2992e0a54e5a8fa277946691a1ac~tplv-k3u1fbpfcp-watermark.image?)

说是没法解析 DddService 的依赖，也是因为循环依赖导致的。

这时候也是通过 forwardRef 解决：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1bc24f5721e483bbcd293551be7084b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e95c0964c748ea8edca908ef6c3d40~tplv-k3u1fbpfcp-watermark.image?)

这时候就不能用默认的注入方式了，通过 @Inject 手动指定注入的 token，这里是 forwardRef 的方式注入。

这样报错就没了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830830a9b3014d938676715f2f73510a~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18746407a2c04e058f1ce0223c8ef8b8~tplv-k3u1fbpfcp-watermark.image?)

两个 service 的相互调用也成功了。

这样我们就解决了循环依赖的问题。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/circular-dependency)。

## 总结

Module 之间可以相互 imports，Provider 之间可以相互注入，这两者都会形成循环依赖。

解决方式就是两边都用 forwardRef 来包裹下。

它的原理就是 nest 会先创建 Module、Provider，之后再把引用转发到对方，也就是 forward ref。



## 144.基于 Redis 实现关注关系

在掘金、知乎、抖音等平台，我们可以关注其他用户，其他用户也可以关注我们，而且如果彼此关注，会标出共同关注：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83cfee2985794c9aa70681c0a8befe65~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=402&h=226&s=16200&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6267eb7098864bc9ad1bd38947d6396b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=224&s=17183&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a840d5d8c2d441e0a6e624bf718c570e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1390&h=854&s=150292&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f37bcdaf9ee4ad0805b2386d4841768~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1370&h=924&s=226747&e=png&b=ffffff)

这种关注、被关注，相互关注，我们每天都能见到。

那它是怎么实现的呢？

一般是用 redis 的 Set 实现的。

Set 是集合，有很多命令：

**SADD**：添加元素

**SMEMBERS**：查看所有元素

**SISMEMBER**：某个 key 是否在集合中

**SCARD**：集合中某个 key 的元素数量

**SMOVE**：移动元素从一个集合到另一个集合

**SDIFF**：两个集合的差集

**SINTER**：两个集合的交集

**SUNION**：两个集合的并集

**SINTERSTORE**：两个集合的交集，存入新集合

**SUNIONSTORE**：两个集合的并集，存入新集合

**SDIFFSTORE**：两个集合的差集，存入新集合

更多命令可以在 [redis 文档](https://redis.io/commands/sismember/)中搜索以 S 开头的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57f47f68a51a4c18ab0c9f0cb694007f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=814&h=902&s=151766&e=png&b=f6f8fb)

关注关系用 redis 来实现就是这样的：

比如张三 的 userId 是 1

那我们用一个 set 来存储它的关注者 followers:1

比如其中有 2、3、4 三个用户

然后用一个集合来存储他关注的人 following:1

其中有 2、5、6 三个用户

那相互关注的人就是 followers:1 和 following:1 的交集 SINTERSTORE 的结果，存入新集合，比如叫 follow-each-other:1

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63be34aa78174e28ac576083e41f44f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1184&h=470&s=50305&e=png&b=fef9f9)

然后返回关注者或者关注的人的时候，用 SISMEMBER 判断下用户是否在 follow-each-other:1 这个集合中，是的话就可以标记出互相关注。

思路理清了，我们来写下代码。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f80d025db48e4f358a6990a8cb2963b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=688&s=160896&e=png&b=010101)

安装 TypeORM 的包：
```bash
npm install --save @nestjs/typeorm typeorm mysql2
```
在 app.module.ts 引入下 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "following_test",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    })
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
在 mysql workbench 里创建 following_test 数据库：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96d52317035e4069a495f0c8b1d928c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1800&h=1114&s=382459&e=png&b=e7e5e5)

新建一个 user 模块：

```
nest g resource user --no-spec
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2113f05c4cb44006a79a500b07759a25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=784&h=292&s=73752&e=png&b=191919)

改下 user.entity.ts

```javascript
import { Column, Entity, JoinTable, ManyToMany, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class User {

    @PrimaryGeneratedColumn()
    id: number;

    @Column()
    name: string;

    @ManyToMany(() => User, user => user.following)
    @JoinTable()
    followers: User[];

    @ManyToMany(() => User, user => user.followers)
    following: User[];
}
```

这里用户和用户是多对多的关系，因为用户可以关注多个用户，用户也可以被多个用户关注。

所以用 @ManyToMany 还有 @JoinTable 来声明。

在 entities 引入这个 User：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4826a80c3214e9e924d716151c163fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=776&h=692&s=110245&e=png&b=202020)

把开发服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6a173d5becc446cb5d62accf25edfd2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1686&h=636&s=280881&e=png&b=191919)

在 mysql workbench 里可以看到 user 表和 user_followers_user 中间表

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8f0ffa92f154d039c53f79c766ee62d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=854&h=280&s=65482&e=png&b=ebe7e6)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580588f3d64041ea8831439904c18034~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=892&h=250&s=56217&e=png&b=ebe8e7)

我们在 UserService 添加一个初始化数据的方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b3cd38c8cf84e59ad7cecc5c546db53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=988&h=1166&s=213194&e=png&b=1f1f1f)
```javascript
@InjectEntityManager()
entityManager: EntityManager;

async initData() {    
    const user2 = new User();
    user2.name = '李四';

    const user3 = new User();
    user3.name = '王五';

    const user4 = new User();
    user4.name = '赵六';

    const user5 = new User();
    user5.name = '刘七';

    await this.entityManager.save(user2);
    await this.entityManager.save(user3);
    await this.entityManager.save(user4);
    await this.entityManager.save(user5);

    const user1 = new User();
    user1.name = '张三';

    user1.followers = [user2, user3, user4];

    user1.following = [user2, user5];

    await this.entityManager.save(user1);
}
```
在 UserController 里添加一个路由：

```javascript
@Get('init')
async init() {
    await this.userService.initData();
    return 'done'
}
```
浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67cae28e4c0c49cc974bc594837e73d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=738&h=188&s=21060&e=png&b=ffffff)

打印了 6 条 sql 语句：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46b3c6c867c0414a8747d2f010301653~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2074&h=626&s=233512&e=png&b=181818)

在 mysql workbench 里看下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b09a5afe2774f7787e83c60c4bd2b58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=868&h=380&s=104706&e=png&b=eae6e5)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a574da7bcdae49e88309da8c20eadac0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=852&h=314&s=78866&e=png&b=ebe8e7)

张三的 id 是 5，他的三个关注者李四、王五、赵六，他关注的人李四、刘七。

关系都保存下来了。

接下来实现相互关注功能，我们要引入 redis。

安装 redis 的包：

```
npm install --save redis
```

然后创建个 redis 模块：

```
nest g module redis
nest g service redis
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf36dbe385544309bc35de23c2a45a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=196&e=webp&b=1f1f1f)

在 RedisModule 创建连接 redis 的 provider，导出 RedisService，并把这个模块标记为 @Global 模块

```javascript
import { Global, Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```

然后在 RedisService 里注入 REDIS_CLIENT，并封装一些方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async sAdd(key: string, ...members: string[]) {
        return this.redisClient.sAdd(key, members);
    }

    async sInterStore(newSetKey: string, set1: string, set2: string) {
        return this.redisClient.sInterStore(newSetKey, [set1, set2]);
    }

    async sIsMember(key: string, member: string) {
        return this.redisClient.sIsMember(key, member);
    }
    
    async sMember(key: string) {
        return this.redisClient.sMembers(key);
    }
    
    async exists(key: string) {
        const result =  await this.redisClient.exists(key);
        return result > 0
    } 
}
```
封装 SADD、SINTERSTORE、SISMEMBER、SMEMBER 命令，分别用来往集合中添加元素，求两个集合的交集创建新集合，判断元素是否在某个集合中、返回集合中的所有元素。

还有 EXISTS 用来判断某个 key 是否存在，返回 1 代表存在，返回 0 代表不存在。

然后在 UserService 添加一个方法：

```javascript
@Inject(RedisService)
redisService: RedisService;

async findUserByIds(userIds: string[] | number[]) {
  let users = [];

  for(let i = 0; i< userIds.length; i ++) {
    const user = await this.entityManager.findOne(User, {
      where: {
        id: +userIds[i]
      }
    });
    users.push(user);
  }

  return users;
}

async getFollowRelationship(userId: number) {
  const exists = await this.redisService.exists('followers:' + userId);
  if(!exists) {
    const user = await this.entityManager.findOne(User, {
      where: {
        id: userId
      },
      relations: ['followers', 'following']
    });

    if(!user.followers.length || !user.following.length) {
      return {
        followers: user.followers,
        following: user.following,
        followEachOther: []
      }
    }

    await this.redisService.sAdd('followers:' + userId, ...user.followers.map(item => item.id.toString()));

    await this.redisService.sAdd('following:' + userId, ...user.following.map(item => item.id.toString()))

    await this.redisService.sInterStore('follow-each-other:' + userId, 'followers:' + userId, 'following:' + userId);

    const followEachOtherIds = await this.redisService.sMember('follow-each-other:' + userId);
    
    const followEachOtherUsers = await this.findUserByIds(followEachOtherIds);

    return {
      followers: user.followers,
      following: user.following,
      followEachOther: followEachOtherUsers
    }
  } else {

    const followerIds = await this.redisService.sMember('followers:' + userId);
    
    const followUsers = await this.findUserByIds(followerIds);
    
    const followingIds = await this.redisService.sMember('following:' + userId);
    
    const followingUsers = await this.findUserByIds(followingIds);

    const followEachOtherIds = await this.redisService.sMember('follow-each-other:' + userId);
    
    const followEachOtherUsers =await this.findUserByIds(followEachOtherIds);

    return {
      followers: followUsers,
      following: followingUsers,
      followEachOtherUsers: followEachOtherUsers
    }
  }
}
```

代码比较多，我们一部分一部分的看：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e80fde93df5e4afda2f192156ce50967~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894&h=616&s=84452&e=png&b=1f1f1f)

传入 userIds，查询对应的 User 信息返回。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eac4179dcc14c92b0ce7facdef2bc4c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=890&h=504&s=72159&e=png&b=1f1f1f)

根据 id 查询用户的信息，关联查出 followers 和 following。

如果 follwers 或者 following 为空，那就没有互相关注，可以直接返回。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56c098baa25a416989b89b25e8594bc1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1698&h=558&s=159931&e=png&b=1f1f1f)

否则就分别把 follwers 和 follwing 的 id 用 SADD 添加到两个集合中。

之后求两个集合的交集，存入 follow-each-other:userId 的集合。

最后把 followers、following 还有求出来的相互关注的关系返回。

如果 exits 判断 followers 集合存在，就是处理过了，那就直接取 redis 里的这三个集合。

根据集合的 id 求出用户信息返回：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a9ee41036d649d0b76554eb9ac5cf66~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1424&h=860&s=202230&e=png&b=1f1f1f)

在 UserController 添加一个路由：

```javascript
@Get('follow-relationship')
async followRelationShip(@Query('id') id: string) {
    if(!id) {
      throw new BadRequestException('userId 不能为空');
    }
    return this.userService.getFollowRelationship(+id);
}
```

浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7a125740526474bab7354d8c28ecb6c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=1384&s=112362&e=png&b=fefefe)

结果是正确的。

在 RedisInsight 里可以看到这三个 set：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aebac60669f74b2f9c8ab9c102a5756f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1686&h=932&s=114978&e=png&b=181818)

逻辑比较复杂，我们调试下。

点击 debug 面板的 create a launch.json file

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/244adf5d3f7f4cd5bef548988ca69475~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=642&h=472&s=51348&e=png&b=181818)

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "debug nest",
            "request": "launch",
            "runtimeArgs": [
                "run",
                "start:dev"
            ],
            "runtimeExecutable": "npm",
            "console": "integratedTerminal",
            "skipFiles": [
                "<node_internals>/**"
            ],
            "type": "node"
        }
    ]
}
```

在代码里打两个断点：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e67fc1bbf94a49f7b0ca57f4a24ac4f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1110&h=934&s=221261&e=png&b=1f1f1f)

点击 debug 启动：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d3354bf801c4579a7018287ccb23d0b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2042&h=1498&s=516798&e=png&b=1a1a1a)

浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30ff0d0aed9f4666990e7904286807c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1696&h=1056&s=406680&e=png&b=1e1e1e)

可以看到，它走到了 else 部分。

在 RedisInsight 里把这三个集合删掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afc555a52bde484ba2bfaea75811a36b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1282&h=598&s=61292&e=png&b=1a1a1a)

再次访问：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c10201730b174780bbeefb5edc839f2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1660&h=1148&s=434894&e=png&b=1d1d1d)

这时候走的就是另一个分支了。

那如果有新的关注者呢？

比如张三又关注了 id 为 3 的赵六：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77c732eae95149668f24eac579a7ca9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1088&h=1376&s=109163&e=png&b=fefefe)

这时要更新下数据库，并且更新 redis 里的 follwing 和 follow-each-other 集合。

在 UserService 添加 follow 方法：

```javascript
async follow(userId: number, userId2: number){
  const user = await this.entityManager.findOne(User, {
    where: {
      id: userId
    },
    relations: ['followers', 'following']
  });

  const user2 = await this.entityManager.findOne(User, {
    where: {
      id: userId2
    }
  });

  user.followers.push(user2);

  await this.entityManager.save(User, user);

  const exists = await this.redisService.exists('followers:' + userId);

  if(exists) {
    await this.redisService.sAdd('followers:' + userId, userId2.toString());
    await this.redisService.sInterStore('follow-each-other:' + userId, 'followers:' + userId, 'following:' + userId);
  }
  
 const exists2 = await this.redisService.exists('following:' + userId2);

 if(exists2) {
    await this.redisService.sAdd('following:' + userId2, userId.toString());
    await this.redisService.sInterStore('follow-each-other:' + userId2, 'followers:' + userId2, 'following:' + userId2);
  }
}
```
先查询出 user 的数据，在 followers 添加 user2，然后 save 保存到数据库。

之后查询下 redis，如果有 followers:userId 的 key，就更新下 followers 和 follow-each-other 集合。

这里 user1 和 user2 的集合都要查询并更新下。

然后在 UserController 里添加下路由：

```javascript
@Get('follow')
async follow(@Query('id1') userId1: string, @Query('id2') userId2: string) {
    await this.userService.follow(+userId1, +userId2);
    return 'done';
}
```
浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36a9600f47804417b175b7716f7c46bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=990&h=214&s=26300&e=png&b=ffffff)

可以看到，数据库和 redis 都更新了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c1b8185529c4bfeba6ebf39cc7212eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1456&h=806&s=244939&e=png&b=191919)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0312d3a592146e4a4cf4092dbf424f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1508&h=754&s=81248&e=png&b=1b1b1b)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c7de7fc8784cb5b7ab87a9f47dd463~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1554&h=692&s=80814&e=png&b=1c1c1c)

再次查询下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/140b07a1de3a4e099c5787c07f9de2e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078&h=1538&s=129669&e=png&b=fefefe)

这样，相互关注的功能就实现了。

知乎、掘金这种关注关系都是这样实现的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6267eb7098864bc9ad1bd38947d6396b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=224&s=17183&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a840d5d8c2d441e0a6e624bf718c570e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1390&h=854&s=150292&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f37bcdaf9ee4ad0805b2386d4841768~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1370&h=924&s=226747&e=png&b=ffffff)

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/following)

## 总结

这节我们实现了下关注、被关注、互相关注。

在 mysql 里用中间表来存储 user 和 user 的关系，在 TypeORM 里用 @ManyToMany 映射。

互相关注用 redis 的 Set 来实现，先把 user 的 followers 和 following 存储到集合中。

然后把两个集合的交集求出来放入一个新的集合。

这样就能求出互相关注的关系。

当有新的关注或者取消关注时，除了要更新数据库外，也要顺便更新下 redis。

这样，查询互相关注关系的功能就完成了。


## 145.基于 Redis 实现各种排行榜（周榜、月榜、年榜）

生活中各种排行榜可太多了。

比如经常有瓜的微博文娱榜：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/895af4664f9c4d408bb3af1a3ad3fe8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=2400&s=707863&e=jpg&b=fefefe)

掘金的文章榜：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb4f4b0f17c14e8db8c970921d52ed77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1450&h=1034&s=254377&e=png&b=ffffff)

作者榜：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5cdddd483994ca0b4b30cace85d46ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2010&h=1280&s=446810&e=png&b=ffffff)

微信的步数排行榜：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8faab6319eff4995bef431ba5d648df6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=2400&s=475034&e=jpg&b=f6f5f5)

我最近订的自习室也有学习时长排行榜：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b76913360af465397faa8726871cf14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=2400&s=446365&e=jpg&b=fcfbfb)

排行的依据各有不同，有的是根据学习时长，有的是根据阅读数、点赞数，有的是根据搜索次数等。

那这些排行榜是怎么实现的呢？

有的同学说，在 mysql 里加一个排序的字段，比如热度，然后根据根据这个字段来排序不就行了？

这样是能完成功能，但是效率太低了。

数据库的读写性能比 Redis 低很多，而且可能这个排序的依据只是一个临时数据，不需要存到数据库里。

一般涉及到排行榜，都是用 Redis 来做，因为它有一个专为排行榜准备的数据结构：有序集合 ZSET。

它有这些命令：

**ZADD**：往集合中添加成员

**ZREM**：从集合中删除成员

**ZCARD**：集合中的成员个数

**ZSCORE**：某个成员的分数

**ZINCRBY**：增加某个成员的分数

**ZRANK**：成员在集合中的排名

**ZRANGE**：打印某个范围内的成员

**ZRANGESTORE**：某个范围内的成员，放入新集合

**ZCOUNT**：集合中分数在某个返回的成员个数

**ZDIFF**：打印两个集合的差集

**ZDIFFSTORE**：两个集合的差集，放入新集合

**ZINTER**：打印两个集合的交集

**ZINTERSTORE**：两个集合的交集，放入新集合

**ZINTERCARD**：两个集合的交集的成员个数

**ZUNION**：打印两个集合的并集

**ZUNIONSTORE**：两个集合的并集，放回新集合

我们依次来试一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a956d7f9f434c3aa3a97ac728539a7f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1886&h=408&s=78708&e=png&b=121212)

```redis
ZADD set1 1 mem1 2 mem2 3 mem3
```

在 RedisInsight 里输入命令，点击执行。

点击刷新就可以看到这个集合：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07c822cc10144c0d829d63a7851d6194~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2112&h=486&s=97806&e=png&b=121212)

三个成员，分数分别是 1、2、3

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8ad9d771a03471baaed48004c7e22cb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1758&h=760&s=72686&e=png&b=1a1a1a)

用命令看的话就是 ZRANGE：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8360e1995a34411b9f78b42470e25221~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1396&h=636&s=47921&e=png&b=121212)

```
ZRANGE set1 0 -1
```

范围从 0 到 -1 就是返回全部。

默认是分数从小到大排序，也可以从大到小，加个 REV 就行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c2274688df24252b6f1af2fa6e6d34d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640&h=604&s=32033&e=png&b=111111)

```
ZRANGE set1 0 -1 REV
```
还可以用 ZRANGESTORE 把它存入新集合：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dee4156d2a21452f9df5000b0cd5b3d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=814&h=542&s=33577&e=png&b=131313)

```
ZRANGESTORE rangeset set1 0 -1
```

查看下新集合：

```
ZRANGE rangeset 0 -1
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ecf49386114801aeab23920d74d6ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=652&h=588&s=29240&e=png&b=111111)

删除个成员试试：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00cabb70cf4646b5a47fa4b4f13c1713~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=546&h=526&s=21630&e=png&b=141414)

```
ZREM set1 mem1
```
再查看下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f92801ae5b494e8128597c1c062d26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=590&h=566&s=25035&e=png&b=111111)

```
ZRANGE set1 0 -1
```

用 ZCARD 查看集合的成员个数：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a98952d1ed5497d832f7504ae104b89~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=530&h=540&s=22247&e=png&b=141414)

```
ZCARD set1
```
用 ZSCORE 查看某个成员的分数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62a0fcae34644e75a0e9b885b350d3eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=586&h=526&s=22440&e=png&b=131313)

用 ZRANK 查看成员在集合内的排名：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8bc518809ac41f2870f4bdacfc8be32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=596&h=518&s=23513&e=png&b=121212)

```
ZRANK set1 mem2
```

然后用 ZINCRBY 给成员增加分数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72d32e595e9749439810722b7388aa9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=568&h=532&s=21346&e=png&b=121212)
```
ZINCRBY set1 3 mem2
```
看下新排名：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8f8bf78ef574f449938869d196d3fbd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=662&h=554&s=26498&e=png&b=101010)

```
ZRANGE set1 0 -1
```

mem2 就到下面去了。

再创建一个集合 set2：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/307e9040f5ca4b1089e0eaf8defbdd0e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=598&h=530&s=27282&e=png&b=131313)

```
ZADD set2 4 aaa 6 bbb
```
用 ZUNION 合并下：

```
ZUNION 2 set1 set2
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0127cdaf4fe2489bad1ec981effefe98~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=576&h=630&s=31858&e=png&b=101010)

还可以加上分数一起：
```
ZUNION 2 set1 set2 WITHSCORES
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c6bbc5651e417cb43ad35c9ca256ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=832&h=762&s=46886&e=png&b=0c0c0c)

或者把合并后放到另一个集合：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc9243e2262e486b8c45f2d210f7de5d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=520&s=30388&e=png&b=121212)

```
ZUNIONSTORE set3 2 set1 set2
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/842a9bdc20f341579da82c5bb894aca5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=558&h=610&s=31416&e=png&b=0f0f0f)

```
ZRANGE set3 0 -1
```
交集和差集的命令也差不多，就不一个个试了。

并集合并的时候相同的 key 的 score 会求和。

```
ZADD s1 1 aa 2 bb

ZADD s2 1 aa 3 cc

ZUNIONSTORE s3 2 s1 s2
```

在 s1 和 s2 集合中都有 aa，合并到 s3 之后 aa 的分数也合并了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67681baa9fc24e1f8d7384da1ddf636a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1508&h=710&s=65434&e=png&b=1b1b1b)

周榜、月榜、年榜就是这么实现的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b76913360af465397faa8726871cf14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=2400&s=446365&e=jpg&b=fcfbfb)

月榜就是对周榜的合并，然后年榜就是月榜的合并，最后就会算出一个新的排行榜。

我们用 Nest 实现下类似的排行榜功能：

```
nest new ranking-list-test
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd50fea9c1484a23b5bfd18e0ceda0a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=698&s=162505&e=png&b=010101)

安装 redis 的包：

```
npm install --save redis
```

然后创建个 redis 模块：

```
nest g module redis
nest g service redis
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf36dbe385544309bc35de23c2a45a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=196&e=webp&b=1f1f1f)

在 RedisModule 创建连接 redis 的 provider，导出 RedisService，并把这个模块标记为 @Global 模块

```javascript
import { Global, Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```

然后在 RedisService 里注入 REDIS_CLIENT，并封装一些方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async zRankingList(key: string, start: number = 0, end: number = -1) {
        const keys = await this.redisClient.zRange(key, start, end, {
            REV: true
        });
        const rankingList = {};
        for(let i = 0; i< keys.length; i++){
            rankingList[keys[i]] = await this.zScore(key, keys[i]);
        }
        return rankingList;
    }

    async zAdd(key: string, members: Record<string, number>) {
        const mems = [];
        for(let key in members) {
            mems.push({
                value: key,
                score: members[key]
            });        
        }
        return  await this.redisClient.zAdd(key, mems);
    }

    async zScore(key: string, member: string) {
        return  await this.redisClient.zScore(key, member);
    }

    async zRank(key: string, member: string) {
        return  await this.redisClient.zRank(key, member);
    }

    async zIncr(key: string, member: string, increment: number) {
        return  await this.redisClient.zIncrBy(key, increment, member)
    }

    async zUnion(newKey: string, keys: string[]) {
        if(!keys.length) {
            return []
        };
        if(keys.length === 1) {
            return this.zRankingList(keys[0]);
        }

        await this.redisClient.zUnionStore(newKey, keys);

        return this.zRankingList(newKey);
    }

    async keys(pattern: string) {
        return this.redisClient.keys(pattern);    
    }
}
```
这里我们对 zset 的命令进行了封装，比如 zRange 只会返回成员名，我们顺带把分数也取出来。

暴露 zAdd、zScore、zRank、zIncr 等方法。

zUnion 要做下边界的处理，如果只传了一个 set 的名字，就染回这个 set 的内容，否则才合并。

创建一个 ranking 模块：

```
nest g module ranking
nest g controller ranking --no-spec
nest g service ranking --no-spec
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca093838eec144deaf478aefe1bd3739~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1032&h=280&s=75766&e=png&b=191919)

我们就实现下自习室学习时长的月榜和年榜吧。

实现下 RankingService：

```javascript
import { RedisService } from './../redis/redis.service';
import { Inject, Injectable } from '@nestjs/common';
import * as dayjs from 'dayjs';

@Injectable()
export class RankingService {

    @Inject(RedisService)
    redisService: RedisService;

    private getMonthKey() {
        const dateStr = dayjs().format('YYYY-MM');
        return `learning-ranking-month:${dateStr}`;
    }

    private getYearKey() {
        const dateStr = dayjs().format('YYYY');
        return `learning-ranking-year:${dateStr}`;
    }

    async join(name: string) {
        await this.redisService.zAdd(this.getMonthKey(), { [name]: 0 });
    }

    async addLearnTime(name:string, time: number) {
        await this.redisService.zIncr(this.getMonthKey(), name, time);
    }

    async getMonthRanking() {
        return this.redisService.zRankingList(this.getMonthKey(), 0, 10);
    }

    async getYearRanking() {
        const dateStr = dayjs().format('YYYY');
        const keys = await this.redisService.keys(`learning-ranking-month:${dateStr}-*`);

        return this.redisService.zUnion(this.getYearKey(), keys);
    }
}
```
这里用到了 dayjs，安装下：

```
npm install --save dayjs
```

月份的榜单是 learning-ranking-mongth:2024-01、learning-ranking-mongth:2024-02 这样的格式。

年份的榜单是 learning-ranking-mongth:2023、learning-ranking-mongth:2024 这样的格式。

我们用 dayjs 拿到当前的年份和月份，拼接出需要的 key。

年份的榜单就是拿到用 learning-ranking-month:当前年份- 开头的所有 zset，做下合并。

在 RankingController 加一下接口：

```javascript
import { Controller, Get, Inject, Query } from '@nestjs/common';
import { RankingService } from './ranking.service';

@Controller('ranking')
export class RankingController {

    @Inject(RankingService)
    rankingService: RankingService;

    @Get('join')
    async join(@Query('name') name: string) {
        await this.rankingService.join(name);
        return 'success';
    }

    @Get('learn')
    async addLearnTime(@Query('name') name:string, @Query('time') time: string) {
        await this.rankingService.addLearnTime(name, parseFloat(time));
        return 'success';
    }

    @Get('monthRanking')
    async getMonthRanking() {
        return this.rankingService.getMonthRanking();
    }

    @Get('yearRanking')
    async getYearRanking() {
        return this.rankingService.getYearRanking();
    }   
}
```
join 是加入自习室，learn 是增加学习时长，monthRanking 和 yearRanking 是拿到月榜和年榜。

把服务跑起来：

```
npm run start:dev
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beeb51e757d2420d842b38e470f7cc00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1626&h=526&s=243473&e=png&b=181818)

在 postman 里调用下：

```
localhost:3000/ranking/join?name=guang
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a97a74e8b1c3472b81243d6a13bc7f42~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=798&h=486&s=49735&e=png&b=fbfbfb)

```
localhost:3000/ranking/join?name=dong
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5d5407bae542538e1fe82e33395044~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=508&s=50805&e=png&b=fbfbfb)
```
localhost:3000/ranking/join?name=xiaohong
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447497049a044e03b4ad7e5fec13106d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=818&h=482&s=50845&e=png&b=fafafa)

调用 join 接口，加入三个同学。

看下现在的月榜：

```
localhost:3000/ranking/monthRanking
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b853d2f94b640a6a1b99e9210ee5e31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=854&h=604&s=61985&e=png&b=fcfcfc)

在 RedisInsight 里看下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cae0e1e536243f58f5f4816ac97871c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1114&h=394&s=41369&e=png&b=181818)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c42317043a44a31813ee265ce01a395~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1398&h=716&s=75205&e=png&b=1b1b1b)

然后调用 learn 接口，增加学习时长：

```
localhost:3000/ranking/learn?name=dong&time=1
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42fe163b497e4e87a962ef59f104b020~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=530&s=52054&e=png&b=fcfcfc)

```
localhost:3000/ranking/learn?name=guang&time=2
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7a00ff1c3174b5eb8b6b8ad416ad5df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=512&s=50445&e=png&b=fbfbfb)

```
localhost:3000/ranking/learn?name=xiaohong&time=5
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd04544984174f71931f4f2e2c8c54d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=904&h=502&s=51566&e=png&b=fbfbfb)

```
localhost:3000/ranking/monthRanking
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2893cc2eab34c2cbde9bf6c6b080d21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=874&h=610&s=58590&e=png&b=fcfcfc)

我们改下本地时间（mac 和 windows 改本地时间的方式不一样）：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71cc6666159d46d9a29733893a030bfd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=972&h=714&s=81104&e=png&b=f1edea)

然后再调用 join 接口：

```
localhost:3000/ranking/join?name=guang
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a97a74e8b1c3472b81243d6a13bc7f42~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=798&h=486&s=49735&e=png&b=fbfbfb)

```
localhost:3000/ranking/join?name=dong
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5d5407bae542538e1fe82e33395044~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=508&s=50805&e=png&b=fbfbfb)
```
localhost:3000/ranking/join?name=xiaogang
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a465751d23d04e29b65f8e2213e55a99~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=768&h=492&s=49518&e=png&b=fcfcfc)

之后增加学习时长：


```
localhost:3000/ranking/learn?name=dong&time=2
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/196cbe861cd3404e8ea4e6e3f612cf03~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=874&h=478&s=50637&e=png&b=fbfbfb)

```
localhost:3000/ranking/learn?name=guang&time=3
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee692a502a5d4675b5fc17af21a257e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=876&h=494&s=50919&e=png&b=fbfbfb)
```
localhost:3000/ranking/learn?name=xiaogang&time=4
```

然后看下 3 月份的月榜：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461d946832254886900f83491b3bbd1b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=858&h=502&s=51092&e=png&b=fbfbfb)

还有年榜：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e6b7c7751974570b23f4c8f5427e8c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=780&h=658&s=60070&e=png&b=fcfcfc)

可以看到，年榜是合并了所有月榜的结果。

在 RedisInsight 里看下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2d7c497ada84c29920bdb0529789b40~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=598&s=71311&e=png&b=191919)

每个月榜和年榜都是单独的 zset。

这样我们就实现了学习时长的排行榜。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b76913360af465397faa8726871cf14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=2400&s=446365&e=jpg&b=fcfbfb)

至于用户自己的排名和时长，就用 zScore、zRank 来实现。

也就是这个我的排名功能：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/388f457677374ca3aa86bdc156ae64c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&h=564&s=540511&e=png&b=374b6a)

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/ranking-list-test)

## 总结

生活中我们经常会见到各种排行榜，以及它们的周榜、月榜、年榜等。

这些排行榜的功能都是用 redis 的 zset 有序集合实现的。

它保存的值都有一个分数，会自动排序。

多个集合之间可以求并集、交集、差集。

通过并集的方式就能实现月榜合并成年榜的功能。

以后见到各种排行榜，你会不会想到 Redis 的 zset 呢？


## 146.用 Node.js 手写 WebSocket 协议

实时的双向数据通信，我们一般会用 WebSocket 来做。

HTTP 的协议格式我们很清楚，就是 header、body 这些。

那 WebSocket 的协议格式是什么样的呢？

这节我们就用 Node 来实现下 WebSocket 协议的解析。

WebSocket 严格来说和 HTTP 没什么关系，是另外一种协议格式。但是需要一次从 HTTP 到 WebSocket 的切换过程。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66a631eacea541b8a21077f3a70a7d30~tplv-k3u1fbpfcp-watermark.image?)

切换过程详细来说是这样的：

请求的时候带上这几个 header：

```
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: Ia3dQjfWrAug/6qm7mTZOg==
```

前两个很容易理解，就是升级到 websocket 协议的意思。

第三个 header 是保证安全用的一个 key。

服务端返回这样的 header：

```
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: JkE58n3uIigYDMvC+KsBbGZsp1A=
```
和请求 header 类似，Sec-WebSocket-Accept 是对请求带过来的 Sec-WebSocket-Key 处理之后的结果。

加入这个 header 的校验是为了确定对方一定是有 WebSocket 能力的，不然万一建立了连接对方却一直没消息，那不就白等了么。

那 Sec-WebSocket-Key 经过什么处理能得到 Sec-WebSocket-Accept 呢？

我用 node 实现了一下，是这样的：

```javascript
const crypto = require('crypto');

function hashKey(key) {
  const sha1 = crypto.createHash('sha1');
  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
  return sha1.digest('base64');
}
```

也就是用客户端传过来的 key，加上一个固定的字符串，经过 sha1 加密之后，转成 base64 的结果。

这个字符串 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 是固定的，不信你搜搜看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae1d0158cd7846baa748766f500df6ac~tplv-k3u1fbpfcp-watermark.image?)

随便找个有 websocket 的网站，比如知乎就有：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/216b4bd530414a98be20d24b48004e9c~tplv-k3u1fbpfcp-watermark.image?)

过滤出 ws 类型的请求，看看这几个 header，是不是就是前面说的那些。

这个 Sec-WebSocket-Key 是 wk60yiym2FEwCAMVZE3FgQ==

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59c04c72059d4065af018e6fa569db42~tplv-k3u1fbpfcp-watermark.image?)

而响应的 Sec-WebSocket-Accept 是 XRfPnS+8xl11QWZherej/dkHPHM=

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/def6d4065c6a43fa9324a066df751c29~tplv-k3u1fbpfcp-watermark.image?)

我们算算看：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f23d5f2866e4050bc868b8fd7f48fb0~tplv-k3u1fbpfcp-watermark.image?)

是不是一毛一样！

这就是 websocket 升级协议时候的 Sec-WebSocket-Key 对应的 Sec-WebSocket-Accept 的计算过程。 

这一步之后就换到 websocket 的协议了，那是一个全新的协议：

勾选 message 这一栏可以看到传输的消息，可以是文本、可以是二进制：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/619acacb8a394458a7d75fc7385891e8~tplv-k3u1fbpfcp-watermark.image?)

全新的协议？那具体是什么样的协议呢？

这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72a5f75c1964af38036e2afef51a35c~tplv-k3u1fbpfcp-watermark.image?)

大家习惯的 http 协议是 key:value 的 header 带个 body 的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5062b7f961ab42ed9f3766ad4a8b6a3a~tplv-k3u1fbpfcp-watermark.image?)

它是文本协议，每个 header 都是容易理解的字符。

这样好懂是好懂，但是传输占的空间太大了。

而 websocket 是二进制协议，一个字节可以用来存储很多信息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671ce2ce334b4d68b4fdd781e132de37~tplv-k3u1fbpfcp-watermark.image?)

比如协议的第一个字节，就存储了 FIN（结束标志）、opcode（内容类型是 binary 还是 text） 等信息。

第二个字节存储了 mask（是否有加密），payload（数据长度）。

仅仅两个字节，存储了多少信息呀！

这就是二进制协议比文本协议好的地方。

我们看到的 weboscket 的 message 的收发，其实底层都是拼成这样的格式。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b136cc1654b42b4a9c1481666c01303~tplv-k3u1fbpfcp-watermark.image?)

只是浏览器帮我们解析了这种格式的协议数据。

这就是 weboscket 的全部流程了。

其实还是挺清晰的，一个切换协议的过程，然后是二进制的 weboscket 协议的收发。

那我们就用 Node.js 自己实现一个 websocket 服务器吧！

新建个项目：

```
mkdir my-websocket

cd my-websocket

npm init -y
```

在 src/ws.js 定义个 MyWebSocket 的 class：

```javascript
const { EventEmitter } = require('events');
const http = require('http');

class MyWebsocket extends EventEmitter {
  constructor(options) {
    super(options);

    const server = http.createServer();
    server.listen(options.port || 8080);

    server.on('upgrade', (req, socket) => {
      
    });
  }
}
```
继承 EventEmitter 是为了可以用 emit 发送一些事件，外界可以通过 on 监听这个事件来处理。

我们在构造函数里创建了一个 http 服务，当 ungrade 事件发生，也就是收到了 Connection: upgrade 的 header 的时候，返回切换协议的 header。

返回的 header 前面已经见过了，就是要对 sec-websocket-key 做下处理。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf421f86affa47a6832bff77dbc3bbb7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1174&h=1116&s=184085&e=png&b=1f1f1f)

```javascript
server.on('upgrade', (req, socket) => {
  this.socket = socket;
  socket.setKeepAlive(true);

  const resHeaders = [
    'HTTP/1.1 101 Switching Protocols',
    'Upgrade: websocket',
    'Connection: Upgrade',
    'Sec-WebSocket-Accept: ' + hashKey(req.headers['sec-websocket-key']),
    '',
    ''
  ].join('\r\n');
  socket.write(resHeaders);

  socket.on('data', (data) => {
    console.log(data)
  });
  socket.on('close', (error) => {
      this.emit('close');
  });
});
```
我们拿到 socket，返回上面的 header，其中 key 做的处理就是前面聊过的算法：

```javascript
function hashKey(key) {
  const sha1 = crypto.createHash('sha1');
  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
  return sha1.digest('base64');
}
```

就这么简单，就已经完成协议切换了。

不信我们试试看。

新建 src/index.js，引入我们实现的 ws 服务器，跑起来：

```javascript
const MyWebSocket = require('./ws');
const ws = new MyWebSocket({ port: 8080 });

ws.on('data', (data) => {
  console.log('receive data:' + data);
});

ws.on('close', (code, reason) => {
  console.log('close:', code, reason);
});
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c35e2304a71b479aba9852ba955eedd0~tplv-k3u1fbpfcp-watermark.image?)

然后新建这样一个 index.html：

```html
<!DOCTYPE HTML>
<html>
<body>
    <script>
        const ws = new WebSocket("ws://localhost:8080");

        ws.onopen = function () {
            ws.send("发送数据");
            setTimeout(() => {
                ws.send("发送数据2");
            }, 3000)
        };

        ws.onmessage = function (evt) {
            console.log(evt)
        };

        ws.onclose = function () {
        };
    </script>
</body>

</html>
```
用浏览器的 WebSocket api 建立连接，发送消息。

起个静态服务:
```
npx http-server . 
```

然后浏览器访问这个 html：

这时打开 devtools 你就会发现协议切换成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c4a9f221d6641e89449111a4657e6cd~tplv-k3u1fbpfcp-watermark.image?)

这 3 个 header 还有 101 状态码都是我们返回的。

message 里也可以看到发送的消息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/058fd50aafec4eb18f9d0ada62efc07d~tplv-k3u1fbpfcp-watermark.image?)

再去服务端看看，也收到了这个消息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d356cfd40341a1a59fc7119b0ea509~tplv-k3u1fbpfcp-watermark.image?)

只不过是 Buffer 的，也就是二进制的。

接下来只要按照协议格式解析这个 Buffer，并且生成响应格式的协议数据 Buffer 返回就可以收发 websocket 数据了。

这一部分还是比较麻烦的，我们一点点来看。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fb528c7bc8a41cda747ebe9de2d66f9~tplv-k3u1fbpfcp-watermark.image?)

我们需要第一个字节的后四位，也就是 opcode。

这样写：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34e4c466a7e14b8c8d57ed744f672d0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=134&s=29918&e=png&b=202020)

```javascript
const byte1 = bufferData.readUInt8(0);
let opcode = byte1 & 0x0f; 
```
读取 8 位无符号整数的内容，也就是一个字节的内容。参数是偏移的字节，这里是 0。

通过位运算取出后四位，这就是 opcode 了。

然后再处理第二个字节：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/229e839639814184ab2d4d928f8bdd6b~tplv-k3u1fbpfcp-watermark.image?)

第一位是 mask 标志位，后 7 位是 payload 长度。

可以这样取：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/197fb1f48fd84da3b984666c8280d092~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=870&h=444&s=83058&e=png&b=1f1f1f)

```javascript
const byte2 = bufferData.readUInt8(1);
const str2 = byte2.toString(2);
const MASK = str2[0];
let payloadLength = parseInt(str2.substring(1), 2);
```

还是用 buffer.readUInt8 读取一个字节的内容。

先转成二进制字符串，这时第一位就是 mask，然后再截取后 7 位的子串，parseInt 成数字，这就是 payload 长度了。

这样前两个字节的协议内容就解析完了。

有同学可能问了，后面咋还有俩 payload 长度呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f06445633ac34228810660211b20e417~tplv-k3u1fbpfcp-watermark.image?)

这是因为数据不一定有多长，可能需要 16 位存长度，可能需要 32 位。

于是 websocket 协议就规定了如果那个 7 位的内容不超过 125，那它就是 payload 长度。

如果 7 位的内容是 126，那就不用它了，用后面的 16 位的内容作为 payload 长度。

如果 7 位的内容是 127，也不用它了，用后面那个 64 位的内容作为 payload 长度。

其实还是容易理解的，就是 3 个 if else。

用代码写出来就是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f795a70851b141e3a790f95fb610c92d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=844&h=682&s=133340&e=png&b=1f1f1f)

```javascript
let payloadLength = parseInt(str2.substring(1), 2);

let curByteIndex = 2;

if (payloadLength === 126) {
  payloadLength = bufferData.readUInt16BE(2);
  curByteIndex += 2;
} else if (payloadLength === 127) {
  payloadLength = bufferData.readBigUInt64BE(2);
  curByteIndex += 8;
}
```
这里的 curByteIndex 是存储当前处理到第几个字节的。

如果是 126，那就从第 3 个字节开始，读取 2 个字节也就是 16 位的长度，用 buffer.readUInt16BE 方法。

如果是 127，那就从第 3 个字节开始，读取 8 个字节也就是 64 位的长度，用 buffer.readBigUInt64BE 方法。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3826c3ca5a54ed7877bbbf35d572d79~tplv-k3u1fbpfcp-watermark.image?)

这样就拿到了 payload 的长度，然后再用这个长度去截取内容就好了。

但在读取数据之前，还有个 mask 要处理，这个是用来给内容解密的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27395e22f9a64d4e84c1df5831c29af7~tplv-k3u1fbpfcp-watermark.image?)

读 4 个字节，就是 mask key。

再后面的就可以根据 payload 长度读出来。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7658325b7184ca29052ab1683c31b37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1274&h=1002&s=211039&e=png&b=1f1f1f)
```javascript
let realData = null;

if (MASK) {
  const maskKey = bufferData.slice(curByteIndex, curByteIndex + 4);  
  curByteIndex += 4;
  const payloadData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);
  realData = handleMask(maskKey, payloadData);
} else {
  realData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);;
}
```
然后用 mask key 来解密数据。

这个算法也是固定的，用每个字节的 mask key 和数据的每一位做按位异或就好了：

```javascript
function handleMask(maskBytes, data) {
  const payload = Buffer.alloc(data.length);
  for (let i = 0; i < data.length; i++) {
    payload[i] = maskBytes[i % 4] ^ data[i];
  }
  return payload;
}
```
这样，我们就拿到了最终的数据！

但是传给处理程序之前，还要根据类型来处理下，因为内容分几种类型，也就是 opcode 有几种值：

```javascript
const OPCODES = {
  CONTINUE: 0,
  TEXT: 1, // 文本
  BINARY: 2, // 二进制
  CLOSE: 8,
  PING: 9,
  PONG: 10,
};
```

我们只处理文本和二进制就好了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771a6c91a0ca4c06b538affb5fd2a4cf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=964&s=127832&e=png&b=1f1f1f)

```javascript
handleRealData(opcode, realDataBuffer) {
    switch (opcode) {
      case OPCODES.TEXT:
        this.emit('data', realDataBuffer.toString('utf8'));
        break;
      case OPCODES.BINARY:
        this.emit('data', realDataBuffer);
        break;
      default:
        this.emit('close');
        break;
    }
}
```
文本就转成 utf-8 的字符串，二进制数据就直接用 buffer 的数据。

这样，处理程序里就能拿到解析后的数据。

我们来试一下：

之前我们已经能拿到 weboscket 协议内容的 buffer 了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/986ae0fe1860438089a8c4077b11086c~tplv-k3u1fbpfcp-watermark.image?)

而现在我们能正确解析出其中的数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b8c4d7d06e548e19f2a270c0911ae6e~tplv-k3u1fbpfcp-watermark.image?)

至此，我们 websocket 协议的解析成功了！

这样的协议格式的数据叫做 frame，也就是帧：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c0858debd3d456f9280491f8bd0183b~tplv-k3u1fbpfcp-watermark.image?)

解析可以了，接下来我们再实现数据的发送。

发送也是构造一样的 frame 格式。

定义这样一个 send 方法：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a52f2e34f444b3f8be01a90fb04146e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1050&h=900&s=175121&e=png&b=1f1f1f)
```javascript
send(data) {
    let opcode;
    let buffer;
    if (Buffer.isBuffer(data)) {
      opcode = OPCODES.BINARY;
      buffer = data;
    } else if (typeof data === 'string') {
      opcode = OPCODES.TEXT;
      buffer = Buffer.from(data, 'utf8');
    } else {
      console.error('暂不支持发送的数据类型')
    }
    this.doSend(opcode, buffer);
}

doSend(opcode, bufferDatafer) {
   this.socket.write(encodeMessage(opcode, bufferDatafer));
}
```

根据发送的是文本还是二进制数据来对内容作处理。

然后构造 websocket 的 frame：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8204b6730fea4c80afd363dd0b31fc45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1142&h=994&s=177010&e=png&b=1f1f1f)
```javascript
function encodeMessage(opcode, payload) {
  //payload.length < 126
  let bufferData = Buffer.alloc(payload.length + 2 + 0);;
  
  let byte1 = parseInt('10000000', 2) | opcode; // 设置 FIN 为 1
  let byte2 = payload.length;

  bufferData.writeUInt8(byte1, 0);
  bufferData.writeUInt8(byte2, 1);

  payload.copy(bufferData, 2);
  
  return bufferData;
}
```
我们只处理数据长度小于 125 的情况。

第一个字节是 opcode，我们把第一位置 1 ，通过按位或的方式。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/321a0f569d23446c858afad9347232df~tplv-k3u1fbpfcp-watermark.image?)

服务端给客户端回消息不需要 mask，所以第二个字节就是 payload 长度。

分别把这前两个字节的数据写到 buffer 里，指定不同的 offset：

```javascript
bufferData.writeUInt8(byte1, 0);
bufferData.writeUInt8(byte2, 1);
```
之后把 payload 数据放在后面：

```javascript
 payload.copy(bufferData, 2);
```
这样一个 websocket 的 frame 就构造完了。

我们试一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0803bb0e24034191973a497395c1ff56~tplv-k3u1fbpfcp-watermark.image?)

收到客户端消息后，每两秒回一个消息。


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cac293a1bb7f47cca0fe4743dbcc9160~tplv-k3u1fbpfcp-watermark.image?)

收发消息都成功了！

就这样，我们自己实现了一个 websocket 服务器，实现了 websocket 协议的解析和生成！

完整代码如下：

MyWebSocket:

```javascript
//ws.js
const { EventEmitter } = require('events');
const http = require('http');
const crypto = require('crypto');

function hashKey(key) {
  const sha1 = crypto.createHash('sha1');
  sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
  return sha1.digest('base64');
}

function handleMask(maskBytes, data) {
  const payload = Buffer.alloc(data.length);
  for (let i = 0; i < data.length; i++) {
    payload[i] = maskBytes[i % 4] ^ data[i];
  }
  return payload;
}

const OPCODES = {
  CONTINUE: 0,
  TEXT: 1,
  BINARY: 2,
  CLOSE: 8,
  PING: 9,
  PONG: 10,
};

function encodeMessage(opcode, payload) {
  //payload.length < 126
  let bufferData = Buffer.alloc(payload.length + 2 + 0);;
  
  let byte1 = parseInt('10000000', 2) | opcode; // 设置 FIN 为 1
  let byte2 = payload.length;

  bufferData.writeUInt8(byte1, 0);
  bufferData.writeUInt8(byte2, 1);

  payload.copy(bufferData, 2);
  
  return bufferData;
}

class MyWebsocket extends EventEmitter {
  constructor(options) {
    super(options);

    const server = http.createServer();
    server.listen(options.port || 8080);

    server.on('upgrade', (req, socket) => {
      this.socket = socket;
      socket.setKeepAlive(true);

      const resHeaders = [
        'HTTP/1.1 101 Switching Protocols',
        'Upgrade: websocket',
        'Connection: Upgrade',
        'Sec-WebSocket-Accept: ' + hashKey(req.headers['sec-websocket-key']),
        '',
        ''
      ].join('\r\n');
      socket.write(resHeaders);

      socket.on('data', (data) => {
        this.processData(data);
        // console.log(data);
      });
      socket.on('close', (error) => {
          this.emit('close');
      });
    });
  }

  handleRealData(opcode, realDataBuffer) {
    switch (opcode) {
      case OPCODES.TEXT:
        this.emit('data', realDataBuffer.toString('utf8'));
        break;
      case OPCODES.BINARY:
        this.emit('data', realDataBuffer);
        break;
      default:
        this.emit('close');
        break;
    }
  }

  processData(bufferData) {
    const byte1 = bufferData.readUInt8(0);
    let opcode = byte1 & 0x0f; 
    
    const byte2 = bufferData.readUInt8(1);
    const str2 = byte2.toString(2);
    const MASK = str2[0];

    let curByteIndex = 2;
    
    let payloadLength = parseInt(str2.substring(1), 2);
    if (payloadLength === 126) {
      payloadLength = bufferData.readUInt16BE(2);
      curByteIndex += 2;
    } else if (payloadLength === 127) {
      payloadLength = bufferData.readBigUInt64BE(2);
      curByteIndex += 8;
    }

    let realData = null;
    
    if (MASK) {
      const maskKey = bufferData.slice(curByteIndex, curByteIndex + 4);  
      curByteIndex += 4;
      const payloadData = bufferData.slice(curByteIndex, curByteIndex + payloadLength);
      realData = handleMask(maskKey, payloadData);
    } 
    
    this.handleRealData(opcode, realData);
  }

  send(data) {
    let opcode;
    let buffer;
    if (Buffer.isBuffer(data)) {
      opcode = OPCODES.BINARY;
      buffer = data;
    } else if (typeof data === 'string') {
      opcode = OPCODES.TEXT;
      buffer = Buffer.from(data, 'utf8');
    } else {
      console.error('暂不支持发送的数据类型')
    }
    this.doSend(opcode, buffer);
  }

  doSend(opcode, bufferDatafer) {
    this.socket.write(encodeMessage(opcode, bufferDatafer));
  }
}

module.exports = MyWebsocket;
```
Index：

```
const MyWebSocket = require('./ws');
const ws = new MyWebSocket({ port: 8080 });

ws.on('data', (data) => {
  console.log('receive data:' + data);
  setInterval(() => {
    ws.send(data + ' ' + Date.now());
  }, 2000)
});

ws.on('close', (code, reason) => {
  console.log('close:', code, reason);
});
```
html:
```html
<!DOCTYPE HTML>
<html>
<body>
    <script>
        const ws = new WebSocket("ws://localhost:8080");

        ws.onopen = function () {
            ws.send("发送数据");
            setTimeout(() => {
                ws.send("发送数据2");
            }, 3000)
        };

        ws.onmessage = function (evt) {
            console.log(evt)
        };

        ws.onclose = function () {
        };
    </script>
</body>

</html>
```
案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/my-websocket)。
## 总结

实时性较高的需求，我们会用 websocket 实现，比如即时通讯、游戏等场景。

websocket 和 http 没什么关系，但从 http 到 websocket 需要一次切换的过程。

这个切换过程除了要带 upgrade 的 header 外，还要带 sec-websocket-key，服务端根据这个 key 算出结果，通过 sec-websocket-accept 返回。响应是 101 Switching Protocols 的状态码。

这个计算过程比较固定，就是 key + 固定的字符串 通过 sha1 加密后再 base64 的结果。

加这个机制是为了确保对方一定是 websocket 服务器，而不是随意返回了个 101 状态码。

之后就是 websocket 协议了，这是个二进制协议，我们根据格式完成了 websocket 帧的解析和生成。

这样就是一个完整的 websocket 协议的实现了。

我们自己手写了一个 websocket 服务，有没有感觉对 websocket 的理解更深了呢？


## 147.Nest 开发 WebSocket 服务

我们最常用的网络协议是 HTTP，它是一问一答的模式，客户端发送请求，服务端返回响应。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6da9b16984df497f885b585c1a0ae229~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1058&h=682&s=56511&e=png&b=ffffff)

有时候也会用 Server Sent Event，它是基于 HTTP 的，客户端发送请求，服务端返回 text/event-stream 类型的响应，可以多次返回数据。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d99ee4d7ad0471db06cb16280001d77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1294&h=832&e=png&b=ffffff)


但是 HTTP 不能服务端向客户端推送数据，SSE 适合一次请求之后服务端多次推送数据的场景。

类似聊天室这种，需要实时的双向通信的场景，还是得用 WebSocket。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d77dfe73e74d4fac89f8747266c01cd1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1260&h=810&e=png&b=ffffff)

在 Nest 里实现 WebSocket 的服务还是很简单的。

我们创建个项目：

```
nest new nest-websocket
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72fad8b1901b45c5bb0b76b2dac096eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=698&s=164649&e=png&b=010101)

进入项目，安装用到的包：

```
npm i --save @nestjs/websockets @nestjs/platform-socket.io
```
然后创建个 websocket 模块：

```
nest g resource aaa
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/935142a52e374c62859b0127dc3c8b37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=958&h=426&s=107584&e=png&b=191919)

生成的代码很容易看懂：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee0f45755ff4410998795c9f1da2d632~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1170&h=1130&s=280664&e=png&b=1f1f1f)

@WebSocketGateWay 声明这是一个处理 weboscket 的类。

默认的端口和 http 服务 app.listen 的那个端口一样。

然后 @SubscribeMessage 是指定处理的消息。

通过 @MessageBody 取出传过来的消息内容。

分别声明了 find、create、update、remove 这些 CRUD 的消息类型。

具体的实现在 AaaService 里：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74be7181e8674a7a9003afdd10100178~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020&h=1008&s=182754&e=png&b=1f1f1f)

然后我们加一下客户端代码，跑起来试试。

添加 pages/index.html

```html
<html>
  <head>
    <script src="https://cdn.socket.io/4.3.2/socket.io.min.js" integrity="sha384-KAZ4DtjNhLChOB/hxXuKqhMLYvx3b5MlT55xPEiNmREKRzeEm+RVPlTnAn0ajQNs" crossorigin="anonymous"></script>
    <script>
      const socket = io('http://localhost:3000');
      socket.on('connect', function() {
        console.log('Connected');

        socket.emit('findAllAaa', response =>
          console.log('findAllAaa', response),
        );

        socket.emit('findOneAaa', 1, response =>
          console.log('findOneAaa', response),
        );

        socket.emit('createAaa', {name: 'guang'},response =>
          console.log('createAaa', response),
        );

        socket.emit('updateAaa',{id: 2, name: 'dong'},response =>
          console.log('updateAaa', response),
        );

        socket.emit('removeAaa', 2,response =>
          console.log('removeAaa', response),
        );
      });
      socket.on('disconnect', function() {
        console.log('Disconnected');
      });
    </script>
  </head>

  <body></body>
</html>
```

这段代码也比较容易看懂，就是用 socket.io 来连接 ws 服务端。

connect 之后，分别发送 find、remove、update 等消息。

然后在 main.ts 里支持下这个 pages 静态目录的访问：

```javascript
import { NestApplication, NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.useStaticAssets('pages');
  await app.listen(3000);
}
bootstrap();
```

把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e54288524c5c458e8f1623883f190333~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1776&h=554&s=243746&e=png&b=181818)

浏览器访问下 http://localhost:3000

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1888dd8944bd4cd08a59579a9320e825~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=978&h=972&s=97892&e=png&b=fefefe)

可以看到，CRUD 方法都有了正确的响应。

在 Nest 里写 WebSocket 服务就这么简单。

那如果响应接受和返回消息不想用同样的名字呢？

这样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a362ed2d7e74839a5f384da5de5a078~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=610&s=127164&e=png&b=202020)

分别指定 event 和 data。

这时候原来的代码就收不到 findAll 返回的消息了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66f6642d80544f7e8d4e93cfe4a5787c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=986&h=956&s=90176&e=png&b=fefefe)

因为返回的消息是 guang，可以加一下这个事件的监听：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/296d293e676742c987b55aa8057d1905~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=482&s=97323&e=png&b=1f1f1f)

```javascript
socket.on('guang', function(data) {
    console.log('guang', data);
});
```
这样就收到消息了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46ac2ba29cbb43f0a221e5bd705bf35d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=966&h=962&s=95949&e=png&b=fefefe)

那如果我不是马上发送消息，而是过几秒再发呢？

这就要返回 rxjs 的 Observer 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1468d5c160148178c339270825e02e3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1120&h=810&s=160555&e=png&b=1f1f1f)

```javascript
@SubscribeMessage('findAllAaa')
findAll() {
    return new Observable((observer) => {
      observer.next({ event: 'guang', data: { msg: 'aaa'} });

      setTimeout(() => {
        observer.next({ event: 'guang', data: { msg: 'bbb'} });
      }, 2000);

      setTimeout(() => {
        observer.next({ event: 'guang', data: { msg: 'ccc'} });
      }, 5000);
    });
}
```

测试下：

可以看到，2s、5s 的时候，收到了服务端传过来的消息。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6bb22a986b4fb39c2def618eff5561~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&h=672&s=65781&e=gif&f=27&b=fefefe)

有这些就足够用了，websocket 是用来双向实时通信的。

当然，如果你想用具体平台的 api，也可以注入实例。

安装 socket.io（Nest 默认使用 socket.io 包实现 WebSocket 功能）
```
npm install socket.io
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cf4aba85c7045d78df8519a16986f39~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1198&h=856&s=207195&e=png&b=1f1f1f)

```javascript
@SubscribeMessage('findOneAaa')
findOne(@MessageBody() id: number, @ConnectedSocket() server: Server) {

    server.emit('guang', 666);
    return this.aaaService.findOne(id);
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/593aa19c68f244019cab9c2455f0c933~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=816&h=762&s=58989&e=png&b=ffffff)

这样也可以，但是和具体的平台耦合了，不建议这样写。

除了 @ConnectedSocket 装饰器注入实例，也可以用 @WebSocketServer 注入实例：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1d9098eaae24585b6c7701ad6a1453e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996&h=734&s=187879&e=png&b=1f1f1f)

```javascript
@WebSocketServer()
server: Server;

@SubscribeMessage('createAaa')
create(@MessageBody() createAaaDto: CreateAaaDto) {
    this.server.emit('guang', 777);
    return this.aaaService.create(createAaaDto);
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/417aaf0a8e7e44fc9ef65e903f8d15a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=780&h=850&s=68755&e=png&b=fefefe)

同样，也是不建议用的。

此外，服务端也有 connected、disconnected 等生命周期函数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/831abbd32acd42c890ec043663ee9385~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1390&h=446&s=92366&e=png&b=1f1f1f)
```javascript
@WebSocketGateway()
export class AaaGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect{

  handleDisconnect(client: Server) {
  }

  handleConnection(client: Server, ...args: any[]) {
  }
    
  afterInit(server: Server) {
  }
}
```
分别实现 OnGatewayInit、OnGatewayConnection、OnGatewayDisconnect 接口。

在生命周期函数里可以拿到实例对象。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-websocket)。

## 总结

这节我们学习了 Nest 实现 WebSocket 服务。

需要用到 @nestjs/websockets 和 @nestjs/platform-socket.io 包。

涉及到这些装饰器：

- @WebSocketGateWay：声明这是一个处理 weboscket 的类。

- @SubscribeMessage：声明处理的消息。

- @MessageBody：取出传过来的消息内容。

- @WebSocketServer：取出 Socket 实例对象

- @ConnectedSocket：取出 Socket 实例对象注入方法

客户端也是使用 socket.io 来连接。

如果想异步返回消息，就通过 rxjs 的 Observer 来异步多次返回。

整体来说，Nest 里用 WebSocket 来做实时通信还是比较简单的。


## 148.聊天室项目：需求分析和原型图

学完 WebSocket 之后，我们做个项目来综合练习下。

WebSocket 的项目实战，最容易想到的就是即时通讯（Instant Messaging），也就是聊天室了。

我们每天都在用 QQ、微信，对它们的功能都很熟悉。 我们会实现最精简的版本，包括这些功能： 

![](<https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78413f01d2c43cf82ca2db9daf8ebd9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=944&h=1100&s=126010&e=png&b=ffffff>) 

用户可以注册账号、登录，忘记密码还可以通过邮箱找回。 

可以添加删除好友、群聊，查看好友、群聊列表。 

聊天支持单聊和群聊，可以发送文字、表情、图片、文件。 可以收藏聊天消息，后续查看。 

然后我们来画下原型图：

## 注册 

注册的时候要填入用户名、昵称、密码、邮箱，然后通过邮箱验证码验证邮箱的有效性，之后点击注册 

![](<https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92544eb78f6d416faeca213b2a74b637~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1656&h=1184&s=70208&e=png&b=ffffff>) 

## 登录

注册完之后，通过用户名密码登录

![](<https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bad2a2f6ff742cb9f96eabd32062fe4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592&h=1002&s=52642&e=png&b=ffffff>) 

## 修改密码

忘记密码的话，可以通过邮箱来重置密码

![](<https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8182de9e088446ef995be0b1f1439b23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1608&h=1068&s=57274&e=png&b=ffffff>)

## 修改信息

登录成功后，可以修改头像、昵称和邮箱：

![](<https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26ce08e936b34f138187ce4a2c520ced~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1208&h=844&s=41235&e=png&b=ffffff>)

## 通讯录

可以添加好友和群聊，在通讯录页面查看好友和群聊列表：

![](<https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933dd37eef4542c1ab8038025e12ed53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1304&h=900&s=57971&e=png&b=fefefe>)

右键可以删除好友/退出群聊。

## 添加好友/群聊

点击添加好友/群聊时，会有一个弹窗，输入账号/群聊号，可以搜索结果，然后点击添加就可以发送请求：

![](<https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd10544db0724209bbe0bfec61c0cdc4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1116&h=782&s=54551&e=png&b=cfcfcf>)

## 通知

收到好友请求或者加入群聊的请求的时候，可以在通知页面查看请求：

![](<https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e1fbc0f1554006b8b7b30368ec59f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1358&h=922&s=82277&e=png&b=ffffff>)

发送请求一方也可以在这里看到发出的请求。

## 聊天

加了好友或者加入群聊之后，就可以开始聊天了：

![](<https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c28534fcdb24af183076bc3d0be4e2d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1406&h=986&s=65437&e=png&b=fefefe>)

可以发送文字、表情、图片、文件。

## 收藏

聊天过程中可以收藏聊天消息，包括文字消息、图片消息、文件消息：

![](<https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/574dcb4751974f3f8f38a9c90236f1e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1440&h=972&s=62875&e=png&b=ffffff>)

可以按照文字、图片、文件等类型来查看。

## 总结

我们分析了下聊天室的需求，并画了原型图。

首先是账号相关，包括注册、登录、修改密码、修改信息等。

然后可以查看好友列表、添加好友、加入群聊、删除好友、退出群聊。

在通知页面可以看到收到的、发出的好友请求，群聊请求，可以通过好友请求。

聊天页面可以和好友聊天，也可以在群聊里聊天，可以发送文字、表情、图片、文件。

聊天消息可以收藏，之后在收藏页面查看，支持按照消息类型来查看。

实现了这些功能，一个简易聊天室就算完成了。

## 149.聊天室项目：技术选型和数据库设计

上节梳理了需求，画了原型图，这节来设计下技术方案。

## 技术栈
前端部分还是 React + Antd Design，脚手架用 create-vite：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0beaf880b4a4ffe8e1ef36e9270582f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1586&h=1048&s=265463&e=png&b=ffffff)

后端部分是 Nest + Prisma + Socket.io。

Prisma 是 ORM 框架，Socket.io 用来做 WebSocket 通信。

数据库是 mysql + redis，mysql 做持久化存储，redis 做缓存以及临时数据的存储。

用 minio 做 OSS 对象存储服务，存储上传的文件。

文档用 swagger 生成，部署用 docker compose + pm2。

## 数据库设计

然后来设计下数据库表：

用户表 users：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 用户ID |
| username | VARCHAR(50) |用户名 |
| password | VARCHAR(50) |密码 |
| nick_name | VARCHAR(50) |昵称 |
| email | VARCHAR(50) | 邮箱 |
| head_pic| VARCHAR(100) | 头像 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

好友关系表 friendship：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| user1_id | INT |用户1 |
| user2_id | INT |用户2 |

聊天室表 chatroom：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 聊天室ID |
| name | VARCHAR(50) |群聊名 |
| type | BOOLEAN | 类型（单聊、群聊） |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

用户所在聊天室表 user_chatroom：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| user_id | INT | 用户ID |
| chatroom_id | INT |聊天室ID |

聊天记录表 chat_history：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 聊天记录ID |
| content | VARCHAR(500) |聊天内容 |
| chatroom_id | INT | 聊天室ID |
| sender_id | INT | 发送者ID |
| send_time | DATETIME | 发送时间 |
| update_time | DATETIME | 更新时间 |

好友申请表 friend_request：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 聊天记录ID |
| from_user_id | VARCHAR(500) |聊天内容 |
| to_user_id | INT | 聊天室ID |
| status | VARCHAR(10) | 状态（待处理、已同意、已拒绝） |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

收藏表 favorite：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | ID |
| user_id | INT |聊天内容 |
| chat_history_id | INT | 聊天记录ID |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dfdb2067179481fb8ef946ce9285386~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1354&h=728&s=92122&e=png&b=fefefe)

然后划分下模块：

## 模块划分

首先是用户模块，实现登录、注册、信息修改的功能：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /user/login | POST | 用户登录 |
| /user/register | POST | 用户注册 |
| /user/update | POST | 用户个人信息修改|
| /user/update_password | POST |用户修改密码|

好友管理模块：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /friendship/add | POST | 添加好友 |
| /friendship/delete | DELETE | 删除好友|
| /friendship/list | GET | 好友列表 |

聊天室管理模块：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /chatroom/join | GET | 加入聊天室 |
| /chatroom/exit | GET | 退出聊天室|
| /chatroom/list | GET | 聊天室列表 |
| /chatroom/add | POST | 新建聊天室（单聊、群聊） |

聊天模块：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /chat | WEBSOCKET | 聊天 |

收藏管理模块：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /favorite/add | GET | 添加收藏 |
| /favorite/delete | DELETE | 删除收藏|
| /favorite/list | GET | 收藏列表 |

好友请求管理模块：

| 接口路径 | 请求方式 | 描述 |
| -- | -- | -- |
| /friend_request/list | GET | 好友请求列表 |
| /friend_request/confirm | GET | 同意好友请求 |
| /friend_request/reject | GET |拒绝好友请求|

## 总结

这节我们设计了下技术方案。

技术栈：前端是 antd + react + vite，后端是 nest + prisma + socket.io，数据库是 mysql + redis，对象存储用 minio，API 文档用 swagger 生成，部署用 docker compose + pm2，网关使用 nginx。

数据库表有 7 个：用户表 users、好友关系表 friendship、聊天室表 chatroom、用户所在聊天室表 user_chatroom、聊天记录表 chat_history、好友申请表 friend_request、收藏表 favorite。

模块有 6 个：用户模块、好友管理模块、聊天室管理模块、聊天模块、收藏管理模块、好友请求管理模块。

下节正式开始开发。


## 15.如何创建动态模块

前面讲过，Provider 是可以通过 useFactory 动态产生的，那 Module 可不可以呢？

自然是可以的，这节我们就来学下动态模块 Dynamic Module。

我们新建一个项目：

```
nest new dynamic-module -p npm
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46444cb09ad5475580b13f91ca1c1b45~tplv-k3u1fbpfcp-watermark.image?)

执行
```
nest g resource bbb
```
创建一个实现了 CRUD 的模块：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0deaf33ac2584601993f9efe543a7f20~tplv-k3u1fbpfcp-watermark.image?)

然后执行：
```
npm run start:dev
```
浏览器访问下，可以看到 bbb 模块生效了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c2e0f5e7124b58bcd45aef68e7c795~tplv-k3u1fbpfcp-watermark.image?)

这个模块是静态的，也就是它的内容是固定不变的，每次 import 都是一样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9ddb1665fb84cd6b936afeaa8f66979~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbbacaae49a24666867f801b5e05fb3d~tplv-k3u1fbpfcp-watermark.image?)

有的时候我们希望 import 的时候给这个模块传一些参数，动态生成模块的内容，怎么办呢？

这时候就需要 Dynamic Module 了：

```javascript
import { DynamicModule, Module } from '@nestjs/common';
import { BbbService } from './bbb.service';
import { BbbController } from './bbb.controller';

@Module({})
export class BbbModule {

  static register(options: Record<string, any>): DynamicModule {
    return {
      module: BbbModule,
      controllers: [BbbController],
      providers: [
        {
          provide: 'CONFIG_OPTIONS',
          useValue: options,
        },
        BbbService,
      ],
      exports: []
    };
  }
}
```

我们给 BbbModule 加一个 register 的静态方法，返回模块定义的对象。

和在装饰器里定义的时候的区别，只是多了一个 module 属性：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45215ab2add145518da9a0d7a82b8dc5~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c3d1fa81d634f7ca8fd247debb5afd3~tplv-k3u1fbpfcp-watermark.image?)

而且我们还可以把参数传入的 options 对象作为一个新的 provider。

import 的时候就得这样用了，通过 register 方法传入参数，返回值就是模块定义：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83f6b4e7df91480188fa7bf997bedae3~tplv-k3u1fbpfcp-watermark.image?)

改成这样之后，再跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/871337c427cd472da6d0e5473dc830a2~tplv-k3u1fbpfcp-watermark.image?)

依然是正常的。

而且这时候我们把传入的 options 通过 useValue 创建了个 provider，这样模块内部就可以注入它了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84605d8853614396983981028a3d88f5~tplv-k3u1fbpfcp-watermark.image?)

我在 BbbController 里面通过 token 注入这个 provider，打印下它的值。

改一下 register 的参数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d86e20ae721a40e194e39625aae8db53~tplv-k3u1fbpfcp-watermark.image?)

浏览器再访问下，可以看到控制台打印了 config 对象：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7d70c1d877a47379c70628b3d44db81~tplv-k3u1fbpfcp-watermark.image?)

这样我们就可以在 import 一个模块的时候，传入参数，然后动态生成模块的内容。

这就是 Dynamic Module。

这里的 register 方法其实叫啥都行，但 nest 约定了 3 种方法名：

*   register
*   forRoot
*   forFeature

我们约定它们分别用来做不同的事情：

*   register：用一次模块传一次配置，比如这次调用是 BbbModule.register({aaa:1})，下一次就是 BbbModule.register({aaa:2}) 了

*   forRoot：配置一次模块用多次，比如 XxxModule.forRoot({}) 一次，之后就一直用这个 Module，一般在 AppModule 里 import

*   forFeature：用了 forRoot 固定了整体模块，用于局部的时候，可能需要再传一些配置，比如用 forRoot 指定了数据库链接信息，再用 forFeature 指定某个模块访问哪个数据库和表。

光这么说可能不够直观，我们看一个真实的动态模块就懂了。

比如 @nestjs/typeorm 的动态模块：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96e4ef222a83420fb0311b590d98c424~tplv-k3u1fbpfcp-watermark.image?)

forRoot 传入配置，动态产生 provider 和 exports，返回模块定义。

而且还有 forRootAsync：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae55b26456214f0598e466248d27962f~tplv-k3u1fbpfcp-watermark.image?)

区别就是可以用 async 的 useFactory 动态产生 provider，比如异步请求别的服务拿到配置返回，作为 options。

forFeature 则是传入局部的一些配置，来动态产生局部用的模块：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6341cb4c47145f9adb9eb3f18a6ab16~tplv-k3u1fbpfcp-watermark.image?)

typeorm 的模块用起来是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cdb01de1a034e8fbd4721a9469c6d61~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee3de0dce054140a52a551c537da233~tplv-k3u1fbpfcp-watermark.image?)

在 AppModule 里 import 通过 forRoot 动态产生的模块，在具体的业务 Module 里，通过 forFeature 传入具体实体类的配置。

其实 forRoot、forFeature、register 有区别么？

本质上没区别，只是我们约定了它们使用上的一些区别。

此外，Nest 还提供了另一种方式来创建动态模块：

我们再生成一个新模块：

    nest g module ccc

然后生成个 controller：

    nest g controller ccc --no-spec

这次我们不手动写 register、registerAsync 等方法了，用 builder 来生成。

新建一个 ccc.module-definition.ts 文件：

```javascript
import { ConfigurableModuleBuilder } from "@nestjs/common";

export interface CccModuleOptions {
    aaa: number;
    bbb: string;
}

export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<CccModuleOptions>().build();
```

用 ConfigurableModuleBuilder 生成一个 class，这个 class 里就带了 register、registerAsync 方法。

返回的 ConfigurableModuleClass、MODULE\_OPTIONS\_TOKEN 分别是生成的 class 、options 对象的 token。

然后 Module 继承它：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b57382dcf0c4615803dba46ac4e4aaf~tplv-k3u1fbpfcp-watermark.image?)

这样这个 CccModule 就已经有了 register 和 registerAsync 方法了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe432d3624394d88bae76568627e9810~tplv-k3u1fbpfcp-watermark.image?)

不用自己定义了，省事了不少。

传入 options：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fa22770c34b48e4ba24700436ce5514~tplv-k3u1fbpfcp-watermark.image?)

那现在如何在 Module 内注入这个 options 呢？

记得 build class 的时候返回了一个 token 么？

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e591a30f6df541d4ae15b903fbb5b18f~tplv-k3u1fbpfcp-watermark.image?)

就用这个注入：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6e02c15f2904ef3a63a4c3ddde1805c~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { Controller, Get, Inject } from '@nestjs/common';
import { MODULE_OPTIONS_TOKEN, CccModuleOptions } from './ccc.module-definition';

@Controller('ccc')
export class CccController {

    @Inject(MODULE_OPTIONS_TOKEN)
    private options: CccModuleOptions;

    @Get('')
    hello() {
        return this.options;
    }
}
```

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66c068786e744a20aed3349bed11abb6~tplv-k3u1fbpfcp-watermark.image?)

可以看到拿到了 options 对象。

当然，options 对象不是这么用的，一般是用来做配置，内部的 provider 基于它来做一些设置，这里只是演示。

你还可以用 registerAsync 方法，用 useFactory 动态创建 options 对象：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50a913efd7e8479fb54f47e517f78ad4~tplv-k3u1fbpfcp-watermark.image?)

前面我们不是说还可以用 forRoot、forFeature 这样的方法么？

那用 builder 的方式如何生成这样的 class 呢？

调用 setClassMethodName 设置下就好了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63a5c0c2f2c40cb9a0719f8afe559dc~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9cad02e3bb84836adc5695ac32f0f06~tplv-k3u1fbpfcp-watermark.image?)

如果我还想根据传入的参数决定是否设置为全局模块呢？

那就要这样写了：

```javascript
import { ConfigurableModuleBuilder } from "@nestjs/common";

export interface CccModuleOptions {
    aaa: number;
    bbb: string;
}

export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<CccModuleOptions>().setClassMethodName('register').setExtras({
    isGlobal: true
  }, (definition, extras) => ({
    ...definition,
    global: extras.isGlobal,
  })).build();

```

setExtras 第一个参数是给 options 扩展啥 extras 属性，第二个参数是收到 extras 属性之后如何修改模块定义。

我们定义了 isGlobal 的 option，收到它之后给模块定义加上个 global。

这时候你就会发现 register 的 options 多了 isGlobal：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bf3b9deaeb54f93a188e3047a12af17~tplv-k3u1fbpfcp-watermark.image?)

这样创建的就是全局的模块。

不过这样还有个问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b88e8a8367840b0b4961162a5b8b69b~tplv-k3u1fbpfcp-watermark.image?)

options 那里多了 isGlobal 属性，但是类型定义这里还没有呀。

因为我们用的是这个类型：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b38c0025ad3d4b31be41167d177e595f~tplv-k3u1fbpfcp-watermark.image?)

最好是用 builder 返回的类型：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7a20711a3e7449a9258864e4ec61d57~tplv-k3u1fbpfcp-watermark.image?)

这样就有了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03dab57fce1c4c06b436b9ef41ce7a9d~tplv-k3u1fbpfcp-watermark.image?)

而这个 ASYNC\_OPTIONS\_TYPE 是 async 方式创建模块的 otpion 类型：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e345b91cb2475fb605f5a658e297de~tplv-k3u1fbpfcp-watermark.image?)

回过头来看一下这个 ConfigurableModuleBuilder，它只是对我们定义 register、registerAsync 的过程做了封装，传参数就可以生成对应的 class，简便了不少。

如果你觉得这种 builder 的方式更麻烦，那直接用第一种方式也可以。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/dynamic-module)。

## 总结

Module 可以传入 options 动态产生，这叫做动态 Module，你还可以把传入的 options 作为 provider 注入到别的对象里。

建议的动态产生 Module 的方法名有 register、forRoot、forFeature 3种。

*   register：用一次注册一次

*   forRoot：只注册一次，用多次，一般在 AppModule 引入

*   forFeature：用了 forRoot 之后，用 forFeature 传入局部配置，一般在具体模块里 imports

并且这些方法都可以写 xxxAsync 版本，也就是传入 useFactory 等 option，内部注册异步 provider。

这个过程也可以用 ConfigurableModuleBuilder 来生成。通过 setClassMethodName 设置方法名，通过 setExtras 设置额外的 options 处理逻辑。

并且返回的 class 都有 xxxAsync 的版本。

这就是动态模块的定义方式，后面用到 typeorm、mongoose 等模块会大量见到这种模块。


## 150.聊天室项目：用户注册

这节正式进入开发，我们先来开发注册功能。

创建个 nest 项目：

```
nest new chat-room-backend
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19e6fb2b45c744418a23b7fdc1f99df5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=944&h=700&s=286393&e=png&b=010101)

在 docker desktop 里把 mysql 的容器跑起来：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f88a32bf05364377b78fa25ca8a5f49d~tplv-k3u1fbpfcp-watermark.image?)

进入项目，安装 prisma

```
npm install prisma --save-dev
```
然后执行 init 创建 schema 文件：

```
npx prisma init
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea10e80f6fd04d7892d98c540a50c1ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1068&h=504&s=98914&e=png&b=181818)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92cd7c967458498ba039c9080c3b66ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1114&h=562&s=127603&e=png&b=1d1d1d)

改下 .env 的配置：

```
DATABASE_URL="mysql://root:你的密码@localhost:3306/chat-room"
```
并且修改下 schema 里的 datasource 部分：

```
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

然后创建 model。

上节分析过用户表的结构：

| 字段名 | 数据类型 | 描述 |
| --- | --- | --- |
| id | INT | 用户ID |
| username | VARCHAR(50) |用户名 |
| password | VARCHAR(50) |密码 |
| nick_name | VARCHAR(50) |昵称 |
| email | VARCHAR(50) | 邮箱 |
| head_pic| VARCHAR(100) | 头像 |
| create_time | DATETIME | 创建时间 |
| update_time | DATETIME | 更新时间 |

创建对应的 modal：

```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id  Int @id @default(autoincrement())
  username String @db.VarChar(50) @unique
  password String @db.VarChar(50)
  nickName String @db.VarChar(50)
  email String @db.VarChar(50)
  headPic String @db.VarChar(100) @default("")
  createTime DateTime @default(now())
  updateTime DateTime @updatedAt
}
```
注意，这里 username 要添加唯一约束。

在 mysql workbench 里创建 chat-room 的数据库：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39c6d6cf9799493daa920d5933bd56f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1652&h=1144&s=288195&e=png&b=e7e6e6)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79c6744195774e0983d2939e43b334c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=566&h=534&s=90810&e=png&b=e7e3e1)

然后先 migrate reset，重置下数据库：

```
npx prisma migrate reset 
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb18945e33674215bf629c4c44146940~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=584&s=89806&e=png&b=191919)

然后创建新的 migration:

```
npx prisma migrate dev --name user
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29dc35c3dae7474489ad14a0a24a6ffe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1140&h=568&s=89459&e=png&b=191919)

这时就生成了迁移文件，包含创建 user 表的 sql 语句：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/230839d862284a0d9bd52a9bc46b855b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1506&h=676&s=214936&e=png&b=1d1d1d)

在 mysql workbench 里可以看到创建好的 user 表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0e46c77c86a410fa062d50641797b77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=594&s=282795&e=png&b=f4f2f1)

并且 migrate dev 还会生成 client 代码，接下来我们就可以直接来做 CRUD 了。

创建个 module 和 service：

```
nest g module prisma
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9c3aef03334fbf83790ed66059ed10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=672&h=106&s=26457&e=png&b=191919)
```
nest g service prisma --no-spec
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f013381ca40e4585989ff508c0005fb9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=708&h=96&s=25318&e=png&b=191919)

改下 PrismaService，继承 PrismaClient，这样它就有 crud 的 api 了：

```javascript
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {

    constructor() {
        super({
            log: [
                {
                    emit: 'stdout',
                    level: 'query'
                }
            ]
        })
    }

    async onModuleInit() {
        await this.$connect();
    }
}
```

在 constructor 里设置 PrismaClient 的 log 参数，也就是打印 sql 到控制台。

在 onModuleInit 的生命周期方法里调用 $connect 来连接数据库。

然后把 PrismaService 导出，并且设置 PrismaModule 为全局模块：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e66f8e8dafc04259b0f68068d64a59a1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=852&h=372&s=72894&e=png&b=1f1f1f)

这样各处就都可以注入 PrismaService 用了。

然后创建 user 模块：

```
nest g resource user
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a8bdb06dba43be8e0a9ee6f1747c05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=268&s=66149&e=png&b=191919)

在 UserService 里注入 PrismaService 来做 crud：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0016ca216a514e1982ef2b355da3accd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=972&h=702&s=126856&e=png&b=1f1f1f)

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { Prisma } from '@prisma/client';

@Injectable()
export class UserService {

  @Inject(PrismaService)
  private prisma: PrismaService;

  async create(data: Prisma.UserCreateInput) {
      return await this.prisma.user.create({
          data,
          select: {
              id: true
          }
      });
  }
}
```
写代码的时候你会发现，参数的类型 prisma 都给你生成好了，直接用就行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1834efcc33ae466f81465725f602300b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=504&s=115981&e=png&b=202020)

user 模块有这些接口：

| 接口路径 | 请求方式 | 描述 |
| -- |-- |-- |
| /user/login | POST | 用户登录 |
| /user/register | POST | 用户注册 |
| /user/update | POST | 用户个人信息修改|
| /user/update_password | POST |用户修改密码|

我们这节实现注册：

在 UserController 增加一个 post 接口：

```javascript
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { UserService } from './user.service';
import { RegisterUserDto } from './dto/register-user.dto';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post('register')
  async register(@Body() registerUser: RegisterUserDto) {
      return await this.userService.create(registerUser);
  }
}
```
dto 是封装 body 里的请求参数的，根据界面上要填的信息，创建 dto：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6301c45c4c304b759b404b92ac28f988~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1656&h=1184&s=61724&e=png&b=ffffff)

创建 user/dto/register-user.dto.ts

```javascript
export class RegisterUserDto{
    username: string;

    password: string;

    nickName: string;

    email: string;

    captcha: string;
}
```

把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01e91a3b37bd40bbbdd41b3c1f86624f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1572&h=468&s=187058&e=png&b=181818)

在 postman 里调用下试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93db2c95a64642f4b3934c03149f4c48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158&h=880&s=119652&e=png&b=fdfdfd)
```javascript
{
    "username": "guang",
    "nickName": "神说要有光",
    "password": "123456",
    "email": "xxxx@xx.com",
    "captcha": "abc123"
}
```
报错了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cfef6be9eab4d568330bdf4474b2d37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=524&s=76584&e=png&b=181818)

数据库中没有 captcha 的字段。

我们要在调用 service 之前删掉它：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f95402e58cf643f4bb81efe78e5fecdb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1014&h=692&s=150785&e=png&b=1f1f1f)

再试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b445de70f9949f88a108c1029487ad6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=770&h=800&s=86510&e=png&b=fcfcfc)

服务端打印了 insert 的 sql 语句：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f14b7fa3769a493592cd40196a3821d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1684&h=566&s=220284&e=png&b=181818)

数据库里也可以看到这条记录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca160547d3e5478080f02f66b2f7f151~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1654&h=342&s=144369&e=png&b=f1efee)

然后加一下 ValidationPipe，来对请求体做校验。

安装用到的包：

```
npm install --save class-validator class-transformer
```

全局启用 ValidationPipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d3f39712c6f469ba987c119d271b92b~tplv-k3u1fbpfcp-watermark.image?)

```javascript
app.useGlobalPipes(new ValidationPipe());
```

然后加一下校验规则：

```javascript
import { IsEmail, IsNotEmpty, MinLength } from "class-validator";

export class RegisterUserDto {

    @IsNotEmpty({
        message: "用户名不能为空"
    })
    username: string;
    
    @IsNotEmpty({
        message: '昵称不能为空'
    })
    nickName: string;
    
    @IsNotEmpty({
        message: '密码不能为空'
    })
    @MinLength(6, {
        message: '密码不能少于 6 位'
    })
    password: string;
    
    @IsNotEmpty({
        message: '邮箱不能为空'
    })
    @IsEmail({}, {
        message: '不是合法的邮箱格式'
    })
    email: string;
    
    @IsNotEmpty({
        message: '验证码不能为空'
    })
    captcha: string;
}
```
测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/891bf47824664ca6a602718f0dde4a31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=964&h=938&s=119657&e=png&b=fdfdfd)

没啥问题。

然后实现注册的逻辑。

注册的逻辑是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fca11ff8154b31bf76cc2cea3d908a~tplv-k3u1fbpfcp-watermark.image?)

我们需要先封装个 redis 模块。

```
nest g module redis
nest g service redis --no-spec
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/872494934b3f4ecb890aab20b2be45d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=654&h=202&s=50827&e=png&b=191919)

安装 redis 的包：

```
npm install --save redis
```
确保 redis 的 docker 容器是启动的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e7584c6b664f13b8521c1a3db3c342~tplv-k3u1fbpfcp-watermark.image?)

添加连接 redis 的 provider

```javascript
import { Global, Module } from '@nestjs/common';
import { RedisService } from './redis.service';
import { createClient } from 'redis';

@Global()
@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            },
            database: 2
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```
用 @Global() 把它声明为全局模块，这样只需要在 AppModule 里引入，别的模块不用引入也可以注入 RedisService 了。

database 指定为 2，默认是 0

把存储的 key-value 的数据放到不同命名空间下，避免冲突。

然后写下 RedisService

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async get(key: string) {
        return await this.redisClient.get(key);
    }

    async set(key: string, value: string | number, ttl?: number) {
        await this.redisClient.set(key, value);

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```

注入 redisClient，实现 get、set 方法，set 方法支持指定过期时间。

然后继续实现 register 方法。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90fca11ff8154b31bf76cc2cea3d908a~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { HttpException, HttpStatus, Inject, Injectable, Logger } from '@nestjs/common';
import { PrismaService } from 'src/prisma/prisma.service';
import { RedisService } from 'src/redis/redis.service';
import { RegisterUserDto } from './dto/register-user.dto';

@Injectable()
export class UserService {

  @Inject(PrismaService)
  private prismaService: PrismaService;

  @Inject(RedisService)
  private redisService: RedisService;

  private logger = new Logger();

  async register(user: RegisterUserDto) {
      const captcha = await this.redisService.get(`captcha_${user.email}`);

      if(!captcha) {
          throw new HttpException('验证码已失效', HttpStatus.BAD_REQUEST);
      }

      if(user.captcha !== captcha) {
          throw new HttpException('验证码不正确', HttpStatus.BAD_REQUEST);
      }

      const foundUser = await this.prismaService.user.findUnique({
        where: {
          username: user.username
        }
      });

      if(foundUser) {
        throw new HttpException('用户已存在', HttpStatus.BAD_REQUEST);
      }

      try {
        return await this.prismaService.user.create({
          data: {
            username: user.username,
            password: user.password,
            nickName: user.nickName,
            email: user.email
          },
          select: {
            id: true,
            username: true,
            nickName: true,
            email: true,
            headPic: true,
            createTime: true
          }
        });
      } catch(e) {
        this.logger.error(e, UserService);
        return null;
      }
  }
}
```
先检查验证码是否正确，如果正确的话，检查用户是否存在，然后用 prismaService.create 插入数据。

失败的话用 Logger 记录错误日志。

这里的 md5 方法放在 src/utils.ts 里，用 node 内置的 crypto 包实现。
```javascript
import * as crypto from 'crypto';

export function md5(str) {
    const hash = crypto.createHash('md5');
    hash.update(str);
    return hash.digest('hex');
}
```
在 UserController 里调用下：

```javascript
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { UserService } from './user.service';
import { RegisterUserDto } from './dto/register-user.dto';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post('register')
  async register(@Body() registerUser: RegisterUserDto) {
    return await this.userService.register(registerUser);
  }
}
```
然后在 postman 里测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb80249d69514fa7a280f0cf4365173f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=802&s=94949&e=png&b=fcfcfc)

因为还没实现发送邮箱验证码的逻辑，这里我们手动在 redis 添加一个 key：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/470ded5fb7b74eee8a12d33cf1870e0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2576&h=1110&s=201778&e=png&b=1b1b1b)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc40a67e2e964c9083b6d7315b90113a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1618&h=558&s=82300&e=png&b=171717)

测试下：

带上错误的验证码，返回验证码不正确；


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81f436f31602425a9f510697cb975e4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=766&s=99412&e=png&b=fcfcfc)
带上正确的验证码，注册成功：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46328bce605f4d1093453865336b67dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=908&h=856&s=119308&e=png&b=fcfcfc)
这时可以在数据库里看到这条记录：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d2d00e97ce643ebabf11e32e2523739~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=258&s=96335&e=png&b=f4f4f4)

然后我们来实现发送邮箱验证码的功能。

封装个 email 模块：

```
nest g resource email --no-spec
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/659eefe03f764e3d89faf41ed204b971~tplv-k3u1fbpfcp-watermark.image?)

安装发送邮件用的包：

```
npm install nodemailer --save
```
在 EmailService 里实现 sendMail 方法

```javascript
import { Injectable } from '@nestjs/common';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor() {
      this.transporter = createTransport({
          host: "smtp.qq.com",
          port: 587,
          secure: false,
          auth: {
              user: '你的邮箱地址',
              pass: '你的授权码'
          },
      });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '聊天室',
          address: '你的邮箱地址'
        },
        to,
        subject,
        html
      });
    }
}
```
把邮箱地址和授权码改成你自己的。

具体怎么生成授权码，看前面的 [node 发送邮件](https://juejin.cn/book/7226988578700525605/section/7247327089496424505)那节。

把 EmailModule 声明为全局的，并且导出 EmailService

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3ef7c1c9104c2aa069be22cf04bfd1~tplv-k3u1fbpfcp-watermark.image?)

然后在 UserController 里添加一个 get 接口：

```javascript
@Inject(EmailService)
private emailService: EmailService;

@Inject(RedisService)
private redisService: RedisService;

@Get('register-captcha')
async captcha(@Query('address') address: string) {
    const code = Math.random().toString().slice(2,8);

    await this.redisService.set(`captcha_${address}`, code, 5 * 60);

    await this.emailService.sendMail({
      to: address,
      subject: '注册验证码',
      html: `<p>你的注册验证码是 ${code}</p>`
    });
    return '发送成功';
}
```

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bfcaa8df33c441f918169ad6a3db8af~tplv-k3u1fbpfcp-watermark.image?)

邮件发送成功：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8898d7dcefa8436c9d451212daeaebc7~tplv-k3u1fbpfcp-watermark.image?)

redis 里也保存了邮箱地址对应的验证码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d502a0e687994163b2b5b832bf920d87~tplv-k3u1fbpfcp-watermark.image?)

通过邮件发送验证码之后，保存到 redis，注册的时候取出邮箱地址对应的验证码来校验。

这样，整个注册的流程就完成了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d91b2715c99c4e699f00087a3fa9ca89~tplv-k3u1fbpfcp-watermark.image?)

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/chat-room-backend)。

## 总结

这节我们创建了 nest 项目，并引入了 prisma 和 redis。

通过 prisma 的 migrate 功能，生成迁移 sql 并同步到数据库。

此外，prisma 会生成 client 的代码，我们封装了 PrismaService 来做 CRUD。

我们实现了 /user/register 和 /user/register-captcha 两个接口。

/user/register-captcha 会向邮箱地址发送一个包含验证码的邮件，并在 redis 里存一份。

/user/register 会根据邮箱地址查询 redis 中的验证码，验证通过会把用户信息保存到表中。

这样，注册功能就完成了。


## 158.MongoDB 快速入门

数据库我们学习了 mysql，这节来再来学下 mongodb。

在 docker desktop 搜索 mongo 镜像，然后把它跑起来：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7964844898c24521b3c42cc1906b78bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1820&h=1356&s=224586&e=png&b=f3f4f8)

指定容器名、映射的端口号，以及挂载到 /data/db 的本地目录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e609de4add42458db6d479c4bc8bac0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1556&h=1422&s=225825&e=png&b=ffffff)

这个本地目录是本地的任何一个目录都行，用来存放 mongodb 的数据的。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d98f8dab560d4566b8d3a2b6f13c34e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2384&h=1354&s=508585&e=png&b=ffffff)

跑起来之后，进入 terminal，开始学习 mongodb 的 crud：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457143fdd8f14c53a7c0514931b1e15c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1882&h=1282&s=238877&e=png&b=ffffff)

输入 mongosh，就可以敲 mongo 命令了：

```
show dbs;
show databases;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cee65144f1c4fc982413c7aa5ca117e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1118&h=726&s=128228&e=png&b=f3f3f5)

查看下现有的 database。

和 mysql 一样，mongodb 也是通过一个个 database 来存储不同数据的，只不过 mysql 的 database 里存的是 table，而 mongo 里存的是 Collection。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4f36495507f4d8588aef91186382eb4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=900&h=596&s=174686&e=png&b=fbfbfb)

创建或者切换 database 用 use 

```
use hello-mongo;
```
然后 db 命令查看当前 database：

```
db;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6532b74ca3974a8c8a54191d211ddd5d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=570&h=448&s=47060&e=png&b=f6f6f8)

但这时候你再用 show dbs 会发现没有这个 db：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d36f3ad079264d73acd6582ba72a585c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=594&h=454&s=50865&e=png&b=f5f5f7)

这是因为默认有了一个 collection 之后才会把 database 写入硬盘。

```javascript
db.createCollection('aaa');
```

创建了一个 collection 之后，再次 show dbs，这时候就看到这个新的 database 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/354ad786c39c44d3b7201d4cdf1b62cb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=860&s=115140&e=png&b=ffffff)

如果你想删除 database，用这个命令：

```javascript
db.dropDatabase();
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/101b32af98c849009a735b1fb2f2fa96~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=598&h=444&s=53271&e=png&b=ffffff)

创建和删除 database 我们会了，然后是 collection：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bad84da104845499e5c415656da7d30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=766&h=584&s=68031&e=png&b=ffffff)

用 db.createCollection 创建 db，然后可以用 db.xxx.drop() 删掉。

接下来向 collection 中插入几个 document：

```javascript
db.xxx.insertOne({ name: 'guang', age: 20, phone: '13222222222'});

db.xxx.insertMany([{ name: 'dong', age: 21}, {name: 'xxx', hobbies: ['writing']}]);

db.xxx.insertMany([{ name: 'dong2', age: 20}, {name: 'guang2', hobbies: ['writing']}]);
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ee9691d90a64dacbcaef6cbed0a6957~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1610&h=1062&s=192695&e=png&b=ffffff)

可以看到，插入的数据可以是任意结构的，这就是 mongodb 和 mysql 的最大区别。

不像 mysql 只能在 table 里存结构化的记录一样，mongodb 的 collection 里可以存任意结构的 document。

再就是 mysql 是需要用 sql 来 crud 的，而 mongodb 里是用 api。

但完成的功能是一样的，可以在 [mongodb 文档](https://www.mongodb.com/docs/mongodb-shell/crud/)里看到每个 api 的介绍下面都有对应的 sql 写法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2672a61daeb4722ab464546afd2cd71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1252&h=766&s=103301&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b92f4741b184e1aa0aea7c9ef04aa81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1478&h=922&s=137115&e=png&b=ffffff)

我们试下查询：

```javascript
db.xxx.find({age: 20});

db.xxx.findOne({ age: 20});
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/390c09c85ee7438ea9abbcc677a825c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=906&s=125311&e=png&b=ffffff)

find 是查询多条记录，而 findOne 只返回第一条。

当不传过滤条件的时候，就是返回所有的 Document：

```javascript
db.xxx.find()
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6352fb6251e4cc5940a10bae71b7c35~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1132&h=1022&s=141139&e=png&b=ffffff)

查询条件有多个值的时候这样写，类似 sql 的 in：

```javascript
db.xxx.find({ age: { $in: [20, 21]}})
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b469f218690c4b888368bfb051be7258~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1124&h=684&s=103581&e=png&b=ffffff)

in 是包含， nin 是不包含。

类似 in 的还有 gt（great than）、lt（less than）、gte（great than equal ）、lte（less than equal ）、ne（not equal）

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f85ea35fd7c441b8d2bcb9cfdd4c6be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=836&s=129614&e=png&b=ffffff)

多个条件的时候用 and：

```javascript
db.xxx.find({ $and: [{age: { $gte: 20 }}, { name: /dong\d/}]})

db.xxx.find({ $and: [{age: { $gte: 20 }}, { name: /dong*/}]})
```
搜索 age 大于等于 20，并且名字包含 dong 的 Document，这里用的正则做的模糊匹配：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed6e2c0a4e6495a96a0d57f36eec928~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1184&h=664&s=115367&e=png&b=ffffff)

用 or 的话就是两个条件满足一个就行：

```javascript
db.xxx.find({ $or: [{age: { $gt: 20 }}, { name: /dong*/}]})
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/084a9a83213f4b2fa7732cf014859645~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1134&h=500&s=83910&e=png&b=ffffff)

分页用的是 skip 和 limit 方法：

```javascript
db.xxx.find().skip(1).limit(2)
```
从第一条 Document 开始，取 2 条：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/302aee71ae304de39ba34fc790f2c44b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1266&h=1306&s=191213&e=png&b=ffffff)

更新的话用 updateOne、updateMany 方法：

```javascript
db.xxx.updateOne({ name: 'guang'}, { $set: {age: 30} })
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe549e27503f4899b6d06b8dbae93c97~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1054&h=910&s=115283&e=png&b=ffffff)

如果在更新的时候带上时间戳，可以用 $currentDate：

```javascript
db.xxx.updateOne({ name: 'guang'}, { $set: {age: 30}, $currentDate: { aaa: true } })
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5870c77d4f4c44feb3dbd664fd77c026~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1502&h=966&s=140361&e=png&b=ffffff)

如果你想替换整个的 document，那么用 replaceOne：

```javascript
db.xxx.replaceOne({name: 'guang'}, { age: 30})
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0193eb8482a94689924dbc4c233d5f64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1236&h=1182&s=174389&e=png&b=ffffff)

删除的话，也有 deleteOne 和 deleteMany 两个方法：

```javascript
db.xxx.deleteMany({ age: { $gt: 20 }});
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8776470d8797476eab34b80c8888094e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1244&h=1388&s=216094&e=png&b=ffffff)

此外，还有 count 可以计数：

```javascript
db.xxx.count()

db.xxx.count({ name: /guang/})
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4431218ae4274d4f8aba5b77153963c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168&h=958&s=125800&e=png&b=ffffff)

sort 可以排序，1 是升序、-1 是降序：

```javascript
db.xxx.find().sort({ age: -1})
```

按照 age 降序：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abed6c924da1466fac75586e42446b40~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1326&h=1262&s=180491&e=png&b=ffffff)

```javascript
db.xxx.find().sort({ age: -1, name: 1})
```

先按照 age 降序，再按照 name 升序：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5dff59167b4e47991ef2c9fabf06b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1142&h=542&s=75845&e=png&b=ffffff)


这样，CRUD 我们都过了一遍。

当然，这些操作也都可以在 GUI 里可视化的搞，这样就不用敲命令了：

下载官方 GUI 工具 [Mongo Compass](https://www.mongodb.com/products/tools/compass)：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d72020b680940b7b1651fd05ecb2afc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2522&h=1446&s=291571&e=png&b=081e2a)

连接上 mongodb 的 server：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0521b85612541c980928b9a53f3e810~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2254&h=1054&s=218737&e=png&b=fefdfd)

在 GUI 工具里操作就很方便直观了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d1de2e794294139a0acf6fac4f44978~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1774&h=1220&s=203782&e=png&b=fffefe)

可以看到所有的 database、collection、document。

在这里输入过滤条件后点击 find：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/496b6b16db1849bfa8e76c200df424ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2178&h=666&s=108995&e=png&b=ffffff)

更新和删除也都很直观：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bef3f4f8eb1645f899c1fd2a7588ca64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1694&h=376&s=69510&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d24886202e224f73afdef3090c71e517~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1630&h=274&s=51400&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e375eaf369a4368ab186a8ae7e5abe9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1664&h=218&s=37631&e=png&b=ffffff)

## 总结

这节我们入门了 mongodb。

它的 database 下是 collection，collection 包含多个 document。

document 可以是任意结构的，这点和 mysql 的 table 不同。

mongo 是通过 api 来做 CRUD 的，不是用的 sql。

我们过了一遍常用的命令和 api：

```javascript
show dbs; // 显示 database
show databases;

use hello-mongo; // 切换或者创建 database

db; // 查看当前 database

db.dropDatabase(); // 删除 database

db.createCollection('aaa'); // 创建 collection

db.xxx.drop() //删除 collection

db.xxx.insertOne({ name: 'guang', age: 20, phone: '13222222222'});// 插入 document

db.xxx.insertMany([{ name: 'dong', age: 21}, {name: 'xxx', hobbies: ['writing']}]);

db.xxx.find({age: 20}); // 查询 collection

db.xxx.findOne({ age: 20});

db.xxx.findOne(); // 查询所有 collection

db.xxx.find({ age: { $in: [20, 21]}}) // 使用 in、nin 查询多个值

db.xxx.find({ $and: [{age: { $gte: 20 }}, { name: /dong\d/}]}) // 使用 and 指定多个条件同时成立

db.xxx.find({ $or: [{age: { $gt: 20 }}, { name: /dong*/}]}) // 使用 or 表示或者

db.xxx.find().skip(1).limit(2) // 使用 skip + limit 实现分页

db.xxx.updateOne({ name: 'guang'}, { $set: {age: 30}, $currentDate: { aaa: true } }) // updateOne、updateMany 更新

db.xxx.replaceOne({name: 'guang'}, { age: 30}) // 整体替换

db.xxx.deleteMany({ age: { $gt: 20 }}); // deleteOne、deleteMany 删除

db.xxx.count({ name: /guang/})

db.xxx.find().sort({ age: -1, name: 1})
```
当然，平时不用敲 api，用 Mongo Compass 的 GUI 工具操作非常简单。


## 159.使用 mongoose 操作 MongoDB 数据库

上节我们用了下 mongodb，这节在 node 里操作下。

在 node 里操作 mongodb 我们常用的是 mongoose 这个包。

创建个项目：

```shell
mkdir mongoose-test
cd mongoose-test
npm init -y
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e48c14c0e614f0da197e64dedb68c43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=648&s=130689&e=png&b=010101)

进入项目，安装 mongoose 包。

```shell
npm install --save mongoose
```
在 Docker Desktop 里把 mongodb 的容器跑起来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e609de4add42458db6d479c4bc8bac0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1556&h=1422&s=225825&e=png&b=ffffff)

然后用 node 代码连接下。

创建 index.js

```javascript
const mongoose = require('mongoose');

main().catch(err => console.log(err));

async function main() {
  await mongoose.connect('mongodb://localhost:27017/guang');

  const PersonSchema = new mongoose.Schema({
    name: String,
    age: Number,
    hobbies: [String]
  });

  const Person = mongoose.model('Person', PersonSchema);

  const guang = new Person();
  guang.name = 'guang';
  guang.age = 20;

  await guang.save();

  const dong = new Person();
  dong.name = 'dong';
  dong.age = 21;
  dong.hobbies = ['reading', 'football']

  await dong.save();

  const persons = await Person.find();
  console.log(persons);
}
```
首先创建 Schema 描述对象的形状，然后根据 Schema 创建 Model，每一个 model 对象存储一个文档的信息，可以单独 CRUD。

因为 collection 中的 document 可以是任意形状：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/158f074fb746421cb4305fc414812065~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=782&h=720&s=88926&e=png&b=ffffff)

我们需要先用 Schema 声明具体有哪些属性再操作。

跑一下：
```
node index.js
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efc1d197546849428f5fa9bba93682b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=502&s=57369&e=png&b=181818)

在 MongoDB Compass 里看下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3950ec7aec954110b33d66d0f3a13255~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1496&h=1092&s=172815&e=png&b=ffffff)

两条数据都插入了。

而且在 mongoose 里查询的语法和上节我们学的 mongodb 的 api 一模一样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7ccf5f5f94542719b70f77e8d36caa4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1010&h=1248&s=185273&e=png&b=1d1d1d)

```javascript
const persons = await Person.find(
    {
        $and: [{age: { $gte: 20 }}, { name: /dong/}]
    }
);
console.log(persons);
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6f7b636f924a69987ede310e6e2c9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=1336&s=193811&e=png&b=1c1c1c)

```javascript
const persons = await Person.find(
    {
        age: { $in: [20, 21]}
    }
);
console.log(persons);
```

增删改查的方法都比较简单，就不一个个试了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b09557e16b4cb98e82919d6b24a656~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=764&h=366&s=60278&e=png&b=202020)

然后在 nest 项目里操作下。

创建个项目：

```shell
nest new nest-mongoose
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c14d5986b404bf68745ece8b23237c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=876&h=692&s=267519&e=png&b=010101)

进入项目，安装用到的包：

```
npm install @nestjs/mongoose mongoose
```
在 AppModule 里引入下 MongooseModule

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35ac95afe35e4a998eb10f927b7bc53f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1030&h=576&s=118033&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { MongooseModule } from '@nestjs/mongoose';

@Module({
  imports: [
    MongooseModule.forRoot('mongodb://localhost:27017/guang')
      
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
创建个模块：

```
nest g resource dog --no-spec
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f0945238d0a4c47bd1d83eabcd1dd9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=886&h=354&s=91308&e=png&b=191919)

改下 dog.entities.ts
```javascript
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { HydratedDocument } from 'mongoose';

@Schema()
export class Dog {
  @Prop()
  name: string;

  @Prop()
  age: number;
  
  @Prop([String])
  tags: string[];
}

export type DogDocument = HydratedDocument<Dog>;

export const DogSchema = SchemaFactory.createForClass(Dog);
```
用 @Schema 创建 schema，然后用 @Prop 声明属性。

之后用 SchemaFactory.createForClass 来根据 class 创建 Schema。

这个 HydratedDocument 只是在 Dog 类型的基础上加了一个 _id 属性：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa17b584540e4447b0dbaf4396f0d2f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1030&h=204&s=44603&e=png&b=202020)

然后 dog.module.ts 里注入 Schema 对应的 Model

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6d1dd8ccacc4e12b1c498be487678ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168&h=574&s=136405&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { DogService } from './dog.service';
import { DogController } from './dog.controller';
import { MongooseModule } from '@nestjs/mongoose';
import { Dog, DogSchema } from './entities/dog.entity';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Dog.name, schema: DogSchema }])
  ],
  controllers: [DogController],
  providers: [DogService],
})
export class DogModule {}
```

这样在 DogService 里就可以用 Model 来做 CRUD 了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/002c5256776d417b90bcc40e7ec93815~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=970&h=772&s=166339&e=png&b=1f1f1f)

```javascript
import { Injectable } from '@nestjs/common';
import { CreateDogDto } from './dto/create-dog.dto';
import { UpdateDogDto } from './dto/update-dog.dto';
import { Model } from 'mongoose';
import { InjectModel } from '@nestjs/mongoose';
import { Dog } from './entities/dog.entity';

@Injectable()
export class DogService {

  @InjectModel(Dog.name)
  private dogModel: Model<Dog>;

  create(createDogDto: CreateDogDto) {
    return 'This action adds a new dog';
  }

  findAll() {
    return this.dogModel.find();
  }

  findOne(id: number) {
    return `This action returns a #${id} dog`;
  }

  update(id: number, updateDogDto: UpdateDogDto) {
    return `This action updates a #${id} dog`;
  }

  remove(id: number) {
    return `This action removes a #${id} dog`;
  }
}
```
然后我们改下 create-dog.dto.ts

```javascript
import { IsNotEmpty, IsNumber, IsString, Length } from "class-validator";

export class CreateDogDto {

    @IsString()
    @IsNotEmpty()
    @Length(30)
    name: string;

    @IsNumber()
    @IsNotEmpty()
    age: number;
  
    tags: string[];
}
```
安装用到的包：

```
npm install class-validator class-transformer
```
之后完善下 DogService：

```javascript
import { Injectable } from '@nestjs/common';
import { CreateDogDto } from './dto/create-dog.dto';
import { UpdateDogDto } from './dto/update-dog.dto';
import { Model } from 'mongoose';
import { InjectModel } from '@nestjs/mongoose';
import { Dog } from './entities/dog.entity';

@Injectable()
export class DogService {

  @InjectModel(Dog.name)
  private dogModel: Model<Dog>;

  create(createDogDto: CreateDogDto) {
    const dog = new this.dogModel(createDogDto);
    return dog.save();
  }

  findAll() {
    return this.dogModel.find();
  }

  findOne(id: string) {
    return this.dogModel.findById(id);
  }

  update(id: string, updateDogDto: UpdateDogDto) {
    return this.dogModel.findByIdAndUpdate(id, updateDogDto);
  }

  remove(id: number) {
    return this.dogModel.findByIdAndDelete(id);
  }
}
```
之前把 id 转为 number 的 + 去掉，因为 mongodb 的 id 是 stirng：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3058a06adfd4029ac9654146c626744~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=416&s=87290&e=png&b=1f1f1f)

把服务跑起来：

```
npm run start:dev
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca34d224e24040d0b27835c1f3cdd57a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1484&h=602&s=287710&e=png&b=181818)

然后在 postman 里测试下：


先创建 2 个 dog：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9aa525eff4a544879ed1eb094fc177fc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=844&h=794&s=82377&e=png&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/747e2e7c304b474bb9e0f993aa23cd08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=894&s=87157&e=png&b=fcfcfc)

查询下全部：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a325ef05347426caaa483bc99dd6255~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=968&s=97520&e=png&b=fcfcfc)

单个：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad64e510d9d4e85812dad313ad48c5a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=822&s=83485&e=png&b=fdfdfd)

然后修改下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad603485e70341658479127a23385270~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=772&s=91229&e=png&b=fcfcfc)

再查询下：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5983ca8c705d4a1289153c16396606d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=860&h=948&s=98824&e=png&b=fdfdfd)

之后删除：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f936ee5049af4dd9b1acad29bd5fefcd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=986&h=688&s=80735&e=png&b=fcfcfc)

在 Mongodb Compass 里点击刷新，也可以看到数据确实被删掉了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12633613196540f199e0b5cf0d9e5fc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2466&h=862&s=145297&e=png&b=ffffff)

这就是在 nest 里对 MongoDB 做 CRUD 的方式。

案例代码在小册仓库：

[mongoose 操作 mongodb](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/mongoose-test)

[nest 集成 mongoose](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-mongoose)

## 总结

我们学习了用 mongoose 操作 MongoDB 以及在 Nest 里集成 mongoose。

主要是通过 Schema 描述形状，然后创建 Model，通过一个个 model 对象保存数据和做 CRUD。

因为 mongodb 本身提供的就是 api 的操作方式，而 mongoose 的 api 也是对底层 api 的封装，
所以基本可以直接上手用。


## 16.Nest 和 Express 的关系，如何切到 fastify

前面我们用的 Nest 的 request、response 对象都是 Express 的，而且 Nest 也支持 Express 的中间件机制。

那 Nest 和 Express 是什么关系呢？

Express 是一个处理请求、响应的库，它是这样用的：

```javascript
const express = require('express')
const cookieParser = require('cookie-parser')
const cookieValidator = require('./cookieValidator')

const app = express()

async function validateCookies (req, res, next) {
  await cookieValidator(req.cookies)
  next()
}

app.use(cookieParser())

app.use(validateCookies)

app.use((err, req, res, next) => {
  res.status(400).send(err.message)
})

app.listen(3000)
```

通过 use 一个个中间件来处理请求、返回响应。

这种调用链叫做洋葱模型：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dd1dde7a5ac42f194ee6c3c13dfbf2f~tplv-k3u1fbpfcp-watermark.image?)

基于中间件能完成各种功能。

但是 Express 只是一个处理请求的库，并没有提供组织代码的架构能力，代码可能写成各种样子。

所以企业级开发，我们会用对它封装了一层的库，比如 Nest。

Nest 提供了 IOC、AOP 等架构特性，规定了代码组织的形式，而且对 websocket、graphql、orm 等各种方案都提供了开箱即用的支持。

也就是说，用 Node 写一个 http 服务有三个层次：

*   直接使用 http、https 的模块
*   使用 express、koa 这种库
*   使用 Nest 这种企业级框架

就像写 java 你还会直接处理 http 请求并手动集成各种方案么？

不会，会直接用 Spring 这种一站式企业级开发框架。

同样的道理， Nest 就是 node 生态里的 Spring。

但是 Nest 也没有和 Express 强耦合，它做了一层抽象：

定义了 [HttpServer 的 interface](https://github.com/nestjs/nest/blob/d352e6f138bc70ff33cccf830053946d17272b82/packages/common/interfaces/http/http-server.interface.ts#L21C1-L85)：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/737f4e28b4e04a0681338bbbaa91ec72~tplv-k3u1fbpfcp-watermark.image?)

然后封装了 [AbstractHttpAdapter 的 abstract class](https://github.com/nestjs/nest/blob/d352e6f138bc70ff33cccf830053946d17272b82/packages/core/adapters/http-adapter.ts#L12C1-L131)：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aedd2108f5948558b48e32515f09eff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1288&h=1016&s=800739&e=png&b=1f1f1f)

之后分别提供了 express 和 fastify 的实现：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45563511aff34a8890efb03088db5d12~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac036845aabe45e1ae942da5e3f28d83~tplv-k3u1fbpfcp-watermark.image?)

Adapter 是适配器的意思，也就是说 Nest 内部并没有直接依赖任何一个 http 处理的库，只是依赖了抽象的接口，想用什么库需要实现这些接口的适配器。

你可以用 express，也可以灵活的切换成 fastify，对 Nest 没有任何影响。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0785a342c5be4bb281be14a2392748b1~tplv-k3u1fbpfcp-watermark.image?)

这俩适配器分别在 @nestjs/platform-express 和 @nestjs/platform-fastify 的包里：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79700acb386b4273a64e0731f2ef9434~tplv-k3u1fbpfcp-watermark.image?)

默认用的是 platform-express 的包：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dec436a6d1b240cb8a44649d300dedcf~tplv-k3u1fbpfcp-watermark.image?)

下面我们切换到 fastify 试试看：

    nest new fastify-test -p npm

同样，先用 @nestjs/cli 创建个 nest 项目

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ad59bc066ef4152b2fa2951ac583be1~tplv-k3u1fbpfcp-watermark.image?)

然后把它跑起来：

    nest start --watch

浏览器访问 <http://localhost:3000> 看到 hello world 就是服务跑成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/310458702e914659a54a8cd5c94dee41~tplv-k3u1fbpfcp-watermark.image?)

现在用的是默认的 express，我们切换到 fastify 试试看：

安装 fastify 和 @nestjs/platform-fastify：

    npm install fastify @nestjs/platform-fastify

然后修改下 Nest 创建的方式：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a243dd5577b42d9b105ccf0beb765bf~tplv-k3u1fbpfcp-watermark.image?)

改成这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58a860f3c9c24c5d85c3837518c309e9~tplv-k3u1fbpfcp-watermark.image?)

这个 FastifyAdapter 前面讲过，传入这个 adapter 之后，就切换到了 fastify 平台。

这里你还可以再传一个类型参数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c1767014d83455cb69862c28cc74238~tplv-k3u1fbpfcp-watermark.image?)

这样返回的 app 就会提示 fastify 平台特有的方法了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b91dd5b6f85435db7b79a84c59713ce~tplv-k3u1fbpfcp-watermark.image?)

这也是为什么之前我们要传入 NestExpressApplication 才有 useStaticAssets 方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13a07116cbc949369f1c32c95b33b41a~tplv-k3u1fbpfcp-watermark.image?)

然后在 controller 里可以注入 fastify 的 reqeust 和 reply 对象：

```javascript
import { Controller, Get, Request, Response } from '@nestjs/common';
import { FastifyReply, FastifyRequest } from 'fastify';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(@Request() request: FastifyRequest, @Response() reply: FastifyReply) {
    reply.header('url', request.url)
    reply.send('hello')
  }
}
```

我们注入了 fastify 的 request 和 reply 对象，然后用它来设置 header 发送响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa142f5c756945e9821982873126f59b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dd35f0b9ea64bac906d18f72b48bd5c~tplv-k3u1fbpfcp-watermark.image?)

这里要注意的是一旦用 @Response 注入了响应对象，就不能通过 return 的方式来返回响应内容了，需要手动调用 res.send。

这点用 express 时也是一样。

很容易理解，因为你可能在方法里用 resposne 对象发送数据了，那如果 Nest 再把返回值作为响应内容，不就冲突了么？

当然，你也可以这样做：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5873e1f9eb3d44b5a6e930a75e9525b4~tplv-k3u1fbpfcp-watermark.image?)

传个 passthrough 参数，代表不会在方法里自己发送响应内容。

这样返回值就生效了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80828b7f572a43958e6e33e0d265da46~tplv-k3u1fbpfcp-watermark.image?)

最后，我们来思考下为什么 Nest 要做能够轻松切换 http 处理库呢？

因为 Nest 的核心还是在于 IOC、AOP 这些架构特性，像 express、fastify 只不过是请求、响应的方法不同而已，区别并不大。

如果强依赖于 express，万一有更好的 http 处理库怎么办？

这种加一层抽象和适配器的方式，能让 Nest 更加通用、灵活，有更强的扩展性。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/fastify-test)。

## 总结

express 是基于中间件的洋葱模型处理请求、响应的库，它并没有提供组织代码的架构特性，代码可以写的很随意。

而为了更好的可维护性，我们都会用 Nest 这种一站式企业级开发框架。就像 java 里会用 Spring 框架一样。

Nest 底层是 express 但也不完全是，它内部实现是基于 interface 的，而且提供了 @nestjs/platform-express、@nestjs/platform-fastify 这两个 adapter 包。

这样就可以轻松的切换 express、fastify 或者其他的 http 请求处理的库。

这就是适配器模式的魅力。


## 160.GraphQL 快速入门

作为前端开发，想必经常做的事情就是：调接口、画页面、调接口、画页面...

调用的接口大概率是 restful 的，也就是类似这种：

/students 查询所有学生信息

/student/1 查询 id 为 1 的学生信息

上面说的是 get 请求。

如果对 /student/1 发送 POST、PUT、DELETE 请求，就分别代表了新增、修改、删除。

这就是 restful 风格的 web 接口。

这种接口返回什么信息是服务端那边决定的，客户端只是传一下参数。

而不同场景下需要的数据不同，这时候可能就得新开发一个接口。特别是在版本更新的时候，接口会有所变动。

这样就很容易导致一大堆类似的接口。

facebook 当时也遇到了这个问题，于是他们创造了一种新的接口实现方案：GraphQL。

用了 GraphQL 之后，返回什么数据不再是服务端说了算，而是客户端自己决定。

服务端只需要提供一个接口，客户端通过这个接口就可以取任意格式的数据，实现 CRUD。

比如想查询所有的学生，就可以这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69766c3214044ea9bb39bccec27ea53f~tplv-k3u1fbpfcp-watermark.image?)

想再查询他们的年龄，就可以这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4e0ec81d7bd4ed4bf6c0db6313cdabd~tplv-k3u1fbpfcp-watermark.image?)

想查询老师的名字和他教的学生，就可以这样：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29f59758180547c0b5e36f6f8bb85ad4~tplv-k3u1fbpfcp-watermark.image?)

而这些都是在一个 http 接口里完成的！

感受了 GraphQL 的好处了没？

**一个 http 接口就能实现所有的 CRUD！**

那这么强大的 GraphQL 是怎么实现的呢？

我们先写个 demo 快速入门一下：

facebook 提供了 graphql 的 npm 包，但那个封装的不够好，一般我们会用基于 graphql 包的 @apollo/server 和 @apollo/client 的包来实现 graphql。

```
mkdir graphql-crud-demo
cd graphql-crud-demo
npm init -y
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fddedf2692a44a91af0ef6c0f02271bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=936&h=668&s=94837&e=png&b=010101)

安装用到的包：

```
npm install @apollo/server
```
然后在 index.js 写一下这段代码：

```javascript
import { ApolloServer } from '@apollo/server';

const typeDefs = `
  type Student {
    id: String,
    name: String,
    sex: Boolean
    age: Int
  }

  type Teacher {
    id: String,
    name: String,
    age: Int,
    subject: [String],
    students: [Student]
  }

  type Query {
    students: [Student],
    teachers: [Teacher],
  }

  schema {
    query: Query
  }
`;
```

比较容易看懂，定义了一个 Student 的对象类型，有 id、name、sex、age 这几个字段。

又定义了一个 Teacher 的对象类型，有 id、name、age、subject、students 这几个字段。students 字段是他教的学生的信息。

然后定义了查询的入口，可以查 students 和 teachers 的信息。

这样就是一个 schema。

对象类型和对象类型之间有关联关系，老师关联了学生、学生也可以关联老师，关联来关联去这不就是一个图么，也就是 graph。

GraphQL 全称是 graph query language，就是从这个对象的 graph 中查询数据的。

现在我们声明的只是对象类型的关系，还要知道这些类型的具体数据，取数据的这部分叫做 resolver。

```javascript
const students = [
    {
      id: '1',
      name: async () => {
        await '取数据';
        return '光光'
      },
      sex: true,
      age: 12
    },
    {
      id: '2',
      name:'东东',
      sex: true,
      age: 13
    },
    {
      id: '3',
      name:'小红',
      sex: false,
      age: 11
    },
];

const teachers = [
  {
    id: '1',
    name: '神光',
    sex: true,
    subject: ['体育', '数学'],
    age: 28,
    students: students
  }
]

const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers
    }
};
```

resolver 是取对象类型对应的数据的，每个字段都可以写一个 async 函数，里面执行 sql、访问接口等都可以，最终返回取到的数据。

当然，直接写具体的数据也是可以的。

这样有了 schema 类型定义，有了取数据的 resovler，就可以跑起 graphql 服务了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92e02989bef0441da2b47d057ffcda1c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1400&h=1164&s=182844&e=png&b=1f1f1f)

也就是这样：

```javascript
import { startStandaloneServer } from '@apollo/server/standalone' 

const server = new ApolloServer({
    typeDefs,
    resolvers,
});
  
const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
});
  
console.log(`🚀  Server ready at: ${url}`);
```
传入 schema 类型定义和取数据的 resolver，就可以用 node 把服务跑起来。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a76c82f15d347deb8b0dc7bc9e1258f~tplv-k3u1fbpfcp-watermark.image?)

有同学可能问了，node 可以直接解析 esm 模块么？

可以的。只需要在 package.json 中声明 type 为 module：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/764dd70c276645b1a20049d0b2605955~tplv-k3u1fbpfcp-watermark.image?)

那所有的 .js 就都会作为 esm 模块解析：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88a61d897c2f4578ad9196303fd98126~tplv-k3u1fbpfcp-watermark.image?)

跑起来之后，浏览器访问一下：

就可以看到这样的 sandbox，这里可以执行 graphql 的查询：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3d94c3284c84d7ab5e5be77ff428e86~tplv-k3u1fbpfcp-watermark.image?)

（graphql 接口是监听 POST 请求的，用 get 请求这个 url 才会跑这个调试的工具）

我查询所有学生的 id、name、age 就可以这样：

```graphql
query Query {
    students {
        name,
        id
    }
}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b278c7267b504004ab7ae454b5050424~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81b8b08007a34bc996425019a8650349~tplv-k3u1fbpfcp-watermark.image?)

这里 “光光” 那个学生是异步取的数据，resolver 会执行对应的异步函数，拿到最终数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f11da7e9bb294f35a96b8ab225353ef8~tplv-k3u1fbpfcp-watermark.image?)

取老师的信息就可以这样：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecd1871863014c3dafe5d3760efe03c9~tplv-k3u1fbpfcp-watermark.image?)

这样我们就实现了一个 graphql 接口！

感觉到什么叫客户端决定取什么数据了么？

当然，我们这里是在 sandbox 里测的，用 @apollo/client 包也很简单。

比如 react 的 graphql 客户端是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bc53b8890a94cb183fe664fe801049e~tplv-k3u1fbpfcp-watermark.image?)

一个 gql 的 api 来写查询语言，一个 useQuery 的 api 来执行查询。

学起来很简单。

我们之后还是直接在 sandbox 里测试。

有的同学可能会说，如果我想查询某个名字的老师的信息呢？

怎么传参数？

graphql 当然是支持的，这样写：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b2178e3ad842fba02af787140d7f70~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1226&h=1112&s=143647&e=png&b=1f1f1f)

```
type Query {
    students: [Student],
    teachers: [Teacher],
    studentsbyTeacherName(name: String!): [Student]
}
```

新加一个 query 入口，声明一个 name 的参数。（这里 String 后的 ! 代表不能为空）

然后它对应的 resolver 就是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46045692e6374bcfacaa01b5f3c11308~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1120&h=946&s=132917&e=png&b=1f1f1f)

```javascript
const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers,
      studentsbyTeacherName: async (...args) => {
        console.log(args);

        await '执行了一个异步查询'
        return students
      }
    }
};
```
studentsbyTeacherName 字段的 resolver 是一个异步函数，里面执行了查询，然后返回了查到的学生信息。

我们打印下参数看看传过来的是什么。

有参数的查询是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc9883cfac5c4990a19e3804ea397d8f~tplv-k3u1fbpfcp-watermark.image?)

传入老师的 name 参数为 111，返回查到的学生的 id、name 信息。

可以看到返回的就是查询到的结果。

而服务端的 resolver 接收到的参数是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec04705f8a04fe78a88d61fb74d1033~tplv-k3u1fbpfcp-watermark.image?)

其余的几个参数不用管，只要知道第二个参数就是客户端传过来的查询参数就好了。

这样我们就可以根据这个 name 参数实现异步的查询，然后返回数据。

这就实现了有参数的查询。

不是说 graphql 能取代 restful 做 CRUD 么？那增删改怎么做呢？

其实看到上面的有参数的查询应该就能想到了，其实写起来差不多。

在 schema 里添加这样一段类型定义：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d60bf2fdfd24d019ba09a3ec5a3c41b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1186&h=1100&s=153842&e=png&b=1f1f1f)
```grqphql
type Res {
    success: Boolean
    id: String
}

type Mutation {
    addStudent(name:String! age:Int! sex:Boolean!): Res

    updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res

    deleteStudent(id: String!): Res
}

schema {
    mutation: Mutation
    query: Query
}
```
和有参数的查询差不多，只不过这部分增删改的类型要定义在 mutation 部分。

然后 resolver 也要有对应的实现：

```javascript
async function addStudent (_, { name, age, sex }) {
    students.push({
        id: '一个随机 id',
        name,
        age,
        sex
    });
    return {
      success: true,
      id: 'xxx'
    }
}

async function updateStudent (_, { id, name, age, sex }) {

    return {
      success: true,
      id: 'xxx'
    }
}

async function deleteStudent (_, { id }) {
    return {
      success: true,
      id: 'xxx'
    }
}
  
const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers,
      studentsbyTeacherName: async (...args) => {
        console.log(args);

        await '执行了一个异步查询'
        return students
      }
    },
    Mutation: {
        addStudent: addStudent,
        updateStudent: updateStudent,
        deleteStudent: deleteStudent
    }
};

```

和 query 部分差不多，只不过这里实现的是增删改。

我只对 addStudent 做了实现。

我们测试下：

执行 addStudent，添加一个学生：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd06869e4ad41d089fa746b37868c23~tplv-k3u1fbpfcp-watermark.image?)

然后再次查询所有的学生：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14e66d3982aa44789cc022c3fb47c38e~tplv-k3u1fbpfcp-watermark.image?)

就可以查到刚来的小刚同学。

这样，我们就可以在一个 graphql 的 POST 接口里完成所有的 CRUD！

全部代码如下，大家可以跑一跑（注意要在 package.json 里加个 type: "module"）

```javascript
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone' 

const typeDefs = `
  type Student {
    id: String,
    name: String,
    sex: Boolean
    age: Int
  }

  type Teacher {
    id: String,
    name: String,
    age: Int,
    subject: [String],
    students: [Student]
  }

  type Query {
    students: [Student],
    teachers: [Teacher],
    studentsbyTeacherName(name: String!): [Student]
  }

  type Res {
    success: Boolean
    id: String
  }

  type Mutation {
    addStudent(name:String! age:Int! sex:Boolean!): Res

    updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res

    deleteStudent(id: String!): Res
  }

  schema {
    mutation: Mutation
    query: Query
  }
`;

const students = [
    {
      id: '1',
      name: async () => {
        await '取数据';
        return '光光'
      },
      sex: true,
      age: 12
    },
    {
      id: '2',
      name:'东东',
      sex: true,
      age: 13
    },
    {
      id: '3',
      name:'小红',
      sex: false,
      age: 11
    },
];

const teachers = [
  {
    id: '1',
    name: '神光',
    sex: true,
    subject: ['体育', '数学'],
    age: 28,
    students: students
  }
]

async function addStudent (_, { name, age, sex }) {
    students.push({
        id: '一个随机 id',
        name,
        age,
        sex
    });
    return {
      success: true,
      id: 'xxx'
    }
}

async function updateStudent (_, { id, name, age, sex }) {

    return {
      success: true,
      id: 'xxx'
    }
}

async function deleteStudent (_, { id }) {
    return {
      success: true,
      id: 'xxx'
    }
}
  
const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers,
      studentsbyTeacherName: async (...args) => {
        console.log(args);

        await '执行了一个异步查询'
        return students
      }
    },
    Mutation: {
        addStudent: addStudent,
        updateStudent: updateStudent,
        deleteStudent: deleteStudent
    }
};

const server = new ApolloServer({
    typeDefs,
    resolvers,
});
  
const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
});
  
console.log(`🚀  Server ready at: ${url}`);
```
完成了 graphql 的入门，我们再稍微思考下它的原理。graphql 是怎么实现的呢？

回顾整个流程，我们发现涉及到两种 DSL（领域特定语言），一个是 schema 定义的 DSL，一个是查询的 DSL。

服务端通过 schema 定义的 DSL 来声明 graph 图，通过 resolver 来接受参数，执行查询和增删改。

客户端通过查询的 DSL 来定义如何查询和如何增删改，再发给服务端来解析执行。

通过这种 DSL 实现了动态的查询。

确实很方便很灵活，但也有缺点，就是 parse DSL 为 AST 性能肯定是不如 restful 那种直接执行增删改查高的。

具体要不要用 graphql 还是要根据具体场景来做判断。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/graphql-crud-demo)。
## 总结

restful 接口是 url 代表资源，GET、POST、PUT、DELETE 请求代表对资源的增删改查。

这种接口返回什么数据完全由服务端决定，每次接口变动可能就得新加一种接口。

为了解决这种问题，facebook 创造了 graphql，这种接口返回什么数据完全由客户端决定。增删改查通过这一个接口就可以搞定。

graphql 需要在服务端定义 schema，也就是定义对象类型和它的字段，对象类型和对象类型之间会有关联，也就是一个 graph，查询就是从这个 graph 里查询数据。

除了 schema 外，还需要有 resolver，它负责接受客户端的参数，完成具体数据的增删改查。

graphql 会暴露一个 post 接口，通过查询语言的语法就可以从通过这个接口完成所有增删改查。

本地测试的时候，get 请求会跑一个 sandbox，可以在这里测试接口。

整个流程涉及到两种新语言： schema 定义语言和 query 查询语言。入门之后向深入的话就是要学下这两种 DSL 的更多语法。

感受到 graphql 的强大之处了么？一个接口就可以实现所有的 CRUD！


## 161.Nest 开发 GraphQL 服务：实现 CRUD

上节我们知道了什么是 graphql，它就是通过模式定义语言 SDL（Schema Definition Language) 定义对象和对象之间关系的 schema：

比如：

```graphql
const typeDefs = `
  type Student {
    id: String,
    name: String,
    sex: Boolean
    age: Int
  }

  type Teacher {
    id: String,
    name: String,
    age: Int,
    subject: [String],
    students: [Student]
  }

  type Query {
    students: [Student],
    teachers: [Teacher],
  }

  type Res {
     success: Boolean
     id: String
  }

  type Mutation {
    addStudent(name:String! age:Int! sex:Boolean!): Res

    updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res

    deleteStudent(id: String!): Res
}

schema {
    mutation: Mutation
    query: Query
}
`;
```
这个 schema 只是类型，负责实现 schema 对应数据的部分叫做 resolver：

```javascript
const students = [
    {
      id: '1',
      name: async () => {
        await '取数据';
        return '光光'
      },
      sex: true,
      age: 12
    },
    {
      id: '2',
      name:'东东',
      sex: true,
      age: 13
    },
    {
      id: '3',
      name:'小红',
      sex: false,
      age: 11
    },
];

const teachers = [
  {
    id: '1',
    name: '神光',
    sex: true,
    subject: ['体育', '数学'],
    age: 28,
    students: students
  }
]

const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers
    }
}
```

schema 结合 resolver，这样客户端就可以按照 schema 的结构来存取数据了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4e0ec81d7bd4ed4bf6c0db6313cdabd~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccd06869e4ad41d089fa746b37868c23~tplv-k3u1fbpfcp-watermark.image?)

这节我们在 Nest 里集成下 graphql。

新建个项目：

```bash
nest new nest-graphql
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae91a37c7137471f85db27c26146a19d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=838&h=680&s=156963&e=png&b=010101)

进入项目，安装 graphql 和 apollo 的包：

```bash
npm i @nestjs/graphql @nestjs/apollo @apollo/server graphql
```
在 main.ts 引入 GraphQLModule：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327c41609033436bbf1bda3f0d43e11f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=904&h=662&s=134591&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver } from '@nestjs/apollo';

@Module({
  imports: [
    GraphQLModule.forRoot({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
    })
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
创建 schema 文件  schema.graphql

```graphql
type Student {
  id: String,
  name: String,
  sex: Boolean
  age: Int
}

type Teacher {
  id: String,
  name: String,
  age: Int,
  subject: [String],
  students: [Student]
}

type Query {
  students: [Student],
  teachers: [Teacher],
}

type Mutation {
  addStudent(name:String! age:Int! sex:Boolean!): Res

  updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res

  deleteStudent(id: String!): Res
}
```
这里直接复制的上节的 schema 定义。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca60e14b25d04c7aa150b858e3249608~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1156&h=1076&s=147152&e=png&b=1f1f1f)

语法高亮需要安装下 graphql 插件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af46b00b892f4b5dadfbff2f71543acf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1812&h=658&s=198913&e=png&b=1e1e1e)

然后定义它的 resolver：

```
nest g resolver student
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf3e6c5e967f42fb93cbe03c529ff28e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=820&h=146&s=35714&e=png&b=191919)

实现下 Query、Mutation 对应的逻辑：

```javascript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';

const students = [ 
    { id: 1, name: '光光', sex: true, age: 20},
    { id: 2, name: '东东', sex: true, age: 21},
    { id: 3, name: '小红', sex: false, age: 20},
];

const teachers = [
    { 
        id: 1, 
        name: "小刚", 
        age: 30, 
        subject: ['体育', '英语'],
        students: students
    },
]

@Resolver()
export class StudentResolver {

    @Query("students")
    students() {
        return students;
    }


    @Query("teachers")
    teachers() {
        return teachers;
    }

    @Mutation()
    addStudent(
        @Args('name') name: string, 
        @Args('age') age: number, 
        @Args('sex') sex: boolean
    ) {
        const id = Math.floor(Math.random() * 1000);
        students.push({
            id,
            name,
            age,
            sex
        });
        return {
            id,
            success: true
        }
    }

    @Mutation()
    updateStudent(
        @Args('id') id,
        @Args('name') name: string, 
        @Args('age') age: number, 
        @Args('sex') sex: boolean
    ) { 
        const index = students.findIndex(item => {
            return item.id === parseInt(id)
        });

        if(index ===-1) {
            return {
                id: null,
                success: true
            }
        }

        students[index].name = name;
        students[index].age = age;
        students[index].sex = sex;
        return {
            id,
            success: true
        }
    }

    @Mutation()
    deleteStudent(@Args('id') id) { 
        const index = students.findIndex(item => {
            return item.id === parseInt(id)
        });
        
        if(index ===-1) {
            return {
                id: null,
                success: true
            }
        }

        students.splice(index, 1);
        return {
            id,
            success: true
        }
    }
      
}
```
比较容易看懂，用 @Query 和 @Mutation 分别实现 Query 和 Mutation 对应的方法。

把服务跑起来：

```
npm run start:dev
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff1fe508fbfc4ea18cc8edce5ef5d826~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1712&h=434&s=166035&e=png&b=181818)

浏览器访问下 http://localhost:3000/graphql

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ac8ef484b594e7d97224df7c89e47db~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2570&h=1202&s=119911&e=png&b=162330)

右侧可以看到 schema 定义还有文档：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/323f012922874bb394bc46f423956f9f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512&h=1216&s=158758&e=png&b=14222e)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a1bb4ce382d4c6c9115fa32b6b23998~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1256&h=1072&s=135420&e=png&b=fefefe)

这个东西就是 graphql 的接口文档了。

我们在左侧输入下查询语法：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2e2baa8df6149e6be4046c4947c6204~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2102&h=1194&s=284060&e=gif&f=47&b=121e2a)

```graphql
query Xxx {
  students {
    id
    name
    age
  }
}
```
对新手来说，写 query language 还是有点难度的，因为不熟悉。

上节那个 playground 就好很多，可以直接生成。

我们换上节的 playground：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b9c8831abaf45539f9ff13afcedc995~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1576&h=808&s=213674&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver } from '@nestjs/apollo';
import { StudentResolver } from './student/student.resolver';
import { ApolloServerPluginLandingPageLocalDefault } from '@apollo/server/plugin/landingPage/default';

@Module({
  imports: [
    GraphQLModule.forRoot({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
      playground: false,
      plugins: [ApolloServerPluginLandingPageLocalDefault()],
    })
  ],
  controllers: [AppController],
  providers: [AppService, StudentResolver],
})
export class AppModule {}
```
刷新就可以看到换成 apollo 的 playground 的了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ad558ef58bd464a80fa660fb99a6d5f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2574&h=1314&s=477261&e=gif&f=61&b=eff3f5)

点击加号就可以生成查询。

试一下添加：

```graphql
mutation Mutation($name: String!, $age: Int!, $sex: Boolean!) {
  addStudent(name: $name, age: $age, sex: $sex) {
    id
    success
  }
}
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/712eadf8f43b4e8e86066ec81dd3a93d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2042&h=982&s=135862&e=png&b=ffffff)

再查一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c9abc22469f44c595c624890219ed78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2090&h=1148&s=180941&e=png&b=ffffff)

可以看到，添加成功了。

然后再来试下修改：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b6a174eb9704e7b90a40840c030fc81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1986&h=950&s=149523&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d45c7b20f70a48f2b754cf1947a5fb43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2076&h=1146&s=145665&e=png&b=ffffff)

修改成功！

试下删除：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab65578834f8469cab46a63fe7456027~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2046&h=852&s=121176&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c285fa6dbee94712b80fe4651f2f5edf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1980&h=876&s=126404&e=png&b=ffffff)

删除成功！

其实还少了个根据 id 查询的方法。

在 schema 里加一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10fa5a17fc794210aad1bd57df3f1564~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=432&s=56273&e=png&b=1f1f1f)

! 代表必填。

在 resolver 里加一下它的实现：

```javascript
@Query("studentById")
studentById(@Args('id') id) {
    return students.find(item => {
        return item.id === id
    });
}
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/232b2550ef44477e83536e4ae581fa0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2176&h=970&s=139870&e=png&b=ffffff)

查询成功！

至此，Nest + GrphQL 的 CRUD 就完成了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-graphql)。

## 总结

这节我们在 Nest 里集成了 GraphQL，并做了 CRUD。

graphql 主要是分为 schema、resolver 两部分。

GraphQLModule.forRoot 指定 typePaths 也就是 schema 文件的位置。

然后用 nest g resolver 生成 resolver 文件，实现 Query、Mutaion 的方法。

并且还可以切换 playground 为 apollo 的。

之后就可以在 palyground 里发送 graphql 请求，做 CRUD 了。





## 162.GraphQL + Primsa + React 实现 TodoList

我们经常用 restful 的接口来开发业务。

比如 GET 请求 /students 查询所有学生，/students/1 查询 id 为 1 的学生

发送 POST、PUT、DETETE 请求分别代表增删改。

其实也可以用 GraphQL 的方式来写接口：

查询：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2588954ae0a410f9874f5f7704b9abd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1122&h=998&s=105312&e=png&b=ffffff)

新增：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e86ac6868ec481dbbd0ddb2d018fad1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1492&h=916&s=116440&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1dace67d38542c897f4eda0fe1c1248~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1466&h=1126&s=130142&e=png&b=ffffff)

增删改查都在一个接口里搞定，并且想要什么数据由前端自己取。

今天我们就用 Nest + GrahQL 做一个 TodoList 的增删改查。

数据存在 mysql 里，用 Prisma 作为 ORM 框架。

```bash
npm install -g @nestjs/cli

nest new graphql-todolist
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ddefb3f395445ae82a2e4a97e69df00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=696&s=165174&e=png&b=010101)

创建个项目，然后我们首先来实现 restful 接口的增删改查。

用 docker 把 mysql 跑起来：

从 docker 官网下载 docker desktop，这个是 docker 的桌面端：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d7da48155df448698ae5fc57072fe0b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2380\&h=1336\&s=459767\&e=png\&b=ffffff)

跑起来后，搜索 mysql 镜像（这步需要科学上网），点击 run：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/659eaef5c4b8445a8c7224981515c1fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2368\&h=1460\&s=326395\&e=png\&b=7a7a7b)

输入容器名、端口映射、以及挂载的数据卷，还要指定一个环境变量：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33961dc3a8cd4d9c805c2ff096a1caf9~tplv-k3u1fbpfcp-watermark.image#?w=1332\&h=1428\&s=187941\&e=png\&b=ffffff)

端口映射就是把宿主机的 3306 端口映射到容器里的 3306 端口，这样就可以在宿主机访问了。

数据卷挂载就是把宿主机的某个目录映射到容器里的 /var/lib/mysql 目录，这样数据是保存在本地的，不会丢失。

而 MYSQL\_ROOT\_PASSWORD 的密码则是 mysql 连接时候的密码。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7db618f4e4b4ca3b0b44752450d4322~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2232\&h=1326\&s=496885\&e=png\&b=ffffff)

跑起来后，我们用 GUI 客户端连上，这里我们用的是 mysql workbench，这是 mysql 官方提供的免费客户端：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1311f9991e248de8a9cdd92c9b72a15~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=270\&h=270\&s=40789\&e=png\&b=9b5801)

连接上之后，点击创建 database：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef0a84137c6249d191c5c798fdfd0cb1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1626&h=1126&s=271190&e=png&b=e8e7e7)

指定名字、字符集为 utf8mb4，然后点击右下角的 apply。

创建成功之后在左侧就可以看到这个 database 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35b4be97f4e54bb89e6c035125c02f26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=402&h=256&s=34981&e=png&b=e9e4e0)

现在还没有表。

我们在 Nest 里用 Prisma 连接 mysql。

进入项目，安装 prisma

```bash
npm install prisma --save-dev
```
执行 prisma init 创建 schema 文件：

```bash
npx prisma init
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea10e80f6fd04d7892d98c540a50c1ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1068&h=504&s=98914&e=png&b=181818)

生成了 schema 文件（用来定义 model 的），和 .env 文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e79653f4b614e369ada66ad4de9834c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1312&h=650&s=152818&e=png&b=1c1c1c)

改下 .env 的配置：

```env
DATABASE_URL="mysql://root:你的密码@localhost:3306/todolist"
```

并且修改下 schema 里的 datasource 部分：

```javascript
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

然后创建 model：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19da9ee8915e4c61b00679fdec070dfa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=900&h=812&s=140024&e=png&b=1f1f1f)

```javascript
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model TodoItem {
  id        Int    @id @default(autoincrement())
  content    String  @db.VarChar(50)
  createTime DateTime @default(now())
  updateTime DateTime @updatedAt
}
```
id 自增，content 是长度为 50 的字符串，还有创建时间 createTime、更新时间 updateTime。

执行 prisma migrate dev，它会根据定义的 model 去创建表：

```
npx prisma migrate dev --name init
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8b384eade2143f0b2c4007f102fd5d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1170&h=758&s=112355&e=png&b=181818)

它会生成 sql 文件，里面是这次执行的 sql。

然后还会生成 client 代码，用来连接数据库操作这个表。

可以看到，这次执行的 sql 就是 create table 建表语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fbc8c88d3cf4062b6d35f95505394ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1640&h=546&s=159515&e=png&b=1d1d1d)

这时候数据库就就有这个表了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58a4409e705848c4bea095f147873ee2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1220&h=578&s=197490&e=png&b=efeceb)

接下来我们就可以在代码里做 CRUD 了。

生成一个 service：

```
nest g service prisma --flat --no-spec
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7a681aae61456e8218f380407c9256~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=116&s=27036&e=png&b=191919)

改下生成的 PrismaService，继承 PrismaClient，这样它就有 crud 的 api 了：

```javascript
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {

    constructor() {
        super({
            log: [
                {
                    emit: 'stdout',
                    level: 'query'
                }
            ]
        })
    }

    async onModuleInit() {
        await this.$connect();
    }
}
```
在 constructor 里设置 PrismaClient 的 log 参数，也就是打印 sql 到控制台。

在 onModuleInit 的生命周期方法里调用 $connect 来连接数据库。

然后在 AppService 里注入 PrismaService，实现 CRUD：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { PrismaService } from './prisma.service';
import { CreateTodoList } from './todolist-create.dto';
import { UpdateTodoList } from './todolist-update.dto';

@Injectable()
export class AppService {

  getHello(): string {
    return 'Hello World!';
  }

  @Inject(PrismaService)
  private prismaService: PrismaService;

  async query() {
    return this.prismaService.todoItem.findMany({
      select: {
        id: true,
        content: true,
        createTime: true
      }
    });
  }

  async create(todoItem: CreateTodoList) {
    return this.prismaService.todoItem.create({
      data: todoItem,
      select: {
        id: true,
        content: true,
        createTime: true
      }
    });
  }

  async update(todoItem: UpdateTodoList) {
    return this.prismaService.todoItem.update({
      where: {
        id: todoItem.id
      },
      data: todoItem,
      select: {
        id: true,
        content: true,
        createTime: true
      }
    });
  }

  async remove(id: number) {
    return this.prismaService.todoItem.delete({
      where: {
        id
      }
    })
  }
}
```
@Inject 注入 PrismaService，用它来做 CRUD，where 是条件、data 是数据，select 是回显的字段：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c05586639ac4733aee363e473f78130~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=822&s=101449&e=png&b=202020)

然后创建用到的两个 dto 的 class

todolist-create.dto.ts

```javascript
export class CreateTodoList {
    content: string;
}
```

todolist-update.dto.ts

```
export class UpdateTodoList {
    id: number;
    content: string;
}
```
在 AppController 里引入下，添加几个路由：

```javascript
import { Body, Controller, Delete, Get, Post, Query } from '@nestjs/common';
import { AppService } from './app.service';
import { CreateTodoList } from './todolist-create.dto';
import { UpdateTodoList } from './todolist-update.dto';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Post('create')
  async create(@Body() todoItem: CreateTodoList) {
    return this.appService.create(todoItem);
  }

  @Post('update')
  async update(@Body() todoItem: UpdateTodoList) {
    return this.appService.update(todoItem);
  }

  @Get('delete')
  async delete(@Query('id') id: number) {
    return this.appService.remove(+id);
  }

  @Get('list')
  async list() {
    return this.appService.query();
  }

}
```
添加增删改查 4 个路由，post 请求用 @Body() 注入请求体，@Query 拿路径中的参数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a7a9e08018742beba2229a63b2c00d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=892&s=145372&e=png&b=1f1f1f)

把服务跑起来试一下：

```
npm run start:dev
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b670df1756294db6b0d1baf09e5c1e78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1570&h=442&s=185512&e=png&b=181818)

首先是 list，现在没有数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9680c6b5b43b4d279310f0ee88c0dfec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=736&h=554&s=48051&e=png&b=fbfbfb)

然后添加一个：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe31162b5c2d4ccea681ec599aa7e2fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=794&h=694&s=80224&e=png&b=fcfcfc)

服务端打印了 insert into 的 sql：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e4d97ae7af64aab8f56cf011fbd2db1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1666&h=682&s=253503&e=png&b=181818)

数据库也有了这条记录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/febf6f78e21845bcb2bac919484a2bf6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1220&h=280&s=91778&e=png&b=eeebea)

再加一个：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a7130f3261c496b8a67dcb6b42cba76~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=782&h=686&s=80284&e=png&b=fbfbfb)

然后查一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13458e32cc534f0b9d5c4f45e36fdaf2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=862&h=926&s=98197&e=png&b=fdfdfd)

接下来试下修改、删除：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f7d77eeec2c4518a45440f7f2fbe3b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=796&h=716&s=83610&e=png&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfbb627e042b4a9e8412161e3692bf1f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=854&h=744&s=84022&e=png&b=fcfcfc)

再查一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/362069aec65347ac8e0ca8de6feab628~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=668&s=72279&e=png&b=fcfcfc)

没啥问题。

这样，todolist 的 restful 版接口就完成了。

接下来实现 graphql 版本：

安装用到的包：

```bash
npm i @nestjs/graphql @nestjs/apollo @apollo/server graphql
```

然后在 AppModule 里引入下：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaService } from './prisma.service';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver } from '@nestjs/apollo';

@Module({
  imports: [
    GraphQLModule.forRoot({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
    })
  ],
  controllers: [AppController],
  providers: [AppService, PrismaService],
})
export class AppModule {}
```
typePaths 就是 schema 文件的路径：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c02915bbc3348c385f86ce55f6fd77d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=700&s=149084&e=png&b=1f1f1f)

添加一个 todolist.graphql

```graphql
type TodoItem {
    id: Int
    content: String
}

input CreateTodoItemInput {
  content: String
}

input UpdateTodoItemInput {
  id: Int!
  content: String
}

type Query {
  todolist: [TodoItem]!
  queryById(id: Int!): TodoItem
}


type Mutation {
  createTodoItem(todoItem: CreateTodoItemInput!): TodoItem!
  updateTodoItem(todoItem: UpdateTodoItemInput!): TodoItem!
  removeTodoItem(id: Int!): Int
}
```
语法比较容易看懂，就是定义数据的结构。

在 Query 下定义查询的接口，在 Mutation 下定义增删改的接口。

然后实现 resolver，也就是这些接口的实现：

```bash
nest g resolver todolist --no-spec --flat
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89294a98b4074c79839466b8803601ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=108&s=28623&e=png&b=191919)

```javascript
import { Args, Mutation, Query, Resolver } from '@nestjs/graphql';
import { PrismaService } from './prisma.service';
import { Inject } from '@nestjs/common';
import { CreateTodoList } from './todolist-create.dto';
import { UpdateTodoList } from './todolist-update.dto';

@Resolver()
export class TodolistResolver {

    @Inject(PrismaService)
    private prismaService: PrismaService;

    @Query("todolist")
    async todolist() {
        return this.prismaService.todoItem.findMany();
    }

    @Query("queryById")
    async queryById(@Args('id') id) {
        return this.prismaService.todoItem.findUnique({
            where: {
                id
            }
        })
    }

    @Mutation("createTodoItem")
    async createTodoItem(@Args("todoItem") todoItem: CreateTodoList) {
        return this.prismaService.todoItem.create({
            data: todoItem,
            select: {
              id: true,
              content: true,
              createTime: true
            }
          });
    }


    @Mutation("updateTodoItem")
    async updateTodoItem(@Args('todoItem') todoItem: UpdateTodoList) {
        return this.prismaService.todoItem.update({
            where: {
              id: todoItem.id
            },
            data: todoItem,
            select: {
              id: true,
              content: true,
              createTime: true
            }
          });
    }

    @Mutation("removeTodoItem")
    async removeTodoItem(@Args('id') id: number) {
        await this.prismaService.todoItem.delete({
            where: {
              id
            }
        })
        return id;
    }
}
```

用 @Resolver 声明 resolver，用 @Query 声明查询接口，@Mutation 声明增删改接口，@Args 取传入的参数。

具体增删改查的实现和之前一样。

浏览器访问 http://localhost:3000/graphql 就是 playground，可以在这里查询：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b26f480948140e19e792158026fff87~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1778&h=760&s=96872&e=png&b=111d28)

左边输入查询语法，右边是执行后返回的结果。

当然，对新手来说这个 playground 不够友好，没有提示。

我们换一个：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71ad14aa08db4ae49e099373c7dac15c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1248&h=854&s=216674&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaService } from './prisma.service';
import { GraphQLModule } from '@nestjs/graphql';
import { ApolloDriver } from '@nestjs/apollo';
import { TodolistResolver } from './todolist.resolver';
import { ApolloServerPluginLandingPageLocalDefault } from '@apollo/server/plugin/landingPage/default';

@Module({
  imports: [
    GraphQLModule.forRoot({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
      playground: false,
      plugins: [ApolloServerPluginLandingPageLocalDefault()],
    })
  ],
  controllers: [AppController],
  providers: [AppService, PrismaService, TodolistResolver],
})
export class AppModule {}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09909742073143be930078ca2202d60a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2192&h=1306&s=306316&e=gif&f=54&b=f0f4f7)

试一下新增：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ddb7225a23e49a088bafe220ad0c86d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=964&s=118088&e=png&b=ffffff)

查询：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b5401d77d04640a2103212419645bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1680&h=654&s=76243&e=png&b=ffffff)

修改：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77814374325d4b42bb047a567a71aef2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1510&h=832&s=115324&e=png&b=ffffff)

单个查询：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5064d3764964429ba9ab78f2fa860869~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1508&h=726&s=98504&e=png&b=ffffff)

删除：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0827524acd884a10af8470290c8a78d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=718&s=92889&e=png&b=ffffff)

查询：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e44f460079c4dfdb238828f1c137a0e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1554&h=574&s=60793&e=png&b=ffffff)

基于 GraphQL 的增删改查都成功了！

然后在 react 项目里调用下。

```bash
npx create-vite
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01c8020be18747eb96547d34446fdae6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&h=406&s=53515&e=png&b=000000)

进入项目，安装 @apollo/client

```bash
npm install

npm install @apollo/client
```
改下 main.tsx

```javascript
import * as ReactDOM from 'react-dom/client';
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';
import App from './App';

const client = new ApolloClient({
  uri: 'http://localhost:3000/graphql',
  cache: new InMemoryCache(),
});

const root = ReactDOM.createRoot(document.getElementById('root')!);

root.render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
);

```
创建 ApolloClient 并设置到 ApolloProvider。

然后在 App.tsx 里用 useQuery 发请求：

```javascript
import { gql, useQuery } from '@apollo/client';

const getTodoList = gql`
  query Query {
    todolist {
      content
      id
    }
  }
`;

type TodoItem = {
  id: number;
  content: string;
}

type TodoList = {
  todolist: Array<TodoItem>;
}

export default function App() {
  const { loading, error, data } = useQuery<TodoList>(getTodoList);

  if (loading) return 'Loading...';
  if (error) return `Error! ${error.message}`;

  return (
    <ul>
      {
        data?.todolist?.map(item => {
          return <li key={item.id}>{item.content}</li>
        })
      }
    </ul>
  );
}
```
把服务跑起来：

```
npm run dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d61f8579b9f94b629ba9697073e90f2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702&h=268&s=35508&e=png&b=181818)

这里涉及到的跨域，现在后端服务里开启下跨域支持：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94650717fdcf4663b6d167acffebf8de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=884&h=416&s=78079&e=png&b=1f1f1f)

可以看到，返回了查询结果：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d289ca239df4f5e8070e926797dcb32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2150&h=1482&s=270322&e=png&b=fefefe)

然后加一下新增：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2c3bb5c2b04f678ef4d61b3be6db37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=924&h=1148&s=180817&e=png&b=1f1f1f)

用 useMutation 的 hook，指定 refetchQueries 也就是修改完之后重新获取数据。

调用的时候传入 content 数据。

```javascript
import { gql, useMutation, useQuery } from '@apollo/client';

const getTodoList = gql`
  query Query {
    todolist {
      content
      id
    }
  }
`;

const createTodoItem = gql`
  mutation Mutation($todoItem: CreateTodoItemInput!) {
    createTodoItem(todoItem: $todoItem) {
      id
      content
    }
  }
`;

type TodoItem = {
  id: number;
  content: string;
}

type TodoList = {
  todolist: Array<TodoItem>;
}

export default function App() {
  const { loading, error, data } = useQuery<TodoList>(getTodoList);

  const [createTodo] = useMutation(createTodoItem, {
    refetchQueries: [getTodoList]
  });

  async function onClick() {
    await createTodo({
      variables: {
        todoItem: {
          content: Math.random().toString().slice(2, 10)
        }
      }
    })
  }

  if (loading) return 'Loading...';
  if (error) return `Error! ${error.message}`;

  return (
    <div>
      <button onClick={onClick}>新增</button>
      <ul>
        {
          data?.todolist?.map(item => {
            return <li key={item.id}>{item.content}</li>
          })
        }
      </ul>
    </div>
  );
}
```
测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dc96154f7e048998abb6c92fd4dd7ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1108&h=634&s=71495&e=gif&f=32&b=fefefe)

数据库里也可能看到新增的数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a16ac5169606455b87273b4f88e1080d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1432&h=386&s=213553&e=png&b=efeceb)

这样，我们就能在 react 项目里用 graphql 做 CRUD 了。

案例代码上传了 github。

后端代码： https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/graphql-todolist

前端代码：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/graphql-todolist-client

## 总结

我们实现了 Restful 和 GraphQL 版的 CRUD。

前端用 React + @apollo/client。

后端用 Nest + GraphQL + Prisma + MySQL。

GraphQL 主要是定义 schema 和 resolver 两部分，schema 是 Query、Mutation 的结构，resolver 是它的实现。

可以在 playground 里调用接口，也可以在 react 里用 @appolo/client 调用。

相比 restful 的版本，graphql 只需要一个接口，然后用查询语言来查，需要什么数据取什么数据，更加灵活。

业务开发中，你会选择用 GraphQL 开发接口么？


## 166.如何调试 Nest 源码？

前面我们学过如何调试 Nest 项目，那如何调试 Nest 源码呢？

有的同学说，调试 Nest 项目的时候，调用栈里不就有源码部分么？

其实不是的，这部分是编译后的代码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2bacca10b44fabb6a48e83ae6636fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1200&h=650&s=130898&e=png&b=29292a)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bf49198bf7242a09fd50641f901ec2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2316&h=1060&s=447155&e=png&b=1f1f1f)

我们新建个 Nest 项目：

```
nest new debug-nest-source
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d41d5bfd38849aab63b4924548e298d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=636&s=269487&e=png&b=010101)

点击 debug 面板的 create a launch.json file按钮：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29487c1eaef442cabe547842ee396993~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=618&s=70481&e=png&b=191919)

输入 npm，选择 launch via npm，创建一个调试 npm scripts 的配置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a58c3a71d99f4627b5d046366dffad52~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=774&s=411894&e=gif&f=27&b=222222)

改为这样：

```json
{
    "name": "Launch via NPM",
    "request": "launch",
    "runtimeArgs": [
        "run-script",
        "start:dev"
    ],
    "runtimeExecutable": "npm",
    "console": "integratedTerminal",
    "skipFiles": [
        "<node_internals>/**"
    ],
    "type": "node"
}
```

这个就是跑 npm run start:dev 的调试配置。

指定 console 为 integratedTerminal，这样日志会输出在 terminal。

不然，日志会输出在 debug console。颜色等都不一样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ca1d191d02a4a038e1f0f8a0ac7ace1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=306&s=45124&e=png&b=181818)

在 AppController 的 getHello 打个断点：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/174028b51d744df5b0b7ddd2a54486b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=908&h=582&s=102402&e=png&b=1f1f1f)

点击 debug 启动：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/766932185fd94fa5ba6c15afd69ece47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2088&h=1334&s=585171&e=gif&f=34&b=1b1b1b)

然后浏览器重新访问 http://localhost:3000

这时候代码就会在断点处断住：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f967d940585c4b14a9a2831babc1e1bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1936&h=1120&s=350562&e=png&b=1b1b1b)

这样就可以断点调试 Nest 项目了。

但如果想调试源码，还需要再做一步：

因为现在调用栈里的 Nest 源码部分都是编译后的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc2bacca10b44fabb6a48e83ae6636fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1200&h=650&s=130898&e=png&b=29292a)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bf49198bf7242a09fd50641f901ec2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2316&h=1060&s=447155&e=png&b=1f1f1f)

我们想调试 Nest 的 ts 源码，这就需要用到 sourcemap 了。

用 npm install 下载的包没有 sourcemap 的代码，想要 sourcemap，需要自己 build 源码。

把 Nest 项目下载下来，并安装依赖（加个 --depth=1 是下载单 commit，--single-branch 是下载单个分支，这样速度会快很多）：

```
git clone --depth=1 --single-branch https://github.com/nestjs/nest
```
build 下：
```
npm install
npm run build
```
会在 node_modules/@nestjs 下生成编译后的代码。

看下 npm scripts：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d489d0306b648aba18e3cb3a5bb4d84~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74e417c52bd849bc86bed2bcf9277dde~tplv-k3u1fbpfcp-watermark.image?)

可以看到它做的事情就是 tsc 编译代码，然后把编译后的文件移动到 node_modules/@nestjs 目录下。

move 的具体实现可以看 tools/gulp/tasks/move.ts 的代码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfedccfc74e3406fae4b16bed4e6c2c4~tplv-k3u1fbpfcp-watermark.image?)

所以，执行 npm run build，你就会在 node_modules/@nestjs 下看到这样的代码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4d8cee11f2c43bfa2c1ef43309d1f26~tplv-k3u1fbpfcp-watermark.image?)

只包含了 js 和 ts，没有 sourcemap：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79e9d0095df14da5a87825a47863a9d6~tplv-k3u1fbpfcp-watermark.image?)

生成 sourcemap 需要改下 tsc 编译配置，也就是 packages/tsconfig.build.json 文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be584d47dc08439989bcb5a168ebeefe~tplv-k3u1fbpfcp-watermark.image?)

设置 sourceMap 为 true 也就是生成 sourcemap，但默认的 sourcemap 里不包含内联的源码，也就是 sourcesContent 部分，需要设置 inlineSources 来包含。

再次执行 npm run build，就会生成带有 sourcemap 的代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d988797ac7ea4b028eab5101fe79da36~tplv-k3u1fbpfcp-watermark.image?)

并且 sourcemap 是内联了源码的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea66020f83e34f03ae1325b6a94d05a1~tplv-k3u1fbpfcp-watermark.image?)

然后我们跑一下 Nest 的项目，直接跑 samples 目录下的项目即可，这是 Nest 内置的一些案例项目：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/903e5b83481846d883771b742d7d6160~tplv-k3u1fbpfcp-watermark.image?)

进入 01-cats-app 目录，安装依赖

```
npm install
```
然后把根目录 node_modules 下生成的代码覆盖下 cats 项目的 node_modules 下的代码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a247da392ce04a8bb5337cdc163faff6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1408&h=816&s=366457&e=png&b=fcfbfb)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48106b06653a4e39985d6a087bbbf586~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1420&h=722&s=355032&e=png&b=f5f3f2)

创建一个调试配置：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29487c1eaef442cabe547842ee396993~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=618&s=70481&e=png&b=191919)

改成这样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0afe8030d89546d9866d5c4d9cebf7ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=970&h=816&s=113822&e=png&b=1f1f1f)

```json
{
    "name": "调试 nest 源码",
    "request": "launch",
    "runtimeArgs": [
        "run-script",
        "start:dev"
    ],
    "runtimeExecutable": "npm",
    "console": "integratedTerminal",
    "cwd": "${workspaceFolder}/sample/01-cats-app/",
    "resolveSourceMapLocations": [
        "${workspaceFolder}/**",
        // "!**/node_modules/**"
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "type": "node"
}
```
指定 cwd 为那个项目的目录，也就是在那个目录下执行 npm run start:dev。

resolveSourceMapLocations 是从哪里找 sourcemap，默认排除掉了 node_modules，我们把它去掉。

在 sample/01-cats-app 的 src/cats/cats.controller.ts 打个断点：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b5811867a9348a4b4ebc7215467ec53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1476&h=748&s=193932&e=png&b=1d1d1d)

然后点击 debug 调试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8948726d03ee4de49cfe09848a069ca4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1888&h=1476&s=474869&e=png&b=1a1a1a)

如果提示端口被占用，你需要先 kill 掉之前的进程再跑：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/999f5d949a5346e7bcd09aeca3f934e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1334&h=184&s=57323&e=png&b=181818)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba62f9b397944abab96f8d539a7d1a5b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=466&s=79681&e=png&b=191919)

浏览器访问 http://localhost:3000/cats

断住之后你看下调用栈：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/215301ff39224b57a11c4f7956292b1c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2104&h=1198&s=558249&e=png&b=1a1a1a)

这时候 sourcemap 就生效了，可以看到调用栈中的就是 Nest 的 ts 源码。

这样就可以调试 Nest 源码了。

比如我们看下 Nest 的 AOP 部分的源码：

点击这个调用栈：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16875e97dd234dad83f4e704b5889638~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2318&h=844&s=432529&e=png&b=1d1d1d)

可以看到它先创建了所有的 pipes、interceptors、guards 的实例，然后封装了调用 pipe 和 guard 的函数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0ee28fc8bc44d7a79c782afa0feba7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1012&h=1062&s=143708&e=png&b=1f1f1f)

下面调用 hander 的时候，先调用 guard、再调用 interceptor，然后调用 handler，并且 handler 里会先用 pipe 处理参数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5b7dd0493342e19b16c114b74e91f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1110&h=828&s=163438&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/448b1b43372f4c9890b845d0a8c56305~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=990&h=400&s=74698&e=png&b=202020)

这就是 AOP 机制的源码。

而如果你想在你的项目里调试 Nest 源码，只要把 node_modules/@nestjs 覆盖你项目下那个就好了。

## 总结

这节我们学习了如何调试 Nest 源码。

vscode 里创建 npm scripts 的调试配置，就可以调试 npm run start:dev 的服务。

但如果想调试源码，需要把 Nest  源码下载下来，build 出一份带有 sourcemap 版本的代码。

同时还要设置 resolveSourcemapLocations 去掉排除 node_modules 的配置。

然后再调试，就可以直接调试 Nest 的 ts 源码了。

我们调试了下 AOP 部分的源码，以后你对哪部分的实现原理感兴趣，也可以自己调试源码了。


## 17.Nest 的 Middleware 

Nest 里也有中间件 Middleware 的概念，它和 Express 的 Middleware 是一个东西么？

很像，但不一样。

上节讲过，Nest 并不是直接依赖于 Express，可以切换到别的 http 请求处理库，那 Nest 的特性肯定也不直接是 Express 里的。

我们创建个项目，边写边看：

```
nest new middleware-test
```
进入项目，执行：
```
nest g middleware aaa --no-spec --flat
```
创建个 middleware：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2120886bafd547569e157e22618acc9e~tplv-k3u1fbpfcp-watermark.image?)

因为这时候并不知道你用的 express 还是 fastify，所以 request、response 是 any，手动标注下类型就好了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bba52f7fe81499290cbdaa94e1e38f0~tplv-k3u1fbpfcp-watermark.image?)

这里是 express 的 request、response。

加一下前后的的逻辑：

```javascript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response } from 'express';

@Injectable()
export class AaaMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: () => void) {
    console.log('brefore');
    next();
    console.log('after');
  }
}
```

然后在 Module 里这样使用：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd6492db33c249b8a68fdb40eb733fac~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { AaaMiddleware } from './aaa.middleware';
import { MiddlewareConsumer, Module, NestModule, RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule implements NestModule{

  configure(consumer: MiddlewareConsumer) {
    consumer.apply(AaaMiddleware).forRoutes('*');
  }
}

```

实现 NestModule 接口的 configure 方法，在里面应用 AaaMiddleware 到所有路由。

然后跑起来试一下：

    nest start --watch

浏览器访问 <http://localhost:3000>

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2800e674faae47eaae69583181759c70~tplv-k3u1fbpfcp-watermark.image?)

可以看到中间件的逻辑都执行了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/851f6daac9024c909d6b25ffe6509065~tplv-k3u1fbpfcp-watermark.image?)

这里也可以指定更精确的路由。

我们添加几个 handler：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49019d736ee149ac987a986d769dd824~tplv-k3u1fbpfcp-watermark.image?)

然后重新指定 Middleware 应用的路由：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/276af257501a4a19acc5e1a600040d4d~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { AaaMiddleware } from './aaa.middleware';
import { MiddlewareConsumer, Module, NestModule, RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule implements NestModule{

  configure(consumer: MiddlewareConsumer) {
    consumer.apply(AaaMiddleware).forRoutes({ path: 'hello*', method: RequestMethod.GET });
    consumer.apply(AaaMiddleware).forRoutes({ path: 'world2', method: RequestMethod.GET });
  }
}
```
可以看到，hello、hello2、world2 的路由都调用了这个中间件，而 world1 没有：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ec746f0d634e9b80ade532f2dc70a2~tplv-k3u1fbpfcp-watermark.image?)

这就是 Nest 里 middleware 的用法。

如果只是这样，那和 Express 的 middleware 差别并不大，无非是变成了 class 的方式。

Nest 为什么要把 Middleware 做成 class 呢？

当然是为了依赖注入了！

我们通过 @Inject 注入 AppService 到 middleware 里：

```javascript
import { AppService } from './app.service';
import { Inject, Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response } from 'express';

@Injectable()
export class AaaMiddleware implements NestMiddleware {
  @Inject(AppService)
  private readonly appService: AppService;

  use(req: Request, res: Response, next: () => void) {
    console.log('brefore');
    console.log('-------' + this.appService.getHello());
    next();
    console.log('after');
  }
}
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e953586b238c4da19a3ee9a10bb6302e~tplv-k3u1fbpfcp-watermark.image?)

当然，这里也可以用构造器注入，这样更简洁一点：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94124984279d43edbc675a0a9df5e33c~tplv-k3u1fbpfcp-watermark.image?)

这时在访问这个路由的时候，就可以看到中间件成功调用了 AppService：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c713f02f65c74fe4aabc3961811847b2~tplv-k3u1fbpfcp-watermark.image?)

这就是 Nest 注入的依赖。

如果不注入依赖，那写函数的方式也是可以的。

看这个 apply 方法的类型声明也可以看出来：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ff0789b8d9944ad8af2f39cb736b324~tplv-k3u1fbpfcp-watermark.image?)

如果不需要注入依赖，那可以写函数形式的 middleware，这时候和 Express 的 middleware 就没啥区别了。

如果需要注入依赖，那就写 class 形式的 middleware，可以用 Nest 的依赖注入能力。

当然，应用实例对象也可以 use 中间件，这个就和 express 那个一样了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55e411f449d44284b05ddd28af32e2d5~tplv-k3u1fbpfcp-watermark.image?)

不过这种形式不能注入依赖，而且也不能配置应用到什么路由，不建议用。

app.use 等同于在 AppModule 的 configure 方法里的 forRoutes('\*')

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f4e084a33784f64b792fd9bafb8a7b4~tplv-k3u1fbpfcp-watermark.image?)

此外，middleware 里有个 next 参数，而 Nest 还有个 @Next 装饰器，这俩的区别是什么呢？

middleware 的 next 参数就是调用下一个 middleware 的，这个很好理解。

而 @Next 装饰器是调用下一个 handler 的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4109a967aac045079f337e77dc94b59c~tplv-k3u1fbpfcp-watermark.image?)

但如果是这样一个 handler，它就不返回值了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97f959fee86440b4832b34c4bda341fc~tplv-k3u1fbpfcp-watermark.image?)

这个和加上 @Response 装饰器的时候的效果一样。

因为 Nest 认为你会自己返回响应或者调用下个 handler，就不会处理返回值了。

如果依然想让 Nest 把函数返回值作为响应，可以这样写：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d080ce7f3a4e4e3193476ba78f938a21~tplv-k3u1fbpfcp-watermark.image?)

这个上节讲过。

当然，传入 Next 参数的时候，一般是不需要在这里响应的，一般是调用下个 handler 来响应：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9313211d72a44cf7a1dc899932eda3f4~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66f4e6a9470f427b8181e983cb1b8894~tplv-k3u1fbpfcp-watermark.image?)

不过一般也不需要这样写，直接写在一个 handler 里就行。

有的同学可能会问：Nest 的 middleware 和 interceptor 都是在请求前后加入一些逻辑的，这俩区别是啥呢？

区别有两点：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/013d75fb98f045ecb06aee78c6689ad6~tplv-k3u1fbpfcp-watermark.image?)

interceptor 是能从 ExecutionContext 里拿到目标 class 和 handler，进而通过 reflector 拿到它的 metadata 等信息的，这些 middleware 就不可以。

再就是 interceptor 里是可以用 rxjs 的操作符来组织响应处理流程的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b5826ac6aec4c0ea2ebb3fba0d69424~tplv-k3u1fbpfcp-watermark.image?)

middleware 里也不可以。

它们都是 Nest AOP 思想的实现，但是 interceptor 更适合处理与具体业务相关的逻辑，而 middleware 适合更通用的处理逻辑。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/midleware-test)。

## 总结

Nest 也有 middleware，但是它不是 Express 的 middleware，虽然都有 request、response、next 参数，但是它可以从 Nest 的 IOC 容器注入依赖，还可以指定作用于哪些路由。

用法是 Module 实现 NestModule 的 configure 方法，调用 apply 和 forRoutes 指定什么中间件作用于什么路由。

app.use 也可以应用中间件，但更建议在 AppModule 里的 configure 方法里指定。

Nest 还有个 @Next 装饰器，这个是用于调用下个 handler 处理的，当用了这个装饰器之后，Nest 就不会把 handler 返回值作为响应了。

middleware 和 interceptor 功能类似，但也有不同，interceptor 可以拿到目标 class、handler 等，也可以调用 rxjs 的 operator 来处理响应，更适合处理具体的业务逻辑。

middleware 更适合处理通用的逻辑。


## 18.RxJS 和 Interceptor

RxJS 是一个组织异步逻辑的库，它有很多 operator，可以极大的简化异步逻辑的编写。

它是由数据源产生数据，经过一系列 operator 的处理，最后传给接收者。

这个数据源叫做 observable。

比如这样：

```javascript
import { of, filter, map } from 'rxjs';

of(1, 2, 3)
.pipe(map((x) => x * x))
.pipe(filter((x) => x % 2 !== 0))
.subscribe((v) => console.log(`value: ${v}`));
```

用 node 跑一下，结果如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c0d7a255bb84cee9c3cd29cc2dfd009~tplv-k3u1fbpfcp-watermark.image?)

这里 node 能直接解析 esm 需要在 package.json 里设置 type 为 module：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/454464cf6765412198523a9c33ff6faf~tplv-k3u1fbpfcp-watermark.image?)

这就是 map、filter 的 operator 的作用。

还是很容易理解的。

有同学说，这样的逻辑自己写也行呀。

那这种呢：

```javascript
import { of, scan, map } from 'rxjs';

const numbers$ = of(1, 2, 3);

numbers$
  .pipe(
    scan((total, n) => total + n),
    map((sum, index) => sum / (index + 1))
  )
  .subscribe(console.log);
```

scan 是计数，map 是转换，结果如下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f53b914317474cb88ead3a21ac30d19c~tplv-k3u1fbpfcp-watermark.image?)

或者是节流、防抖：

```javascript
import { fromEvent, throttleTime } from 'rxjs';

const clicks = fromEvent(document, 'click');
const result = clicks.pipe(throttleTime(1000));

result.subscribe(x => console.log(x));
```

```javascript
import { fromEvent, debounceTime } from 'rxjs';

const clicks = fromEvent(document, 'click');
const result = clicks.pipe(debounceTime(1000));
result.subscribe(x => console.log(x));
```

有同学说，这些逻辑都很简单呀，完全可以自己写。

没错，一般异步逻辑自己写也行。

但是架不住 RxJS 的 operator 多呀，组合起来可以实现非常复杂的异步逻辑处理。

可以在官网文档看到[所有的 operator](https://rxjs.dev/guide/operators#creation-operators-1)。

所以说，如果异步逻辑复杂度高了，那上 RxJS 收益还是很高的，异步逻辑的编写就变成了 operator 的组合，少写很多代码。

感受到为啥要用 RxJS 了么？

也是因为这个原因，Nest 的 interceptor 集成了 RxJS，可以用它来处理响应。

当然，也有人觉得这里没必要用 RxJS。

但既然 Nest 支持了，我们就用用看，基于那一堆 operator 确实是能简化异步逻辑的。

创建一个测试项目：

    nest new interceptor-test -p npm

进入目录执行 nest g interceptor：

    nest g interceptor aaa --flat --no-spec

我们可以这样实现接口耗时统计：

```javascript
import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Observable, tap } from 'rxjs';

@Injectable()
export class AaaInterceptor implements NestInterceptor {

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const now = Date.now();
    return next
      .handle()
      .pipe(
        tap(() => console.log(`After... ${Date.now() - now}ms`)),
      );
  }
}
```

tap operator 不会改变数据，只是额外执行一段逻辑。

在 handler 上启用 interceptor：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d9bd2a014e840de8bbd782c4caee1cc~tplv-k3u1fbpfcp-watermark.image?)

然后浏览器访问 <http://localhost:3000>

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c65983ca7714b7d9e13effcedc5f474~tplv-k3u1fbpfcp-watermark.image?)

就会看到打印的耗时数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b6ebab0a034cc4beeddc4e2d846557~tplv-k3u1fbpfcp-watermark.image?)

或者全局启用这个 interceptor：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13609d5a22d346f08ac3844c3dbe1395~tplv-k3u1fbpfcp-watermark.image?)

路由级别和全局级别的 interceptor 还是有区别的，路由级别的可以注入依赖，而全局的不行：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a509b7937904912b0617d540ed6b544~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5eb833551804c0aa7ab24f4fc2d148d~tplv-k3u1fbpfcp-watermark.image?)

我们再来使用下别的 RxJS operator：

其实适合在 Nest 的 interceptor 里用的 operator 还真不多，也就这么几个：

## map

再生成一个 interceptor：

    nest g interceptor map-test --flat --no-spec

使用 map operator 来对 controller 返回的数据做一些修改：

```javascript
import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { map, Observable } from 'rxjs';

@Injectable()
export class MapTestInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(map(data => {
      return {
        code: 200,
        message: 'success',
        data
      }
    }))
  }
}
```

在 controller 里引入下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc01fd3012b9483ca01bee46570cd8e0~tplv-k3u1fbpfcp-watermark.image?)

跑下试试：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47a71b3069394bf49aecc524731ba47f~tplv-k3u1fbpfcp-watermark.image?)

现在返回的数据就变成了这样。

map 算是在 nest interceptor 里必用的 rxjs operator 了

## tap

再生成个 interceptor

    nest g interceptor tap-test --flat --no-spec

使用 tap operator 来添加一些日志、缓存等逻辑：

```javascript
import { AppService } from './app.service';
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { Observable, tap } from 'rxjs';

@Injectable()
export class TapTestInterceptor implements NestInterceptor {
  constructor(private appService: AppService) {}

  private readonly logger = new Logger(TapTestInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(tap((data) => {
      
      // 这里是更新缓存的操作，这里模拟下
      this.appService.getHello();

      this.logger.log(`log something`, data);
    }))
  }
}
```

因为还没讲到缓存那块，这里就调用 service 方法模拟了下。

日志记录我们用的 nest 内置的 Logger，在 controller 返回响应的时候记录一些东西。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed609e29fa88415ea2bed46de8884f4e~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问这个接口，会打印日志：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b82fffddcb744bbd932b63ad47f8b72d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fda80ddff2f4c989f1b866102a577b6~tplv-k3u1fbpfcp-watermark.image?)

这里我们用的是 Nest 内置的 Logger，所以打印格式是这样的。

## catchError

controller 里很可能会抛出错误，这些错误会被 exception filter 处理，返回不同的响应，但在那之前，我们可以在 interceptor 里先处理下。

生成 interceptor：

    nest g interceptor catch-error-test --flat --no-spec

使用 catchError 处理抛出的异常：

```javascript
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { catchError, Observable, throwError } from 'rxjs';

@Injectable()
export class CatchErrorTestInterceptor implements NestInterceptor {
  private readonly logger = new Logger(CatchErrorTestInterceptor.name)

  intercept (context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(catchError(err => {
      this.logger.error(err.message, err.stack)
      return throwError(() => err)
    }))
  }
}
```

这里我们就是日志记录了一下，当然你也可以改成另一种错误，重新 throwError。

在 controller 里用一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5fbe5adee840e8b58211dd6c849b55~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下，可以看到返回 500 的错误：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e74998be76c3424b9fa81b6a546a50b8~tplv-k3u1fbpfcp-watermark.image?)

打印了两次错误：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74d1cc1f61c84b6786bcbc117ea1284b~tplv-k3u1fbpfcp-watermark.image?)

一次是我们在 interceptor 里打印的，一次是 exception filter 打印的。

其实我们能看到这个 500 错误，就是内置的 exception filter 处理的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e74998be76c3424b9fa81b6a546a50b8~tplv-k3u1fbpfcp-watermark.image?)

对应的 Nest 源码如下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2198e6aae4344a2c9b64bc0fa5734b60~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9eccf5302f942c2b8ac6c9075e92987~tplv-k3u1fbpfcp-watermark.image?)

## timeout

接口如果长时间没返回，要给用户一个接口超时的响应，这时候就可以用 timeout operator。

我们再创建个 nest interceptor

    nest g interceptor timeout --flat --no-spec

添加如下逻辑：

```javascript
import { CallHandler, ExecutionContext, Injectable, NestInterceptor, RequestTimeoutException } from '@nestjs/common';
import { catchError, Observable, throwError, timeout, TimeoutError } from 'rxjs';

@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      timeout(3000),
      catchError(err => {
        if(err instanceof TimeoutError) {
          console.log(err);
          return throwError(() => new RequestTimeoutException());
        }
        return throwError(() => err);
      })
    )
  }
}
```

timeout 操作符会在 3s 没收到消息的时候抛一个 TimeoutError。

然后用 catchError 操作符处理下，如果是 TimeoutError，就返回 RequestTimeoutException，这个有内置的 exception filter 会处理成对应的响应格式。

其余错误就直接 throwError 抛出去。

在 controller 里用一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f5989c408b14c5ca0a40ad97f433647~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问，3s 后返回 408 响应：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32efac20c280471898effb85d91fe169~tplv-k3u1fbpfcp-watermark.image?)

就是在这里处理的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e3eb04201dc43008ad0349168319ced~tplv-k3u1fbpfcp-watermark.image?)

不信可以抛一个其他的 exception 试一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9973417e6f414bf88992f58161624c8d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca1c77286ba4951ba0b5693c5b54e5f~tplv-k3u1fbpfcp-watermark.image?)

最后，再来看下全局的 interceptor：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cea9df36fe24df9bd2f372cfe7453bc~tplv-k3u1fbpfcp-watermark.image?)

因为这种是手动 new 的，没法注入依赖。

但很多情况下我们是需要全局 interceptor 的，而且还用到一些 provider，怎么办呢？

nest 提供了一个 token，用这个 token 在 AppModule 里声明的 interceptor，Nest 会把它作为全局 interceptor：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e126e39cc9e435aac798e07947c4cfb~tplv-k3u1fbpfcp-watermark.image?)

在这个 interceptor 里我们注入了 appService：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b212d7a10d874341afdf2395e5e517ba~tplv-k3u1fbpfcp-watermark.image?)

添加一个路由：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecedb90ff1c8481b94dae6e796879e83~tplv-k3u1fbpfcp-watermark.image?)

访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a99e53b4ee544ba69d55b081e8a4288d~tplv-k3u1fbpfcp-watermark.image?)

可以看到全局 interceptor 生效了，而且这个 hello world 就是注入的 appService 返回的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b91330c950347a3ab4dbb435ca1df43~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/interceptor-test)。

## 总结

rxjs 是一个处理异步逻辑的库，它的特点就是 operator 多，你可以通过组合 operator 来完成逻辑，不需要自己写。

nest 的 interceptor 就用了 rxjs 来处理响应，但常用的 operator 也就这么几个：

*   tap: 不修改响应数据，执行一些额外逻辑，比如记录日志、更新缓存等
*   map：对响应数据做修改，一般都是改成 {code, data, message} 的格式
*   catchError：在 exception filter 之前处理抛出的异常，可以记录或者抛出别的异常
*   timeout：处理响应超时的情况，抛出一个 TimeoutError，配合 catchErrror 可以返回超时的响应

总之，rxjs 的 operator 多，但是适合在 nest interceptor 里用的也不多。

此外，interceptor 也是可以注入依赖的，你可以通过注入模块内的各种 provider。

全局 interceptor 可以通过 APP\_INTERCEPTOR 的 token 声明，这种能注入依赖，比 app.useGlobalInterceptors 更好。

interceptor 是 nest 必用功能，还是要好好掌握的。


## 19.内置 Pipe 和自定义 Pipe

Pipe 是在参数传给 handler 之前对参数做一些验证和转换的 class，

对应的源码如下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed89de3d40e498bade8a478e22f4b2f~tplv-k3u1fbpfcp-watermark.image?)

对每个参数都会应用 pipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/062d2f24b9874a8fbedc7a3085e62e63~tplv-k3u1fbpfcp-watermark.image?)

内置的 Pipe 有这些：

*   ValidationPipe
*   ParseIntPipe
*   ParseBoolPipe
*   ParseArrayPipe
*   ParseUUIDPipe
*   DefaultValuePipe
*   ParseEnumPipe
*   ParseFloatPipe
*   ParseFilePipe

它们都实现了 PipeTransform 接口：

比如 ParseIntPipe 的源码是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa9cca172621448da12d1b2fcedd7fdd~tplv-k3u1fbpfcp-watermark.image?)

我们分别来试下内置的 Pipe 的功能吧。

创建个项目：

    nest new pipe-test -p npm

参数默认是 string 类型：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87eb6e7c9e5042ebb71a1227578f4e66~tplv-k3u1fbpfcp-watermark.image?)

我们可以通过 Pipe 把它转为整数：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f168c749eb014e869d44ddc4e8b89870~tplv-k3u1fbpfcp-watermark.image?)

效果如下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/231946ac471b45d0873ff3a97651b26b~tplv-k3u1fbpfcp-watermark.image?)

当你传入的参数不能 parse 为 int 时，会返回这样的响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62eee43c9237471bb5052cdc8d0806e9~tplv-k3u1fbpfcp-watermark.image?)

这个也是可以修改的，但要使用 new XxxPipe 的方式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eef1df33b7c4c0885dd4fde73332708~tplv-k3u1fbpfcp-watermark.image?)

比如我指定错误时的状态码为 404。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dfeac56cc0e496a86d6dc865c1c68b6~tplv-k3u1fbpfcp-watermark.image?)

就会返回这样的响应。

此外，你还可以自己抛一个异常出来，然后让 exception filter 处理：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96004942abf84719a72afb80ff32acce~tplv-k3u1fbpfcp-watermark.image?)

可以看到，状态码和 message 都改了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e32b042f7744b988597d11f58caae5~tplv-k3u1fbpfcp-watermark.image?)

你也可以加个 @UseFilters 来使用自己的 exception filter 处理。

ParseFloatPipe 是把参数转换为 float 类型的。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc7d6ef5f44946e593c04603f174235b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000c46317e7f449bb504d3b02f12466e~tplv-k3u1fbpfcp-watermark.image?)

它也同样可以 new ParseFloatPipe 的形式，传入 errorHttpStatusCode 和 exceptionFactory。

剩下这些与 parse 有关的 pipe 我们都试一下：

ParseBoolPipe：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88758a82a1b54cc69425c0086def72ea~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f3da13bc7cb4c6ca8380f8811c81d83~tplv-k3u1fbpfcp-watermark.image?)

ParseArrayPipe：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b7f3fe51102479c90c9d93b6729515c~tplv-k3u1fbpfcp-watermark.image?)

这时会提示需要 class-validator 这个包：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c24ae6a218074f2380acb4fecd420625~tplv-k3u1fbpfcp-watermark.image?)

这是可以用装饰器和非装饰器两种方式对 class 属性做验证的库

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ce5ff851375484f8927ea4b05f16c71~tplv-k3u1fbpfcp-watermark.image?)

还会提示需要 class-transformer 这个包：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9950f20f7db4de895efc6c2e328c522~tplv-k3u1fbpfcp-watermark.image?)

它是把普通对象转换为对应的 class 实例的包：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d025a51956394e74a1a82ff11c590098~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98495919df1543ff902de67745de3b3f~tplv-k3u1fbpfcp-watermark.image?)

后面我们也会用到这俩包。

安装这俩包：

    npm install -D class-validator class-transformer

然后访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d39b2ada2747299fdc7f7fd37c9406~tplv-k3u1fbpfcp-watermark.image?)

你会发现它确实把每一项都提取出来了，但是没有转为 number。

这时候就需要用 new XxxPipe 的方式传入参数了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95f05794c3f94db9ad283e4930147b51~tplv-k3u1fbpfcp-watermark.image?)

指定 item 的类型。

这样就把数组每一项处理为 number 了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6077cce97aef47cfb6df5a0f420fb91b~tplv-k3u1fbpfcp-watermark.image?)

此外，你还可以指定分隔符：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa6c885ffc2f4eccb06442430b2b7176~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0361c705bb9845da9b38c32d6c23f411~tplv-k3u1fbpfcp-watermark.image?)

当没有传参数的时候会报错：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/203e7685cadb41fb9b07cb05a2925af5~tplv-k3u1fbpfcp-watermark.image?)

可以把它设置为 optional：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e389f42e0a8b4ad89511bf73b3c9a27d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d79c376c0ae48ac9d16bcf7476f7a01~tplv-k3u1fbpfcp-watermark.image?)

然后是 ParseEnumPipe：

假设我们有这样一个枚举：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b18934cd71074a1abb00e5788650c40d~tplv-k3u1fbpfcp-watermark.image?)

就可以用 ParseEnumPipe 来取：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd33fe52b7f0491d892e95462e8107e3~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c55f4a16e454abe8c3aca59ed01111f~tplv-k3u1fbpfcp-watermark.image?)

有同学说，这不是多此一举么，本来 @Param 也能把它取出来呀。

ParseEnumPipe 还是有用的：

第一个是可以限制参数的取值范围：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c64dc64a7f9742c083ddaae9e041ad32~tplv-k3u1fbpfcp-watermark.image?)

如果参数值不是枚举里的，就会报错。

这个错误自然也可以通过 errorHttpStatusCode 和 exceptionFactory 来定制。

第二个是帮你转换类型：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66bbf74c69a14addae795fc398e25d1d~tplv-k3u1fbpfcp-watermark.image?)

这里拿到的就直接是枚举类型了，如果有个方法的参数是这样的枚举类型，就可以直接传入。

接下来是 ParseUUIDPipe：

UUID 是一种随机生成的几乎不可能重复的字符串，可以用来做 id。

它有 v3、v4、v5 3 个版本，我们用 uuid 包可以生成这种 id：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e352ab28776a4174b0b32d89f6d59d4d~tplv-k3u1fbpfcp-watermark.image?)

在参数里，可以用 ParseUUIDPipe 来校验是否是 UUID：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d046a82c4b9345daad4d4be5f19d5fbc~tplv-k3u1fbpfcp-watermark.image?)

如果不是 uuid 会抛异常：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3de426d3123c4e23a336d006d4ba2380~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a41ef1845a9849f08e923dc8361097bf~tplv-k3u1fbpfcp-watermark.image?)

接下来是 DefaultValuePipe：

这个是设置参数默认值的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8077504a0f1404482d6f3be7b17ac5c~tplv-k3u1fbpfcp-watermark.image?)

当你没传参数的时候，会使用默认值：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3026296b87344451b8dfc929c741307b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d732443f95d4ee0aa23248436497b56~tplv-k3u1fbpfcp-watermark.image?)

它的源码也很简单：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44835473f29b4304a78850642c238437~tplv-k3u1fbpfcp-watermark.image?)

还剩下 ValidationPipe 和 ParseFilePipe，这个我们之后再讲。

接下来我们自己实现个 Pipe 试一下：

    nest g pipe aaa --flat --no-spec

生成一个 pipe，打印下参数值，返回 aaa：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3ba624bacce466da270a118eb856fe3~tplv-k3u1fbpfcp-watermark.image?)

在 handler 里用下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cfb11c44b6648328d1890e1c3154884~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问这个接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00cde610b641471eb9f5c520654a6c44~tplv-k3u1fbpfcp-watermark.image?)

返回的值是 aaaaaa，也就是说 pipe 的返回值就是传给 handler 的参数值。

打印的 value 就是 query、param 的值，而 metadata 里包含 type、metatype、data：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db98d9dc787040c2b2db96ce7c3e54c2~tplv-k3u1fbpfcp-watermark.image?)

type 就是 @Query、@Param、@Body 装饰器，或者自定义装饰器：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f784ab236374d5c89645c9a707002d7~tplv-k3u1fbpfcp-watermark.image?)

而 metatype 是参数的 ts 类型：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/835ef7054764499b8fbfb6c821801568~tplv-k3u1fbpfcp-watermark.image?)

data 是传给 @Query、@Param、@Body 等装饰器的参数。

有了这些东西，做一下验证，抛出异常给 exception filter 处理，或者对 value 做些转换再传给 handler 就都是很简单的事情了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/pipe-test)。

## 总结

Pipe 是在参数传给 handler 之前做一些验证和转换的，有 9 个内置的 Pipe 可以直接用。

我们过了一遍内置的 ParseIntPipe、ParseBoolPipe、ParseArrayPipe、ParseUUIDPipe、ParseEnumPipe、ParseFloatPipe 还有 DefaultValuePipe。

剩下的 ValidationPipe 和 ParseFilePipe 之后的章节讲。

自己写一个 pipe 也很简单，就是实现 PipeTransform 接口的 transform 方法，它的返回值就是传给 handler 的值。

在 pipe 里可以拿到装饰器和 handler 参数的各种信息，基于这些来实现校验和转换就是很简单的事情了。


## 2.给你 5 个学习 Nest 的理由，你会心动么

你可能经常听到 Nest，会觉得它和我的工作也没啥关系呀，为什么要学习 Nest 呢？

这里给出 5 个学习 Nest 的理由：

## 最流行的 Node 企业级框架

开发 node 应用有 3 个层次：

*   直接用 http、https 包的 createServer api
*   使用 express、koa 这种处理请求响应的库
*   使用 nest、egg、midway 这类企业级框架

直接用 createServer api 创建服务适合特别简单的场景，比如工具提供的开发服务。

express、koa 这种处理请求响应的库并不能约束代码的写法，代码可以写的很随意，所以不适合开发大型项目。

大型项目会用企业级开发框架，也就是规定了代码的写法，对很多功能都有开箱即用的解决方案的框架。

比如 Nest 代码一般都是分了很多模块：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/549bc636a9a84b56bfde197d088f7ded~tplv-k3u1fbpfcp-watermark.image?)

每个模块下都是 controller、service、guard、filter、interceptor、dto 等这些代码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6e576d76aa4a0583ad40a183b6229c~tplv-k3u1fbpfcp-watermark.image?)

什么代码放在哪里都是有规范的。

上面这个目录是一个 8.7k 的已经盈利的项目的服务端代码，感兴趣可以看一下：

<https://github.com/apitable/apitable/tree/35b05eb421d31a4e4b68ca0bacb1fb484186f4ea/packages/room-server>

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c03ce098c634b8781fc03d5c68c6949~tplv-k3u1fbpfcp-watermark.image?)

那 egg 和 midway 呢？

egg 的 ts 支持不行，在当下 ts 这么主流的情况下，已经不合适了。更何况它是阿里的项目，而阿里 egg 团队也被打包裁了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45ed098f827f4b348d434305d04e9f7d~tplv-k3u1fbpfcp-watermark.image?)

midway 呢？

star 数差太多了，和 nest 不在一个量级。

而且你能保证它不是下一个 egg 么？

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f81b4885744c6f98ba9bc03e851583~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38212a2f2e0445b090868b6794c29522~tplv-k3u1fbpfcp-watermark.image?)

Nest 是在全世界都很火，在国内也越来越流行，找不到啥对手。

如果你想学习 Node 框架，那 Nest 基本是唯一的选择了。

## 学习各种后端中间件

后端有很多中间件，比如 mysql、redis、rabbitmq、nacos、elasticsearch 等等，学习 Nest 的过程会用到这些中间件。

比如类似这种的后端架构：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38a8aa18ae1a40e1ab83767b2558d84f~tplv-k3u1fbpfcp-watermark.image?)

所以我们学的并不只是 Nest，而是整个后端生态。

这些东西就算换了 go 或者 java，也是一样要学的。

## 可以找国外的全栈工作，或者接远程外包

国外远程工作这块，电鸭社区是最有发言权的。

你逛一逛就会发现，很多创业公司都会用 Nest 做服务端：

比如这个：

<https://eleduck.com/posts/oQfOD7>


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003b04cad510485e8c9728e0d65b89c2~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88e83771b51d49da901e9ba4856f846a~tplv-k3u1fbpfcp-watermark.image?)

这个：

<https://eleduck.com/tposts/Baf0Dy>

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/776effcee7ba4ccab9ad4d9fb9f019b0~tplv-k3u1fbpfcp-watermark.image?)

或者这个：

<https://eleduck.com/posts/njfbzD>

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8af15eea44a345138f436fe5c9302be9~tplv-k3u1fbpfcp-watermark.image?)

还有这个：

<https://eleduck.com/posts/XNfBXN>

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fbdb09abe634dbfabf069040efbca6b~tplv-k3u1fbpfcp-watermark.image?)

如果你会 React + Nest 技术栈，找个远程全栈工作不也很香么。

## 可以独立做自己的产品

如果你想做一个自己的产品，不管是网站、app、小程序还是游戏等应用，都得配上后端吧，如果你熟悉 js/ts，那 Nest 是最适合的选择了。

比如刚才我们看到这个国外的这个盈利的产品，它就是用 Nest 做的后端：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dad2ada4c884466b5604f4d5cdc8560~tplv-k3u1fbpfcp-watermark.image?)

或者你是大学生，想做一个写在简历里的前端项目，那只写前端就可以了么？

肯定不行呀，你得前后端都搞定，在简历上写一个完整的项目，这时候 Nest 就很合适了。因为如果你是想做前端工作，那用 java 并不咋加分。

## 学习优秀的架构设计

Nest 的架构很优雅，因为它用了不少设计模式。

比如 Nest 并不和 Express 耦合，你可以轻松切换到 Fastify。

就是因为它用了适配器的设计模式：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b41feed8d54e8bb264e508cd55c9c3~tplv-k3u1fbpfcp-watermark.image?)

Nest 本身只依赖 HttpServer 接口，并不和具体的库耦合。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/237d45ff113a4fe1b7386d3dc7847355~tplv-k3u1fbpfcp-watermark.image?)

你想换别的 http 处理的库，只要写一个新的适配器就好了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baeb2549d43c4ab79b65d8f3d717abd1~tplv-k3u1fbpfcp-watermark.image?)

再比如 Nest 内构建复杂对象很多地方都用到了 builder 的设计模式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6ccae877dc4078b115317f3c8d8c13~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738ce1e89cdc438cbe6092b3d3aabe40~tplv-k3u1fbpfcp-watermark.image?)

类似这样的设计有很多。

当你把 Nest用熟之后，潜移默化中，你就知道了什么地方用什么模式是最好的，应该怎么设计。无形中就提升了架构设计能力。

## 总结

不管是你想学 Node 框架，学习各种后端中间件，找国外的远程工作或远程外包，独立开发自己的产品，还是想学习优秀的设计，提升架构能力。Nest 都是一个非常好的选择。

心动了么？赶紧上车。


## 20.如何使用 ValidationPipe 验证 post 请求参数

上节我们学了 pipe 来对参数做验证和转换，但那些都是 get 请求的参数，如果是 post 请求呢？

post 请求的数据是通过 @Body 装饰器来取，并且要有一个 dto class 来接收：

（dto 是 data transfer object，数据传输对象，用于封装请求体的数据）

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89880e17ce6c458dbbdd098a4cca78b3~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc0b0df7fa5b468f87ea5f36d3329886~tplv-k3u1fbpfcp-watermark.image?)

我们用 postman 来发个 post 请求。

(postman 在这里下载： <https://www.postman.com/downloads>)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/745b9d9702b54dde8d84ef37df47bd84~tplv-k3u1fbpfcp-watermark.image?)

content-type 指定为 json。

点击 send，就可以看到服务端接收到了数据，并且把它转为了 dto 类的对象：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb9b7d08313499a93ccefb04e6b4b17~tplv-k3u1fbpfcp-watermark.image?)

但如果我们 age 传一个浮点数，服务端也能正常接收：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f33b184c864e47a19257a94d41fe9b8f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bda66123b6494113ac2e12272e5f78f2~tplv-k3u1fbpfcp-watermark.image?)

因为它也是 number。

而这很可能会导致后续的逻辑出错。

所以我们要对他做参数验证。

怎么做呢？

这就需要用到这节的 ValidationPipe 了。

它需要两个依赖包：
```
npm install class-validator class-transformer
```
然后在 @Body 里添加这个 pipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85882d3e4a6e424e91c032bfbfc115c5~tplv-k3u1fbpfcp-watermark.image?)

在 dto 这里，用 class-validator 包的 @IsInt 装饰器标记一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d36bfb83ca2a4257b6f506aa3b735988~tplv-k3u1fbpfcp-watermark.image?)

再次请求，你就会发现它检查出了参数里的错误：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb8e96a92eb454d8240f878e6ee3637~tplv-k3u1fbpfcp-watermark.image?)

那它是怎么实现的呢？

[class-validator](https://www.npmjs.com/package/class-validator) 包提供了基于装饰器声明的规则对对象做校验的功能：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e7b7376b04c458f9e92c863cef3456a~tplv-k3u1fbpfcp-watermark.image?)

而 [class-transformer](https://www.npmjs.com/package/class-transformer) 则是把一个普通对象转换为某个 class 的实例对象的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/578fadf837754284a4952e45e322fd21~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b61c5f50c45b42eb87c7e9ad79704d64~tplv-k3u1fbpfcp-watermark.image?)

这两者一结合，那 ValidationPipe 是怎么实现的不就想明白了么：

**我们声明了参数的类型为 dto 类，pipe 里拿到这个类，把参数对象通过 class-transformer 转换为 dto 类的对象，之后再用 class-validator 包来对这个对象做验证。**

我们自己写写看：

```javascript
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common';
import { validate } from 'class-validator';
import { plainToInstance } from 'class-transformer';

@Injectable()
export class MyValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype) {
      return value;
    }
    const object = plainToInstance(metatype, value);
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('参数验证失败');
    }
    return value;
  }
}
```

pipe 里拿到的 metatype 就是这部分：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2d114db874a4949be4012eee67a21a0~tplv-k3u1fbpfcp-watermark.image?)

如果没有声明这部分，那就没法转换和验证，直接返回 value。

否则，通过 class-transformer 包的 plainToInstance 把普通对象转换为 dto class 的实例对象。

之后调用 class-validator 包的 validate api 对它做验证。如果验证不通过，就抛一个异常。

我们来用下看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e74db89b6afa4d0ebdf966c630fa62b7~tplv-k3u1fbpfcp-watermark.image?)

替换为我们自己实现的 MyValidationPipe。

再次请求下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd4ec80f4d8744e89d0e3b81967575bd~tplv-k3u1fbpfcp-watermark.image?)

确实检查出了错误。

当然，我们做的并不够完善，还是直接用内置的 ValidationPipe 好了。

pipe 里也是可以注入依赖的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fc1687121fc474caf84258dc728cb59~tplv-k3u1fbpfcp-watermark.image?)

比如，我们指定 @Inject 注入 token 为 validation\_options 的对象。

因为标记了 @Optional，没找到对应的 provider 也不会报错：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e22faba38c894ef395105bf900e70a1e~tplv-k3u1fbpfcp-watermark.image?)

但当我们在 module 里添加了这个 provider：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10128118e6a443649ceab27b41a18338~tplv-k3u1fbpfcp-watermark.image?)

就可以正常注入了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66ae19e0796f4ece8745eb08634c2687~tplv-k3u1fbpfcp-watermark.image?)

当然，这种方式就不能用 new 的方式了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e48818e0378a4a32a831e4b677ad1c2e~tplv-k3u1fbpfcp-watermark.image?)

直接指定 class，让 Nest 去创建对象放到 ioc 容器里。

如果是全局的 pipe，要通过这种方式来创建才能注入依赖：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d0bc8f8372d40edb3d86f5458e97686~tplv-k3u1fbpfcp-watermark.image?)

这就和我们之前创建全局 interceptor 一样。

同理，其余的 filter、guard 也可以通过这种方式声明为全局生效的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0073fb99ec44b1a56554eb7144d6dc~tplv-k3u1fbpfcp-watermark.image?)

现在我们就可以把 handler 里的 ValidationPipe 去掉了

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f4e2c0a00084bc79776572aefd228ef~tplv-k3u1fbpfcp-watermark.image?)

再次访问，它依然是生效的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/017851a4b31e42db8aeab3de9b20bd93~tplv-k3u1fbpfcp-watermark.image?)

当然，这里我们没有注入什么依赖，所以这种方式也可以：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad509bf38ac42489e2702ef3ac99c29~tplv-k3u1fbpfcp-watermark.image?)

会用 ValidationPipe 之后，我们回过头来再看看 class-validator 都支持哪些验证方式：

我们声明这样一个 dto class：

```javascript
import { Contains, IsDate, IsEmail, IsFQDN, IsInt, Length, Max, Min } from 'class-validator';

export class Ppp {
    @Length(10, 20)
    title: string;
  
    @Contains('hello')
    text: string;
  
    @IsInt()
    @Min(0)
    @Max(10)
    rating: number;
  
    @IsEmail()
    email: string;
  
    @IsFQDN()
    site: string;
}
```

其中 @IsFQDN 是是否是域名的意思。

然后添加一个 post 的 handler：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c48c65e0e869479b911c520d72f90368~tplv-k3u1fbpfcp-watermark.image?)

在 postman 里发送 post 请求。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e82040862e514a42aed15255ee438ec3~tplv-k3u1fbpfcp-watermark.image?)
```json
{
    "title": "aaaaaaaaaaaaaaa",
    "text": "hello aaa",
    "rating": 10,
    "email": "aaa@qq.com",
    "site": "aaa.guang.com",
    "createDate": "2023-05-28T01:45:37.803Z"
}
```
参数正确的时候是不会报错的。

当参数不正确，ValidationPipe 就会返回 class-validator 的报错：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/958ecb1dc38c4b4692bf9a6cc421b9bd~tplv-k3u1fbpfcp-watermark.image?)

这个错误消息也是可以定制的：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e667a3fbc62485ab382767e5abea4b0~tplv-k3u1fbpfcp-watermark.image?)

添加一个 options 对象，传入 message 函数，打印下它的参数：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/932df50b7d144cb58b2862c07f33c41a~tplv-k3u1fbpfcp-watermark.image?)

可以拿到对象、属性名、属性值、class 名等各种信息，然后你可以返回自定义的 message：
```typescript
@Length(10, 20, {
    message({targetName, property, value, constraints}) {
        return `${targetName} 类的 ${property} 属性的值 ${value} 不满足约束: ${constraints}`
    }
})
title: string;
```
再次访问，返回的就是自定义的错误消息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70705e328fb44fa8a4611a53d07a838d~tplv-k3u1fbpfcp-watermark.image?)

更多的装饰器可以看 [class-validator 文档](https://www.npmjs.com/package/class-validator)。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/pipe-test)。

## 总结

接收 post 请求的方式是声明一个 dto class，然后通过 @Body 来取请求体来注入值。

对它做验证要使用 ValidationPipe。

它的实现原理是基于 class-tranformer 把参数对象转换为 dto class 的对象，然后通过 class-validator 基于装饰器对这个对象做验证。

我们可以自己实现这样的 pipe，pipe 里可以注入依赖。

如果是全局 pipe 想注入依赖，需要通过 APP\_PIPE 的 token 在 AppModule 里声明 provider。

class-validator 支持很多种验证规则，比如邮箱、域名、长度、值的范围等，而且错误消息也可以自定义。

ValidationPipe 是非常常用的 pipe，后面会大量用到。


## 21.如何自定义 Exception Filter

Exception Filter 是在 Nest 应用抛异常的时候，捕获它并返回一个对应的响应。

比如路由找不到时返回 404：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b9d75dc99fc4121a6679f7530555925~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=598&h=300&s=33718&e=png&b=fdfdfd)

服务端报错时返回 500：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27012d32c72f472186b05bbfa3f6bfe4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=540&h=296&s=29295&e=png&b=fdfdfd)

参数的错误返回 400：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96886fcf1ee7463889c6ec18ae45a099~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=494&h=304&s=32943&e=png&b=fdfdfd)

这些都是 Exception Filter 做的事情。

那么，如果我们想自定义异常时返回的响应格式呢？

这种就要自定义 Exception Filter 了。

创建个 nest 项目：

```
nest new exception-filter-test
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f859b57160eb4facbedd424e1beeb017~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=970&h=684&s=168165&e=png&b=010101)

把它跑起来：

```
npm run start:dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c48febb788f4c94b8fedb1ff01e0630~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1526&h=334&s=115093&e=png&b=181818)

浏览器访问 http://localhost:3000 可以看到 hello world，代表服务跑起来了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d5bd0d07fcb4477814ca97b8fe287ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=170&s=15840&e=png&b=ffffff)

然后在 controller 里抛个异常： 

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6513d46aec8c406ba44a1e6593c9288e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=994&h=486&s=112600&e=png&b=202020)

```javascript
throw new HttpException('xxxx', HttpStatus.BAD_REQUEST)
```
这个 HttpStatus 就是一些状态码的常量：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f1c9abeb20640b988eed80ab6f7fb9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1110&h=524&s=171231&e=gif&f=34&b=222222)

这时候刷新页面，返回的就是 400 对应的响应：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f04c970babc949df9c342131f610a21e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=600&h=280&s=25680&e=png&b=fdfdfd)

这个响应的格式是内置的 Exception Filter 生成的。

当然，你也可以直接抛具体的异常：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/813ffdfd373d4d4fbb00ee8408f35c35~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=248&s=48310&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00fd127d5c70464290bfcd27a40a9628~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=314&s=31111&e=png&b=fdfdfd)

然后我们自己定义个 exception filter：

```
nest g filter hello --flat --no-spec
```

--flat 是不生成 hello 目录，--no-spec 是不生成测试文件。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b1e3e7ac8284574b058710e89d9e751~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=670&h=70&s=17647&e=png&b=191919)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13da92ec51ae4f6596fed68444879d00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1172&h=284&s=62603&e=png&b=1f1f1f)

@Catch 指定要捕获的异常，这里指定 BadRequestException。


```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter } from '@nestjs/common';

@Catch(BadRequestException)
export class HelloFilter implements ExceptionFilter {
  catch(exception: BadRequestException, host: ArgumentsHost) {
    debugger;
  }
}
```
先打个断点。

在 AppModule 里引入：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d675e362c14d4b5898ba56ac4fc23f6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=484&s=93395&e=png&b=1f1f1f)

```javascript
app.useGlobalFilters(new HelloFilter());
```
如果你想局部启用，可以加在 handler 或者 controller 上：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/991278f81105477baf1fc9426ca38db7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=504&h=182&s=30353&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a18e5b669d3845f2b092982b644bea2c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=490&h=150&s=25435&e=png&b=1f1f1f)

然后新建个调试配置文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d286f2ac98dd4e5e99f57a2ac803eb0e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640&h=390&s=45127&e=png&b=181818)

输入调试配置：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de2342ca2649488f86a3085daf20e45a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=872&h=840&s=116234&e=png&b=1f1f1f)

```json
{
    "type": "node",
    "request": "launch",
    "name": "debug nest",
    "runtimeExecutable": "npm",
    "args": [
        "run",
        "start:dev",
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "console": "integratedTerminal",
}
```
把之前的服务关掉，点击调试启动：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3c4753f4795472881a96add2a298858~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1324&h=852&s=176647&e=png&b=1c1c1c)

刷新页面，代码会在断点处断住：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ba99ed6372c413bbfd4050248dccac2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1598&h=858&s=238183&e=png&b=1d1d1d)

我们只要根据异常信息返回对应的响应就可以了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d01b846ffbe8485fad5d1d838eca3525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&h=540&s=129790&e=png&b=202020)

```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter, HttpException } from '@nestjs/common';
import { Response } from 'express';

@Catch(BadRequestException)
export class HelloFilter implements ExceptionFilter {
  catch(exception: BadRequestException, host: ArgumentsHost) {
    const http = host.switchToHttp();
    const response = http.getResponse<Response>();

    const statusCode = exception.getStatus();

    response.status(statusCode).json({
       code: statusCode,
       message: exception.message,
       error: 'Bad Request',
       xxx: 111
    })
  }
}

```
这样，抛异常时返回的响应就是自定义的了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf1ce8c1a18945a98ee2e4babae2994a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=356&s=32092&e=png&b=fdfdfd)

但我们只是 @Catch 了 BadRequestException

如果抛的是其他异常，依然是原来的格式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ae44ad88cb34a4c809a3aa9e35265f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=904&h=226&s=47330&e=png&b=1f1f1f)

比如我抛一个 BadGatewayException。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa4500ea58224c8a990fde02ecfcaf2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=570&h=304&s=30168&e=png&b=fdfdfd)

依然是默认格式。

那我们只要 @Catch 指定 HttpException 不就行了？

因为 BadRequestExeption、BadGateWayException 等都是它的子类。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3e384391b13481ea29e678c14602f21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=740&s=150347&e=png&b=1f1f1f)

试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/947030e2ced443cd9ed1f4d8555e2f87~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=574&h=344&s=31776&e=png&b=fdfdfd)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2df461a79adc4d61b0bcc172dad6bbcd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=538&h=344&s=31635&e=png&b=fdfdfd)

确实，现在所有的 HttpException 都会被处理了。

但其实这也有个问题。

就是当我们用了 ValidationPipe 的时候。

比如我们加一个路由：

```javascript
@Post('aaa') 
aaa(@Body() aaaDto: AaaDto ){
    return 'success';
}
```
然后创建 src/aaa.dto.ts

```javascript
export class AaaDto {
    aaa: string;
    
    bbb: number;
}
```
安装用到的包：

```
npm install --save class-validator class-transformer
```
然后给 AaaDto 添加几个校验规则：

```javascript
import { IsEmail, IsNotEmpty, IsNumber } from "class-validator";

export class AaaDto {
    @IsNotEmpty({message: 'aaa 不能为空'})
    @IsEmail({}, {message: 'aaa 不是邮箱格式'})
    aaa: string;
    
    @IsNumber({}, {message: 'bbb 不是数字'})
    @IsNotEmpty({message: 'bbb 不能为空'})
    bbb: number;
}
```
在 main.ts 启用 ValidationPipe：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/649786f904ea41b1b2cdd4d43492bae6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=866&h=608&s=122015&e=png&b=1f1f1f)

```javascript
app.useGlobalPipes(new ValidationPipe());
```

在 postman 里测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/298928b550af4817bb070d12c37f8b70~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=818&s=82850&e=png&b=fcfcfc)

可以看到，提示的错误也不对了。

因为我们自定义的 exception filter 会拦截所有 HttpException，但是没有对这种情况做支持。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5df5b55aa61b4499a6cf23718bd13d4b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=872&h=620&s=123385&e=png&b=1f1f1f)

先不加这个 filter。

这时候响应是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eec351b99ec4674846958c92693fe47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=894&s=90951&e=png&b=fcfcfc)

我们对这种情况做下支持：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c26c24ed49b64c908fdbb398519592b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=886&h=590&s=121580&e=png&b=1f1f1f)

启用自定义的 filter，然后打个断点：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/052703cecab44c65835f5d0ffb6d3f4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1036&h=594&s=122550&e=png&b=1f1f1f)

再次访问会在断点处断住：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95c13555449345f2b59b1dd88bbea4e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1036&h=598&s=151151&e=png&b=202020)

可以看到 ValidationPipe 的 response 格式是这样的。

所以我们可以这样改：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48446a774ec84fa58563fea546afe6a1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1310&h=738&s=172236&e=png&b=1f1f1f)

```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter, HttpException } from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class HelloFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const http = host.switchToHttp();
    const response = http.getResponse<Response>();

    const statusCode = exception.getStatus();

    const res = exception.getResponse() as { message: string[] };
    
    response.status(statusCode).json({
       code: statusCode,
       message: res?.message?.join ? res?.message?.join(',') : exception.message,
       error: 'Bad Request',
       xxx: 111
    })
  }
}
```

如果 response.message 是个数组，就返回 join 的结果，否则还是返回 exception.message

再试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d4b65e69c6f4ec38777e76d70c36ccc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=950&h=806&s=87413&e=png&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcbb65dfb38d4a3bae2a06d2abca9fc2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=554&h=326&s=31640&e=png&b=fdfdfd)

现在，ValidationPipe 的错误和其他的错误就都返回了正确的格式。

那如果我想在 Filter 里注入 AppService 呢？

这就需要改一下注册方式：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/579bb3c079f94392a19e817f937b88b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=600&s=123262&e=png&b=1f1f1f)

不用 useGlobalFilters 注册了，而是在 AppModule 里注册一个 token 为 APP_FILTER 的 provider：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d674aeefea6d444298bba83448e6f414~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=876&h=718&s=125118&e=png&b=1f1f1f)

```javascript
{
  provide: APP_FILTER,
  useClass: HelloFilter
}
```
Nest 会把所有 token 为 APP_FILTER 的 provider 注册为全局 Exception Filter。

注册多个 Filter 也是这么写。

其余的全局 Guard、Interceptor、Pipe 也是这样注册：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53bc0c71ad5e4dd5ac6896f933cf57b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=222&s=28288&e=png&b=222222)

这样注册的好处就是可以注入其他 provider 了：

比如我注入了 AppService，然后调用它的 getHello 方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0febd36852749139bd753a31ccfa169~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=984&s=218038&e=png&b=1f1f1f)

```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter, HttpException, Inject } from '@nestjs/common';
import { Response } from 'express';
import { AppService } from './app.service';

@Catch(HttpException)
export class HelloFilter implements ExceptionFilter {

  @Inject(AppService)
  private service: AppService;

  catch(exception: HttpException, host: ArgumentsHost) {
    const http = host.switchToHttp();
    const response = http.getResponse<Response>();

    const statusCode = exception.getStatus();

    const res = exception.getResponse() as { message: string[] };
    
    response.status(statusCode).json({
       code: statusCode,
       message: res?.message?.join ? res?.message?.join(',') : exception.message,
       error: 'Bad Request',
       xxx: 111,
       yyy: this.service.getHello()
    })
  }
}
```
可以看到，service 方法调用成功了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fc8070b467e469abaec739549f12104~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=888&h=872&s=91087&e=png&b=fcfcfc)

此外，如果你想自定义 Exception 也是可以的。

比如添加一个 src/unlogin.filter.ts 

```javascript
import { ArgumentsHost, Catch, ExceptionFilter, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

export class UnLoginException{
  message: string;

  constructor(message?){
    this.message = message;
  }
}

@Catch(UnLoginException)
export class UnloginFilter implements ExceptionFilter {
  catch(exception: UnLoginException, host: ArgumentsHost) {
    const response = host.switchToHttp().getResponse<Response>();

    response.status(HttpStatus.UNAUTHORIZED).json({
      code: HttpStatus.UNAUTHORIZED,
      message: 'fail',
      data: exception.message || '用户未登录'
    }).end();
  }
}
```
我们创建了一个 UnloginException 的异常。

然后在 ExceptionFilter 里 @Catch 了它。

在 AppModule 里注册这个全局 Filter：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b219d2fc7303447486687e1496569c8d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=866&h=892&s=153175&e=png&b=1f1f1f)

```javascript
{
  provide: APP_FILTER,
  useClass: UnloginFilter
}
```
之后在 AppController 里抛出这个异常：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/417033967a124ab1966d8f2e2f167caa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=268&s=48195&e=png&b=202020)

浏览器里访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a0b0dd568ba4b55a5c7a8474f20f262~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=592&h=298&s=29084&e=png&b=fdfdfd)

可以看到，返回的是我们自定义的格式。

也就是说，可以用自定义 Exception Filter 捕获内置的或者自定义的 Exception。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/exception-filter-test)。
## 总结

这节我们学习了自定义 Exception Filter。

通过 @Catch 指定要捕获的异常，然后在 catch 方法里拿到异常信息，返回对应的响应。

如果捕获的是 HttpException，要注意兼容下 ValidationPipe 的错误格式的处理。

filter 可以通过 @UseFilters 加在 handler 或者 controller 上，也可以在 main.ts 用 app.useGlobalFilters 全局启用。

如果 filter 要注入其他 provider，就要通过 AppModule 里注册一个 token 为 APP_FILTER 的 provider 的方式。

此外，捕获的 Exception 也是可以自定义的。

这样，我们就可以自定义异常和异常返回的响应格式了。

## 22.图解串一串 Nest 核心概念

前面讲了 IOC、AOP、全局模块、动态模块、自定义 provider、生命周期等概念，比较零散，这节我们画图来整体串一串。

首先，provider 是可以注入的对象，它们都有 token，比如 @Injectable 装饰器声明的 class

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb316b34958c4d489557c294311618ef~tplv-k3u1fbpfcp-watermark.image?)

token 可以是 class 也可以是 string：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bc462dddd914295ac4d75d4afb3b501~tplv-k3u1fbpfcp-watermark.image?)

provider 可以是 useClass 指定 class，也可以 useValue 指定值，或者 useFactory 动态创建。

provider 之间可以相互注入，还可以注入到 controller 里。

provider、controller 放在一个个 Module 里：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3063e55cbeda4f9f9658e5d67f63a4e2~tplv-k3u1fbpfcp-watermark.image?)

module 里 exports 的 provider 在模块被 imports 之后就可以用于别的模块的注入了。

或者可以通过 @Global 把这个模块声明为全局的，那样 Module 内的 provider 就可以在各处注入了。

Provider 可以通过 useFactory 动态创建，Module 也是，可以通过 register、forRoot、forFeature 等方法来动态创建。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17939d8d1e994752aa491fd7e0526bbf~tplv-k3u1fbpfcp-watermark.image?)

在 main.ts 里调用 NestFactory.create 方法，就会从 AppModule 开始递归解析 Module，实例化其中的 provider、controller，并依次调用它们的 onModuleInit 生命周期方法。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fa2b122667f4dcb8912ebf5b01c97ba~tplv-k3u1fbpfcp-watermark.image?)

之后会再递归调用每个 Module 的 provider、controller 的还有 Module 自身的 onApplicationBootstrap 生命周期方法。

这样 Nest 就能对外提供服务了。

再就是 Nest 从接收到请求，到返回响应的这个流程，有很多切面。

路由最终是在 cotnroller 的方法，也就是 handler 里处理的。

在这个过程中，会经历很多层切面：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24060e0f32204907887ede38c1aa018c~tplv-k3u1fbpfcp-watermark.image?)

首先，请求会被 middleware 处理，这一层可以复用 express 的中间件生态，实现 session、static files 等功能。

这个 middleware 也可以是 Nest 的那种 class 的 middleware，可以注入 provider。

然后在具体的路由会经历 Guard 的处理，它可以通过 ExecutionContext 拿到目标 class、handler 的metadata 等信息，可以实现权限验证等功能。

之后是 Interceptor 可以在请求前后做一些处理，它也可以通过 ExecutionContext 拿到 class、handler 的信息。

在到达 handler 之前，还会对参数用 Pipe 做下检验和转换。

这个过程中不管是哪一层抛的异常，都会被 Exception Filter 处理下，返回给用户友好的响应信息。

这就是整个请求到响应的流程。

通过 AOP 的切面，可以把通用逻辑封装起来，在各处复用。

之后，Nest 销毁的时候，也会依次调用 Module 的 provider、controller 还有 Module 自己的 onModuleDestroy 方法、beforeApplicationShutdown 还有 onApplicationShutdown 的生命周期方法。

后两者的区别是 beforeApplication 可以拿到终止信号。

这就是 Nest 从创建、启动，到处理请求返回响应，再就是销毁的整个流程。

通过 IOC 实现了对象的自动创建、依赖的自动组装。

通过 AOP 实现了通用逻辑的抽取和复用。

IOC 内部的 Module 和 Provider 也都支持动态创建，灵活度很高。

## 总结

我们通过图解串了一下 Module、Provider、Controller、动态模块、全局模块、自定义 Provider、生命周期、Middleware、Guard、Pipe、Interceptor、Exception Filter 等概念。

对 IOC、AOP 也有了更加清晰的认识。

把这些核心概念理解了，对 Nest 就算有比较好的掌握了。


## 23.接口如何实现多版本共存

应用开发完一版上线之后，还会不断的迭代。

后续可能需要修改已有的接口，但是为了兼容，之前版本的接口还要保留。

那如何同时支持多个版本的接口呢？

Nest 内置了这个功能，我们来试一下：

```
nest new version-test
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbc6fecf784a40ffbd3c823017362a69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=856&h=710&s=260160&e=png&b=010101)

创建个 nest 项目。

进入项目，创建 aaa 模块：

```
nest g resource aaa --no-spec
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf3332080b664801b11e248725f7a073~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=774&h=360&s=88876&e=png&b=191919)

把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b85d2cd9344f2384a446d9b2e58367~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1590&h=548&s=232419&e=png&b=181818)

postman 里访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d41c68443f040309f25c13feba419a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=494&s=40222&e=png&b=fcfcfc)

这是版本一的接口。

假设后面我们又开发了一版接口，但路由还是 aaa，怎么做呢？

这样：


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c250308ccd844d718012f31be1936210~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1046&h=1046&s=203587&e=png&b=1f1f1f)

在 controller 上标记为 version 1，这样默认全部的接口都是 version 1。

然后单独用 @Version 把 version 2 的接口标识一下。

在 main.ts 里调用 enableVersioning 开启接口版本功能：

```javascript
import { VersioningType } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.enableVersioning({
    type: VersioningType.HEADER,
    header: 'version'
  })
  await app.listen(3000);
}
bootstrap();
```
开启接口版本功能，指定通过 version 这个 header 来携带版本号。

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ceb66b0e2054af1b380f3941dabf294~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=744&s=71130&e=png&b=fbfbfb)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d4017c479d2462aaaa3be46395b33e3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=780&h=738&s=68871&e=png&b=fafafa)

可以看到，带上 version:1 的 header，访问的就是版本 1 的接口。

带上 version:2 的 header，访问的就是版本 2 的接口。

它们都是同一个路由。

但这时候有个问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0820e02311694cb99587de5e9bd47d50~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=844&h=834&s=86331&e=png&b=fbfbfb)

如果不带版本号就 404 了。

这个也很正常，因为这就是版本一的接口嘛，只有显式声明版本才可以。

如果你想所有版本都能访问这个接口，可以用 VERSION_NEUTRAL 这个常量：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b8a0b312a954fcd9a06fa6ae61f3fc2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=952&h=940&s=177909&e=png&b=1f1f1f)

现在带不带版本号，不管版本号是几都可以访问这些接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74e38dbd860340ce92b733371d2a1e12~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=820&h=662&s=65007&e=png&b=fafafa)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee57c76be2e144d09b5b5cf066443f04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=824&h=688&s=65226&e=png&b=fafafa)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a46469a0d5854a0eaba556af9fb40b4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=860&h=682&s=67222&e=png&b=fbfbfb)

但是现在因为从上到下匹配，版本 2 的接口不起作用了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04e8fc6531764dcfbce0743dc3923d58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=820&s=117414&e=png&b=1f1f1f)

这时候或者可以把它移到上面去：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2e86f2604ee4129807e98954a972575~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=754&h=864&s=120678&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e27d6c8fdbe74286a697fc4f9179708c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=782&h=690&s=64622&e=png&b=fbfbfb)

或者单独建一个 version 2 的 controller
```
nest g controller aaa/aaa-v2 --no-spec --flat
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e1a6c503ba1493b93aee2f5d2dcae8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=822&h=122&s=29419&e=png&b=191919)

把 AaaController 里 version 2 的接口删掉，移到这里来：

```javascript
import { Controller, Get,Version } from '@nestjs/common';
import { AaaService } from './aaa.service';

@Controller({
    path: 'aaa',
    version: '2'
})
export class AaaV2Controller {
    constructor(private readonly aaaService: AaaService) {}

    @Get()
    findAllV2() {
      return this.aaaService.findAll() + '222';
    }
}
```
现在版本 2 就走的 AaaV2Controller：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be3257c23fc4f52956cc93a8190c64f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=688&s=71303&e=png&b=fbfbfb)

其他版本走 AaaController：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/473e09b4438e44a483171d7804b91ad8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=748&h=650&s=61604&e=png&b=fafafa)

一般我们就是这样做的，有一个 Controller 标记为 VERSION_NEUTRAL，其他版本的接口放在单独 Controller 里。

注意，controller 之间同样要注意顺序，前面的 controller 先生效：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/023021b745054ed99b8184fa4ebfc9a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1054&h=422&s=101609&e=png&b=1f1f1f)

试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/860fb89a3c8e43f8921e4fffe6ed80e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=538&s=56896&e=png&b=fafafa)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3edf83a92cf5454cb86fb9ec9820c931~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=758&h=572&s=54199&e=png&b=fafafa)

除了用自定义 header 携带版本号，还有别的方式：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ebe215f03746fc84767f688d362f77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=908&h=680&s=124059&e=png&b=1f1f1f)

```javascript
app.enableVersioning({
    type: VersioningType.MEDIA_TYPE,
    key: 'vv='
})
```
MEDIA_TYPE 是在 accept 的 header 里携带版本号：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ff07b6eff24d84b1f463a15159b35e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=876&h=656&s=68634&e=png&b=fbfbfb)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89e5cbf05f164f90b92ef10181241ce0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=878&h=652&s=67990&e=png&b=fbfbfb)

你也可以用 URI 的方式：

```javascript
app.enableVersioning({
    type: VersioningType.URI
})
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2862e5a2ccce4c9fb7b4033fa51aaea5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=586&s=55320&e=png&b=fcfcfc)


但是这种方式不支持 VERSION_NEUTRAL，你要指定明确的版本号才可以：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a74148c256fd4ee5a09cd17d5ea1c30c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=694&h=664&s=66147&e=png&b=fcfcfc)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b1954e36140460689f19854d62c1927~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=838&h=528&s=113934&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ce8e4c765354d06a654225b02a8106c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=820&h=566&s=55477&e=png&b=fbfbfb)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf2075b1dca3440a9b7da62add45e185~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=564&s=51386&e=png&b=fafafa)

此外，如果觉得这些指定版本号的方式都不满足需求，可以自己写：

```javascript
import { VersioningType } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Request } from 'express';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const extractor = (request: Request)=> {
    if(request.headers['disable-custom']) {
      return '';
    }
    return request.url.includes('guang') ? '2' : '1';
  }

  app.enableVersioning({
    type: VersioningType.CUSTOM,
    extractor
  })

  await app.listen(3000);
}

bootstrap();
```
我们自己实现了一个版本号的逻辑，如果 url 里包含 guang，就返回版本 2 的接口，否则返回版本 1 的。

此外，如果有 disable-custom 的 header 就返回 404。

试一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c67fc216cb0945f995bdf277e1e320be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=782&h=496&s=46961&e=png&b=fafafa)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db6ff09759d545c5b4d6f1cb62d1c61c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=718&h=482&s=42144&e=png&b=fbfbfb)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f8f5eca724f4f4bb4102c5488829f28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=830&h=604&s=66267&e=png&b=fbfbfb)

这样，就能实现各种灵活的版本号规则。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/version-test)。
## 总结

今天我们学了如何开发一个接口的多个版本。

Nest 内置了这个功能，同一个路由，指定不同版本号就可以调用不同的接口。

只要在 main.ts 里调用 enableVersioning 即可。

有 URI、HEADER、MEDIA_TYPE、CUSTOM 四种指定版本号的方式。

HEADER 和 MEDIA_TYPE 都是在 header 里置顶，URI 是在 url 里置顶，而 CUSTOM 是自定义版本号规则。

可以在 @Controller 通过 version 指定版本号，或者在 handler 上通过 @Version 指定版本号。

如果指定为 VERSION_NEUTRAL 则是匹配任何版本号（URI 的方式不支持这个）。

这样，当你需要开发同一个接口的多个版本的时候，就可以用这些内置的功能。


## 24.Express 如何使用 multer 实现文件上传

Nest 的文件上传是基于 Express 的中间件 multer 实现的，所以在学习 Nest 文件上传之前，我们先学习下 multer 包的使用。

新建目录，npm init -y 创建 package.json

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0171b52c789d41daa7cadf185fd358c8~tplv-k3u1fbpfcp-watermark.image?)

然后安装 express 和 multer 还有 cors 包：

    npm install express multer cors

这个 cors 包是处理跨域 header 的。

然后创建 index.js，输入如下内容：

```javascript
const express = require('express')
const multer  = require('multer')
const cors = require('cors');

const app = express()
app.use(cors());

const upload = multer({ dest: 'uploads/' })

app.post('/aaa', upload.single('aaa'), function (req, res, next) {
  console.log('req.file', req.file);
  console.log('req.body', req.body);
})

app.listen(3333);
```

app.use 使用中间件 cors 来处理跨域。

用 multer 处理文件上传，指定保存目录为 uploads/。

然后新建这样一个 index.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file"/>
    <script>
        const fileInput = document.querySelector('#fileInput');

        async function formData() {
            const data = new FormData();
            data.set('name','光');
            data.set('age', 20);
            data.set('aaa', fileInput.files[0]);

            const res = await axios.post('http://localhost:3333/aaa', data);
            console.log(res);
        }

        fileInput.onchange = formData;
    </script>
</body>
</html>
```

通过 FormData + axios 上传文件，指定内容的传输格式 content-type 为 multipart/form-data。

（这里 axios 会自动根据内容指定 content-type，不需要手动指定）

然后用 node 把 server 跑起来，并且用 http-server 把静态服务跑起来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2254517fd534b26b35518a73322501e~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c2e1f251cb482281e3da9b9b68cdae~tplv-k3u1fbpfcp-watermark.image?)

这时候在 devtools 可以看到 aaa 请求的 body 是多个 boundary 分隔的格式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4081f20c201849e3ac9a2e27e4e461dc~tplv-k3u1fbpfcp-watermark.image?)

而分隔符是在 Content-Type 指定的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76cefb7b228543e29e1702c2ac70044f~tplv-k3u1fbpfcp-watermark.image?)

这就是 form-data 的传输格式。

然后去服务端看看：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45b415b776c847dc83aebe63aa0af640~tplv-k3u1fbpfcp-watermark.image?)

req.file 可以拿到文件字段，其余非文件字段在 req.body。

并且服务端多了 uploads 目录，下面就保存着我们上传的文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd8495f65bbb440a837a20c48dff6406~tplv-k3u1fbpfcp-watermark.image?)

单文件上传我们会了，那多文件上传呢？

再添加一个路由处理多文件的上传：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78939177ca454a5facc19afae0b432e7~tplv-k3u1fbpfcp-watermark.image?)

bbb 路由通过 array 方法来取上传的文件，并且指定最大数量的限制。

上传的文件通过 req.files 来取。

然后前端这样传：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file" multiple/>
    <script>
        const fileInput = document.querySelector('#fileInput');

        async function formData2() {
            const data = new FormData();
            data.set('name','光');
            data.set('age', 20);
            [...fileInput.files].forEach(item => {
                data.append('bbb', item)
            })

            const res = await axios.post('http://localhost:3333/bbb', data);
            console.log(res);
        }

        fileInput.onchange = formData2;
    </script>
</body>
</html>
```

input 标签添加 multiple 属性允许多选。

onchange 的时候取出每个 file，通过 append 方法添加到 bbb 字段。

（这里fileInput.files 是一个伪数组，要转成数组才能用 forEach 方法）

这样 bbb 实际上就保存着上传的多个文件了。

我们传下试试：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0eeb79f63a32459880387fdd77e175ff~tplv-k3u1fbpfcp-watermark.image?)

node 服务的 req.files 接收到了多个文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/635b42c3666449f98fe5b103e4ee1ff6~tplv-k3u1fbpfcp-watermark.image?)

并且 uploads 目录下也多了俩文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f54d762ec9f4859bf11167704a90f50~tplv-k3u1fbpfcp-watermark.image?)

这就是多文件上传。

那如果传了超过 2 个文件呢？

会报错。

我们添加一个错误处理中间件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9e8b6172d2d4091bc99faad4a24d57b~tplv-k3u1fbpfcp-watermark.image?)

在 express 里，约定有 4 个参数的中间件为错误处理中间件。

一旦某个中间件出了错，express 就会向后找错误处理中间件来调用，如果没有，那就用默认错误处理中间件，返回 500 响应。

我们多传几个文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21a96c36e954a19b4e8aba780e803e5~tplv-k3u1fbpfcp-watermark.image?)

可以看到服务端打印了报错：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87026b0af4f54654800da3e49f36c3b7~tplv-k3u1fbpfcp-watermark.image?)

这样我们只要返回对应的响应就好了：

```javascript
app.post('/bbb', upload.array('bbb', 2), function (req, res, next) {
    console.log('req.files', req.files);
    console.log('req.body', req.body);
}, function(err, req, res, next) {
    if(err instanceof MulterError && err.code === 'LIMIT_UNEXPECTED_FILE') {
        res.status(400).end('Too many files uploaded');
    }
})
```

这样再次上传超过 2 个文件，就会收到服务端的 400 的响应，提示文件上传过多：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ef28fb2f5f5442bb741575986bd3058~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e92ab5dca01c43e08a3671dbac4c4657~tplv-k3u1fbpfcp-watermark.image?)

更复杂一点的情况，如果多个字段都会上传文件，而且限制也都不同呢？

那可以这样处理：

```javascript
app.post('/ccc', upload.fields([
    { name: 'aaa', maxCount: 3 },
    { name: 'bbb', maxCount: 2 }
]), function (req, res, next) {
    console.log('req.files', req.files);
    console.log('req.body', req.body);
})
```

通过 fields 方法指定每个字段的名字和最大数量，然后接收到请求后通过 req.files\['xxx'] 来取对应的文件信息。

其他非文件字段，同样是通过 req.body 来取。

前端写下对应的代码：

```javascript
async function formData3() {
    const data = new FormData();
    data.set('name','光');
    data.set('age', 20);
    data.append('aaa', fileInput.files[0]);
    data.append('aaa', fileInput.files[1]);
    data.append('bbb', fileInput.files[2]);
    data.append('bbb', fileInput.files[3]);

    const res = await axios.post('http://localhost:3333/ccc', data);
    console.log(res);
}
```

这里本来要写两个 file input 分别上传 aaa、bbb 的文件，这里为了测试方便简化了下。

浏览器里再次上传：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dde061ac96e409eac92e326c4b8fdbf~tplv-k3u1fbpfcp-watermark.image?)

服务端收到了 aaa 和 bbb 的文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/545c45358f6841898fccbb00027ace25~tplv-k3u1fbpfcp-watermark.image?)

此外，如果我们并不知道有哪些字段是 file 呢？

这时候可以用 any 来接收：

```javascript
app.post('/ddd', upload.any(), function(req, res, next) {
    console.log('req.files', req.files);
    console.log('req.body', req.body);
});
```

改下前端代码，这次设置 aaa、bbb、ccc、ddd 4 个 file 字段：

```javascript
async function formData4() {
    const data = new FormData();
    data.set('name','光');
    data.set('age', 20);
    data.set('aaa', fileInput.files[0]);
    data.set('bbb', fileInput.files[1]);
    data.set('ccc', fileInput.files[2]);
    data.set('ddd', fileInput.files[3]);

    const res = await axios.post('http://localhost:3333/ddd', data);
    console.log(res);
}
```

再次上传 4 个文件，可以看到服务端接收到了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6c68ba82f34c05b826e2246a603540~tplv-k3u1fbpfcp-watermark.image?)

只不过这时候不是 key、value 的形式了，需要自己遍历数组来查找。

还有一个问题，如何修改保存的文件名呢？

之前是通过 dest 指定了保存的目录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6661ecc1f35447398aa9a1518eef622c~tplv-k3u1fbpfcp-watermark.image?)

现在这样写：

```javascript
const fs = require('fs');
const path = require('path');

const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        try {
            fs.mkdirSync(path.join(process.cwd(), 'my-uploads'));
        }catch(e) {}
        cb(null, path.join(process.cwd(), 'my-uploads'))
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9) + '-' + file.originalname
        cb(null, file.fieldname + '-' + uniqueSuffix)
    }
});
```

自己指定怎么存储，multer.distkStorage 是磁盘存储，通过 destination、filename 的参数分别指定保存的目录和文件名。

这里要先创建下用到的目录，然后再返回它的路径。

file 对象就是之前打印的那种：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/075b0caa35b2429598617db296a744a7~tplv-k3u1fbpfcp-watermark.image?)

我们用时间戳 Date.now() 加上Math.random() 乘以 10 的 9 次方，然后取整，之后加上原来的文件名。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/109991d821854b7c970febb679424292~tplv-k3u1fbpfcp-watermark.image?)

然后浏览器再次上传：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d3778bdd0c94564b3688e66fb3285ea~tplv-k3u1fbpfcp-watermark.image?)

就可以看到目录和文件名都修改了：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c672b4cf3d2f4db384c031062d91f8ca~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/multer-test)。

## 总结

express 的 multer 包是用来处理 multipart/form-data 格式的文件上传请求的。

通过 single 方法处理单个字段的单个文件，array 方法处理单个字段的多个文件，fields 方法处理多个字段的文件，any 处理任意数量字段的文件，分别用 req.file 和 req.files 来取解析出的文件。

其余非文件字段不会处理，还是通过 req.body 来取。

类似文件数量过多等错误，会抛出对应的 error 对象，在错误处理中间件里处理并返回对应的响应就好了。

Nest 的文件上传就是通过 multer 包实现的，下节我们来学下 Nest 里怎么使用 multer。


## 25.Nest 如何使用 multer 实现文件上传

上节我们学了在 Express 里用 multer 包处理 multipart/form-data 类型的请求中的 file。

单个、多个字段的单个、多个 file 都能轻松取出来。

那在 Nest 里怎么用呢？

我们新建个 nest 项目来试试：

```
nest new nest-multer-upload -p npm
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/882bb2b261dc498e9c86eac064e9b71d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=928&h=658&s=268268&e=png&b=010101)

还需要安装下 multer 的 ts 类型的包：
```
npm install -D @types/multer
```
在 AppController 添加这样一个 handler：

```javascript
@Post('aaa')
@UseInterceptors(FileInterceptor('aaa', {
    dest: 'uploads'
}))
uploadFile(@UploadedFile() file: Express.Multer.File, @Body() body) {
    console.log('body', body);
    console.log('file', file);
}
```

使用 FileInterceptor 来提取 aaa 字段，然后通过 UploadedFile 装饰器把它作为参数传入。

用 npm run start:dev 把服务跑起来，一保存，就可以看到这个目录被创建了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c4eb5949e5c4db58be3a5e609a9cfec~tplv-k3u1fbpfcp-watermark.image?)

然后来写前端代码。

之前我们用过这种方式：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753d11400bb24de990c88aed2747e5b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1102&h=434&s=101648&e=png&b=1f1f1f)

就是让 nest 服务支持静态文件的访问。

现在我们换种方式，让 nest 服务支持跨域，再单独跑个 http-server 来提供静态服务：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/880bed6b418146429c3ffefcf9fd122d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79133c8d30e24ac697a70f77a89beade~tplv-k3u1fbpfcp-watermark.image?)

在根目录创建 index.html，前端代码和之前差不多：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file" multiple/>
    <script>
        const fileInput = document.querySelector('#fileInput');

        async function formData() {
            const data = new FormData();
            data.set('name','光');
            data.set('age', 20);
            data.set('aaa', fileInput.files[0]);

            const res = await axios.post('http://localhost:3000/aaa', data);
            console.log(res);
        }

        fileInput.onchange = formData;
    </script>
</body>
</html>
```

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e926c1cac43e4e7582582f3df856bc4b~tplv-k3u1fbpfcp-watermark.image?)

服务端就打印了 file 对象，并且文件也保存到了 uploads 目录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7c34f46db274df6bc550055de2135ae~tplv-k3u1fbpfcp-watermark.image?)

其他字段通过 @Body 装饰器获取。

再来试下多文件上传：

```javascript
@Post('bbb')
@UseInterceptors(FilesInterceptor('bbb', 3, {
    dest: 'uploads'
}))
uploadFiles(@UploadedFiles() files: Array<Express.Multer.File>, @Body() body) {
    console.log('body', body);
    console.log('files', files);
}
```

把 FileInterceptor 换成 FilesInterceptor，把 UploadedFile 换成 UploadedFiles，都是多加一个 s。

然后写下前端代码：

```javascript
async function formData2() {
    const data = new FormData();
    data.set('name','光');
    data.set('age', 20);
    [...fileInput.files].forEach(item => {
        data.append('bbb', item)
    })

    const res = await axios.post('http://localhost:3000/bbb', data, {
        headers: { 'content-type': 'multipart/form-data' }
    });
    console.log(res);
}
```

这样就可以上传多文件了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94658887fadf4555ad96831b807e7161~tplv-k3u1fbpfcp-watermark.image?)

那如果有多个文件的字段呢？

和 multer 里类似，使用这种方式来指定：

```javascript
@Post('ccc')
@UseInterceptors(FileFieldsInterceptor([
    { name: 'aaa', maxCount: 2 },
    { name: 'bbb', maxCount: 3 },
], {
    dest: 'uploads'
}))
uploadFileFields(@UploadedFiles() files: { aaa?: Express.Multer.File[], bbb?: Express.Multer.File[] }, @Body() body) {
    console.log('body', body);
    console.log('files', files);
}
```

然后前端代码这样写：

```javascript
async function formData3() {
    const data = new FormData();
    data.set('name','光');
    data.set('age', 20);
    data.append('aaa', fileInput.files[0]);
    data.append('aaa', fileInput.files[1]);
    data.append('bbb', fileInput.files[2]);
    data.append('bbb', fileInput.files[3]);

    const res = await axios.post('http://localhost:3000/ccc', data);
    console.log(res);
}
```

这里应该用两个 file input 来分别上传 aaa 和 bbb 对应的文件，我这里为了测试方便就简化了下。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/205af2332049409c99314f874019dcca~tplv-k3u1fbpfcp-watermark.image?)

后端收到了上传的 aaa、bbb 的文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a613787305044330a21da8819748e3a1~tplv-k3u1fbpfcp-watermark.image?)

那如果并不知道有哪些字段是 file 呢？

这时可以用 AnyFilesInterceptor：

```javascript
@Post('ddd')
@UseInterceptors(AnyFilesInterceptor({
    dest: 'uploads'
}))
uploadAnyFiles(@UploadedFiles() files: Array<Express.Multer.File>, @Body() body) {
    console.log('body', body);
    console.log('files', files);
}
```

然后写下前端代码：

```javascript
async function formData4() {
    const data = new FormData();
    data.set('name','光');
    data.set('age', 20);
    data.set('aaa', fileInput.files[0]);
    data.set('bbb', fileInput.files[1]);
    data.set('ccc', fileInput.files[2]);
    data.set('ddd', fileInput.files[3]);

    const res = await axios.post('http://localhost:3000/ddd', data);
    console.log(res);
}
```

同样识别出了所有 file 字段：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb670f0f7c74247ae5d28ed67ba3b22~tplv-k3u1fbpfcp-watermark.image?)

这就是 Nest 上传文件的方式。

而且你也同样可以指定 storage：

```javascript
import * as multer from "multer";
import * as fs from 'fs';
import * as path from "path";

const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        try {
            fs.mkdirSync(path.join(process.cwd(), 'my-uploads'));
        }catch(e) {}

        cb(null, path.join(process.cwd(), 'my-uploads'))
    },
    filename: function (req, file, cb) {
        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9) + '-' + file.originalname
        cb(null, file.fieldname + '-' + uniqueSuffix)
    }
});

export { storage };
```

把我们之前写的这个 storage 拿过来，在 controller 里用一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a9c49812e6347ea85448ef02c47ecf6~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b18c4423b6f944588a6ed526493d98d0~tplv-k3u1fbpfcp-watermark.image?)
为什么 Nest 上传文件的方式和直接使用 multer 这么像呢？

因为它就是对 multer 做了一层简单的封装呀。

比如在 multer 里我们是通过 single 方法来处理单个 file 的字段：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f7d2696cf74b92bc7717cb97e56b54~tplv-k3u1fbpfcp-watermark.image?)

在 FileInterceptor 里也是一样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ec1738c231b404f987188d0a889d8d7~tplv-k3u1fbpfcp-watermark.image?)

在 multer 里我们是通过 array 方法来处理多个 file 的字段：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4c8d3a72bf5409b9063e63a4bab4b82~tplv-k3u1fbpfcp-watermark.image?)

在 FilesInterceptor 里也一样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cf97274ab374920ae7ad7cef44c3782~tplv-k3u1fbpfcp-watermark.image?)

另外两个装饰器也是同理：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f718fcfe8b1a40c983afcf6819374eb9~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88bfd8c8b8f54580b58c424d663465eb~tplv-k3u1fbpfcp-watermark.image?)

而 UploadedFile、UploadedFiles 这些装饰器，只是从 request 中取出处理完的 file、files 等属性作为参数传入 handler：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99c9bc9118334a67b02ec3f988e6ea3d~tplv-k3u1fbpfcp-watermark.image?)

了解了这些装饰器的原理之后，回头再来看这些文件上传用的装饰器，是不是就很清晰了呢：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13e71610bb544aa3bfa3660c1e89f588~tplv-k3u1fbpfcp-watermark.image?)

此外，我们还要对上传的文件做一些限制，比如文件大小、类型等，很明显，这部分可以放在 pipe 里做：

比如我们生成一个 pipe：

    nest g pipe file-size-validation-pipe --no-spec --flat

然后添加检查文件大小的逻辑：

```javascript
import { PipeTransform, Injectable, ArgumentMetadata, HttpException, HttpStatus } from '@nestjs/common';

@Injectable()
export class FileSizeValidationPipe implements PipeTransform {
  transform(value: Express.Multer.File, metadata: ArgumentMetadata) {
    if(value.size > 10 * 1024) {
      throw new HttpException('文件大于 10k', HttpStatus.BAD_REQUEST);
    }
    return value;
  }
}
```

大于 10k 就抛出异常，返回 400 的响应。

把它加到 UploadedFile 的参数里：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4192a44fd2bd4116ba72c6f5b84ca935~tplv-k3u1fbpfcp-watermark.image?)

然后访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/503b8d783e364a1d86f4e54dcae7a74a~tplv-k3u1fbpfcp-watermark.image?)

这样就可以实现文件的校验了。

但像文件大小、类型的校验这种逻辑太过常见，Nest 给封装好了，可以直接用：

```javascript
@Post('fff')
@UseInterceptors(FileInterceptor('aaa', {
    dest: 'uploads'
}))
uploadFile3(@UploadedFile(new ParseFilePipe({
    validators: [
      new MaxFileSizeValidator({ maxSize: 1000 }),
      new FileTypeValidator({ fileType: 'image/jpeg' }),
    ],
})) file: Express.Multer.File, @Body() body) {
    console.log('body', body);
    console.log('file', file);
}
```

之前内置的 pipe 还有个没讲，就是这个 ParseFilePipe。

它的作用是调用传入的 validator 来对文件做校验。

比如 MaxFileSizeValidator 是校验文件大小、FileTypeValidator 是校验文件类型。

常用的也就是校验这俩东西。

我们来试试：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3399d79b81e413d8afbeab48e1e9b58~tplv-k3u1fbpfcp-watermark.image?)

可以看到，返回的也是 400 响应，并且 message 说明了具体的错误信息。

而且这个错误信息可以自己修改：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb21c5bd18524ad682bb1963447a1213~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3c9e71974a24148872514e620c68491~tplv-k3u1fbpfcp-watermark.image?)

我们也可以自己实现这样的 validator，只要继承 FileValidator 就可以：

```javascript
import { FileValidator } from "@nestjs/common";

export class MyFileValidator extends FileValidator{
    constructor(options) {
        super(options);
    }

    isValid(file: Express.Multer.File): boolean | Promise<boolean> {
        if(file.size > 10000) {
            return false;
        }
        return true;
    }
    buildErrorMessage(file: Express.Multer.File): string {
        return `文件 ${file.originalname} 大小超出 10k`;
    }
}
```

然后在 controller 用一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe54b13c46c644648d512d1d7a695d51~tplv-k3u1fbpfcp-watermark.image?)

在浏览器上传个文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92f91e62e20429f8385ecfa94f46cbe~tplv-k3u1fbpfcp-watermark.image?)

可以看到我们自定义的 FileValidator 生效了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-multer-upload)。

## 总结

Nest 的文件上传也是基于 multer 实现的，它对 multer api 封装了一层，提供了 FileInterceptor、FilesInterceptor、FileFieldsInterceptor、AnyFilesInterceptor 的拦截器，分别用到了 multer 包的 single、array、fields、any 方法。

它们把文件解析出来，放到 request 的某个属性上，然后再用 @UploadedFile、@UploadedFiles 的装饰器取出来传入 handler。

并且这个过程还可以使用 ParseFilePipe 来做文件的验证，它内置了 MaxFileSizeValidator、FileTypeValidator，你也可以实现自己的 FileValidator。

这就是 Nest 里处理文件上传的方式。

## 26.大文件分片上传

文件上传是常见需求，只要指定 content-type 为 multipart/form-data，内容就会以这种格式被传递到服务端：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f2e069a81ba4d75a7c92f010adfe644~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1440&h=836&s=405486&e=png&b=fdfdfd)

服务端再按照 multipart/form-data 的格式提取数据，就能拿到其中的文件。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e06f7d7e18b04eb5812223cc20025027~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=460&h=604&s=24207&e=png&b=fefbfb)

但当文件很大的时候，事情就变得不一样了。

假设传一个 100M 的文件需要 3 分钟，那传一个 1G 的文件就需要 30 分钟。

这样是能完成功能，但是产品的体验会很不好。

所以大文件上传的场景，需要做专门的优化。

把 1G 的大文件分割成 10 个 100M 的小文件，然后这些文件并行上传，不就快了？

然后等 10 个小文件都传完之后，再发一个请求把这 10 个小文件合并成原来的大文件。

这就是大文件分片上传的方案。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b1015bdc6349238bb7a18b1b2c6095~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=606&h=844&s=53296&e=png&b=fefaf9)

那如何拆分和合并呢？

浏览器里 Blob 有 slice 方法，可以截取某个范围的数据，而 File 就是一种 Blob：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a75a0f31cca4bf98954655488a1b8b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1522&h=686&s=93393&e=png&b=f9f9f9)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b339e52f61984a4dba01e75a5dcc370f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1524&h=244&s=63895&e=png&b=fdfdfd)

所以可以在 input 里选择了 file 之后，通过 slice 对 File 分片。

那合并呢？

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2bce0816bb4e54ac46f363c600aab8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1958&h=1200&s=271917&e=png&b=fefefe)

fs 的 createWriteStream 方法支持指定 start，也就是从什么位置开始写入。

这样把每个分片按照不同位置写入文件里，不就完成合并了么。

思路理清了，接下来我们实现一下。

创建个 Nest 项目：

```javascript
npm install -g @nestjs/cli

nest new large-file-sharding-upload
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50562833c5cb4297998e3803536ab369~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020&h=688&s=176132&e=png&b=010101)

在 AppController 添加一个路由：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fad550c256f04e8bbca80d126271cbfe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1318&h=856&s=192796&e=png&b=1f1f1f)

```javascript
@Post('upload')
@UseInterceptors(FilesInterceptor('files', 20, {
  dest: 'uploads'
}))
uploadFiles(@UploadedFiles() files: Array<Express.Multer.File>, @Body() body) {
  console.log('body', body);
  console.log('files', files);
}
```
这是一个 post 接口，会读取请求体里的 files 文件字段传入该方法。

这里还需要安装用到的 multer 包的类型：

```
npm install -D @types/multer
```

然后我们在网页里试一下：

首先在 main.ts 里开启跨域支持：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80387470962c48f0a0385c50da74dff4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=878&h=402&s=77339&e=png&b=1f1f1f)

然后添加一个 index.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file" multiple/>
    <script>
        const fileInput = document.querySelector('#fileInput');

        fileInput.onchange =  async function () {
            const data = new FormData();
            data.set('name','光');
            data.set('age', 20);

            [...fileInput.files].forEach(item => {
                data.append('files', item)
            })

            const res = await axios.post('http://localhost:3000/upload', data);
            console.log(res);
        }
    </script>
</body>
</html>
```

input 指定 multiple，可以选择多个文件。

选择文件之后，通过 post 请求 upload 接口，携带 FormData。FormData 里保存着 files 和其它字段。

起个静态服务：

```
npx http-server .
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/963cad3215e74adda04408c2e8b18e89~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=614&s=94942&e=png&b=181818)

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4ad8f16478246868e4c5d6a5fb12f0c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=700&h=410&s=26857&e=png&b=fefefe)

选择几个文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/480c15d09dc044659723b175cb8d4fd0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1572&h=1020&s=1136212&e=gif&f=42&b=fdfdfd)

这时候，Nest 服务端就接收到了上传的文件和其他字段：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2171fb3efe294ae384b5ba54ce40e051~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1730&h=1232&s=361371&e=png&b=191919)

当然，我们并不是想上传多个文件，而是一个大文件的多个分片。

所以是这样写：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file"/>
    <script>
        const fileInput = document.querySelector('#fileInput');

        const chunkSize = 20 * 1024;

        fileInput.onchange =  async function () {

            const file = fileInput.files[0];

            console.log(file);

            const chunks = [];
            let startPos = 0;
            while(startPos < file.size) {
                chunks.push(file.slice(startPos, startPos + chunkSize));
                startPos += chunkSize;
            }

            chunks.map((chunk, index) => {
                const data = new FormData();
                data.set('name', file.name + '-' + index)
                data.append('files', chunk);
                axios.post('http://localhost:3000/upload', data);
            })
        
        }

    </script>
</body>
</html>
```

对拿到的文件进行分片，然后单独上传每个分片，分片名字为文件名 + index。

这里我们测试用的图片是 80k：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68fbe48d17cc428497d0483a1405a79e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=564&s=204232&e=png&b=fefefe)

所以每 20k 一个分片，一共是 4 个分片。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43d077a6f685449b9cf5087d3629c3ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606&h=1102&s=1031020&e=gif&f=31&b=fefefe)

服务端接收到了这 4 个分片:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/096df6ae3eeb4508bc83867423fb33a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1306&h=1346&s=315887&e=png&b=181818)

然后我们把它们移动到单独的目录：

```javascript
@Post('upload')
@UseInterceptors(FilesInterceptor('files', 20, {
  dest: 'uploads'
}))
uploadFiles(@UploadedFiles() files: Array<Express.Multer.File>, @Body() body: { name: string }) {
  console.log('body', body);
  console.log('files', files);

  const fileName = body.name.match(/(.+)\-\d+$/)[1];
  const chunkDir = 'uploads/chunks_'+ fileName;

  if(!fs.existsSync(chunkDir)){
    fs.mkdirSync(chunkDir);
  }
  fs.cpSync(files[0].path, chunkDir + '/' + body.name);
  fs.rmSync(files[0].path);
}
```

用正则匹配出文件名：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09835fc0320b4edd9985e61a19ef5b94~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=530&h=100&s=18743&e=png&b=fefdfd)

在 uploads 下创建 chunks_文件名 的目录，把文件复制过去，然后删掉原始文件。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43d077a6f685449b9cf5087d3629c3ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606&h=1102&s=1031020&e=gif&f=31&b=fefefe)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a69d360cd314fa6becb5ad96488f266~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512&h=1198&s=276105&e=png&b=191919)

分片文件移动成功了。

不过直接以 chunks_文件名 做为目录名，太容易冲突了。

我们可以在上传文件的时候给文件名加一个随机的字符串。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd76b0568f54cf09d779b819fbd220c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=900&s=176091&e=png&b=1f1f1f)

这样就不会冲突了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d0870734f674c8990672228814432e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=486&h=416&s=40728&e=png&b=181818)

接下来，就是在全部分片上传完之后，发送合并分片的请求。

添加一个 merge 的接口：

```javascript
@Get('merge')
merge(@Query('name') name: string) {
    const chunkDir = 'uploads/chunks_'+ name;

    const files = fs.readdirSync(chunkDir);

    let startPos = 0;
    files.map(file => {
      const filePath = chunkDir + '/' + file;
      const stream = fs.createReadStream(filePath);
      stream.pipe(fs.createWriteStream('uploads/' + name, {
        start: startPos
      }))

      startPos += fs.statSync(filePath).size;
    })
}
```
接收文件名，然后查找对应的 chunks 目录，把下面的文件读取出来，按照不同的 start 位置写入到同一个文件里。

浏览器访问下这个接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3105597f454d4cf1baff08949c6016ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=804&h=220&s=19364&e=png&b=ffffff)

可以看到，合并成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ebc3c0c4a2143cf9a37676f40937415~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1816&h=1050&s=450395&e=png&b=1d1d1d)

再测试一个：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/847eb844a2204e08888d084cdb18bff8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=284&s=23027&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd9e36416e4f4b86ba54303de9936964~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1838&h=1054&s=487249&e=png&b=1d1d1d)

也没啥问题。

然后我们在合并完成之后把 chunks 目录删掉。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/741d40da15414716b4cb07f15390e025~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=814&h=786&s=122018&e=png&b=202020)

```javascript
@Get('merge')
merge(@Query('name') name: string) {
    const chunkDir = 'uploads/chunks_'+ name;

    const files = fs.readdirSync(chunkDir);

    let count = 0;
    let startPos = 0;
    files.map(file => {
      const filePath = chunkDir + '/' + file;
      const stream = fs.createReadStream(filePath);
      stream.pipe(fs.createWriteStream('uploads/' + name, {
        start: startPos
      })).on('finish', () => {
        count ++;

        if(count === files.length) {
          fs.rm(chunkDir, {
            recursive: true
          }, () =>{});
        }
      })

      startPos += fs.statSync(filePath).size;
    });
}
```
然后在前端代码里，当分片全部上传完之后，调用 merge 接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da3ccb6b0bc4b40bc724560618895ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1176&h=918&s=200174&e=png&b=1f1f1f)

```javascript
const tasks = [];
chunks.map((chunk, index) => {
    const data = new FormData();

    data.set('name', randomStr + '_' + file.name + '-' + index)
    data.append('files', chunk);
    tasks.push(axios.post('http://localhost:3000/upload', data));
})
await Promise.all(tasks);
axios.get('http://localhost:3000/merge?name=' + randomStr + '_' + file.name);
```
连起来测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faeb926af8e34efeb7001d020fd6d447~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1802&h=1172&s=2346315&e=gif&f=70&b=181818)

因为文件比较小，开启 network 的 slow 3g 网速来测。

可以看到，分片上传和最后的合并都没问题。

当然，你还可以加一个进度条，这个用 axios 很容易实现：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d535852ecbb24d72bbbf68fec7980269~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1166&h=648&s=114159&e=png&b=f7f7f7)

至此，大文件分片上传就完成了。

案例代码上传里 github：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/large-file-sharding-upload

## 总结

当文件比较大的时候，文件上传会很慢，这时候一般我们会通过分片的方式来优化。

原理就是浏览器里通过 slice 来把文件分成多个分片，并发上传。

服务端把这些分片文件保存在一个目录下。

当所有分片传输完成时，发送一个合并请求，服务端通过 fs.createWriteStream 指定 start 位置，来把这些分片文件写入到同一个文件里，完成合并。

这样，我们就实现了大文件分片上传。


## 27.最完美的 OSS 上传方案

文件上传是常见需求，一般我们不会把文件直接上传到应用服务器，因为单台服务器存储空间是有限的，不好扩展。

我们会用单独的 OSS （Object Storage Service）对象存储服务来上传下载文件。

比如一般会买阿里云的 OSS 服务。

我们本地文件存储是目录-文件的组织方式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42affeadb6d4d7885ba4223fe8b6b49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=656&s=50009&e=png&b=fefdfd)

而 OSS 服务的存储结构是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/883911af24c14b3ca1ca330c965c7f9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1060&h=508&s=37017&e=png&b=ffffff)

一个桶里放一些文件。

阿里云 OSS 的控制台也提到了对象存储没有目录层级结构：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f74c4bc490e4bf684ba8eaac8cc1bf6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1718&h=616&s=115001&e=png&b=ffffff)

但下面明明是支持目录的呀：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/524c8d5b0e73481bb65bf5f6107ba273~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1556&h=626&s=109683&e=png&b=ffffff)

这其实只是模拟实现的。

Object 会存储 id、文件内容、元数据三部分信息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e190a20da341198e36f7e45060d1b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=742&h=356&s=19427&e=png&b=ffffff)

阿里云 OSS 只是用元信息部分模拟实现了目录。

就像打了个 tag 一样，并不是说文件存储在这个 tag 下，只是你可以用这个 tag 来检索文件。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5c7eb8c524c431faef737ff8da4547a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1130&h=214&s=54679&e=png&b=fefefe)

除了对象存储 OSS，阿里云也提供了文件存储和块存储的方式：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/379e9dde7dcf42a5821fc0e1a56bb0df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1954&h=972&s=141741&e=png&b=fcfcfc)

块存储就是把整块磁盘给你用，你需要自己格式化，存储容量有限。

文件存储就是有目录层次结构，你可以上传下载文件，存储容量有限。

对象存储就是 key-value 存储，分布式的方式实现的，存储容量无限。

这些简单了解就行，绝大多数情况下，我们都是用 OSS 对象存储。

我们买个[阿里云的 OSS 服务](https://www.aliyun.com/product/oss)来试试看：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1886a29f4f4b73b79dce222248c8e3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2136&h=1376&s=268874&e=png&b=fefefe)

我买了 40G 的 OSS 国内通用资源包，花了 5 块钱。

然后我们创建个 Bucket（桶）：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01cbf6715b734310b31d6a0c46541f48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1676&h=1336&s=283874&e=png&b=fefcfc)

在北京创建了一个 Bucket，文件就会存储在那里的服务器上。

设置公共读，也就是这些文件大家都可以直接访问。

不然私有的方式，你访问每个文件都要带上一些身份信息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5578d3c2b54a4dad990925895bbd75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1252&h=756&s=210593&e=png&b=fcfcfc)

有的同学说，不是静态文件要在全国各地都能访问到么？存在北京的服务器会不会访问速度慢？

这是 CDN 的活：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab0dead050e4bf6a95649cb1fbe9f28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1222&h=1152&s=332121&e=png&b=fefefe)

接入 CDN 后，访问该域名会走到云服务的 DNS，然后返回一台最近的缓存服务器的地址，这台服务器会从源站拿文件来缓存，之后就不再访问源站。

这里的源站就可以是 OSS 服务。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/771a695efc8e4eec9cd4b7dcf94fd77c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=508&h=353&s=41323&e=png&b=ffffff)

创建 Bucket 之后，我们上传个文件试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4b60227dcaf43b4af792c1a57c3a1b5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1790&h=1120&s=2063115&e=gif&f=57&b=fdfdfd)

上传完之后在文件列表就可以看到这个文件了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c238bdc367a4e7da769111eb8da549b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1838&h=1006&s=991862&e=png&b=8c8c8c)

点开可以看到文件详情，用这个 URL 就可以访问：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1847f935bb84d88bb5c0e972d0d8317~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1430&h=886&s=1013545&e=png&b=d2ddf0)

当然，生产环境下我们不会直接用 OSS 的 URL 访问，而是会开启 CDN，用网站域名访问，最终回源到 OSS 服务：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14f0a1f4a50b4e3aa42b8430e14724f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1560&h=502&s=107054&e=png&b=fafafa)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69d6c8bf283d49edb00484603c3af90b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1564&h=386&s=130373&e=png&b=ffffff)

在控制台里上传很简单，那如果想在代码里上传呢？

官方文档里有示例代码，我们试试看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c11b37e8e564a79a5201e278d934531~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1844&h=1418&s=446776&e=png&b=ffffff)

```
mkdir oss-test
cd oss-test
npm init -y
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed8f43e33e044abba31b1d41eca7cdeb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=836&h=632&s=114551&e=png&b=010101)

安装用到的包：

```
npm install ali-oss
```

写下代码：

```javascript
const OSS = require('ali-oss')

const client = new OSS({
    region: 'oss-cn-beijing',
    bucket: 'guang-333',
    accessKeyId: '',
    accessKeySecret: '',
});

async function put () {
  try {
    const result = await client.put('cat.png', './mao.png');
    console.log(result);
  } catch (e) {
    console.log(e);
  }
}

put();
```
region 在概览里可以看到：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e4a6ba711944197982eb2b59f7bd1bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1684&h=954&s=225030&e=png&b=ffffff)

这里的 accessKeyId 和 acessKeySecret 是什么呢？

本来我们身份认证都是通过用户名密码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a7d6a85fd1b41bebe0e89c6a97d2cea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=742&h=284&s=17801&e=png&b=ffffff)

但这样不够安全，所以我们创建了 accessKey 用来代表身份，用它来做身份认证，就算泄漏了，也不影响别的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83d2b960c3464d3bbadc964c269773cd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=798&h=514&s=33672&e=png&b=ffffff)

我们创建个 accesKey：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2dfa90ffc41454f93a47ff06529f370~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=626&h=796&s=64559&e=png&b=fefefe)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa9d11035ea3457ea12b499c38524878~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=546&s=122069&e=png&b=ffffff)

创建完成后，拿到 accesKeyId 和 accessKeySecret 后运行代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46888772fc6a4cdd80281d51a1e687b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=830&s=154401&e=png&b=181818)

这里的 mao.png 是这样的：


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f74bb88195a476ab386719f243b9f8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=710&s=379430&e=png&b=202020)

在控制台可以看到上传成功了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63cb0a38082d42c7ab1547700c7c7e79~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2018&h=1134&s=536715&e=png&b=8b8a8a)

这就是 OSS 用 api 上传文件的用法。

只是我们刚刚用的 accessKey 不够安全。

打开 accessKey 管理页面的时候就提示了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7be95451e63343ffa32be751c673048d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=382&s=97125&e=png&b=fef4ef)

让我们不要直接用 accessKey，而是创建一个子用户再创建 accessKey。

那我们就创建个子用户：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8cd8632816e44fd902810a432999eb5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1338&h=634&s=124468&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fd4a9e8f3364f2ea9a0df89b94e807d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=970&h=664&s=71789&e=png&b=ffffff)

然后用这个 accessKey 的 id 和 secret 就好了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3904e4e4a73f4a25a6dfc72157c3f2b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1928&h=738&s=135573&e=png&b=fffaf9)

但你直接换上它还不行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69a7a7dc3fe249beadd65d83f41b08a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1342&h=1276&s=271590&e=png&b=1c1c1c)

会提示你 403，没有权限。

需要你授权下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de63b48653b489c87e11e3c302912a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=628&h=784&s=66326&e=png&b=fefefe)

新增一个授权：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b94c98a61f4555b15f6d605f24892e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1130&h=798&s=102716&e=png&b=fefefe)

把 OSS 的管理和读取权限给这个子用户：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b35e139980c148dba0c33b5893e0c17c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1656&h=1352&s=552424&e=png&b=fdfdfd)

然后再试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30acc180379f43b1bae31bd4d2af210b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=1060&s=198897&e=png&b=1b1b1b)

这时候就上传成功了。

回过头来看下，不得不说阿里云在安全这一块设计的就很巧妙。

如果我们直接用用户名密码验证呢：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e45fb9b6fd394448a7643ad7e2223551~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=766&h=214&s=16602&e=png&b=ffffff)

那万一泄漏了不就完蛋了么？

但是如果创建个 accessKey 用它来做身份认证：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e52b9bfec8543378e3714044608f002~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=872&h=542&s=35006&e=png&b=ffffff)

就算泄漏了我也可以禁用啊：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d77ecadb1e14bd881fbec0e32c1ac00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1770&h=416&s=74111&e=png&b=fefefe)

再进一步，直接用这个 accessKey 它是有所有权限的。

我们先创建个 RAM 子用户，再分配给他某些权限，这样就算泄漏了，是不是能做的事情就更少了？

当然就更安全。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc0239504615408d9d0f1fcbb272b168~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=542&s=49523&e=png&b=ffffff)

所以说，阿里云这套 accessKey 和 RAM 子用户的身份认证方式，还是很不错的。

再说回 OSS，一般的文件直接上传就行，涉及到大文件就要分片上传了。

分片上传实现原理是前端常见面试题了，大家都能答上来，上节我们刚实现过。

就是把文件用 slice 方法分成一个个小的片，然后全部上传完之后请求一个接口合并分片。

[阿里云的大文件分片上传](https://help.aliyun.com/zh/oss/user-guide/multipart-upload)也是这样实现的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/896de2622dbf4b5a8f110388f91fee51~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2028&h=1046&s=285258&e=png&b=fefefe)

具体怎么用直接看文档就好了，这里我们就不试了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cf86dfa4a904cfb9268562d6c5069a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1682&h=1120&s=284602&e=png&b=ffffff)

有了 OSS 服务之后，我们上传文件还需要经过应用服务器么？

可以经过也可以不经过。

如果经过应用服务器，那就要客户端上传文件之后，我们在服务里接受文件，上传 OSS：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b363bfe995714131b0f25dea6ad18822~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1302&h=302&s=29501&e=png&b=ffffff)

这样当然是可以的，还能保护 accessKey 不被人窃取。

只是会浪费应用服务器的流量。

那如果不经过呢？

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4a4d64a83884b6c8670c4ed09ccd716~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=514&s=38047&e=png&b=ffffff)

在客户端用 accessKey 把文件传到 OSS，之后把 URL 传给应用服务器就好了。

这样减少了应用服务器的流量消耗，但是增加了 accessKey 暴露的风险。

各有各的坏处。

那有没有啥两全其美的办法呢？

有。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4b44d3c76ae4c1ca38230fd09f5770e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1778&h=936&s=296704&e=png&b=fefefe)

[阿里云的文档](https://help.aliyun.com/zh/oss/user-guide/authorized-third-party-upload)里也提到了这个问题。

它给出的解决方案就是生成一个临时的签名来用。

代码是这样的：

```javascript
const OSS = require('ali-oss')

async function main() {

    const config = {
        region: 'oss-cn-beijing',
        bucket: 'guang-333',
        accessKeyId: 'LTAI5tDemEBPwQkTx65jZCdy',
        accessKeySecret: 'I0vHYOoqIC78lH7A5c5XB1H7Pev7bp',
    }

    const client = new OSS(config);
    
    const date = new Date();
    
    date.setDate(date.getDate() + 1);
    
    const res = client.calculatePostSignature({
        expiration: date.toISOString(),
        conditions: [
            ["content-length-range", 0, 1048576000], //设置上传文件的大小限制。      
        ]
    });
    
    console.log(res);
    
    const location = await client.getBucketLocation();
    
    const host = `http://${config.bucket}.${location.location}.aliyuncs.com`;

    console.log(host);
}

main();

```
上传 OSS 的地址，用的临时 signature 和 policy 都有了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c18ffbe373b74b1da1f08eb0e333efc3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1232&h=252&s=64402&e=png&b=181818)

这些代码不用记，文档里都有：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74c442a1f2de4861b78fe59fea1c77c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1774&h=1150&s=360253&e=png&b=ffffff)

这样就能在网页里用这些来上传文件到 OSS 了：

创建个 index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/axios@1.6.5/dist/axios.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file"/>
    
    <script>
        const fileInput = document.getElementById('fileInput');

        async function getOSSInfo() {
            await '请求应用服务器拿到临时凭证';
            return {
                OSSAccessKeyId: 'LTAI5tDemEBPwQkTx65jZCdy',
                Signature: 'NfXgq/qLIR2/v87j/XC9sjrASOA=',
                policy: 'eyJleHBpcmF0aW9uIjoiMjAyNC0wMS0yMFQwMzoyNjowOC4xMDZaIiwiY29uZGl0aW9ucyI6W1siY29udGVudC1sZW5ndGgtcmFuZ2UiLDAsMTA0ODU3NjAwMF1dfQ==',
                host: 'http://guang-333.oss-cn-beijing.aliyuncs.com'
            }
        }

        fileInput.onchange = async () => {
            const file = fileInput.files[0];

            const ossInfo = await getOSSInfo();


            const formdata = new FormData()
 
            formdata.append('key', file.name);
            formdata.append('OSSAccessKeyId', ossInfo.OSSAccessKeyId)
            formdata.append('policy', ossInfo.policy)
            formdata.append('signature', ossInfo.Signature)
            formdata.append('success_action_status', '200')
            formdata.append('file', file)

            const res = await axios.post(ossInfo.host, formdata);
            if(res.status === 200) {
                
                const img = document.createElement('img');
                img.src = ossInfo.host + '/' + file.name
                document.body.append(img);

                alert('上传成功');
            }
        }
    </script>
</body>
</html>
```

这里 getOSSInfo 应该是请求服务端的接口，拿到刚才我们控制台输出的那些东西。

这里就简化下，直接写死在代码里了。

引入 axios，用这些信息来上传文件。

跑个静态服务器：

```
npx http-server .
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df383c8936814fcf93f8fa388534d143~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=582&s=93425&e=png&b=181818)

这时候你上传文件的时候会提示跨域错误：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4c1a25c88c0455ca25463753fd737ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1562&h=884&s=159518&e=png&b=fefcfc)

我们在控制台开启下跨域：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3b099abe3794369bafd9a412f8afc26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1942&h=1340&s=273036&e=png&b=8b8b8b)

然后再试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0fa91fc6654687b2bd80c841f50477~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1790&h=1120&s=1037999&e=gif&f=40&b=fefefe)

上传成功了！


控制台文件列表也可以看到这个文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/663aaf15d52046ca9f1b438a254d43ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1878&h=1094&s=352599&e=png&b=f8f6f6)

这就是完美的 OSS 上传方案。

服务端用 RAM 子用户的 accessKey 来生成临时签名，然后返回给客户端，客户端用这个来直传文件到 OSS。

因为临时的签名过期时间很短，我们设置的是一天，所以暴露的风险也不大。

这样服务端就根本没有接受文件的压力，只要等客户端上传完之后，带上 URL 就好了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/oss-test)

## 总结

上传文件一般不会直接存在服务器目录下，这样不好扩展，一般我们会用阿里云的 OSS，它会自己做弹性扩展，所以存储空间是无限的。

OSS 对象存储是在一个 bucket 桶下，存放多个文件。

它是用 key-value 存储的，没有目录的概念，阿里云 OSS 的目录只是用元信息来模拟实现的。

我们在测试了在控制台的文件上传，也测试过了 node 里用 ali-oss 包来上传、在网页里直传 OSS 这三种上传方式。

不管在哪里上传，都需要 acessKeyId 和 acessKeySecret。

这个是阿里云的安全策略，因为直接用用户名密码，一旦泄漏就很麻烦，而 acessKey 泄漏了也可以禁用。而且建议用 RAM 子用户的方式生成 accessKey，这样可以最小化权限，进一步减少泄漏的风险。

客户端直传 OSS 的方式不需要消耗服务器的资源，但是会有泄漏 acessKey 的风险，所以一般都是用服务端生成临时的签名等信息，然后用这些信息来上传。

这种方案就是最完美的 OSS 上传方案了。

掌握了这些，就完全足够应对工作中的 OSS 使用了。


## 28.Nest 里如何打印日志？

前面我们都是用 console.log 打印的日志，这样有不少弊端：没有日志的不同级别的区分，不能通过开关控制是否打印等。

其实 Nest 提供了打印日志的 api，这节我们就来学习一下吧。

还是先创建个项目：
```
nest new logger-test -p npm
```
进入目录，执行 nest start --watch 把服务跑起来。

Nest 会打印这些日志：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/749f82a9fc894ac6859f9827b7845c34~tplv-k3u1fbpfcp-watermark.image?)

它也同样提供了打印这种日志的 api。

我们在 AppController 里创建个 logger 对象，使用它的 api 打印日志：

```javascript
import { ConsoleLogger, Controller, Get, Logger } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  private logger = new Logger();

  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    this.logger.debug('aaa', AppController.name);
    this.logger.error('bbb', AppController.name);
    this.logger.log('ccc', AppController.name);
    this.logger.verbose('ddd', AppController.name);
    this.logger.warn('eee', AppController.name);
    
    return this.appService.getHello();
  }
}

```

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f669d2514084ef7894f35bfe92e9439~tplv-k3u1fbpfcp-watermark.image?)

会打印这样的日志：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c24ac2a4e1540fa88fdb51e8b11123d~tplv-k3u1fbpfcp-watermark.image?)

这里的 verbose、debug、log、warn、error 就是日志级别，而 \[] 中的是 context，也就是当前所在的上下文，最后是日志的内容。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ead7a4c67254e3aa20ffe4bd84f1266~tplv-k3u1fbpfcp-watermark.image?)

这个日志是受 Nest 控制的，可以在创建应用的时候指定是否开启：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17ec845196684061a38da9f7daa4e2a6~tplv-k3u1fbpfcp-watermark.image?)

设置 logger 为 false 之后就没有日志了。

你也可以自己决定输出什么级别的日志：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaea63a9c9e04a52854e6a58a5b0bd92~tplv-k3u1fbpfcp-watermark.image?)

此外，你还可以自定义日志打印的方式，定义一个实现 LoggerService 接口的类：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ee54307de014b418c708cd3bf0013e5~tplv-k3u1fbpfcp-watermark.image?)

只要实现 log、warn、error 3 个方法就好了：

```javascript
import { LoggerService, LogLevel } from '@nestjs/common';

export class MyLogger implements LoggerService {
    log(message: string, context: string) {
        console.log(`---log---[${context}]---`, message)
    }

    error(message: string, context: string) {
        console.log(`---error---[${context}]---`, message)
    }

    warn(message: string, context: string) {
        console.log(`---warn---[${context}]---`, message)
    }
}
```

在创建应用时指定这个 logger：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac42f8d90a4f4192b95823d5e5d9c18f~tplv-k3u1fbpfcp-watermark.image?)

然后现在项目启动就是这样了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7079be45489d46c4a3306e4444c77460~tplv-k3u1fbpfcp-watermark.image?)

刷新页面打印的日志是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31f90826822f4a70be7c1c477f8c9a69~tplv-k3u1fbpfcp-watermark.image?)

确实还挺丑的。。

我们只是测试下自定义 Logger。

你也可以不自己实现 LoggerService 的全部方法，而是继承 ConsoleLogger，重写一些方法：

```javascript
import { ConsoleLogger } from '@nestjs/common';

export class MyLogger2 extends ConsoleLogger{
    log(message: string, context: string) {
        console.log(`[${context}]`,message)
    }
}
```

因为 ConsoleLogger 实现了 LoggerService 接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a89634bcb6430dab1b772e1787d4d0~tplv-k3u1fbpfcp-watermark.image?)

这样你没重写的方法就是原来的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f46ab655eca441b8bd02bbab812ff86~tplv-k3u1fbpfcp-watermark.image?)

这就是创建应用时 logger 的 3 种取值：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8720102246e465a8b0dcfcc22ac2028~tplv-k3u1fbpfcp-watermark.image?)

但这样有个问题，没法注入依赖，因为 Logger 是在容器外面，手动 new 的对象。

怎么办呢？

这时候可以这样：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3142d31e9ba74b2ba22691b302ed6c87~tplv-k3u1fbpfcp-watermark.image?)

bufferLogs 就是先不打印日志，把它放到 buffer 缓冲区，直到用 useLogger 指定了 Logger 并且应用初始化完毕。

app.get 就是从容器中取这个类的实例的，我们写一个 Logger 类放到容器里：

```javascript
import { Inject } from '@nestjs/common';
import { ConsoleLogger, Injectable } from '@nestjs/common';
import { AppService } from './app.service';

@Injectable()
export class MyLogger3 extends ConsoleLogger{
    @Inject(AppService)
    private appService: AppService;

    log(message, context) {
        console.log(this.appService.getHello());
        console.log(`[${context}]`, message);
        console.log('--------------')
    }
}
```

添加 @Injectable() 装饰器，代表这是一个 provider，并且要在 Module 里引入：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/060b4c8ba5d94b02a072f6cb4d138f47~tplv-k3u1fbpfcp-watermark.image?)

通过 @Inject 注入 AppService，并在 log 的时候调用。

现在的日志是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10ef3733c2c40649386dc2c89b7adba~tplv-k3u1fbpfcp-watermark.image?)

很明显，logger 里成功注入了 appService 的依赖。

我们可以单独搞一个模块来放 Logger。

    nest g module logger

把这个 Module 设置为全局模块：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637c9632df204d3fa73be21165d5f3f6~tplv-k3u1fbpfcp-watermark.image?)

这样在任何地方都可以注入这个 logger 对象了。

我们创建个新模块：

```
nest g resource aaa 
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4611d105de248558d7c2505d9e80066~tplv-k3u1fbpfcp-watermark.image?)

在这个模块里可以直接注入 MyLogger，不用 imports 那个 Module。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0044702b569b4409a84bd4332d329cbc~tplv-k3u1fbpfcp-watermark.image?)

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d298f6fe65d5497d9be34c896d01a95b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef03de64216c400c872a9e737d25e668~tplv-k3u1fbpfcp-watermark.image?)

可以看到，成功注入了 MyLogger。

或者你也可以声明一个动态模块，每次 imports 的时候配置下：

```javascript
import { DynamicModule, Global, Module } from '@nestjs/common';
import { MyLogger } from './MyLogger';

@Module({})
export class Logger2Module{

    static register(options): DynamicModule {
        return {
            module: Logger2Module,
            providers: [
                MyLogger, 
                {
                    provide: 'LOG_OPTIONS',
                    useValue: options
                }
            ],
            exports: [MyLogger, 'LOG_OPTIONS']
        }
    }
}
```
把传入的 options 作为 provider，在 Logger 里注入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8a3106dfb784d0ab969682dab783ae2~tplv-k3u1fbpfcp-watermark.image?)


![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64739b1d8eb84b85b541eb12e6c60422~tplv-k3u1fbpfcp-watermark.image?)

每次 imports 的时候传入不同的配置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efbe72168bec42788f75c7bbc53fcd01~tplv-k3u1fbpfcp-watermark.image?)

在 AppService 里注入下：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { MyLogger } from './logger2/MyLogger';

@Injectable()
export class AppService {

  @Inject(MyLogger)
  private logger: MyLogger;

  getHello(): string {
    this.logger.log('yyy', AppService.name);
    
    return 'Hello World!';
  }
}

```
浏览器访问 http://localhost:3000 就可以看到 MyLogger 打印的传入的 option：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ffe39b3413d4d07b4d770a0cf5678eb~tplv-k3u1fbpfcp-watermark.image?)

具体是用全局模块还是动态模块，可以根据情况来选择。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/logger-test)。

## 总结

日志打印可以用 Nest 的 Logger，它支持在创建应用的时候指定 logger 是否开启，打印的日志级别，还可以自定义 logger。

自定义 Logger 需要实现 LoggerService 接口，或者继承 ConsoleLogger 然后重写部分方法。

如果想在 Logger 注入一些 provider，就需要创建应用时设置 bufferLogs 为 true，然后用 app.useLogger(app.get(xxxLogger)) 来指定 Logger。

你可以把这个自定义 Logger 封装到全局模块，或者动态模块里。

当然，一般情况下，直接使用 Logger 就可以了。


## 29.为什么 Node 里要用 Winston 打印日志？

Node 里怎么打印日志呢？

有同学说，不也是用 console.log 么。

不，服务端打印日志一般不会用 console.log。

因为 console.log 打印完就没了，而服务端的日志经常要用来排查问题，需要搜索、分析日志内容，所以需要写入文件或者数据库里。

而且打印的日志需要分级别，比如有的是错误的日志，有的只是普通日志，需要能够过滤不同级别的日志。

此外，打印的日志需要带上时间戳，所在的代码位置等信息。

这些都是 console.log 没有的功能。

所以我们一般都会用专门的日志框架来做，比如 winston。

它是 Node 最流行的日志框架，[npm 官网](https://www.npmjs.com/package/winston)上可以看到每周千万级的下载量：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a0d65f5b90548bfaa4c5ac12a888697~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=556&h=604&s=47935&e=png&b=fefefe)

那 winston 都有什么功能？怎么用呢？

我们试试看：

```
mkdir winston-test
cd winston-test
npm init -y
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/642f73bedb39404aaebab2522cd2f7fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=812&h=686&s=127944&e=png&b=000000)

先创建个项目。

安装 winston：

```
npm install --save winston
```
然后写下 index.js

```javascript
import winston from 'winston';

const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.simple(),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ 
            dirname: 'log', filename: 'test.log' 
        }),
    ]
});

logger.info('光光光光光光光光光');
logger.error('东东东东东东东东');
logger.debug(66666666);
```
用 createLogger 创建了 logger 实例，指定 level、format、tranports。

level：打印的日志级别

format：日志格式

transports：日志的传输方式

我们指定了 Console 和 File 两种传输方式。

在 package.json 里指定 type 为 module，也就是所有代码都是 es module 的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e342e670838498b8f1b1a42dc913bed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=530&h=402&s=55987&e=png&b=202020)

这样代码里就可以直接用 import、export 这些语法了。

用 node 跑一下：

```
node index.js
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea61bd0d0cf45e6b0f31ade40551308~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1210&h=564&s=88217&e=png&b=1b1b1b)

可以看到控制台和文件里都有了打印的日志。

再跑一遍：

```
node index.js
```
会在后面追加：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/527f2f4f626948e6bc30fb40e6ae038c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=908&h=338&s=56832&e=png&b=1d1d1d)

那么问题来了，如果所有日志都写在一个文件里，那这个文件最终会不会特别大？

不用担心，winston 支持按照大小自动分割文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4f8daa3082c4ff3a323e2a9c60ecef1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1114&h=642&s=119756&e=png&b=1f1f1f)

我们指定 maxsize 为 1024 字节，也就是 1kb。

然后再跑几次：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b0e054204ef45438c81d714c76c0515~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1132&h=1148&s=223224&e=png&b=1a1a1a)

大概跑了 10 次左右，出现了第二个文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3d388d3363547be863123c531bdba92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=910&h=332&s=59599&e=png&b=1e1e1e)

而这时第一个日志文件刚好是 1kb：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec72c1f41154446827eaa063bd5435e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=926&h=596&s=67453&e=png&b=fefefe)

这就是根据大小自动分割日志文件的功能。

有同学说，一般日志都是按照日期自动分割的，比如 2023-10-28 的日志文件，2023-10-29 的日志文件，这样之后也好管理。

这个支持么？

当然支持，但是要换别的 Transport 了。

在 [winston 文档](https://github.com/winstonjs/winston/blob/HEAD/docs/transports.md#winston-core)里可以看到有很多 Transport：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5db55345e24f0bb77ddc3c37d37ba3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864&h=1016&s=106987&e=png&b=ffffff)

Console、File、Http、Stream 这几个 Transport 是内置的。

下面还有很多社区的 Transport，比如 MongoDB 的 Transport，很明显就是把日志写入 mongodb 的。

这里的 DailyRotateFile 就是按照日期滚动存储到日志文件的 Transport。

我们试试看：

```
npm install --save winston-daily-rotate-file
```
安装这个 Transport。

然后改下代码：

```javascript
import winston from 'winston';
import 'winston-daily-rotate-file';

const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.simple(),
    transports: [
        new winston.transports.Console(),
        new winston.transports.DailyRotateFile({
            level: 'info',
            dirname: 'log2',
            filename: 'test-%DATE%.log',
            datePattern: 'YYYY-MM-DD-HH-mm',
            maxSize: '1k'
        })
    ]
});

logger.info('光光光光光光光光光');
logger.error('东东东东东东东东');
logger.debug(66666666);
```

这里使用了 DailyRotateFile 的 transport，然后指定了文件名和日期格式。

指定文件名里的日志格式包含分钟，所以不同的分钟打印的日志会写入不同文件里：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f0cb082f31458e988525910787d0fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1182&h=322&s=62610&e=png&b=1e1e1e)

这就达到了滚动日志的效果。

再来试试 http 的 transport：

先创建个 nest 服务：

```
nest new winston-log-server
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d82b3a3bc694cdebed44d65a4a6dcdd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=674&s=284602&e=png&b=010101)

添加一个路由：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9627e64fdb34e36a2bc0ae411bbb06b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=814&h=666&s=117492&e=png&b=1f1f1f)
```javascript
@Post('log')
log(@Body() body) {
    console.log(body);
}
```
把它跑起来：

```
npm run start:dev
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a877b312c1e84825b8ab687f52a80866~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=366&s=122431&e=png&b=181818)

然后改下 index.js

```javascript
import winston from 'winston';
import 'winston-daily-rotate-file';

const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.simple(),
    transports: [
        new winston.transports.Console(),
        new winston.transports.Http({
            host: 'localhost',
            port: '3000',
            path: '/log'
        })
    ]
});

logger.info('光光光光光光光光光');
logger.error('东东东东东东东东');
logger.debug(66666666);
```
使用 http 的 transport 来传输日志。

跑一下：
```
node ./index.js
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78108e221b74dcf81e7551f990e49b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=542&h=164&s=23391&e=png&b=191919)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b39035003c343b7a6d31e89a3a6576c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=830&h=512&s=111820&e=png&b=181818)

nest 服务收到了传过来的日志。

基本上，内置的和社区的 transport 就足够用了，不管是想把日志发送到别的服务，还是把日志存到数据库等，都可以用不同 Transport 实现。

这些 transport 可以用 add、remove 方法来动态增删：

```javascript
import winston from 'winston';

const console = new winston.transports.Console();
const file = new winston.transports.File({ filename: 'test.log' });

const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.simple()
});

logger.clear();
logger.add(console);
logger.remove(console);
logger.add(file);

logger.info('光光光光光光光光光');
logger.error('东东东东东东东东');
logger.debug(66666666);
```
比如我先 clear，然后动态添加又删除了 console，然后又添加了一个 file 的 transport。

效果就是只有一个 file 的 transport：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e4a9ad955fb498182bda9231b0dd581~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082&h=684&s=92309&e=png&b=1c1c1c)

再就是日志级别，winston 有 6 种级别的日志：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5577d07cbe21459f9b4fffcba5443e7b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=472&h=486&s=30770&e=png&b=f7f7f7)

从上往下，重要程度依次降低。

比如当你指定 level 是 info 时，那 info、warn、error 的日志会输出，而 http、debug 这些不会。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65d7eba57be74bb4a295117aa74a0b89~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=826&h=608&s=91608&e=png&b=1d1d1d)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f5993e89a44ae08d6d38512d7a62f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=858&h=702&s=105645&e=png&b=1d1d1d)

日志级别的功能虽然简单，但却是很实用的功能。

日志可以通过 format 指定格式：

simple：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8399f03b559e4d35ab022d17bec48d48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=744&s=114721&e=png&b=1d1d1d)

json：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1a86f51a19b4aedb73ca853a4d49b7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=794&h=718&s=120569&e=png&b=1d1d1d)

prettyPrint（比 json 的格式多了一些空格）：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eff507e4696e453eaa6f10d272bf2bc4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=792&s=131623&e=png&b=1d1d1d)

用 combine 组合 timestamp 和 json：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9740fb3f13414789884fb2d615676d25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1296&h=742&s=149315&e=png&b=1d1d1d)

或者再组合个 label：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f453f0e45de044509a7de965edefdd15~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1488&h=626&s=142403&e=png&b=1d1d1d)

加上个标签，再搜索相关日志就方便多了。

彩色：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e3762babce4aa681dc2d132b825ee5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=698&s=113226&e=png&b=1d1d1d)

通过这些，就可以指定各种日志格式。

但现在有个问题，如果我不同的 transport 要指定不同的格式呢？

可以这样：

```javascript
import winston from 'winston';

const logger = winston.createLogger({
    level: 'debug',
    transports: [
        new winston.transports.Console({
            format: winston.format.combine(
                winston.format.colorize(),
                winston.format.simple()
            ),
        }),
        new winston.transports.File({ 
            dirname: 'log3',
            filename: 'test.log',
            format: winston.format.json()
        }),
    ]
});

logger.info('光光光光光光光光光');
logger.error('东东东东东东东东');
logger.debug(66666666);
```

每个 transport 单独指定 format 就好了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ba9e0e9c4ac47a5a1563c3bc2e6dce1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=514&h=160&s=22739&e=png&b=181818)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50cea20a3307415c8ba1369094ead62b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1190&h=210&s=50227&e=png&b=1e1e1e)

那如果我有的日志只想 console，而有的日志希望写入文件，而且配置都不同呢？

我们可以创建多个 logger 实例，每个 logger 实例有不同的 format、transport、level 等配置：

```javascript
import winston from 'winston';

winston.loggers.add('console', {
    format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
    ),
    transports: [
        new winston.transports.Console()
    ]
});

winston.loggers.add('file', {
    format:winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.File({
            dirname: 'log4',
            filename: 'test.log',
            format: winston.format.json()
        })
    ]
});


const logger1 = winston.loggers.get('console');

logger1.info('aaaaa');
logger1.error('bbbbb');

const logger2 = winston.loggers.get('file');

logger2.info('xxxx');
logger2.info('yyyy');
```
我们创建了 2 个 logger 实例，其中一个只写入 console，另一个只写入 file，并且 format 都不同。

然后分别用不同的 logger 来打印日志。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee8252d81b5b4d6fbacdaa32eded9861~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=386&h=148&s=18845&e=png&b=181818)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb3fa4aba52e4e54bb7059e8317c89cb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=214&s=45557&e=png&b=1f1f1f)

这样，项目中有不同的日志需求的时候，就可以创建多个 logger 实例。

此外，winston 还支持指定如何处理未捕获的错误的日志：

```javascript
import winston from 'winston';

const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.simple(),
    transports: [
        new winston.transports.Console()
    ],
    exceptionHandlers: [
        new winston.transports.File({
            filename: 'error.log'
        })
    ]
});

throw new Error('xxx');

logger.info('光光光光光光光光光');
logger.error('东东东东东东东东');
logger.debug(66666666);
```
跑一下，可以看到错误日志被输出到了 error.log

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05be437a9ab24732a2c04d0b57e8bd5d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=246&s=52553&e=png&b=1f1f1f)

除了 error 外，Promise 的未捕获异常也可以指定如何处理日志：

```javascript
import winston from 'winston';

const logger = winston.createLogger({
    level: 'debug',
    format: winston.format.simple(),
    transports: [
        new winston.transports.Console()
    ],
    rejectionHandlers: [
        new winston.transports.File({
            filename: 'rejection.log'
        })
    ]
});

(async function(){
    throw Error('yyy');
})();

logger.info('光光光光光光光光光');
logger.error('东东东东东东东东');
logger.debug(66666666);
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ec5aff43824a1ba3df19fefa42aca6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1238&h=268&s=66666&e=png&b=1f1f1f)

这些就是 winston 的主要功能了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/winston-test)。

## 总结

Node 服务端我们不会用 console.log 打印日志，而是会用日志框架，比如 winston。

winston 支持 tranport 配置，可以把日志传输到 console、file、通过 http 发送到别的服务，写入 mongodb 数据库等。

社区有很多 transport 可用，我们尝试了滚动日志的 transport，可以根据日期来自动分割日志文件。

winston 还支持 level 配置，可以根据级别来过滤日志。

而且还支持 format 的设置，比如 json、simple、label、timstamp 等，一般我们输出到文件里的都是 json 格式，并且给他加上时间戳和 label，这样方便之后分析。

每个 transport 都可以单独指定 format，而且还可以创建多个 logger，每个 logger 用不同的配置。

此外，winston 还支持指定未捕获的 error 的日志怎么处理。

总之，相比直接 console.log，用 winston 这样的灵活强大的日志框架可太香了。


## 3.快速掌握 Nest CLI

项目开发离不开工程化的部分，比如创建项目、编译构建、开发时 watch 文件变动自动构建等。

Nest 项目自然也是这样，所以它在 @nestjs/cli 这个包里提供了 nest 命令。

可以直接 npx 执行，npm 会把它下载下来然后执行：

```
npx @nestjs/cli new 项目名
```

也可以安装到全局，然后执行，更推荐这种：

```
npm install -g @nestjs/cli

nest new 项目名
```
不过后者要时不时升级下版本，不然可能用它创建的项目版本不是最新的：

```
npm update -g @nestjs/cli
```
那 nest 都提供了啥命令呢？

nest -h 看看:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5825f0b71ed243ccaff39c6d5010110d~tplv-k3u1fbpfcp-watermark.image?)

有创建新项目的 nest new，有生成某些代码的 nest generate，还有编译构建的 nest build，开发模式的 nest start 等。

分别看一下：

## nest new

nest new 我们用过，就是创建一个新的 nest 项目的。

它有这么几个选项：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b94ca38aaef4d13acb999234c0ea3df~tplv-k3u1fbpfcp-watermark.image?)

--skip-git 和 --skip-install 很容易理解，就是跳过 git 的初始化，跳过 npm install。

--package-manager 是指定包管理器的，之前创建项目的时候会让我们选择：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74fe9a9c3c77465c904b587574c128ed~tplv-k3u1fbpfcp-watermark.image)

指定之后，就跳过包管理器选择这步了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33871e97763d4ddc983f0a36099164c5~tplv-k3u1fbpfcp-watermark.image?)

--language 可以指定 typescript 和 javascript，一般我们都选择 ts，用默认的就好。

--strict 是指定 ts 的编译选项是否开启严格模式的，也就是这么 5 个选项：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e004a861e0146fd8b2b48c7d954a744~tplv-k3u1fbpfcp-watermark.image?)

默认是 false，也可以指定为 true：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e7c8a78c688481695933d04055634b4~tplv-k3u1fbpfcp-watermark.image?)

这个之后需要的话再改就行。

## nest generate'

nest 命令除了可以生成整个项目外，还可以生成一些别的代码，比如 controller、service、module 等。

比如生成 module：

```
nest generate module aaa
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ffdcbbd08fc4d048b59a860b55b4312~tplv-k3u1fbpfcp-watermark.image?)

它会生成 module 的代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14fdef17ae594e62b25623a4254a34d8~tplv-k3u1fbpfcp-watermark.image?)

还会自动在 AppModule 里引入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/357fecc074a540eeb6e4f70a1b5f5471~tplv-k3u1fbpfcp-watermark.image?)

当然你也可以生成 controller、service 等代码：

```
nest generate controller aaa
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4ffe08e5ee40a792f3ca7927bcca16~tplv-k3u1fbpfcp-watermark.image?)

同样，它也会更新到 module 的依赖里去。

生成 service 也是一样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1545c50932654314b02f35e4f9dac3be~tplv-k3u1fbpfcp-watermark.image?)

当然，如果是要完整生成一个模块的代码，不需要一个个生成，可以用 

```
nest generate resource xxx
```
它会让你选择是哪种代码，因为 nest 支持 http、websocket、graphql、tcp 等，这里我们选择 http 的 REST 风格 api：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1480b030b48b4517b9ee38e8bda06e81~tplv-k3u1fbpfcp-watermark.image?)

然后会让你选择是否生成 CRUD 代码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90edc9b8005547cb9d7c6e10e8f2b73a~tplv-k3u1fbpfcp-watermark.image?)

选择是。

然后就会生成整个模块的 CRUD + REST api 的代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94ebae465ba94991a154ffe7652b3557~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d1c3305fcc647fea46629933fb4432f~tplv-k3u1fbpfcp-watermark.image?)

当然，它同样会自动在 AppModule 引入：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e09b9ac107e840b2883c81764d0dc48d~tplv-k3u1fbpfcp-watermark.image?)

这就是 nest generate，可以快速生成各种代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a33cc387c39b4870b698dbc518a98530~tplv-k3u1fbpfcp-watermark.image?)

这些代码模版的集合是在 @nestjs/schematics 这个包里定义的。

nest new 创建项目的时候有个 --collection 选项，就是配置这个的。

不过一般我们不需要配置。

你可以在 [@nestjs/schematics](https://github.com/nestjs/schematics/tree/master/src/lib) 里看到这些代码模版的定义：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d9109ed36fa4287b05803b841ca5754~tplv-k3u1fbpfcp-watermark.image?)

它的实现原理很简单，就是模版引擎填充变量，打印成代码：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e441a62a8904bb8b4832df6b48508bb~tplv-k3u1fbpfcp-watermark.image?)

nest generate 也有不少选项：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76df459728cd4f69bfede05aec788658~tplv-k3u1fbpfcp-watermark.image?)

--flat 和 --no-flat 是指定是否生成对应目录的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d37577a1f5ef4d9aa7b1ccb4c2502cda~tplv-k3u1fbpfcp-watermark.image?)

--spec 和 --no-spec 是指定是否生成测试文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8f052d8088f41c3a881ab289c551c3e~tplv-k3u1fbpfcp-watermark.image?)

--skip-import 是指定不在 AppModule 里引入：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a635e5d8a0b6494eb59109bfe5e10fce~tplv-k3u1fbpfcp-watermark.image?)

也就是不生成这部分代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef965983632c43b6a314aada5d2e572c~tplv-k3u1fbpfcp-watermark.image?)

至于 --project，这是指定生成代码在哪个子项目的，等之后用到 monorepo 项目的时候再说。

这就是 nest cli 提供的快速生成各种代码的能力，是不是还挺方便的？

## nest build

然后就是 nest build 了，它是用来构建项目的:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe5cb526a5724f3a95a299e51193ff6e~tplv-k3u1fbpfcp-watermark.image?)

执行 nest build，会在 dist 目录下生成编译后的代码。

同样，它也有一些选项：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e74a180fe0f481cbe6d99f38071488e~tplv-k3u1fbpfcp-watermark.image?)

--wepback 和 --tsc 是指定用什么编译，默认是 tsc 编译，也可以切换成 webpack。

这是 tsc 的编译产物：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afac24d943e14446aa9c3d593770b06a~tplv-k3u1fbpfcp-watermark.image?)

这是 webpack 的编译产物：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/706b166b0afc4fc18a6af653f846f63a~tplv-k3u1fbpfcp-watermark.image?)

tsc 不做打包、webpack 会做打包，两种方式都可以。

node 模块本来就不需要打包，但是打包成单模块能提升加载的性能。

--watch 是监听文件变动，自动 build 的。

但是 --watch 默认只是监听 ts、js 文件，加上 --watchAssets 会连别的文件一同监听变化，并输出到 dist 目录，比如 md、yml 等文件。

--path 是指定 tsc 配置文件的路径的。

那 --config 是指定什么配置文件呢？

是 nest cli 的配置文件。

## nest-cli.json

刚刚我们说的那些选项都可以在 nest-cli.json 里配置：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2297cf557e54157961a7e6ee67ee180~tplv-k3u1fbpfcp-watermark.image?)

比如 compilerOptions 里设置 webpack 为 true 就相当于 nest build --webpack，一样的效果：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fad42dc73a404089abbd5f921c43350a~tplv-k3u1fbpfcp-watermark.image?)

webpack 设置为 false 就是用 tsc 了。

deleteOutDir 设置为 true，每次 build 都会都清空 dist 目录。

而 assets 是指定 nest build 的时候，把那些非 js、ts 文件也复制到 dist 目录下。

可以通过 include、exclude 来精确匹配，并且可以单独指定是否 watchAssets。

不过只支持 src 下文件的复制，如果是非 src 下的，可以自己写脚本复制：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4335579ee0a846fdbfc0ef022eed5c8a~tplv-k3u1fbpfcp-watermark.image?)

然后是 generateOptions，这些就和我们 nest generate 时的 --no-spec、--no-flat 一样的效果。

比如我把 flat 设置为 false、spec 设置为 false，那再 generate 代码时就是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb9a3995fd3a47138eb2be3f12169954~tplv-k3u1fbpfcp-watermark.image?)

生成了一层目录，并且没有生成测试文件。

sourceRoot 是指定源码目录。

entryFile 是指定入口文件的名字，默认是 main。

而 $schema 是指定 nest-cli.json 的 schema，也就是可以有哪些属性的：

[https://json.schemastore.org/nest-cli](https://json.schemastore.org/nest-cli)

这是一种 json schema 的规范，还是挺容易看懂的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6afce9b2ea204fd49f1ef2fef2c59312~tplv-k3u1fbpfcp-watermark.image?)

如果想全面了解 nest-cli.json 都有啥属性，可以看看这个 schema 定义。

## nest start

最后，再来看下 nest start 命令：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a6eb5dd0f94712ace4e9db607701a7~tplv-k3u1fbpfcp-watermark.image?)

可以看到每次重新 build 了，并且用 node 把 main.js 跑了起来。

它有这些选项：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c961834fd8124bcb8803a39769f30679~tplv-k3u1fbpfcp-watermark.image?)

--watch 是最常用的选项了，也就是改动文件之后自动重新 build：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e9594f302f4344be3adc4e84af0342~tplv-k3u1fbpfcp-watermark.image?)

--debug 是启动调试的 websocket 服务，用来 debug。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/921f0364a9ef4f5799a7217b0ebef375~tplv-k3u1fbpfcp-watermark.image?)

--exec 可以指定用什么来跑，默认是用 node 跑，你也可以切换别的 runtime。

其余选项和 nest build 一样，就不复述了。

## nest info

最后还有个 nest info 命令，这个就是查看项目信息的，包括系统信息、 node、npm 和依赖版本：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71eaf4f2c4d24447bab2aa00e598c7dc~tplv-k3u1fbpfcp-watermark.image?)

## 总结

nest 在 @nestjs/cli 包里提供了 nest 命令，它可以用来做很多事情：

- 生成项目结构和各种代码
- 编译代码
- 监听文件变动自动编译
- 打印项目依赖信息

也就是这些子命令：

- nest new 快速创建项目
- nest generate 快速生成各种代码
- nest build 使用 tsc 或者 webpack 构建代码
- nest start 启动开发服务，支持 watch 和调试
- nest info 打印 node、npm、nest 包的依赖版本

并且，很多选项都可以在 nest-cli.json 里配置，比如 generateOptions、compilerOptions 等。

学会用 nest cli，是学好 nest 很重要的一步。


## 30.Nest 集成日志框架 Winston

我们学习了 Nest 如何自定义 logger，也学习了 Winston 的使用。

那如何在 Nest 里集成 Winston 呢？

这节我们来实现下。

```
nest new nest-winston-test
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a6ddf416f7847b4a12d9fc2732a0307~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=734&s=179723&e=png&b=020202)

创建个 nest 项目。

在 src 添加一个 MyLogger.ts

```javascript
import { LoggerService, LogLevel } from '@nestjs/common';

export class MyLogger implements LoggerService {
    log(message: string, context: string) {
        console.log(`---log---[${context}]---`, message)
    }

    error(message: string, context: string) {
        console.log(`---error---[${context}]---`, message)
    }

    warn(message: string, context: string) {
        console.log(`---warn---[${context}]---`, message)
    }
}
```
然后在 main.ts 里引入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/832f3c922d9a42ec9c72f4f3e6ae1e15~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=454&s=93386&e=png&b=1f1f1f)

```javascript
app.useLogger(new MyLogger());
```
把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63a4ccef41024896984cc364a8ddae11~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234&h=292&s=71857&e=png&b=181818)

现在的 logger 就换成我们自己的了。

然后在 AppController 里添加 logger：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f85411fb623487294b99ea259f8f329~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126&h=592&s=124574&e=png&b=1f1f1f)

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a60d5d558794fe7b448267881887987~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=622&h=208&s=18157&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/139cd0a1b1dd4178b250a24b12e85164~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=368&s=72573&e=png&b=181818)

这样就完成了 logger 的自定义。

接下来只要换成 winston 的 logger 就好了。

安装 winston：

```
npm install --save  winston
```

然后改下 MyLogger：

```javascript
import { ConsoleLogger, LoggerService, LogLevel } from '@nestjs/common';
import { createLogger, format, Logger, transports } from 'winston';

export class MyLogger implements LoggerService {

    private logger: Logger;

    constructor() {    
        this.logger = createLogger({
            level: 'debug',
            format: format.combine(
                format.colorize(),
                format.simple()
            ),
            transports: [
                new transports.Console()
            ]
        });
    }

    log(message: string, context: string) {
        this.logger.log('info', `[${context}] ${message}`);
    }

    error(message: string, context: string) {
        this.logger.log('error', `[${context}] ${message}`);
    }

    warn(message: string, context: string) {
        this.logger.log('warn', `[${context}] ${message}`);
    }
}
```
把 console.log 换成 winston 的 logger。

再跑下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6d7b41086534c52984e9b820425b72d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1040&h=420&s=97595&e=png&b=191919)

现在的日志就是 winston 的了。

只不过和 nest 原本的日志格式不大一样。

这个简单，我们自己写一下这种格式就好了。

安装 dayjs 格式化日期：

```
npm install --save dayjs
```
安装 chalk 来打印颜色：

```
npm install --save chalk@4
```
注意：这里用的是 chalk 4.x 的版本。

然后来实现下 nest 日志的格式：

```javascript
import { ConsoleLogger, LoggerService, LogLevel } from '@nestjs/common';
import * as chalk from 'chalk';
import * as dayjs from 'dayjs';
import { createLogger, format, Logger, transports } from 'winston';

export class MyLogger implements LoggerService {

    private logger: Logger;

    constructor() {
        super();
    
        this.logger = createLogger({
            level: 'debug',
            transports: [
                new transports.Console({
                    format: format.combine(
                        format.colorize(),
                        format.printf(({context, level, message, time}) => {
                            const appStr = chalk.green(`[NEST]`);
                            const contextStr = chalk.yellow(`[${context}]`);
        
                            return `${appStr} ${time} ${level} ${contextStr} ${message} `;
                        })
                    ),
                })
            ]
        });
    }

    log(message: string, context: string) {
        const time = dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss');

        this.logger.log('info', message, { context, time });
    }

    error(message: string, context: string) {
        const time = dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss');

        this.logger.log('info', message, { context, time });
    }

    warn(message: string, context: string) {
        const time = dayjs(Date.now()).format('YYYY-MM-DD HH:mm:ss');

        this.logger.log('info', message, { context, time });
    }
}
```

这里用到了 printf 的 format 函数，它可以自定义打印的日志格式。

我们用 chalk 加上了颜色，并且打印了 dayjs 格式化的时间。

效果是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5586d8f5b4cd4305bea2797bf2e459de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1338&h=392&s=126132&e=png&b=181818)

是不是和 nest 原本的日志很像了？

然后我们再加一个 File 的 transport。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9db123bf4e974ca7a6e3cb0cf3ce8056~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1378&h=952&s=184712&e=png&b=1f1f1f)

指定为 json 格式，加上时间戳：

```javascript
new transports.File({
    format: format.combine(
        format.timestamp(),
        format.json()
    ),
    filename: '111.log',
    dirname: 'log'
})
```

console 的日志是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a4bb470c244503ac0a6d9cd4cc6dc6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1292&h=372&s=126240&e=png&b=191919)

file 的日志是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb310931904490f8569e929cd5334fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2032&h=274&s=107610&e=png&b=1f1f1f)

这样，我们就完成了 nest 和 winston 的集成。

我们还可以进一步把它封装成一个动态模块。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e3b134ef6834e20af7011c1ddb674f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=110&s=28520&e=png&b=191919)

```javascript
import { DynamicModule, Global, Module } from '@nestjs/common';
import { LoggerOptions, createLogger } from 'winston';
import { MyLogger } from './MyLogger';

export const WINSTON_LOGGER_TOKEN = 'WINSTON_LOGGER';

@Global()
@Module({})
export class WinstonModule {

    public static forRoot(options: LoggerOptions): DynamicModule {    
        return {
            module: WinstonModule,
            providers: [
                {
                    provide: WINSTON_LOGGER_TOKEN,
                    useValue: new MyLogger(options)
                }
            ],
            exports: [
                WINSTON_LOGGER_TOKEN
            ]
        };
      }
}

```

添加 forRoot 方法，接收 winston 的 createLogger 方法的参数，返回动态模块的 providers、exports。

用 useValue 创建 logger 对象作为 provider。

这里的 MyLogger 是之前那个复制过来的，但需要改一下 constructor：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/064e62df7d7549fab47b1074d919548e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1586&h=700&s=206697&e=png&b=1d1d1d)

```javascript
constructor(options) {    
    this.logger = createLogger(options)
}
```
然后在 AppModule 引入下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad440d150d934da7aa711b62dce8e17d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1562&h=1234&s=251865&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { WinstonModule } from './winston/winston.module';
import { transports, format } from 'winston';
import * as chalk from 'chalk';

@Module({
  imports: [WinstonModule.forRoot({
      level: 'debug',
      transports: [
          new transports.Console({
              format: format.combine(
                  format.colorize(),
                  format.printf(({context, level, message, time}) => {
                      const appStr = chalk.green(`[NEST]`);
                      const contextStr = chalk.yellow(`[${context}]`);
  
                      return `${appStr} ${time} ${level} ${contextStr} ${message} `;
                  })
              ),

          }),
          new transports.File({
              format: format.combine(
                  format.timestamp(),
                  format.json()
              ),
              filename: '111.log',
              dirname: 'log'
          })
      ]
  })],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

之后改一下 main.ts 里用的 logger：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42d162c402d144e3b2f7d5f9268ef399~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1092&h=502&s=104732&e=png&b=1f1f1f)

```javascript
app.useLogger(app.get(WINSTON_LOGGER_TOKEN));
```
功能正常：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2241720859204baaaf86b519c85e3273~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1294&h=438&s=129221&e=png&b=181818)

只不过现在就没必要每次都 new 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06cd31d3fde048e199b09f19a550c9f2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074&h=728&s=160802&e=png&b=1f1f1f)

改成 inject 的方式，始终使用同一个实例，性能更好：

```javascript
@Inject(WINSTON_LOGGER_TOKEN)
private logger;
```
案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-winston-test)。
## 总结

这节我们集成了 nest 和 winston。

前面我们学过了如何自定义 Nest 的 logger，现在只要在 Logger 的实现里改成 winston 的 logger 就好了。

只是想要保持 nest 原本日志的格式，需要用 printf 自定义。我们使用 dayjs + chalk 自定义了 winston 的日志格式。

当然，打印到 File 的日志，依然是 json 的。

之后封装了个动态模块，在 forRoot 方法里传入 options，模块内创建 winston 的 logger 实例。并且这个模块声明为全局模块。

这样，在应用的各处都可以注入我们自定义的基于 winston 的 logger 了。


## 31.通过 Desktop 学 Docker 也太简单了

后端系统会部署很多服务，包括我们自己开发的服务，还有 mysql、redis 等中间件的服务，部署它们需要一系列依赖的安装、环境变量的设置等等。

如果你要部署多台机器的话，同样的操作要重复多次，万一哪一步漏掉了，服务就跑不起来了。

就很麻烦。

而 Docker 就能完美解决这个问题：

它把系统的所有文件封装成一个镜像，镜像跑起来作为容器，它可以在一台机器上跑多个容器，每个容器都有独立的操作系统环境，比如文件系统、网络端口等，在容器内跑各种服务。

这样整个环境都保存在这个镜像里，部署多个实例只要通过这个镜像跑多个容器就行。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf8ee80acf09467e9d873455f0ab545a~tplv-k3u1fbpfcp-watermark.image?)

这也是为什么它的 logo 是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a395455ab5941d8af56a0342efda985~tplv-k3u1fbpfcp-watermark.image?)

Docker 提供了 Docker Hub 镜像仓库，可以把本地镜像 push 到仓库或者从仓库 pull 镜像到本地。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f8ed80edf034c44a5f8a5ce4a03315d~tplv-k3u1fbpfcp-watermark.image?)

我们 pull 个镜像下来试试看：

首先需要安装 Docker，直接从[官网](https://docker.com)下载 docker desktop 就行：

（windows 选择 widnows 的安装包。m1 要注意芯片类型，选择 apple chip 那个包）

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08c1060cac544672aeacce19273771f8~tplv-k3u1fbpfcp-watermark.image?)

它内置了 docker 命令。

把它安装到系统之后，可以在命令行看下 docker 命令是否可用：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d84cf0ec2b25421286d57b35dd1a0093~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/019987ca1b804ee68b2e0c442f97ac60~tplv-k3u1fbpfcp-watermark.image?)

如果不可用，那要设置下这个：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef48c389e45347b9a9f133276605c286~tplv-k3u1fbpfcp-watermark.image?)

点击 Settings > Advanced，里面有两种安装路径，如果是 /usr/local/bin，那 docker 命令就是直接可用的，因为这个路径在 PATH 变量里。

如果是第二种，那就需要手动把它加到 PATH 环境变量里。

然后我们来看看 docker desktop 的界面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6edd86d6264b488d918ac95a32d657da~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3601b0d26df3452abbe668a2d35498ef~tplv-k3u1fbpfcp-watermark.image?)

images 是本地的所有镜像，containers 是镜像跑起来的容器。

docker desktop 可以可视化的管理它们，很方便。

我们 pull 一个镜像试试看。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/801a7dc0994a438eb9abfb06ee6c1b9f~tplv-k3u1fbpfcp-watermark.image?)

搜索 nginx 镜像，点击 pull（搜索这步需要翻墙，不然搜不到）。

pull 下来之后，就可以在本地 images 看到了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a03b9f9bad247cb8bdbc9d7c01e37d8~tplv-k3u1fbpfcp-watermark.image?)

如果搜不到，那直接在命令行用 docker search、docker pull 搜索和拉取镜像也可以：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddd3536dd2b74dc2a2e5117441b55a2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1480&h=486&s=169978&e=png&b=010101)

点击 run 会让你填一些参数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/555e97e310c74081912888dccda95e6a~tplv-k3u1fbpfcp-watermark.image?)

首先是名字，如果不填，docker desktop 会给你生成随机的容器名字。

就是这种：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40fbead5cd9c411ab3e65a688c69aef5~tplv-k3u1fbpfcp-watermark.image?)

然后是端口，容器内跑的 nginx 服务是在 80 端口，你要把宿主机的某个端口映射到容器的 80 端口才可以访问。

接下来是数据卷 volume，这个是把宿主机某个目录挂到容器内。

因为容器是镜像跑起来的，下次再用这个镜像跑的还是同样的容器，那你在容器内保存的数据就会消失。

所以我们都是把某个宿主机目录，挂载到容器内的某个保存数据的目录，这样数据是保存在宿主机的，下次再用镜像跑一个新容器，只要把这个目录挂载上去就行。

至于环境变量，这个就很容易理解了。

我们分别设置一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2cbaaf6efbf488ab841a54cfbf3c070~tplv-k3u1fbpfcp-watermark.image?)

挂载本地的 /tmp/aaa 到容器内的 /usr/share/nginx/html 目录。

这里的 /tmp/aaa 可以换成宿主机的任何目录，如果是 windows 系统，那就是类似 D://tmp/aaa 这种。

**（注意，这里是 /usr 而不是 /user）**

点击 run：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dab38ba7546426781ad5990f7ec4e7a~tplv-k3u1fbpfcp-watermark.image?)

可以看到容器内的 nginx 服务跑起来了。

我们在 /tmp/aaa 目录下添加一个 index.html:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2c2fb3ca0db45d8b8936a1bfebecad1~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问 <http://localhost> 就可以访问到：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76c805c5de3b47d0bae4c39141a5631b~tplv-k3u1fbpfcp-watermark.image?)

这就说明数据卷挂载成功了。

点击 files 标签就可以看到容器内的文件。

可以看到 /usr/share/nginx/html 被标识为 mounted，就是挂载目录的意思：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f35e723f8570443da0ecd95bdebffb3d~tplv-k3u1fbpfcp-watermark.image?)

我们再在本地添加一个文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5638889e8e8048c4878536f9d2d0bef0~tplv-k3u1fbpfcp-watermark.image?)

你会发现容器内这个目录内容也变了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5dda62645e84ed18665bcbd32cc5a66~tplv-k3u1fbpfcp-watermark.image?)

这就是 volume 挂载的作用。

如果你挂载某些目录报错，是因为 docker desktop 挂载的目录是需要配置的，在 Settings > Resources > File Sharing 里加一下就行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4e088be41e24fbeb9678156587aa7cc~tplv-k3u1fbpfcp-watermark.image?)

至于挂载到的目录，在镜像搜索结果页有写：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bbe1e0dc98d4d799250d74c9da153a4~tplv-k3u1fbpfcp-watermark.image?)

通过命令行  docker run 来跑镜像， -v 是指定挂载的数据卷，后面的 :ro 代表 readonly，也就是容器内这个目录只读，:rw 表示容器内可以读写这个目录。

这就是数据卷的作用。

此外，你还可以进入到容器内执行各种命令：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcafb3239c1e4469a3a1e90ffa79dc49~tplv-k3u1fbpfcp-watermark.image?)

是不是感觉 docker 学起来还挺简单的？

docker 常用的就是这些东西。

当然，在服务器上没有 Docker Desktop 这种东西，还是要敲命令的。

比如我们点击 pull 按钮，就相当于执行了 docker pull：

    docker pull nginx:latest

latest 是标签，也就是这个：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d438a6f7ef5442abcea39f0c62e6301~tplv-k3u1fbpfcp-watermark.image?)

然后我们点击 run 按钮，填了个表单，就相当于执行了 docker run：

    docker run --name nginx-test2 -p 80:80 -v /tmp/aaa:/usr/share/nginx/html -e KEY1=VALUE1 -d nginx:latest 

\-p 是端口映射

\-v 是指定数据卷挂载目录

\-e 是指定环境变量

\-d 是后台运行

对照下前面可视化界面，是不是瞬间就懂了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75282ad24d541c8b3a9d87a989a6f2c~tplv-k3u1fbpfcp-watermark.image?)

docker run 会返回一个容器的 hash：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97c622d43fdf401da3b324496710accc~tplv-k3u1fbpfcp-watermark.image?)

就是这里的 id：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32e12d3e35f748f6ba5fe1104c5c318b~tplv-k3u1fbpfcp-watermark.image?)

这个界面可以用 docker ps 来获取：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637543ff05444c1bb8fb2eec3cce63e0~tplv-k3u1fbpfcp-watermark.image?)

它是显示容器列表的，默认是运行中的。

想显示全部的，可以加个 -a

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24d3bc05e98d4af4bf5fa48a2b47a1bb~tplv-k3u1fbpfcp-watermark.image?)

除了 container 列表，image 镜像列表也可以通过 docker images 命令获取：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/407f97f8b637471aa2fc4c68cf2d38bc~tplv-k3u1fbpfcp-watermark.image?)

我们在容器的 terminal 里执行命令，对应的是  docker exec 命令：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/402924b76ba84361b4dd48aa4db8d1a4~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0601c124b48e414ca4b22b93d6e433d7~tplv-k3u1fbpfcp-watermark.image?)

\-i 是 terminal 交互的方式运行

\-t 是 tty 终端类型

然后指定容器 id 和 shell 类型，就可以交互的方式在容器内执行命令了。

查看日志，对应 docker logs 命令：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d86752e576824bd58a97b118377abbbd~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fec0abf5d94f407f91fed3e240db77d9~tplv-k3u1fbpfcp-watermark.image?)

输入 exit 退出：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0262e0d045f74b5cb3cce2aaf44ea057~tplv-k3u1fbpfcp-watermark.image?)

docker inspect 可以查看容器的详情

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7754966f9a64d49b8110e35c7f0551f~tplv-k3u1fbpfcp-watermark.image?)

对应 desktop 里的 inspect 的 tab：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24cd735b47634d948e4fb3999624e41e~tplv-k3u1fbpfcp-watermark.image?)

docker volume 可以管理数据卷：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bfbe4013bbf4fe1b2e272ba7e95c196~tplv-k3u1fbpfcp-watermark.image?)

对应 desktop 的这部分：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b4ec0dff7b74ae68727c786028fb22e~tplv-k3u1fbpfcp-watermark.image?)

此外，还有这些常用命令：

*   docker start：启动一个已经停止的容器
*   docker rm：删除一个容器
*   docker stop：停止一个容器

都可以通过 docker desktop 很方便的操作

## 总结

Docker 可以把环境封装成镜像，镜像跑起来是一个独立的容器。通过这种方式可以快速部署多个相同的实例。

docker 提供了一个 desktop 工具，可以可视化的操作 docker，包括容器、镜像、volume 等

我们 pull 了一个 nginx 镜像下来，指定端口映射、挂载的数据卷，并把它跑起来了。

这就是 docker 的基本用法。

当然，这些可视化的操作都有对应的命令，当服务器上没有桌面的时候，就需要用命令行操作了。

不得不说，用 desktop 来学 docker 真是太简单了。


## 32.你的第一个 Dockerfile

上节我们通过 desktop 从 docker hub 拉取了 nginx 的镜像，并把它跑了起来。

跑这个镜像的时候指定了映射的端口、挂载的数据卷、环境变量等。

跑起来的容器就已经有可用的 nginx 服务了。

那如果我们要自己制作一个这样的镜像，怎么做呢？

docker 容器内就是一个独立的系统环境，想想如果在这样一个系统上，要安装 nginx 服务，怎么做呢？

需要执行一些命令、复制一些文件进来，然后启动服务。

制作镜像自然也要进行这样的过程，不过可以自动化。

只要在 dockerfile 里声明要做哪些事情，docker build 的时候就会根据这个 dockerfile 来自动化构建出一个镜像来。

比如这样：

    FROM node:latest

    WORKDIR /app

    COPY . .

    RUN npm config set registry https://registry.npmmirror.com/

    RUN npm install -g http-server

    EXPOSE 8080

    CMD ["http-server", "-p", "8080"]

这些指令的含义如下：

*   FROM：基于一个基础镜像来修改
*   WORKDIR：指定当前工作目录
*   COPY：把容器外的内容复制到容器内
*   EXPOSE：声明当前容器要访问的网络端口，比如这里起服务会用到 8080
*   RUN：在容器内执行命令
*   CMD：容器启动的时候执行的命令

我们先通过 FROM 继承了 node 基础镜像，里面就有 npm、node 这些命令了。

通过 WORKDIR 指定当前目录。

然后通过 COPY 把 Dockerfile 同级目录下的内容复制到容器内，这里的 . 也就是 /app 目录

之后通过 RUN 执行 npm install，全局安装 http-server

通过 EXPOSE 指定要暴露的端口

CMD 指定容器跑起来之后执行的命令，这里就是执行 http-server 把服务跑起来。

把这个文件保存为 Dockerfile，然后在同级添加一个 index.html

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bb70bf7afb14bb7af6ca6cdf1b72b29~tplv-k3u1fbpfcp-watermark.image?)

然后通过 docker build 就可以根据这个 dockerfile 来生成镜像。

    docker build -t aaa:ccc .

aaa 是镜像名，ccc 是镜像的标签

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78b75cad62c14aa5bde5455b81fe817c~tplv-k3u1fbpfcp-watermark.image?)

FROM 是继承一个基础镜像，看输出也可以看出来，前面都是 node 镜像的内容，会一层层下载下来。

最后才是本地的我们添加的那些。

这时你在 desktop 的 images 列表里就可以看到这个镜像了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29f516c1f3874802b3822e2b61d071d7~tplv-k3u1fbpfcp-watermark.image?)

然后执行 docker run 把这个镜像跑起来，用 desktop 我们就直接点击 run 按钮了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78eaea612f654aae896f8760a0b860de~tplv-k3u1fbpfcp-watermark.image?)

会让你输入这些内容：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e791bc3f1bbb4dc8bf8698c556618cb7~tplv-k3u1fbpfcp-watermark.image?)

是不是上节用 nginx 镜像的感觉回来了？这次是我们自己 build 的镜像。

指定容器名、映射的端口、点击 run：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91c03c09b625413bbb3afde49c073572~tplv-k3u1fbpfcp-watermark.image?)

然后可以看到容器内的日志，服务启动成功了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab0a16d25054400a07f53ac683d1c30~tplv-k3u1fbpfcp-watermark.image?)

当然，容器内打印的是 8080 端口，但在容器外要用映射的 8888 端口访问：

访问 <http://localhost:8888> 就可以看到我们在 html 写的内容了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90d4381f765f4980be3bc24f523fc96d~tplv-k3u1fbpfcp-watermark.image?)

在容器内页打印了一条访问日志：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2874fd653694bf1a3ca88edf058cce5~tplv-k3u1fbpfcp-watermark.image?)

至此，我们写的第一个 dockerfile 和 build 出的第一个镜像就跑成功了！

我们在 files 里看看 /app 下是啥内容：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3301630ab724feabdde84a9cc1fcc21~tplv-k3u1fbpfcp-watermark.image?)

双击 index.html，可以看到这就是我们 build 镜像的时候 COPY 进去的文件。

但是我们想修改静态文件怎么办呢？

进入容器内改太麻烦，不如把这个 /app 目录设置为挂载点吧。

这样改下 Dockerfile：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/694c7d53c1f64ef4972cb1beda771ba8~tplv-k3u1fbpfcp-watermark.image?)

然后重新 build 出一个镜像来：

    docker build -t aaa:ddd -f 2.Dockerfile .

因为现在不是默认的 Dockerfile 了，需要用 -f 指定下 dockefile 的文件名。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16cdc1821fe4f1e8d0f2d3827832c52~tplv-k3u1fbpfcp-watermark.image?)

构建完之后再 run 一下这个新镜像：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd9d4f456c7c4554a7cedf33a0ee15a7~tplv-k3u1fbpfcp-watermark.image?)

这次我把我的桌面目录作为数据卷挂载到 /app 目录了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10602e44e26f4e019c26276ac59947ca~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432ed7adea09434a9055134b95899c5e~tplv-k3u1fbpfcp-watermark.image?)

容器跑起来后可以看到确实挂载上去了，也标识为了 mount：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2ca0036d214d5c991da9d67ea08cd8~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/464690f71f7e46b79b300ba16416a725~tplv-k3u1fbpfcp-watermark.image?)

在 inspect 这里也可以看到挂载的目录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f681b0ce058d48e4b9c0e374bdb03d18~tplv-k3u1fbpfcp-watermark.image?)

有同学说，就算不在 dockerfile 里指定 VOLUME，我还是可以 docker run 的时候通过 -v 挂载数据卷呀。

那我为啥还要指定 VOLUME？

在 dockerfile 里指定 VOLUME 之后，如果你 docker run 的时候没有带 -v，那会放在一个临时的目录里。

比如我直接点击 run，不设置参数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45e670e6bf204940a427ad320fb1b404~tplv-k3u1fbpfcp-watermark.image?)

docker 会随机给他生成一个名字。

还会随机生成一个目录作为数据卷挂载上去：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e5e60a80cab49a595ae9aa7cc083881~tplv-k3u1fbpfcp-watermark.image?)

inspect 可以看到这时候的路径是一个临时的目录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42c87675dbf64458a343c3f349eb736a~tplv-k3u1fbpfcp-watermark.image?)

这样就算你删了容器，数据也可以在这里找回。

设想下，如果你跑了个 mysql 容器，存了很多数据，但是跑容器的时候没指定数据卷。有一天，你把容器删了，所有数据都没了，可不可怕？

为了避免这种情况，mysql 的 dockerfile 里是必须声明 volume 的，这样就算你没通过 -v 指定数据卷，将来也可以找回数据。

在镜像详情可以看到 mysql 的 dockerfile，确实声明了 volume

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f8305a1fec941b58a29d40fe46ae6c0~tplv-k3u1fbpfcp-watermark.image?)

这样就能保证数据不丢失。

dockerfile 在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/docker-test)。

## 总结

docker 镜像是通过 dockerfile 构建出来的。

我们写了第一个 dockerfile，通过 FROM、WORKDIR、COPY、RUN、EXPOSE、CMD 等指令声明了一个 http-server 提供静态服务的镜像。

docker run 这个镜像就可以生成容器，指定映射的端口、挂载的数据卷、环境变量等。

VOLUME 指令看起来没啥用，但能保证你容器内某个目录下的数据一定会被持久化，能保证没挂载数据卷的时候，数据不丢失。

写完这个 dockerfile，相信你会对 docker 镜像、容器有更具体的理解了。


## 33.Nest 项目如何编写 Dockerfile

首先思考一个问题：

dockerfile 是在哪里 build 的，在命令行工具里，还是在 docker 守护进程呢？

答案是在守护进程 docker daemon。

我没启动 docker daemon 的时候是不能 build 的，启动之后才可以：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f773825af9c04a6c92c9a19cf50abc7e~tplv-k3u1fbpfcp-watermark.image?)

命令行工具会和 docker daemon 交互来实现各种功能。

比如 docker build 的时候，会把 dockerfile 和它的构建上下文（也就是所在目录）打包发送给 docker daemon 来构建镜像。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d05e0df6a147818d3523030da497a9~tplv-k3u1fbpfcp-watermark.image?)

比如我们会执行这样的命令：
```shell
docker build -t name:tag -f filename .
```
这个 . 就是构建上下文的目录，你也可以指定别的路径。

而镜像自然是越小性能越好，所以 docker 支持你通过 .dockerignore 声明哪些不需要发送给 docker daemon。

.dockerignore 是这样写的：
```
*.md
!README.md
node_modules/
[a-c].txt
.git/
.DS_Store
.vscode/
.dockerignore
.eslintignore
.eslintrc
.prettierrc
.prettierignore
```
\*.md 就是忽略所有 md 结尾的文件，然后 !README.md 就是其中不包括 README.md

node\_modules/ 就是忽略 node\_modules 下 的所有文件

\[a-c].txt 是忽略 a.txt、b.txt、c.txt 这三个文件

.DS\_Store 是 mac 的用于指定目录的图标、背景、字体大小的配置文件，这个一般都要忽略

eslint、prettier 的配置文件在构建镜像的时候也用不到

此外，还有注释的语法：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6785ea39c73d43318b84f89433d44223~tplv-k3u1fbpfcp-watermark.image?)

这就是 dockerfile 的全部语法，没多少东西。

**docker build 时，会先解析 .dockerignore，把该忽略的文件忽略掉，然后把剩余文件打包发送给 docker daemon 作为上下文来构建产生镜像。**

这就像你在 git add 的时候，.gitignore 下配置的文件也会被忽略一样。

忽略这些用不到的文件，是为了让构建更快、镜像体积更小。

此外，还有一种减小镜像体积的手段：多阶段构建。

我们会先把源码目录发送到 docker daemon 中执行 npm run build 来构建产物，之后再 node ./dist/main.js 把服务跑起来。

也就是这样：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e15787ea384e26a1ea1c19eb7cd2b7~tplv-k3u1fbpfcp-watermark.image?)

新建个项目：
```shell
nest new dockerfile-test -p npm
```
编写 .dockerignore：
```.ignore
*.md
node_modules/
.git/
.DS_Store
.vscode/
.dockerignore
```
编写 Dockerfile：
```docker
FROM node:18

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

EXPOSE 3000

CMD [ "node", "./dist/main.js" ]
```
基于 node 18 的镜像。

指定当前目录为容器内的 /app。

把 package.json 复制到容器里，设置淘宝的 npm registry，执行 npm install。

之后把其余的文件复制过去，执行 npm run build。

指定暴露的端口为 3000，容器跑起来以后执行 node ./dist/main.js 命令。

然后执行 docker build：
```
docker build -t nest:first .
```
镜像名为 nest、标签为 first，构建上下文是当前目录

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41fdc3a13cef43299ecff52842df0c3a~tplv-k3u1fbpfcp-watermark.image?)

然后就可以在 docker desktop 里看到你构建出来的镜像了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eff013188ba492bbbc6c150eaa96bd6~tplv-k3u1fbpfcp-watermark.image?)

如果你 build 的时候报这个错误：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e976e14995544199ad21a300a1e833c~tplv-k3u1fbpfcp-watermark.image?)

那需要加一行：

    RUN ln -s /sbin/runc /usr/bin/runc

原因如下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1183b1a92605424eabb781e52c0b28e1~tplv-k3u1fbpfcp-watermark.image?)

点击 run 把它跑起来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbcc91f51a7b4c1ea59acc180612a48e~tplv-k3u1fbpfcp-watermark.image?)

容器跑成功了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c874381b5db464f9f8ede830622bf8b~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下也没啥问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de236086bf0c453d81d4310277c4730d~tplv-k3u1fbpfcp-watermark.image?)

这样我们就用 docker 把我们的 nest 应用跑起来了！

但现在 docker 镜像还是不完美的。

这样构建出来的镜像有什么问题呢？

明显，src 等目录就不再需要了，构建的时候需要这些，但运行的时候只需要 dist 目录就可以了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/433c253702a942ceac37a1a635720d0d~tplv-k3u1fbpfcp-watermark.image?)

把这些文件包含在内，会让镜像体积变大。

那怎么办呢？

构建两次么？第一次构建出 dist 目录，第二次再构建出跑 dist/main.js 的镜像。那不是要两个 dockerfile？

确实需要构建两次，但只需要一个 dockerfile 就可以搞定。

这需要用到 dockerfile 的多阶段构建的语法。
```docker
# build stage
FROM node:18 as build-stage

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install --production

EXPOSE 3000

CMD ["node", "/app/main.js"]
```
通过 FROM 继承镜像的时候，给当前镜像指定一个名字，比如 build-stage。

然后第一个镜像执行 build。

之后再通过 FROM 继承 node 镜像创建一个新镜像。

通过 COPY --from-build-stage 从那个镜像内复制 /app/dist 的文件到当前镜像的 /app 下。

还要把 package.json 也复制过来，然后切到 /app 目录执行 npm install --production 只安装 dependencies 依赖

这个生产阶段的镜像就指定容器跑起来执行 node /app/main.js 就好了。

执行 docker build，打上 second 标签：
```
docker build -t nest:second .
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20e72d75bbbe4c25a92550af8754ea08~tplv-k3u1fbpfcp-watermark.image?)

把之前的容器停掉，把这个跑起来：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/154f9b89aba247f5bdf4fc53189e3b69~tplv-k3u1fbpfcp-watermark.image?)

这次用 3003 端口来跑：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/219ddae5f2f74fc89eead1f94dae381c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2edb14b6b5a14db0a853e1d3fa1779a5~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485940af45b1484283a04d1e4067cc21~tplv-k3u1fbpfcp-watermark.image?)

nest 服务跑成功了。

这时候 app 下就是有 dist 的文件、生产阶段的 node\_modules、package.json 这些文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdbedb6e21ce4f22a5f2797890f81bae~tplv-k3u1fbpfcp-watermark.image?)

对比下镜像体积，明显看出有减小，少的就是 src、test、构建阶段的 node\_modules 这些文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a92e698c2ad547febb914e84d86640de~tplv-k3u1fbpfcp-watermark.image?)

这就是多阶段构建（multi-stage build）的魅力。

有同学说，但现在镜像依然很大呀，那是因为我们用的基础的 linux 镜像比较大，可以换成 alpine 的，这是一个 linux 发行版，主打的就是一个体积小。

```docker
FROM node:18.0-alpine3.14 as build-stage

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18.0-alpine3.14 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install --production

EXPOSE 3000

CMD ["node", "/app/main.js"]
```

node:18-alpine3.14 就是用 alpine 的 linux 的 3.14 版本，用 node 的 18.0 版本。

然后再 docker build 一下。

```
docker build -t nest:ccc .
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/730cb68366fe4a72a8a87b3ee4aa5bab~tplv-k3u1fbpfcp-watermark.image?)

可以看到现在镜像体积只有 277M 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c423df1b5148f08f6c3653991280b9~tplv-k3u1fbpfcp-watermark.image?)

一般情况下，我们都会用多阶段构建 + alpine 基础镜像。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/786525d5a5fa49e492bb70a6fc22af5d~tplv-k3u1fbpfcp-watermark.image?)

alpine 是一种高山植物，就是很少的养分就能存活，很贴合体积小的含义。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-dockerfile)。

## 总结

docker build 的时候会把构建上下文的所有文件打包发送给 docker daemon 来构建镜像。

可以通过 .dockerignore 指定哪些文件不发送，这样能加快构建时间，减小镜像体积。

此外，多阶段构建也能减小镜像体积，也就是 build 一个镜像、production 一个镜像，最终保留下 production 的镜像。

而且我们一般使用 alpine 的基础镜像，类似 node:18.10-alpine3.14，这样构建出来镜像体积会小很多。

这就是用 Nest 项目构建 Docker 镜像的方式。


## 34.提升 Dockerfile 水平的 5 个技巧

Docker 是一种容器技术，它可以在操作系统上创建多个相互隔离的容器。容器内独立安装软件、运行服务。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db580a5bbf2847d8a4fb9607e9a9775e~tplv-k3u1fbpfcp-watermark.image?)

但是，这个容器和宿主机还是有关联的，比如可以把宿主机的端口映射到容器内的端口、宿主机某个目录挂载到容器内的目录。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf13c72485e642a28a9aa6b2ecf2bc00~tplv-k3u1fbpfcp-watermark.image?)

比如映射了 3000 端口，那容器内 3000 端口的服务，就可以在宿主机的 3000 端口访问了。

比如挂载了 /aaa 到容器的 /bbb/ccc，那容器内读写 /bbb/ccc 目录的时候，改的就是宿主机的 /aaa 目录，反过来，改宿主机 /aaa 目录，容器内的 /bbb/ccc 也会改，这俩同一个。

这分别叫做端口映射、数据卷（volume）挂载。

这个容器是通过镜像起来的，通过 docker run image-name。

比如:

```
docker run -p 3000:3000 -v /aaa:/bbb/ccc --name xxx-container xxx-image
```
通过 xxx-image 镜像跑起来一个叫做 xxx-container 的容器。

-p 指定端口映射，映射宿主机的 3000 到容器的 3000 端口。

-v 指定数据卷挂载，挂载宿主机的 /aaa 到容器的 /bbb/ccc 目录。

这个镜像是通过 Dockerfile 经过 build 产生的。

也就是这样的流程：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27011d7643014cd9b50777a504448537~tplv-k3u1fbpfcp-watermark.image?)

一般在项目里维护 Dockerfile ，然后执行 docker build 构建出镜像、push 到镜像仓库，部署的时候 pull 下来用 docker run 跑起来。

基本 CI/CD 也是这样的流程：

CI 的时候 git clone 项目，根据 dockerfile 构建出镜像，打上 tag，push 到仓库。

CD 的时候把打 tag 的镜像下下来，docker run 跑起来。

这个 Dockerfile 是在项目里维护的，虽然 CI/CD 流程不用自己搞，但是 Dockefile 还是要开发者自己写的。

比如我创建一个 nest 项目：

```
npx nest new dockerfile-test -p npm
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1e748e934b649739ddff4183054202c~tplv-k3u1fbpfcp-watermark.image?)

然后执行 npm run build，之后把它跑起来：

```
npm run build
node ./dist/main.js
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bd4b983d31743ebb2bdb1e62aad1807~tplv-k3u1fbpfcp-watermark.image?)

这时候访问 http://localhost:3000 可以看到 hello world，说明服务跑成功了:

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d9fe3c0161b4b6c8e5dd4432d08b314~tplv-k3u1fbpfcp-watermark.image?)

那如何通过 Docker 部署这个服务呢？

我们来写下 Dockerfile：

```docker
FROM node:18

WORKDIR /app

COPY package.json .

COPY *.lock .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

EXPOSE 3000

CMD [ "node", "./dist/main.js" ]
```
FROM node:18 是继承 node:18 基础镜像。

WORKDIR /app 是指定当前目录为 /app

COPY 复制宿主机的 package.json 和 lock 文件到容器的当前目录，也就是 /app 下

RUN 是执行命令，这里执行了 npm install。

然后再复制其余的文件到容器内。

EXPOSE 指定容器需要暴露的端口是 3000。

CMD 指定容器跑起来时执行的命令是 node ./dist/main.js。

然后通过 docker build 把它构建成镜像：

```
docker build -t dockerfile-test:first .
```

-t 是指定名字和标签，这里镜像名为 dockerfile-test 标签为 first。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac919ad51f5b485c990d71cba714de7d~tplv-k3u1fbpfcp-watermark.image?)

然后在 docker desktop 的 images 里就可以看到这个镜像了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64797c3c1bea4d5186f616fe32fe0d8f~tplv-k3u1fbpfcp-watermark.image?)

就是现在镜像稍微大了点，有 1.45 G。

我们先跑起来看看：

```
docker run -d -p 2333:3000 --name first-container dockerfile-test:first
```
-d 是后台运行。

-p 指定端口映射，映射宿主机的 2333 端口到容器的 3000 端口。

--name 指定容器名

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d49b82111dc45abb0c1206a06f16a6f~tplv-k3u1fbpfcp-watermark.image?)

然后就可以看到容器部分有了这个容器了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3919be67ab4685847772c6515b7ebb~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问 http://localhost:2333 就可以访问容器内跑的这个服务：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf1ce464be31409a928a509990431be8~tplv-k3u1fbpfcp-watermark.image?)

这就是 Dockerfile 构建成镜像，然后通过容器跑起来的流程。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c06a4afd1027473cb21e7cbd66254cb1~tplv-k3u1fbpfcp-watermark.image?)

但是刚才也发现了，现在镜像太大了，有 1.45G 呢，怎么优化一下呢？

这就涉及到了第一个技巧：

## 使用 alpine 镜像，而不是默认的 linux 镜像

docker 容器内跑的是 linux 系统，各种镜像的 dockerfile 都会继承 linux 镜像作为基础镜像。

比如我们刚刚创建的那个镜像，点开详情可以看到它的镜像继承关系：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7b4e66157f04e6db41c120223e1181c~tplv-k3u1fbpfcp-watermark.image?)

最终还是继承了 debian 的 Linux 镜像，这是一个 linux 发行版。

但其实这个 linux 镜像可以换成更小的版本，也就是 alpine。

它裁剪了很多不必要的 linux 功能，使得镜像体积大幅减小了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/786525d5a5fa49e492bb70a6fc22af5d~tplv-k3u1fbpfcp-watermark.image?)

alpine 是高山植物，就是很少的资源就能存活的意思。

我们改下 dockerfile，使用 alpine 的镜像：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e94bfb985f244cd8447778d28b938ec~tplv-k3u1fbpfcp-watermark.image?)

node:18-alpine3.14 是使用 18 版本的 node 镜像，它底层使用 alpine 3.14 的基础镜像。

然后 docker build

```
docker build -t dockerfile-test:second .
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fceb38d17b540e8a792eaa702b7fba8~tplv-k3u1fbpfcp-watermark.image?)

这次的 tag 为 second。

然后在 docker desktop 里看下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ad3b246c6f74294b0bcaf68811b8719~tplv-k3u1fbpfcp-watermark.image?)

好家伙，足足小了 900M。

我们点开看看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f64dcd18ace42b695220fd46b794f3d~tplv-k3u1fbpfcp-watermark.image?)

可以看到它的底层 linux 镜像是 alpine3.14。

体积小了这么多，功能还正常么？

我们跑跑看：

```
docker run -d -p 2334:3000 --name second-container dockerfile-test:second
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/296e3082a1fa427abacce2129f9aea06~tplv-k3u1fbpfcp-watermark.image?)

docker desktop 可以看到这个跑起来的容器：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a581340a62694ef7a81439ad900f1357~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下，依然是正常的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ad33cfcc58e425b938620683d617bf2~tplv-k3u1fbpfcp-watermark.image?)

alpine 只是去掉了很多 linux 里用不到的功能，使得镜像体积更小。

这就是第一个技巧。

然后再来看第二个：

## 使用多阶段构建

看下这个 dockerfile，大家发现有啥问题没：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c5c7b72c0e74681a19d9a9627c9e7b2~tplv-k3u1fbpfcp-watermark.image?)

有的同学可能会说：为什么先复制 package.json 进去，安装依赖之后再复制其他文件，直接全部复制进去不就行了？

不是的，这两种写法的效果不同。

docker 是分层存储的，dockerfile 里的每一行指令是一层，会做缓存。

每次 docker build 的时候，只会从变化的层开始重新构建，没变的层会直接复用。

也就说现在这种写法，如果 package.json 没变，那么就不会执行 npm install，直接复用之前的。

那如果一开始就把所有文件复制进去呢？

那不管 package.json 变没变，任何一个文件变了，都会重新 npm install，这样没法充分利用缓存，性能不好。

我们试试看就知道了：

现在重新跑 docker build，不管跑多少次，速度都很快，因为文件没变，直接用了镜像缓存：

```
docker build -t dockerfile-test:second .
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03cec6ad71964ff78d1c96398eae7584~tplv-k3u1fbpfcp-watermark.image?)

现在我们改下 README.md：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adb9d4044cc04dcaae887870b0466a05~tplv-k3u1fbpfcp-watermark.image?)

然后重新跑 build：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337d91042adb49cd8d9160967db512ea~tplv-k3u1fbpfcp-watermark.image?)

现在花了 25s，其实是没有重新 npm install 的。

然后改下 package.json：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9607cdf0b15b444b9b70c77fad0e64e3~tplv-k3u1fbpfcp-watermark.image?)

再跑 docker build

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5a7bfbfd74640439fde65550d86033d~tplv-k3u1fbpfcp-watermark.image?)

时间明显多了很多，过程中你可以看到在 npm install 那层停留了很长时间。

这就是为什么要这样写：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a82acd8cbb784530a8aa03566a023440~tplv-k3u1fbpfcp-watermark.image?)

这里没问题，大家还能发现有没有什么别的问题么？

问题就是源码和很多构建的依赖是不需要的，但是现在都保存在了镜像里。

实际上我们只需要构建出来的 ./dist 目录下的文件还有运行时的依赖。

那怎么办呢？

这时可以用多阶段构建：

```docker
FROM node:18-alpine3.14 as build-stage

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18-alpine3.14 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install --production

EXPOSE 3000

CMD ["node", "/app/main.js"]
```

FROM 后面添加一个 as 来指定当前构建阶段的名字。

通过 COPY --from=xxx 可以从上个阶段复制文件过来。

然后 npm install 的时候添加 --production，这样只会安装 dependencies 的依赖。

docker build 之后，只会留下最后一个阶段的镜像。

也就是说，最终构建出来的镜像里是没有源码的，有的只是 dist 的文件和运行时依赖。

这样镜像就会小很多。

我们来试试看：

```
docker build -t dockerfile-test:third -f 222.Dockerfile .
```
标签为 third。

-f 是指定 Dockerfile 的名字。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0614454fe6394bb1bdd6d7477c25f623~tplv-k3u1fbpfcp-watermark.image?)

然后 desktop 里看下构建出来的镜像：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a36847acfb7e4d9d8f23e27ebf8d5c1b~tplv-k3u1fbpfcp-watermark.image?)

镜像体积比没有用多阶段构建的时候小了 250 M。

然后跑起来试试看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8860c194ad40429b835883f0a9464718~tplv-k3u1fbpfcp-watermark.image?)

这次映射 2335 端口到容器内的 3000 端口。

依然能正常访问：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ab205faff4e4d33b6c0962aba48df5a~tplv-k3u1fbpfcp-watermark.image?)

这就是第二个技巧，多阶段构建。

## 使用 ARG 增加构建灵活性

我们写一个 test.js 

```javascript
console.log(process.env.aaa);
console.log(process.env.bbb);
```
打印了环境变量 aaa、bbb 

跑一下：
```
export aaa=1 bbb=2
node ./test.js
```

可以看到打印了这俩环境变量：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd86890fe8ab4ab394a0be5d708863c9~tplv-k3u1fbpfcp-watermark.image?)

然后我们写个 dockerfile，文件名是 333.Dockerfile：

```docker
FROM node:18-alpine3.14

ARG aaa
ARG bbb

WORKDIR /app

COPY ./test.js .

ENV aaa=${aaa} \
    bbb=${bbb}

CMD ["node", "/app/test.js"]
```
使用 ARG 声明构建参数，使用 \${xxx} 来取

然后用 ENV 声明环境变量。

dockerfile 内换行使用 \

之后构建的时候传入构建参数：

```
docker build --build-arg aaa=3 --build-arg bbb=4 -t arg-test -f 333.Dockerfile .
```
通过 --build-arg xxx=yyy 传入 ARG 参数的值。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/052f8b4d301e4724984deffdf64da266~tplv-k3u1fbpfcp-watermark.image?)


点击查看镜像详情，可以看到 ARG 已经被替换为具体的值了：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e01565474f24d1ea4819a5492603aa9~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2443db3cf6394a96be7c9d88834fc0f0~tplv-k3u1fbpfcp-watermark.image?)

然后跑起来：

```
docker run  --name fourth-container arg-test
```

这次就不用 -d 后台运行了，直接看下日志：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3a15c10087044fda31bcc99b6ce7db1~tplv-k3u1fbpfcp-watermark.image?)

可以看到容器内拿到的环境变量就是 ENV 设置的。

也就是说 ARG 是构建时的参数，ENV 时运行时的变量。

灵活使用 ARG，可以增加 dockerfile 的灵活性。

这就是第三个技巧。

## CMD 结合 ENTRYPOINT

前面我们指定容器跑起来之后运行什么命令，用的是 CMD：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79d7f94069c34283a00cfd510cb4d1bc~tplv-k3u1fbpfcp-watermark.image?)

其实还可以写成 ENTRYPOINT：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e75546b3a464c80ae27b869291cd896~tplv-k3u1fbpfcp-watermark.image?)

这两种写法有什么区别么？

我们来试试：

写个 444.Dockerfile 

```docker
FROM node:18-alpine3.14

CMD ["echo", "光光", "到此一游"]
```

然后 build：

```
docker build -t cmd-test -f 444.Dockerfile .
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b3f2a2e08548f5b138d958da8ee184~tplv-k3u1fbpfcp-watermark.image?)

然后 run 一下：
```
docker run cmd-test
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aa22b23766045fdb3111fffa0b3336c~tplv-k3u1fbpfcp-watermark.image?)

没有指定 --name 时，会生成一个随机容器名。

就是这种：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/938f50cebb2b409099d1bf6ea36a7943~tplv-k3u1fbpfcp-watermark.image?)

这不是重点。

重点是用 CMD 的时候，启动命令是可以重写的：

```
docker run cmd-test echo "东东"
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a34568fe40754411bc41212be232f7ff~tplv-k3u1fbpfcp-watermark.image?)

可以替换成任何命令。

而用 ENTRYPOINT 就不会：

```docker
FROM node:18-alpine3.14

ENTRYPOINT ["echo", "光光", "到此一游"]
```
docker build: 
```
docker build -t cmd-test -f 444.Dockerfile .
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53a67f44a9ef4ed0833b3ec2e561eca7~tplv-k3u1fbpfcp-watermark.image?)
docker run: 

```
docker run cmd-test echo "东东"
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d3c6d5fb8ad48f2be1f82bca0115c9a~tplv-k3u1fbpfcp-watermark.image?)

可以看到，现在 dockerfile 里 ENTRYPOINT 的命令依然执行了。

docker run 传入的参数作为了 echo 的额外参数。

这就是 ENTRYPOINT 和 CMD 的区别。

一般还是 CMD 用的多点，可以灵活修改启动命令。

其实 ENTRYPOINT 和 CMD 是可以结合使用的。

比如这样：

```docker
FROM node:18-alpine3.14

ENTRYPOINT ["echo", "光光"]

CMD ["到此一游"]
```
docker build：
```
docker build -t cmd-test -f 444.Dockerfile .
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2605356bd1824045a8c4f05fc3c0e063~tplv-k3u1fbpfcp-watermark.image?)

docker run:
```
docker run cmd-test
docker run cmd-test 66666
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/321f2a27cfca4fe093e73890e4866809~tplv-k3u1fbpfcp-watermark.image?)

当没传参数的时候，执行的是 ENTRYPOINT + CMD 组合的命令，而传入参数的时候，只有 CMD 部分会被覆盖。

这就起到了默认值的作用。

所以，用 ENTRYPOINT + CMD 的方式更加灵活。

这是第四个技巧。

## COPY vs ADD

其实不只是 ENTRYPOINT 和 CMD 相似，dockerfile 里还有一对指令也比较相似，就是 ADD 和 COPY。

这俩都可以把宿主机的文件复制到容器内。

但有一点区别，就是对于 tar.gz 这种压缩文件的处理上：

我们创建一个 aaa 目录，下面添加两个文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c66829888bf54dfa801d5876fe47c0cb~tplv-k3u1fbpfcp-watermark.image?)

使用 tar 命令打包：

```
tar -zcvf aaa.tar.gz ./aaa
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f69017d69794f64b7412964fbbd11a2~tplv-k3u1fbpfcp-watermark.image?)

然后写个 555.Dockerfile

```docker
FROM node:18-alpine3.14

ADD ./aaa.tar.gz /aaa

COPY ./aaa.tar.gz /bbb
```

docker build 生成镜像：

```
docker build -t add-test -f 555.Dockerfile .
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40fdaed48df45bfb3d0b868c2cef58a~tplv-k3u1fbpfcp-watermark.image?)

docker run 跑起来：

```
docker run -d --name sixth-container add-test
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7e0e3abaeb7423e930d5b22c66f2f86~tplv-k3u1fbpfcp-watermark.image?)

可以看到，ADD 把 tar.gz 给解压然后复制到容器内了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbb052f1b7ef465dbc8fa8076736ee42~tplv-k3u1fbpfcp-watermark.image?)

而 COPY 没有解压，它把文件整个复制过去了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fc08dffaabc45d1845efcb3dc28eb3a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e0f945732b4a0cb9d506f60f9d370d~tplv-k3u1fbpfcp-watermark.image?)

也就是说，ADD、COPY 都可以用于把目录下的文件复制到容器内的目录下。

但是 ADD 还可以解压 tar.gz 文件。

一般情况下，还是用 COPY 居多。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/dockerfile-test)

## 总结

Docker 是流行的容器技术，它可以在操作系统上创建多个隔离的容器，在容器内跑各种服务。

它的流程是 Dockerfile 经过 docker build 生成 docker 镜像，然后 docker run 来跑容器。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/897c9f267bdc420887cd699f0e6f8e29~tplv-k3u1fbpfcp-watermark.image?)

docker run 的时候可以通过 -p 指定宿主机和容器的端口映射，通过 -v 挂载数据卷到容器内的某个目录。

CI/CD 基本也是这套流程，但是 Dockerfile 是要开发者自己维护的。

Dockerfile 有挺多技巧：

- 使用 alpine 的镜像，而不是默认的 linux 镜像，可以极大减小镜像体积，比如 node:18-alpine3.14 这种
- 使用多阶段构建，比如一个阶段来执行 build，一个阶段把文件复制过去，跑起服务来，最后只保留最后一个阶段的镜像。这样使镜像内只保留运行需要的文件以及 dependencies。
- 使用 ARG 增加构建灵活性，ARG 可以在 docker build 时通过 --build-arg xxx=yyy 传入，在 dockerfile 中生效，可以使构建过程更灵活。如果是想定义运行时可以访问的变量，可以通过 ENV 定义环境变量，值使用 ARG 传入。
- CMD 和 ENTRYPOINT 都可以指定容器跑起来之后运行的命令，CMD 可以被覆盖，而 ENTRYPOINT 不可以，两者结合使用可以实现参数默认值的功能。
- ADD 和 COPY 都可以复制文件到容器内，但是 ADD 处理 tar.gz 的时候，还会做一下解压。

灵活使用这些技巧，可以让你的 Dockerfile 更加灵活、性能更好。



## 35.Docker 是怎么实现的？

前面我们学习了 Docker 镜像、容器的各种操作，dockerfile 的编写，dockerignore 和镜像的多阶段构建。

是不是感觉 Docker 也没多少东西？

确实，Docker 用起来还是很简单的，学习成本不高。

那它是怎么实现的呢？

Docker 容器跑起来就像一个独立的系统一样，它是怎么做到的？

如果网页上有两份 aaa、bbb 变量，我们怎么保证它们不冲突呢？

namespace 呀：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69b105d627b446a6a56c19770fb862ee~tplv-k3u1fbpfcp-watermark.image?)

变成 xxx.aaa、xxx.bbb 和 yyy.aaa、yyy.bbb 就不冲突了。

Docker 在一个操作系统上实现多个独立的容器也是这种思路。

linux 操作系统提供了 namespace 机制，可以给进程、用户、网络等分配一个命名空间，这个命名空间下的资源都是独立命名的。

比如 PID namespace，也就是进程的命名空间，所有进程都是在命名空间内独立分配 id 的。

而 IPC namespace 能限制只有这个 namespace 内的进程可以相互通信，不能和 namespace 外的进程通信。

Mount namespace 会创建一个新的文件系统，namespace 内的文件访问都是在这个文件系统之上。

类似这样的 namespace 一共有 6 种：

*   PID namespace： 进程 id 的命名空间
*   IPC namespace： 进程通信的命名空间
*   Mount namespace：文件系统挂载的命名空间
*   Network namespace：网络的命名空间
*   User namespace：用户和用户组的命名空间
*   UTS namespace：主机名和域名的命名空间

通过这 6 种命名空间，Docker 就实现了独立的容器，在容器内运行的代码就像在一个独立的系统里跑一样。

但是只有命名空间的隔离还不够，还得对资源做限制。

比如一个容器占用了太多的资源，那就会导致别的容器受影响。

怎么能限制容器的资源访问呢？

这就需要 linux 操作系统的另一种机制：Control Group。

创建一个 Control Group 可以给它指定参数，比如 cpu 用多少、内存用多少、磁盘用多少，然后加到这个组里的进程就会受到这个限制。

这样，创建容器的时候先创建一个 Control Group，指定资源的限制，然后把容器进程加到这个 Control Group 里，就不会有容器占用过多资源的问题了。

那这样就完美了么？

其实还有一个问题：每个容器都是独立的文件系统，相互独立，而这些文件系统之间可能很大部分都是一样的，同样的内容占据了很大的磁盘空间，会导致浪费。

所以 Docker 设计了一种分层机制：

每一层都是不可修改的，也叫做镜像。

要修改就创建个新的层：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0f7de7542054f748e3c7e5964a82191~tplv-k3u1fbpfcp-watermark.image?)

然后通过一种叫做 UnionFS 的机制把这些层合并起来，变成一个文件系统：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/174a57adf33b4b99ab7a1ade26822ebc~tplv-k3u1fbpfcp-watermark.image?)

这样如果有多个容器内做了文件修改，只要创建不同的层即可，底层的基础镜像是一样的。

我们写的这个 Dockerfile，每一行指令都会生成一层镜像：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5d2b2a32ded4c8da31faec710b73613~tplv-k3u1fbpfcp-watermark.image?)

点开 docker 镜像的详情可以看到：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a84a9935d4d4cfb958eb87809754b9b~tplv-k3u1fbpfcp-watermark.image?)

就上面这个 dockerfile，它对应的镜像就有 20 层。

当然，很多都是一层层通过 FROM 继承下来的。

Docker 通过这种分层的镜像存储，极大的减少了文件系统的磁盘占用。

哪里看出来的呢？

比如 nest 的镜像有 1g 多：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f729f92458144387a12e1abb55912446~tplv-k3u1fbpfcp-watermark.image?)

但是很多都是它继承的 node 镜像里的，可以看到每一层用了多少存储空间：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66f1260b48a942fa899e25eb1e181b76~tplv-k3u1fbpfcp-watermark.image?)

我本地两个 nest 镜像，它们都继承了 node 镜像，这两个合起来有 2g 的存储空间么？

没有，因为下面的镜像层是公用的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61a61cc0cd084fd59c50902b27146fcc~tplv-k3u1fbpfcp-watermark.image?)

如果有 10 个这种类似的镜像，之前需要 10g。现在呢？可能不到 2g 就够了。

这就是分层存储的魅力。

而且还可以把这些镜像 push 到 registry 镜像仓库，别人拉下来也可以直接用。

但镜像是不可修改的，那为啥我们可以在容器内写文件呢？

因为容器跑起来会给他多加一个可写层，或者叫容器层：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/689f619938dd4675a284ee57fb2e24eb~tplv-k3u1fbpfcp-watermark.image?)

这样容器就能在这里一层写文件了。

当然，再跑一个容器会创建一个新的可写层，另一个容器的可写层的数据就丢了。

所以 Docker 设计了挂载机制，可以挂载数据卷到这个可写层上去。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b13c4403e844665b183c00ad4a9bd6c~tplv-k3u1fbpfcp-watermark.image?)

这个数据卷是可以持久化的，再跑个新容器，依然可以把这个 volume 挂上去。

这就是数据卷的作用。

回顾一下 Docker 实现原理的三大基础技术：

*   Namespace：实现各种资源的隔离
*   Control Group：实现容器进程的资源访问限制
*   UnionFS：实现容器文件系统的分层存储，镜像合并

都是缺一不可的。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aecb63016ab45c0bc2603071b65a420~tplv-k3u1fbpfcp-watermark.image?)

## 总结

Docker 的实现原理依赖 linux 的 Namespace、Control Group、UnionFS 这三种机制。

Namespace 做资源隔离，Control Group 做容器的资源限制，UnionFS 做文件系统的分层镜像存储、镜像合并。

我们通过 dockerfile 描述镜像构建的过程，每一条指令都是一个镜像层。

镜像通过 docker run 就可以跑起来，对外提供服务，这时会添加一个可写层（容器层）。

挂载一个 volume 数据卷到 Docker 容器，就可以实现数据的持久化。

这就是 Docker 的实现原理。


## 36.为什么 Node 应用要用 PM2 来跑？

前面我们都是 node 直接跑的 Nest 应用，但生产环境我们不会直接跑 node，而会用 pm2 来跑。

为什么要用 pm2 呢？它解决了啥问题？

想一下：

如果你的 node 应用跑的时候突然抛了个错，崩溃了，是不是需要重新跑起来？

这时候是不是就需要另一个进程来自动做重启这件事情？

node 应用的日志默认输出在控制台，如果想输出到不同的日志文件，是不是可以让另一个进程获取 node 应用的输出，然后写文件来实现？

node 是单线程的，而机器是多个 cpu 的，为了充分利用 cpu 的能力，我们会用多个进程来跑 node 应用，这种通用逻辑是不是也可以放到一个单独进程里来实现？

node 运行时的 cpu、内存等资源的占用，是不是需要监控？这时候是不是可以让另一个进程来做？

线上的 node 应用不只是跑起来就行了，还要做自动重启、日志、多进程、监控这些事情。

而这些事情，都可以用 pm2 来做。

pm2 是 process manager，进程管理，它是第二个大版本，和前一个版本差异很大，所以叫 pm2.

pm2 的主要功能就是**进程管理、日志管理、负载均衡、性能监控**这些。

我们分别来看一下：

首先安装 pm2:

    npm install -g pm2

然后跑一个 node 应用，我这里跑一个 Nest 的应用：

直接 node 跑是这样的，日志打印在控制台：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceddcfe098aa4a6a8c3420559813ee11~tplv-k3u1fbpfcp-watermark.image?)

而用 pm2 的话，就可以这样跑：

    pm2 start ./dist/main.js

它会把这个 node 进程跑起来，然后管理起来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a5c5e73aeb844e889dc8feb912e5a31~tplv-k3u1fbpfcp-watermark.image?)

管理起来之后，就有我们上面说的那些功能了，比如自动重启、日志管理、性能监控等。

首先看下日志，执行

    pm2 logs

![i](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a2e6c231d8c436cb9e4f0fe309e5c61~tplv-k3u1fbpfcp-watermark.image?)

可以看到 pm2 会把所有进程的日志打印出来，通过前面的“进程id|进程名字”来区分，比如 0|main。

而且，它会把它写到日志文件里，在 \~/.pm2/logs 下，以“进程名-out.log”和“进程名-error.log”分别保存不同进程的日志：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/030ba69ae6cb4265af0be0141ce9f460~tplv-k3u1fbpfcp-watermark.image?)

比如 main-out.log 里保存了 main 进程的正常日志，而 main-error.log 里保存了它的报错日志：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/535d059c01e74d358a105d016e25a12f~tplv-k3u1fbpfcp-watermark.image?)

我们再跑一个进程试试：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7407cc359a2244378f941ed786885bda~tplv-k3u1fbpfcp-watermark.image?)

现在有两个进程了，pm2 logs 可以看到这两个进程的日志：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3855017102544537a5a00b8fedc45cf1~tplv-k3u1fbpfcp-watermark.image?)

也可以

    pm2 logs 进程名
    pm2 logs 进程id

这样查看单个进程的日志：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4399d7d1d84e6bbb6e0b9b1afd056c~tplv-k3u1fbpfcp-watermark.image?)

这就是 pm2 的日志管理的功能。

进程管理的话就是可以手动启动、重启、停止某个进程，而且崩溃了会自动重启，也可以定时自动重启。

只需要 pm2 start 的时候带上几个选项就好了：

超过 200M 内存自动重启：

    pm2 start xxx --max-memory-restart 200M

从 2s 开始每 3s 重启一次：

    pm2 start xxx --cron-restart "2/3 * * * * *"

当文件内容改变自动重启：

    pm2 start xxx --watch

不自动重启：

    pm2 start xxx --no-autorestart

我们分别试一下：

把之前的进程删掉：

    pm2 delete 0

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c2127727e5042bbaf88e5398c419736~tplv-k3u1fbpfcp-watermark.image?)

我们指定 1k 内存就重启：

    pm2 start xxx --max-memory-restart 1K

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6374798eaff406585cb6c654917c125~tplv-k3u1fbpfcp-watermark.image?)

然后在 nest 代码里用超过 1k 的内存：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a43867d8ded2483f8052eb30c19f75ac~tplv-k3u1fbpfcp-watermark.image?)

先把之前的日志清空，使用 pm2 flush 或者 pm2 flush 进程名|id

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5f3189f8113483289bfa389e49ca89e~tplv-k3u1fbpfcp-watermark.image?)

确实清空了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13532c0784f94058b9c1c240c055ceac~tplv-k3u1fbpfcp-watermark.image?)

访问下这个 controller：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b1f705073f048cf9fcb1abe00572ac4~tplv-k3u1fbpfcp-watermark.image?)

查看 main 进程的前 100 行日志：

    pm2 logs main --lines 100 

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1deced0e08d45b2a2a75fa9f124d801~tplv-k3u1fbpfcp-watermark.image?)

明显看到重启了。

这是超过内存的自动重启。

崩溃的自动重启、定时自动重启、文件变动自动重启等也是类似 。

我们前面用到的 pm2 start、pm2 stop、pm2 restart、pm2 delete 等就是进程管理的功能。

再就是负载均衡，node 应用是单进程的，而为了充分利用多核 cpu，我们会使用多进程来提高性能。

node 提供的 cluster 模块就是做这个的，pm2 就是基于这个实现了负载均衡。

我们只要启动进程的时候加上 -i num 就是启动 num 个进程做负载均衡的意思。

    pm2 start app.js -i max 
    pm2 start app.js -i 0

这俩是启动 cpu 数量的进程。

用多进程的方式跑 nest 应用：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e18577a7e24f5f8cb15729aa10c102~tplv-k3u1fbpfcp-watermark.image?)

可以看到启动了 8 个进程，因为我是 8 核 cpu。

跑起来之后，还可以动态调整进程数，通过 pm2 scale：

    pm2 scale main 3

我把 main 的集群调整为 3 个进程：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93758cd7ce842bda077326bb155e7d7~tplv-k3u1fbpfcp-watermark.image?)

可以看到 pm2 删除了 5 个，留下了 3 个。

    pm2 scale main +3

我又加了 3 个，现在变成了 6 个：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a09f97908c2b4b3c95c825a532e8e2ad~tplv-k3u1fbpfcp-watermark.image?)

可以动态伸缩进程的数量，pm2 会把请求分配到不同进程上去。

这就是负载均衡功能。

此外，还有个性能监控功能，执行 pm2 monit:

    pm2 monit

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffff991307f24238992507f61d89be1b~tplv-k3u1fbpfcp-watermark.image?)

可以看到不同进程的 cpu 和内存占用情况。

大概就是这些功能，但是当进程多了之后，难道都要手动通过命令行来启动么？

肯定不会每次都敲一遍。

pm2 支持配置文件的方式启动多个应用。

执行 pm2 ecosystem，会创建一个配置文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7db9ed3f113c4814b53bea785944767f~tplv-k3u1fbpfcp-watermark.image?)

apps 部分就是配置应用的，scripts 就是应用的启动路径：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd5cc9ae43c8456b9a0af47344c37568~tplv-k3u1fbpfcp-watermark.image?)

它可以指定的配置非常多，基本就是命令行有啥选项，这里就有啥属性：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a01e588000344da9b95d10bbc46fd2d~tplv-k3u1fbpfcp-watermark.image?)

然后 pm2 start ecosystem.config.js 就可以批量跑一批应用。

就相当于 pm2 根据配置文件自动执行这些命令，不用我们手动敲了。

这样，我们就可以把启动的选项保存在配置文件里。

最后，还有个 pm2 plus，这个是收费功能，看看就行：

访问 pm2 的网站，登录，创建 bucket：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06be03d0cca44e19ae61943ea0bace96~tplv-k3u1fbpfcp-watermark.image?)

然后在本地执行 pm2 link xxx xxx，把本地的 pm2 和那个网站关联起来：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d621a4477b3043848033c3209df248df~tplv-k3u1fbpfcp-watermark.image?)

再执行 pm2 plus 就会打开 bucket 对应的网页：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e487c9ac5de406caf8843825dd95228~tplv-k3u1fbpfcp-watermark.image?)

可以在线监控你的应用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68df61f9f9634ab981c146e0e1eb4b14~tplv-k3u1fbpfcp-watermark.image?)

下面这些 plus 的功能都是收费的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bc6e650b3c3447ea78daa37a3e17787~tplv-k3u1fbpfcp-watermark.image?)

一般也不需要用，用免费的本地功能就好了。

有同学说，不都是 docker 部署了么？还需要 pm2 么？

当然需要了，万一 docker 容器内 node 服务崩溃了，是不是需要重启？

docker 容器内的进程同样有日志管理、进程管理和监控的需求。

一般都是 [docker 镜像](https://github.com/Unitech/pm2/blob/master/examples/docker-pm2/Dockerfile)内安装 pm2 来跑 node：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b92859191c441feba2a8e21f778eba2~tplv-k3u1fbpfcp-watermark.image?)

之前我们写的 Nest 的 dockerfile 是这样的：

```docker
# build stage
FROM node:18 as build-stage

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm install --production

EXPOSE 3000

CMD ["node", "/app/main.js"]
```

现在要改成这样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9ca3bdaf97a4532a29bf06490befd4d~tplv-k3u1fbpfcp-watermark.image?)

就是多装一个 pm2，然后用 pm2 代替 node 来跑。

我们 docker build 一下：

    docker build -t nest:ccc .

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6eba9f5ea9a5428693dec1eb25622f19~tplv-k3u1fbpfcp-watermark.image?)

把它跑起来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62745eefc28f45d9a339798c8ab18a45~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9598f92408794b07b8471149c79d4d6b~tplv-k3u1fbpfcp-watermark.image?)


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c807f7b6462f4042b0878a7551a2299f~tplv-k3u1fbpfcp-watermark.image?)

这个就是 pm2 打印的日志。

你可以在 terminal 使用 pm2 的命令：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cee84ad567a041e29f1f9aba9f249fd4~tplv-k3u1fbpfcp-watermark.image?)

现在这个容器内的 node 进程在崩溃时就会自动重启。

## 总结

服务器上的 node 应用需要用 pm2 的日志管理、进程管理、负载均衡、性能监控等功能。

分别对应 pm2 logs、pm2 start/restart/stop/delete、pm2 start -i、pm2 monit 等命令。

多个应用或者想把启动选项保存下来的时候，可以通过 ecosystem 配置文件，批量启动一系列应用。

我们会把 docker 和 pm2 结合起来，在进程崩溃的时候让 pm2 来自动重启。

只要写 dockerfile 的时候多安装一个 pm2 的依赖，然后把 node 换成 pm2-runtime 就好了。

不管是出于稳定性、性能还是可观测性等目的，pm2 都是必不可少的。


## 37.快速入门 MySQL

后端主要做的事情就是把数据从数据库中查出来返回给前端渲染，或者把前端提交的数据存入数据库。

学习后端技术，数据库是很重要的一步。

这节我们就来学下最流行的数据库 MySQL 的使用。

就和我们用 Docker 时一样，mysql 也是分为后台守护进程和客户端两方面。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb24542069c642528df69f7781b63d26~tplv-k3u1fbpfcp-watermark.image?)

我们会在命令行客户端或者 GUI 客户端里连接 MySQL，发送 SQL 语句来操作它。

通过 Docker Desktop 查询下 MySQL 的镜像：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e845a52a08646088c4caf6e62a752bc~tplv-k3u1fbpfcp-watermark.image?)

点击 run，传入参数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33961dc3a8cd4d9c805c2ff096a1caf9~tplv-k3u1fbpfcp-watermark.image?)

这里端口 3306 就是 client 连接 mysql 的端口。

（另一个 33060 端口是 mysql8 新加的管理 mysql server 的端口，这里用不到）

指定 volume，用本地目录作为数据卷挂载到容器的 /var/lib/mysql 目录，这个是 mysql 保存数据的目录。

（这里的 /Users/guang/mysql 是我本地的一个目录，任意目录都行。在 windows 下就是 D://xxx/xx 的形式）

之前我们也在 mysql 镜像的 dockerfile 里看到过这个 volume 声明：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d21fb69df4814ca6b09d860a76169aca~tplv-k3u1fbpfcp-watermark.image?)

这里还要指定密码 MYSQL\_ROOT\_PASSWORD，也就是 client 连接 mysql server 的密码。

如果不填，容器跑起来会有这样的提示：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d048bdc4e9a346e5a954a24e4a8aebef~tplv-k3u1fbpfcp-watermark.image?)

让你必须指定这三个环境变量中的一个。

现在 mysql 容器就成功跑起来了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d54eef315d2a454bab9b1980f1c7db72~tplv-k3u1fbpfcp-watermark.image?)

mysql 镜像里带了 mysql 命令行工具，我们先用它连上 mysql server 操作下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12cfb210ec46413fa8c1f4d283162bf3~tplv-k3u1fbpfcp-watermark.image?)

输入 mysql -u root -p 然后会让你输入密码，之后就进入 mysql 操作界面了。

现在可以通过 sql 操作数据库了。

但我们不着急学 sql，还是从 GUI 客户端开始学。

GUI 客户端有很多，这里我们用 mysql 官方的 GUI 客户端： [MySQL Workbench](https://dev.mysql.com/downloads/workbench/)

选择你的操作系统版本和 cpu 架构对应的安装包，点击 download：

（m1 芯片要选择 arm 的包）

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f771e67913f4440a69cbe3cc3778cdf~tplv-k3u1fbpfcp-watermark.image?)

它会让你登录，你可以点下面的 no thanks，直接开始下载：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592ec2f05895495da340ff9ca7294659~tplv-k3u1fbpfcp-watermark.image?)

安装包下载后，点击安装。

安装好后，打开 mysql workbench，点击这个 + 号：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6b8755152034d25bffb272c4a642c81~tplv-k3u1fbpfcp-watermark.image?)

输入连接名，点击 store in keychain 输入密码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b076aa8b54e42d1acf080f15f878d4c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe94aaf1a22944348e9b473fae832474~tplv-k3u1fbpfcp-watermark.image?)

之后你可以点击下 Test Connection 测试连接是否成功：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02a6fa76b8b54c4aaadf647086fb8754~tplv-k3u1fbpfcp-watermark.image?)

然后点击 ok。

之后点击这个连接，进入操作 mysql server 的界面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/778b991cc2f14d99aaf946d057281649~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/474c3d7987c642c5a25c0af8e1b2dc00~tplv-k3u1fbpfcp-watermark.image?)

点击 schemas 就可以看到 mysql 现在已有的数据库和它下面的表、视图、存储过程、函数等：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bef064519e443b7a58abbb04b6d34fc~tplv-k3u1fbpfcp-watermark.image?)

什么是视图、存储过程、函数之后再讲。

我们先点击这个图标看一下 sys\_config 表中的数据：

它会自动执行查询这个表全部数据的 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bf4bf35997b44e5ad5174d3e80b5a52~tplv-k3u1fbpfcp-watermark.image?)

这就是这个表的数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa9748f06c747739188e32c743b2044~tplv-k3u1fbpfcp-watermark.image?)

点击第一个图标，会展示表的信息，比如多少列、多少行、占据了多大的空间等：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/537270f09a3b4f42afcfed0ab12f2e05~tplv-k3u1fbpfcp-watermark.image?)

点击第二个图标是修改表的列的定义的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a46b949944341b8afebb294fd9362ac~tplv-k3u1fbpfcp-watermark.image?)

不要改这个数据库，我们新建一个来测试。

连接之后，我们可以看到 mysql server 的所有的 database 或者叫 schema。

（从 MySQL5.0 开始，官方文档中开始使用 schema 来代替 database 来描述 MySQL 中的数据库。但是，实际上 MySQL 中的数据库仍然可以使用 database 来称呼，两者是等价的）

每个数据库下存储着很多表、视图、存储过程和函数。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1551e10ee464e4aa12c041aa7d37bc2~tplv-k3u1fbpfcp-watermark.image?)

当然，我们最常用的还是表。

上面这 5 个按钮分别是创建 schema、table、view、stored procedure、function 的。

点击第一个，创建个 database（或者叫 schema）：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71d2cee7bb0a48369e3348b3218298d1~tplv-k3u1fbpfcp-watermark.image?)

输入名字，指定字符集，点击右下角的 apply。

创建成功之后，就可以看到我们刚建的数据库了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1afa8bd8e7d3421ebd418d98166bd347~tplv-k3u1fbpfcp-watermark.image?)

选中 hello-mysql 数据库，点击创建 table 的按钮，我们来建个表：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3b76c4ccbee4e3ea0454b2241ad3349~tplv-k3u1fbpfcp-watermark.image?)

输入表名 student。

先建立 id 列：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c692ce2b473346a9ab68d803d6ed32e0~tplv-k3u1fbpfcp-watermark.image?)

输入描述，选中 primary key、 auto increment 的约束。

primary key 是主键，也就是区分每一行数据的那一列，这一列一般命名为 id。

primary key 自带了唯一（unique）和非空（not null）的约束。

再就是要勾选 auto increment 这样插入数据的时候，会自动设置 1、2、3、4、 的递增的 id。

然后依次创建 name、age、sex、email、create\_time、status 列：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75b57c88448241759286441ce074e339~tplv-k3u1fbpfcp-watermark.image?)

分别是名字、年龄、性别、邮箱、创建时间、是否删除的意思。

可以填入注释和默认值。

比如 status 用 0 表示未删除，1 表示已删除，这叫做逻辑删除。也就是删除的时候就是从 0 改成 1，但不会真正删除数据。

name 和 create\_time 添加非空约束。

mysql 的数据类型有很多：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453930c61b6a4a729743f49c858acf98~tplv-k3u1fbpfcp-watermark.image?)

整数类的有：TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT

看名字就可以看出来，就是存储空间的大小不同

浮点型数字的有 FLOAT、DOUBLE

定点型数字的有 DECIMAL、MUMARIC

字符串型的有 CHAR、VARCHAR、TEXT和 BLOB

日期型的有 DATE、TIME、DATETIME、TIMESTAMP

不过我们常用的也就这么几个：

**INT**：存储整数

**VARCHAR(100)**: 存储变长字符串，可以指定长度

**CHAR**：定长字符串，不够的自动在末尾填充空格

**DOUBLE**：存储浮点数

**DATE**：存储日期 2023-05-27

**TIME**：存储时间 10:13

**DATETIME**：存储日期和时间 2023-05-27 10:13

其余的类型用到再查也行。

这里还有个 TIMESTAMP 类型，它也是存储日期时间的，但是范围小一点，而且会转为中央时区 UTC 的时间来存储。

可以看到，mysql 设计了这么多的数据类型，一个目的自然是存储更丰富的信息，另一个目的就是尽可能的节省存储空间，比如 tiny、small、medinum、big 等各种 int。。。

点击右下角的 apply，就会生成建表 sql：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7726bc5092b640a48609067038b2c61d~tplv-k3u1fbpfcp-watermark.image?)

这就是建表语句的语法。

这里简单说一下 sql 的分类，sql 是分为好几种的，这种创建数据库、创建表等修改结构的 sql 叫做 DDL（Data Definition Language），而增删改那种叫做 DML（Data Manipulate Language），查询数据的叫做 DQL（Data Query Language）。

知道这个概念就好了。

然后我们继续：

创建成功之后点击第三个图标，就可以查询这个表的所有数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eacc77c17a24a84a39f9b7f2dfc3480~tplv-k3u1fbpfcp-watermark.image?)

你可以新增几行数据，每一行数据叫做一个记录（Record）。

可以在下面直接编辑，然后点击 apply：

（这里不用设置 id，因为我们指定了它自增了，会自动设置）

（status 也不用设置，因为我们指定了默认值了）

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec7914c1266c467abc04a19c69b8c7fe~tplv-k3u1fbpfcp-watermark.image?)

他会生成 insert 语句，这是向表中插入数据的语法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1dac17b831e49a483273c1a86c2be3f~tplv-k3u1fbpfcp-watermark.image?)

把它复制一下，之后我们用 insert 语句来插入数据吧，mysql workbench 这个可视化编辑功能不好用。

点击 apply 之后，mysql 会执行 sql，这时候就可以看到这条记录被插入了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/331d4828ca70470bb2e20f7c0de2520b~tplv-k3u1fbpfcp-watermark.image?)

因为我之前测试的时候插入过几条，所以 id 自增到了 5，status 默认设置了 0。

接下来我们用 sql 的方式插入：

```sql
INSERT INTO `hello-mysql`.`student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('bbb', '23', '1', 'bbb@qq.com', '2023-05-27 10:50:00');

INSERT INTO `hello-mysql`.`student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('ccc', '21', '0', 'ccc@qq.com', '2023-05-26 10:50:00');

INSERT INTO `hello-mysql`.`student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('ddd', '22', '1', 'ddd@qq.com', '2023-05-28 10:50:00');
```

在上面的输入框输入这几条 sql，选中它们，然后点击执行 sql 的按钮：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb9cf395d2604199905d4c8d43b46192~tplv-k3u1fbpfcp-watermark.image?)

下面是执行结果，可以看到都插入成功了，一共 3 行。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61222401e88b4d8795d0c6f75217b693~tplv-k3u1fbpfcp-watermark.image?)

然后再选中上面的查询 sql 来执行：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bcbc26509dcd41609e38a0140aa35fd1~tplv-k3u1fbpfcp-watermark.image?)

下面也同样会展示查询 sql 的执行情况，一共返回了 4 行数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43cb23dab16442ca9680cf3e8bf95dab~tplv-k3u1fbpfcp-watermark.image?)

新增学会了，修改和删除呢？

我们同样可视化操作一下，然后看看 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8de7ca71957e49f995d73464ae77b836~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/780a530ec409476986507fdb8a23c7dc~tplv-k3u1fbpfcp-watermark.image?)

修改和删除的 sql 分别是这样的：

```sql
UPDATE `hello-mysql`.`student` SET `email` = 'xxx@qq.com' WHERE (`id` = '10');
```

```sql
DELETE FROM `hello-mysql`.`student` WHERE (`id` = '10');
```

更新 hello-mysql 数据库的 student 表，设置 email 列为 <xxx@qq.com>，条件是 id 为 10。

是不是很容易理解？

毕竟 sql 就是设计出来给人用的嘛。

删除数据也同样很容易理解：

删除 hello-mysql 数据的 student 的 id 为 10 的列。

至此，我们已经学会 mysql 的数据库表的创建和增删改查了。

创建表是这样的（这个不用记，一般不会手动写 sql 创建表）：

```sql
CREATE TABLE `student` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(45) NOT NULL COMMENT '名字',
  `age` int DEFAULT NULL COMMENT '年龄',
  `sex` int DEFAULT NULL COMMENT '性别',
  `email` varchar(60) DEFAULT NULL COMMENT '邮箱',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `status` int DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`)
) CHARSET=utf8mb4
```

也就是指定创建的表的名字，然后括号内 , 分隔的每一列分别指定名字、类型、约束、注释、默认值等。

插入记录是这样的：

```sql
INSERT INTO `student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('bbb', '23', '1', 'bbb@qq.com', '2023-05-27 10:50:00');
```

更新记录是这样的：

```sql
UPDATE `hello-mysql`.`student` SET `email` = 'xxx@qq.com' WHERE (`id` = '2');
```

删除记录是这样的：

```sql
DELETE FROM `hello-mysql`.`student` WHERE (`id` = '2');
```

查询记录是这样的：

```sql
SELECT * FROM `hello-mysql`.student;
```

增删改的 sql 都很简单，查询的 sql 可以写的很复杂，这个我们下节再讲。

最后再来学下删除和清空表的 sql：

清空是 truncate：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f161834b59dc4e9287b2929e4e3de308~tplv-k3u1fbpfcp-watermark.image?)

点击 review sql
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/568e4fcd2e7e49f4bd275f1496c01175~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c70f0a8cffdc4f14912b2da2c106cc23~tplv-k3u1fbpfcp-watermark.image?)

删除是 drop：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb7bb88d0ae14962b316d45b62071423~tplv-k3u1fbpfcp-watermark.image?)

都很好理解。

按照 sql 分类，我们学的 table 的创建、删除、清空的 sql 都属于 DDL。table 数据的增删改属于 DML，而数据的查询属于 DQL。

这些 sql 在 mysql 命令行里执行也是一样的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5989606aabe4cfc94e371fdd9065cb3~tplv-k3u1fbpfcp-watermark.image?)

一般我们还是用 GUI 工具更多一些。

最后还有一个小技巧，这里每次都要指定数据库名比较麻烦：

可以先 use 数据库名 切换下数据库：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a647b8141594493a9a29a3c4b3ef4b4~tplv-k3u1fbpfcp-watermark.image?)

这就像我们切到某个目录执行命令一样。

在 mysql workbench 里也是这样，先选中 use xx 那行执行，然后再选中其他 sql 执行。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a8e3a2dda0f472dae8980076b370ab3~tplv-k3u1fbpfcp-watermark.image?)

有同学可能会问，之前 sql 不一直都大写么？咋这里用小写了？

sql 语句不区分大小写，用大写只是关键词更容易区分一些。

最后，还记得我们跑 mysql 镜像指定了个 volume 数据卷么？

之前是没数据的，现在就有数据了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0acab77ce294379a36f39334b6353c1~tplv-k3u1fbpfcp-watermark.image?)

本地对应的目录也修改了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c7694e1422543548957e6377c06aa81~tplv-k3u1fbpfcp-watermark.image?)

这样还会丢数据么？

不会，哪怕这个容器不行了，下次换个镜像挂载上这个目录一样跑。

## 总结

mysql 分为 server 和 client，我们通过 docker 跑了一个 mysql server，指定了端口、数据卷，并通过 MYSQL\_ROOT\_PASSWORD 环境变量指定了 root 的密码。

然后下载了 mysql workbench 这个官方的 GUI 客户端。

可视化创建了一个 database 或者叫 schema。

之后创建了一个表，指定了主键和其他列的约束、默认值等。

之后学习了增删改查数据的可视化操作和对应的 INSERT、DELETE、UPDATE、SELECT 的 sql 语句。

还有 CREATE TABLE、TRUNCATE TABLE、DROP TABLE 等语句，这些修改结构的 sql 叫做 DDL。

增删改数据的 sql 叫做 DML，而查询数据的 sql 叫做 DQL。

当然，这只是单表的操作，下一节我们来学习多表的关联以及复杂 sql 查询语句的编写。


## 38.SQL 查询语句的所有语法和函数

上节我们学了 mysql 的数据库、表的创建删除，单表的增删改查。

其实增删改查的 sql 语法还有很多，这节我们就来一起过一遍。

用 docker 跑个 mysql 镜像：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7a27cb986a44bb4a01c1a940734f499~tplv-k3u1fbpfcp-watermark.image?)

上节我们跑 mysql 镜像的时候，把数据保存在了一个目录下，这次把那个目录挂载到新容器的 /var/lib/mysql

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd85aa185494cddb17f717ff19f67c4~tplv-k3u1fbpfcp-watermark.image?)

指定容器名、端口映射，点击 run。

这次不用再指定 MYSQL\_ROOT\_PASSWORD 的环境变量了，因为这个配置同样保存在挂载目录下。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd05582e6d6142e099b452ef7adb198e~tplv-k3u1fbpfcp-watermark.image?)

还是用之前的密码连接 mysql，然后 show databases 查看所有数据库。

可以看到上节我们创建的 hello-mysql 数据库还在。

这就是数据卷挂载的用处，就算你跑了个新容器，那只要把数据卷挂上去，数据就能保存下来。

然后还是用 mysql workbench 来连接：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ce7857b289c40a78e42cbc7eaa74d3a~tplv-k3u1fbpfcp-watermark.image?)

点击之前建的 connection 就行。

我们先建个表：

```sql
CREATE TABLE student(
    id INT PRIMARY KEY AUTO_INCREMENT COMMENT 'Id',
    name VARCHAR(50) NOT NULL COMMENT '学生名',
    gender VARCHAR(10) NOT NULL COMMENT '性别',
    age INT NOT NULL COMMENT '年龄',
    class VARCHAR(50) NOT NULL COMMENT '班级名',
    score INT NOT NULL COMMENT '分数'
) CHARSET=utf8mb4
```

这时学生表。

id 为主键，设置自动增长。

name 为名字，非空。

gender 为性别，非空。

age 为年龄，非空。

class 为班级名，非空。

score 为成绩，非空。

这和你可视化的建表是一样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4809612d6e6b4eb7b4cc4aa2a2928e6d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5b1c30d3fb64934859df1444e2318f5~tplv-k3u1fbpfcp-watermark.image?)

这次我们就通过 sql 建表了。

之前我们建了个 student 表，先把它删掉。

```sql
drop table student;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5ae99594bce4e1c85d84b02081e540a~tplv-k3u1fbpfcp-watermark.image?)

然后执行建表 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a24353ed2b449a69c47241e4cd77a03~tplv-k3u1fbpfcp-watermark.image?)

然后查询下这个表：

```sql
SELECT * FROM student;
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/755b3fbf8c844f089877f1c5d8e7d569~tplv-k3u1fbpfcp-watermark.image?)

没什么数据。

我们插入一些：

```sql
INSERT INTO student (name, gender, age, class, score)
    VALUES 
        ('张三', '男',18, '一班',90),
        ('李四', '女',19, '二班',85),
        ('王五', '男',20, '三班',70),
        ('赵六', '女',18, '一班',95),
        ('钱七', '男',19, '二班',80),
        ('孙八', '女',20, '三班',75),
        ('周九', '男',18, '一班',85),
        ('吴十', '女',19, '二班',90),
        ('郑十一', '男',20, '三班',60),
        ('王十二', '女',18, '一班',95),
        ('赵十三', '男',19, '二班',75),
        ('钱十四', '女',20, '三班',80),
        ('孙十五', '男',18, '一班',90),
        ('周十六', '女',19, '二班',85),
        ('吴十七', '男',20, '三班',70),
        ('郑十八', '女',18, '一班',95),
        ('王十九', '男',19, '二班',80),
        ('赵二十', '女',20, '三班',75);
```

id 是自动递增的，不需要指定。

先选中执行 insert，再选中执行 select：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/985ad56ee0214a31992538552a1c9652~tplv-k3u1fbpfcp-watermark.image?)

插入了这样 18 条数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8a82e2ef1d4845b3ef13afe9f51257~tplv-k3u1fbpfcp-watermark.image?)

接下来就用这些数据来练习 sql：

首先，查询是可以指定查询的列的：

```sql
SELECT name, score FROM student;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9ec2a9908674897805c1a04325853be~tplv-k3u1fbpfcp-watermark.image?)

之前 select \* 是查询所有列的意思。

可以通过 as 修改返回的列名：

```sql
SELECT name as 名字, score as 分数 FROM student;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa114f531394a228cddaa53e753d7f8~tplv-k3u1fbpfcp-watermark.image?)

查询自然是可以带条件的，通过 where：

```sql
select name as 名字,class as 班级 from student where age >= 19;
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/137981fb9af04b53b13a2769d5acfd8e~tplv-k3u1fbpfcp-watermark.image?)

并且条件可以是 and 连接的多个：

```sql
select name as 名字,class as 班级 from student where gender='男' and score >= 90;
```

这里单双引号都可以。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/069640f216a84d25bef29d77331dd6ed~tplv-k3u1fbpfcp-watermark.image?)

可以看到，有两个成绩在 90 以上的男生。

你还可以用 LIKE 做模糊查询。

比如查询名字以“王”开头的学生：

```sql
select * from student where name like '王%';
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a037f08b25094d219d7d407bb3cb495c~tplv-k3u1fbpfcp-watermark.image?)

还可以通过 in 来指定一个集合：

```sql
select * from student where class in ('一班', '二班');
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a902ee4120a496fb6232f0be0b2ef89~tplv-k3u1fbpfcp-watermark.image?)

也可以 not in：

```sql
select * from student where class not in ('一班', '二班');
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9debf31e7bbf480ba0f7a84a717d765e~tplv-k3u1fbpfcp-watermark.image?)

in 指定的是一个集合，还可以通过 between and 来指定一个区间：

```sql
select * from student where age between 18 and 20;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8346de8e35041cb97ddc7cdb2d06bf2~tplv-k3u1fbpfcp-watermark.image?)

如果觉得返回的数量太多，可以分页返回，这个是通过 limit 实现的：

```sql
select * from student limit 0,5;
```

比如从 0 开始的 5 个：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4906c635918b43479c93a774a6442ddf~tplv-k3u1fbpfcp-watermark.image?)

这种也可以简化为：

```sql
select * from student limit 5;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d139a1cbc134100b9d85a7f466d7123~tplv-k3u1fbpfcp-watermark.image?)

第二页的数据：

```sql
select * from student limit 5,5;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03894f4fe17c4d0da3b22dc5befd4a2c~tplv-k3u1fbpfcp-watermark.image?)

此外，你可以通过 order by 来指定排序的列：

```sql
select name,score,age from student order by score asc,age desc;
```

order by 指定根据 score 升序排列，如果 score 相同再根据 age 降序排列。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5d571bfd71d44f6bd9fd324c0e2d471~tplv-k3u1fbpfcp-watermark.image?)

此外，还可以分组统计。

比如统计每个班级的平均成绩：

```sql
SELECT class as 班级, AVG(score) AS 平均成绩
    FROM student
    GROUP BY class
    ORDER BY 平均成绩 DESC;
```

这里用到不少新语法：

根据班级来分组是 GROUP BY class。

求平均成绩使用 sql 内置的函数 AVG()。

之后根据平均成绩来降序排列。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c25d09bfb214c769988b0c90e431a9c~tplv-k3u1fbpfcp-watermark.image?)

这种内置函数还有不少，比如 count：

```sql
select class, count(*) as count from student group by class;
```

这里的 \* 就代表当前行。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403176d8fe2744508ac82ef4e6a31621~tplv-k3u1fbpfcp-watermark.image?)

分组统计之后还可以做进一步的过滤，但这时候不是用 where 了，而是用 having：

```sql
SELECT class,AVG(score) AS avg_score
    FROM student
    GROUP BY class
    HAVING avg_score > 90;
```

不过滤的时候是这样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fff7977a66f4726950fa00673f19c6b~tplv-k3u1fbpfcp-watermark.image?)

过滤之后是这样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ba1a2ad339242208c13877346e2cdbc~tplv-k3u1fbpfcp-watermark.image?)

如果你想查看有哪些班级，可能会这样写：

```sql
SELECT class FROM student;
```

但这样会有很多重复的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf8b29e8f66640d0a79a127d3ce074a4~tplv-k3u1fbpfcp-watermark.image?)

这时候可以用 distinct 去重：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e2c454d3b9d4a499c1d876de0b7e047~tplv-k3u1fbpfcp-watermark.image?)

最后再来过一遍所有的内置函数，函数分为这么几类：

**聚合函数**：用于对数据的统计，比如 AVG、COUNT、SUM、MIN、MAX。

```sql
select avg(score) as 平均成绩,count(*) as 人数,sum(score) as 总成绩,min(score) as 最低分, max(score) as 最高分 from student 
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/593187d4e7894eea8f67e46706734172~tplv-k3u1fbpfcp-watermark.image?)

**字符串函数**：用于对字符串的处理，比如 CONCAT、SUBSTR、LENGTH、UPPER、LOWER。

```sql
SELECT CONCAT('xx', name, 'yy'), SUBSTR(name,2,3), LENGTH(name), UPPER('aa'), LOWER('TT') FROM student;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81123b35617c4000a00f16c38b896a8f~tplv-k3u1fbpfcp-watermark.image?)

其中，substr 第二个参数表示开始的下标（**mysql 下标从 1 开始**），所以 substr('一二三',2,3) 的结果是 '二三'。

当然，也可以不写结束下标 substr('一二三',2)

**数值函数**：用于对数值的处理，比如 ROUND、CEIL、FLOOR、ABS、MOD。

```sql
SELECT ROUND(1.234567, 2), CEIL(1.234567), FLOOR(1.234567), ABS(-1.234567), MOD(5, 2);
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72d16d627b6d4736a9a4bfc538d15664~tplv-k3u1fbpfcp-watermark.image?)

分别是 ROUND 四舍五入、CEIL 向上取整、FLOOR 向下取整、ABS 绝对值、MOD 取模。

**日期函数**：对日期、时间进行处理，比如 DATE、TIME、YEAR、MONTH、DAY
```sql
SELECT YEAR('2023-06-01 22:06:03'), MONTH('2023-06-01 22:06:03'),DAY('2023-06-01 22:06:03'),DATE('2023-06-01 22:06:03'), TIME('2023-06-01 22:06:03');
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adf55e56ad4040bfa39242f456fb9c5a~tplv-k3u1fbpfcp-watermark.image?)

**条件函数**：根据条件是否成立返回不同的值，比如 IF、CASE

```sql
select name, if(score >=60, '及格', '不及格') from student;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed0b5702340d4cc49e0237551d8af74b~tplv-k3u1fbpfcp-watermark.image?)

```sql
SELECT name, score, CASE WHEN score >=90 THEN '优秀' WHEN score >=60 THEN '良好'ELSE '差' END AS '档次' FROM student;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d37ab0b2e14476a93c7302a8bd66665~tplv-k3u1fbpfcp-watermark.image?)

if 和 case 函数和 js 里的 if、swtch 语句很像，很容易理解。

if 函数适合单个条件，case 适合多个条件。

**系统函数**：用于获取系统信息，比如 VERSION、DATABASE、USER。

    select VERSION(), DATABASE(), USER()

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd5ee8f1ecfd45c49bcf2a58586663b6~tplv-k3u1fbpfcp-watermark.image?)

**其他函数**：NULLIF、COALESCE、GREATEST、LEAST。

NULLIF：如果相等返回 null，不相等返回第一个值。

```sql
select NULLIF(1,1), NULLIF(1,2);
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f39ce16e5ef43b48911319d6119a954~tplv-k3u1fbpfcp-watermark.image?)

COALESCE：返回第一个非 null 的值：

```sql
select COALESCE(null, 1), COALESCE(null, null, 2)
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04525430993a41ceab4242f17a2a5ea3~tplv-k3u1fbpfcp-watermark.image?)

GREATEST、LEAST：返回几个值中最大最小的。

```sql
select GREATEST(1,2,3),LEAST(1,2,3,4);
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aec06f8dfa2b4f5f8227180b80e8ff67~tplv-k3u1fbpfcp-watermark.image?)

**类型转换函数**：转换类型为另一种，比如 CAST、CONVERT、DATE\_FORMAT、STR\_TO\_DATE。

比如下面的函数：

```sql
select greatest(1, '123',3);
```

3 最大，因为它并没有把 '123' 当成数字

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b10911293dd647c69a7ca49d1f21be62~tplv-k3u1fbpfcp-watermark.image?)

这时候就可以用 convert 或者 cast 做类型转换了：

```sql
select greatest(1, convert('123', signed),3);
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fe56c5a529b4e1fb3450470eef98dfb~tplv-k3u1fbpfcp-watermark.image?)

```sql
select greatest(1, cast('123' as signed),3);
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31c97f14a3fd40078f924b408451271c~tplv-k3u1fbpfcp-watermark.image?)

这里可以转换的类型有这些：

*   signed：整型；
*   unsigned：无符号整型
*   decimal：浮点型；
*   char：字符类型；
*   date：日期类型；
*   time：时间类型；
*   datetime：日期时间类型；
*   binary：二进制类型

剩下的 STR\_TO\_DATE 和 DATE\_FORMAT 还是很容易理解的：

```sql
SELECT DATE_FORMAT('2022-01-01', '%Y年%m月%d日');
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d0588a0456440fab1aef39e7ecba8ad~tplv-k3u1fbpfcp-watermark.image?)

```sql
SELECT STR_TO_DATE('2023-06-01', '%Y-%m-%d');
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50015449656042839010b8ed11e2575b~tplv-k3u1fbpfcp-watermark.image?)

至此，我们就把 sql 查询的语法和函数都过了一遍。

此外，你可能注意到，写 sql 的时候，我们有的时候用单双引号，有的时候用反引号，有的时候不加引号：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38934bb3a4d24b82808d79604d7f6de8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=672&h=364&s=66529&e=png&b=f7f7f7)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2ad567af50c4b5b93bf7588ee0274c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=564&h=184&s=23243&e=png&b=f7f7f7)

这里要注意下，当作字符串值用的时候，需要加单引号或者双引号。当作表名、列名用的时候，用反引号或者不加引号。

## 总结

我们连接 mysql 数据库，建了张 student 表，插入了一些数据，然后用这些数据来练习了各种查询语法和函数。

*   **where**：查询条件，比如 where id=1
*   **as**：别名，比如 select xxx as 'yyy'
*   **and**: 连接多个条件
*   **in/not in**：集合查找，比如 where a in (1,2)
*   **between and**：区间查找，比如 where a between 1 and 10
*   **limit**：分页，比如 limit 0,5
*   **order by**：排序，可以指定先根据什么升序、如果相等再根据什么降序，比如 order by a desc,b asc
*   **group by**：分组，比如 group by aaa
*   **having**：分组之后再过滤，比如 group by aaa having xxx > 5
*   **distinct**：去重

sql 还可以用很多内置函数：

*   聚合函数：avg、count、sum、min、max
*   字符串函数：concat、substr、length、upper、lower
*   数值函数：round、ceil、floor、abs、mod
*   日期函数：year、month、day、date、time
*   条件函数：if、case
*   系统函数：version、datebase、user
*   类型转换函数：convert、cast、date\_format、str\_to\_date
*   其他函数：nullif、coalesce、greatest、least

灵活掌握这些语法，就能写出各种复杂的查询语句。


## 39.一对一、join 查询、级联方式

数据库中会有很多的表，分别存储不同的信息，比如学生表存学生的信息、老师表存老师的信息，班级表存班级的信息。

这些表之间不是孤立的，有着一定的关系。

比如班级和学生之间是一对多的关系，也就是一个班级可以有多个学生。

班级和老师之间是多对多的关系，也就是一个班级可以有多个老师，一个老师也可以教多个班级。

如果存储一对一、一对多、多对多这些关系呢？

这就涉及到外键了。

比如一对一的关系，一个用户只能有一个身份证。

这样两个表，分别存储用户信息，还有身份证信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7ac9f4ac6fa4e93b2c51b66d9757b9c~tplv-k3u1fbpfcp-watermark.image?)

它们之间是一对一的关系，这时就可以用外键来表示。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/520ee3961ce045fd8dae99388f04821d~tplv-k3u1fbpfcp-watermark.image?)

user 表的主键是 id、可以通过 id 来唯一标识一个 user。

那 id\_card 想查找 user，自然也是通过 id 来查找，多一个列来存储 user id 就可以实现这种一对一的关联。

这个 user\_id 的列就是外键。

user 表叫主表，使用外键引用它的 id\_card 表是从表。

我们建个表来试试看：

选中 hello-mysql 数据库，点击建表按钮：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7057a83d1824e18af6e798da0120281~tplv-k3u1fbpfcp-watermark.image?)

分别添加 id、name 列：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72b3b3f6baa447d185a4c4df8ea2a8b0~tplv-k3u1fbpfcp-watermark.image?)

点击 apply，建表 sql 如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a3a93170424521a193b2c303b6bfc2~tplv-k3u1fbpfcp-watermark.image?)

你也可以直接用这个 sql 来建表：

```sql
CREATE TABLE `hello-mysql`.`user` (
  `id` INT NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` VARCHAR(45) NOT NULL COMMENT '名字',
  PRIMARY KEY (`id`)
);
```

然后再建个 id\_card 表：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65592844feda4d7f808aa44e9e610791~tplv-k3u1fbpfcp-watermark.image?)

id 为 INT 类型，设置 primary key、not null 的约束，然后设置 auto increment。

card\_name 为 VARCHAR(45) 类型，设置 not null 的约束

user\_id 为 INT 类型。

然后添加外键：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb36a6531bff4f9eb99d1bd6d7194e0c~tplv-k3u1fbpfcp-watermark.image?)

指定外键 user\_id 关联 user 表的 id。

这里还要选择主表数据 update 或者 delete 的时候，从表怎么办：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56073e48339c461a8dac495f096f71f3~tplv-k3u1fbpfcp-watermark.image?)

我们先用默认的。

点击 apply，生成的建表 sql 是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2579cd003f0a4b58aef966455cee8961~tplv-k3u1fbpfcp-watermark.image?)

```sql
CREATE TABLE `id_card` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'id',
  `card_name` varchar(45) NOT NULL COMMENT '身份证号',
  `user_id` int DEFAULT NULL COMMENT '用户 id',
  PRIMARY KEY (`id`),
  INDEX `card_id_idx` (`user_id`),
  CONSTRAINT `user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
)  CHARSET=utf8mb4
```

**这些建表 sql 的语法了解即可，一般不会自己写。**

前面的三行都比较好理解，就是指定每一列的类型、约束、注释。

PRIMARY KEY 是指定 id 为主键。

INDEX 是建立索引，索引名是 card\_id\_idex，这个是用于加速 user\_id 的访问的。

CONSTRINT user\_id FOREIGN KEY 是给 user\_id 添加一个外键约束，然后 user\_id REFERENCES user id 则是指定 user\_id 引用这 user 表的 id 列。

然后就可以看到 user 和 id\_card 表了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4f50e3b75404fbdb9ecbe1796f9ca61~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36c8133bcdc0463f956c39d24a38521c~tplv-k3u1fbpfcp-watermark.image?)

我们插入几条数据：

```sql
INSERT INTO `user` (`name`)
	VALUES
		('张三'),
		('李四'),
		('王五'),
		('赵六'),
		('孙七'),
		('周八'),
		('吴九'),
		('郑十'),
		('钱十一'),
		('陈十二'); 
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd7df24a9d3541e189f20fe390689ecc~tplv-k3u1fbpfcp-watermark.image?)

查询一下：

```sql
SELECT * FROM user;
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72b370030a3f4fb38443d1cc21e7f357~tplv-k3u1fbpfcp-watermark.image?)

用户表数据成功插入了。

再插入 id\_card 表的数据：

```sql
INSERT INTO id_card (card_name, user_id) 
    VALUES
        ('110101199001011234',1),
	('310101199002022345',2),
	('440101199003033456',3),
	('440301199004044567',4),
	('510101199005055678',5),
	('330101199006066789',6),
	('320101199007077890',7),
	('500101199008088901',8),
	('420101199009099012',9),
	('610101199010101023',10);
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38421eabe50d418585e0ecce78195352~tplv-k3u1fbpfcp-watermark.image?)

查询一下：

```sql
SELECT * FROM id_card;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2eedd5e4bb341288dfac40eb154fb28~tplv-k3u1fbpfcp-watermark.image?)

这样，一对一关系的数据就插入成功了。

那怎么关联查出来呢？

这样：

```sql
SELECT * FROM user JOIN id_card ON user.id = id_card.user_id;
```

这里用到了 JOIN ON，也就是连接 user 和 id\_card 表，关联方式是 user.id = id\_card.user\_id，也就是 id\_card 表中的外键关联 user 表的主键。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/520ee3961ce045fd8dae99388f04821d~tplv-k3u1fbpfcp-watermark.image?)

点击左上角按钮，新建一条 sql：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09826ae8450342d39f1649a1e4b7648b~tplv-k3u1fbpfcp-watermark.image?)

查询的结果是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ec86f4db396478b8561852175421b43~tplv-k3u1fbpfcp-watermark.image?)

这里的两个 id 分别是 user 和 card 的 id，而且后面的 user\_id 也没必要展示。

我们改下 sql：

```sql
SELECT user.id, name, id_card.id as card_id, card_name 
    FROM user
    JOIN id_card ON user.id = id_card.user_id;
```

指定显示的列，并给 id\_card 表的 id 起个 card\_id 的别名。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c680ece661bf4157b02913f5479f43a0~tplv-k3u1fbpfcp-watermark.image?)

这就是多表关联查询，语法是 JOIN ON。

有同学可能问了，那如果 id\_card 表里有的没有关联 user 呢？

比如这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c75226700d694130a11039f6ca2e718e~tplv-k3u1fbpfcp-watermark.image?)

选中单元格，点击 delete 就可以把它置为 null。

我们把 id\_card 表的最后两条记录的 user\_id 删掉，点击 apply。

这时候再执行上面那条 sql 来查询，就可以看到少了两条记录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9960fb6c72374da09f8b5977aab243e1~tplv-k3u1fbpfcp-watermark.image?)

因为 JOIN ON 其实默认是 INNER JOIN ON，相当于这么写：

```sql
SELECT user.id, name, id_card.id as card_id, card_name 
    FROM user
    INNER JOIN id_card ON user.id = id_card.user_id;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cc40772e66742e19e0ab1a97961173a~tplv-k3u1fbpfcp-watermark.image?)

INNER JOIN 是只返回两个表中能关联上的数据。

你还可以指定其余 2 种 join 类型：

LEFT JOIN 是额外返回左表中没有关联上的数据。

RIGHT JOIN 是额外返回右表中没有关联上的数据。

**在 FROM 后的是左表，JOIN 后的表是右表。**

我们来试一下：

```sql
SELECT user.id, name, id_card.id as card_id, card_name 
    FROM user
    RIGHT JOIN id_card ON user.id = id_card.user_id;
```

当使用 RIGHT JOIN 时，会额外返回右表中没有关联的数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de446edf08e04ef0af975b87d5bdd0fc~tplv-k3u1fbpfcp-watermark.image?)

可以看到返回了所有 id\_card 的数据，没有关联 user 的记录 user 信息为 null。

当时用 LEFT JOIN 时，正好相反：

```sql
SELECT user.id, name, id_card.id as card_id, card_name 
    FROM user
    LEFT JOIN id_card ON user.id = id_card.user_id;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cf88544235e462d8c3ea2d34e9a5077~tplv-k3u1fbpfcp-watermark.image?)

一般情况，还是用默认的 JOIN ON 比较多，也就是 INNER JOIN。

前面还讲到了删除和更新时的级联操作。

也就是当 user 删除的时候，关联的 id\_card 要不要删除？

当 user 的 id 修改的时候，关联的 id\_card 要不要改 user\_id？

我们之前设置的是默认的 RESTICT：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2134c6a4b35a43fc86935a968942810a~tplv-k3u1fbpfcp-watermark.image?)

其实可选的值有 4 种：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f5ab0aabb994bf99731137c9475d804~tplv-k3u1fbpfcp-watermark.image?)

*   CASCADE： 主表主键更新，从表关联记录的外键跟着更新，主表记录删除，从表关联记录删除

*   SET NULL：主表主键更新或者主表记录删除，从表关联记录的外键设置为 null

*   RESTRICT：只有没有从表的关联记录时，才允许删除主表记录或者更新主表记录的主键 id

*   NO ACTION： 同 RESTRICT，只是 sql 标准里分了 4 种，但 mysql 里 NO ACTION 等同于 RESTRICT。

这里不理解不要紧，我们试一下：

现在 user 表是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25ebae1ab06b4097a745c443fda34359~tplv-k3u1fbpfcp-watermark.image?)

右键选择 delete row：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6a77afd4f704c56849a1cd8150197c3~tplv-k3u1fbpfcp-watermark.image?)

这时候会提示你更新失败，因为有外键的约束。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f91da3522b949c684beab76fe7b6ecf~tplv-k3u1fbpfcp-watermark.image?)

点击 revert，回到之前的状态：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4f8b0cfd8244a67a29a3d616fdcaac6~tplv-k3u1fbpfcp-watermark.image?)

然后更新 id 为 11，点击 apply：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d889df506c704bc0904933f2cf5857d0~tplv-k3u1fbpfcp-watermark.image?)

同样会提示你更新失败，因为有外键的约束：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6186789b3a447c6b8ab327a1e5b1d67~tplv-k3u1fbpfcp-watermark.image?)

这就是 **RESTIRCT 和 NO ACTION 的处理逻辑：只要从表有关联记录，就不能更新 id 或者删除记录。**

我们手动把从表记录的关联去掉，也就是删除第一条记录的外键（按 delete 键）：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb9535d02ee544368a49d8d69a5b3377~tplv-k3u1fbpfcp-watermark.image?)

点击 apply 应用这次改动。

然后再试下主表的更新：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32d11bccbbe14d9e996415f0573feb1c~tplv-k3u1fbpfcp-watermark.image?)

这次就更新成功了！

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9536fecbfb6b4b1a8efd34aa23a462f0~tplv-k3u1fbpfcp-watermark.image?)

再来试下删除：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7e5128b7cfd46d7a8a553c46afa0a44~tplv-k3u1fbpfcp-watermark.image?)

同样也成功了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a81c40fb7a486cab97c966b59f4f32~tplv-k3u1fbpfcp-watermark.image?)

这就是 RESTRICT 或者 NO ACTION，只有当从表没有关联的记录的时候，才能更新主表记录的 id 或者删除它。

我们再来试试 CASCADE：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7357d1bb3a1466c987c58905178e481~tplv-k3u1fbpfcp-watermark.image?)

修改外键级联方式为 CASCADE，点击 apply。

先看一下现在 id\_card 表的数据：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85c3956e9a44336b58a4c13861d9c0c~tplv-k3u1fbpfcp-watermark.image?)

把 id 为 2 的 user 的 id 改为 22，点击 apply：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42c706c63fa04056a8374adbe6d30bc3~tplv-k3u1fbpfcp-watermark.image?)

再看下 id\_card 表的数据，你会发现 user\_id 跟着改了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dedfb9e04484069970d2efa76bdc6fb~tplv-k3u1fbpfcp-watermark.image?)

然后把 id 为 22 的 user 删除掉，点击 apply：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb22b69d3f774ab1846093ff1d97a924~tplv-k3u1fbpfcp-watermark.image?)

再看下 id\_card 表会发现那条 user\_id 为 22 的记录也没了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26d293ab656f406db2a4204f673764d2~tplv-k3u1fbpfcp-watermark.image?)

这就是级联方式为 **CASCADE 的处理逻辑：主表删除，从表关联记录也级联删除，主表 id 更新，从表关联记录也跟着更新。**

然后再试下 set null：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66cda20b31a34821a2f3778fc0ccf47d~tplv-k3u1fbpfcp-watermark.image?)

修改之后点击 apply。

查询下现在的 id\_card 表的数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec6ad89254d42a79a0326f506266493~tplv-k3u1fbpfcp-watermark.image?)

把 user 表中 id 为 5 的记录 id 改为 55，点击 apply：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6477a549c9024a42b5b6e90b2d779660~tplv-k3u1fbpfcp-watermark.image?)

这时候 id\_card 中那条记录的外键被置为 null 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfbe2579e22c4d749de268738df1a8f5~tplv-k3u1fbpfcp-watermark.image?)

这就是 **set null 的处理逻辑：主表记录删除或者修改 id，从表关联记录外键置为 null。**

## 总结

这节我们学习了一对一的数据表设计，在从表里通过外键来关联主表的主键。

查询的时候需要使用 join on，默认是 inner join 也就是只返回有关联的记录，也可以用 left join、right join 来额外返回没有关联记录的左表或右表的记录。

from 后的是左表，join 后的是右表。

此外，外键还可以设置级联方式，也就是主表修改 id 或者删除的时候，从表怎么做。

有 3 种级联方式：CASCADE（关联删除或更新），SET NULL（关联外键设置为 null），RESTRICT 或者 NO ACTION（没有从表的关联记录才可以删除或更新）

多表的连接是非常常用的操作，下节我们继续学习一对多和多对多的数据表设计。


## 4.5 种 HTTP 数据传输方式

对于前端来说，后端主要是提供 http 接口来传输数据，而这种数据传输的方式主要有 5 种：

*   url param
*   query
*   form-urlencoded
*   form-data
*   json

我们分别来看一下：

## url param

我们可以把参数写在 url 中，比如：

    http://guang.zxg/person/1111

这里的 1111 就是路径中的参数（url param），服务端框架或者单页应用的路由都支持从 url 中取出参数。

## query

通过 url 中 ？后面的用 & 分隔的字符串传递数据。比如：
```
http://guang.zxg/person?name=guang&age=20
```
这里的 name 和 age 就是 query 传递的数据。

其中非英文的字符和一些特殊字符要经过编码，可以使用 encodeURIComponent 的 api 来编码：
```javascript
const query = "?name=" + encodeURIComponent('光') + "&age=20"

// ?name=%E5%85%89&age=20
```
或者使用封装了一层的 query-string 库来处理。

```javascript
const queryString = require('query-string');

queryString.stringify({
  name: '光',
  age: 20
});

// ?name=%E5%85%89&age=20
```

## form-urlencoded

直接用 form 表单提交数据就是这种，它和 query 字符串的方式的区别只是放在了 body 里，然后指定下 content-type 是 `application/x-www-form-urlencoded`。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b09a4411e26a40a0be7272dae3213eeb~tplv-k3u1fbpfcp-watermark.image?)

因为内容也是 query 字符串，所以也要用 encodeURIComponent 的 api 或者 query-string 库处理下。

这种格式也很容易理解，get 是把数据拼成 query 字符串放在 url 后面，于是表单的 post 提交方式的时候就直接用相同的方式把数据放在了 body 里。

通过 & 分隔的 form-urlencoded 的方式需要对内容做 url encode，如果传递大量的数据，比如上传文件的时候就不是很合适了，因为文件 encode 一遍的话太慢了，这时候就可以用 form-data。

## form-data

form data 不再是通过 & 分隔数据，而是用 --------- + 一串数字做为 boundary 分隔符。因为不是 url 的方式了，自然也不用再做 url encode。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af563395e1984ea5b90a19a04ce6730f~tplv-k3u1fbpfcp-watermark.image?)

form-data 需要指定 content type 为 `multipart/form-data`，然后指定 boundary 也就是分割线。

body 里面就是用 boundary 分隔符分割的内容。

很明显，这种方式适合传输文件，而且可以传输多个文件。

但是毕竟多了一些只是用来分隔的 boundary，所以请求体会增大。

## json

form-urlencoded 需要对内容做 url encode，而 form data 则需要加很长的 boundary，两种方式都有一些缺点。如果只是传输 json 数据的话，不需要用这两种。

可以直接指定content type 为 application/json 就行：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c429166d35264cea922ebe45d399d4ef~tplv-k3u1fbpfcp-watermark.image?)

我们平时传输 json 数据基本用的是这种。

那这 5 种接口怎么用 Nest 实现呢？

我们分别看一下：

首先我们要把 Nest 服务端跑起来，并且支持 api 接口、静态页面。

Nest 创建一个 crud 服务是非常快的，只需要这么几步：

*   安装 @nestjs/cli，使用 nest new xxx 创建一个 Nest 的项目，
```
nest new xxx
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a973017feb47e48e69c5054b2faa83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=738&s=241806&e=png&b=010101)

*   在根目录执行 nest g resource person 快速生成 person 模块的 crud 代码
```
nest g resource person
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11b0c13aa815440eac113ad6b73f42a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=458&s=111235&e=png&b=191919)

*   nest start --watch 启动 Nest 服务
```
nest start --watch
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a5e59b898a14bfbbfa649299f91d2ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1536&h=550&s=228917&e=png&b=181818)

这样一个有 person 的 crud 接口的服务就跑起来了。

服务跑起来以后是这样的

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47547045ae0e48f0959e9f52b284cfe7~tplv-k3u1fbpfcp-watermark.image?)

打印出了有哪些接口可以用，可以在浏览器测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b290de4da2f249358342ceb7aa3c3dcf~tplv-k3u1fbpfcp-watermark.image?)

api 接口跑通了，再支持下静态资源的访问：

main.ts 是负责启动 Nest 的 ioc 容器的，调用下 useStaticAssets 来支持静态资源的请求：

```typescript
import { NestExpressApplication } from '@nestjs/platform-express';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  app.useStaticAssets('public', { prefix: '/static'});
  await app.listen(3000);
}
bootstrap();
```

（注意要给 create 方法传入 NestExpressApplication 的泛型参数才有 useStaticAssets这些方法）

我们指定 prefix 为 static，然后在静态文件目录 public 下添加一个 html：

```html
<html>
<body>hello</body>
</html>
```

重启服务，然后浏览器访问下试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a1c5ea5d5c44227b083db1bd516f950~tplv-k3u1fbpfcp-watermark.image?)

api 接口和静态资源的访问都支持了，接下来就分别实现下 5 种前后端 http 数据传输的方式吧。

## url param

url param 是 url 中的参数，Nest 里通过 :参数名 的方式来声明（比如下面的 :id），然后通过 @Param(参数名) 的装饰器取出来注入到 controller：

```typescript
@Controller('api/person')
export class PersonController {
  @Get(':id')
  urlParam(@Param('id') id: string) {
    return `received: id=${id}`;
  }
}
```

@Controller('api/person') 的路由和 @Get(':id') 的路由会拼到一起，也就是只有 /api/person/xxx 的 get 请求才会走到这个方法。

前端代码就是一个 get 方法，参数放在 url 里：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <script>
        async function urlParam() {
            const res = await axios.get('/api/person/1');
            console.log(res);            
        }
        urlParam();
   </script>
</body>
```

启动服务，在浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03cc5b8bea74411eb1d2c13ff9951be2~tplv-k3u1fbpfcp-watermark.image?)

控制台打印了服务端返回的消息，证明服务端拿到了通过 url param 传递的数据。

通过 url 传递数据的方式除了 url param 还有 query：

## query

query 是 url 中 ? 后的字符串，需要做 url encode。

在 Nest 里，通过 @Query 装饰器来取：

```typescript
@Controller('api/person')
export class PersonController {
  @Get('find')
  query(@Query('name') name: string, @Query('age') age: number) {
    return `received: name=${name},age=${age}`;
  }
}
```

注意，这个 find 的路由要放到 :id 的路由前面，因为 Nest 是从上往下匹配的，如果放在后面，那就匹配到 :id 的路由了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c07cbcf33e64205904f6dd0a813cda6~tplv-k3u1fbpfcp-watermark.image?)

前端代码同样是通过 axios 发送一个 get 请求：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <script>
        async function query() {
            const res = await axios.get('/api/person/find', {
                params: {
                    name: '光',
                    age: 20
                }
            });
            console.log(res);            
        }
        query();
   </script>
</body>
</html>
```

参数通过 params 指定，axios 会做 url encode，不需要自己做。

然后测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4648b0e210f49f2885e0f2e10654cdc~tplv-k3u1fbpfcp-watermark.image?)

服务端成功接受了我们通过 query 传递的数据。

上面两种（url param、query）是通过 url 传递数据的方式，下面 3 种是通过 body 传递数据。

## form urlencoded

form urlencoded 是通过 body 传输数据，其实是把 query 字符串放在了 body 里，所以需要做 url encode：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e33a33bdee4541eaab6af22108010161~tplv-k3u1fbpfcp-watermark.image?)

用 Nest 接收的话，使用 @Body 装饰器，Nest 会解析请求体，然后注入到 dto 中。

dto 是 data transfer object，就是用于封装传输的数据的对象：

```typescript
export class CreatePersonDto {
    name: string;
    age: number;
}
```

```typescript
import { CreatePersonDto } from './dto/create-person.dto';

@Controller('api/person')
export class PersonController {
  @Post()
  body(@Body() createPersonDto: CreatePersonDto) {
    return `received: ${JSON.stringify(createPersonDto)}`
  }
}
```

前端代码使用 post 方式请求，指定 content type 为 `application/x-www-form-urlencoded`，用 qs 做下 url encode：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
    <script src="https://unpkg.com/qs@6.10.2/dist/qs.js"></script>
</head>
<body>
    <script>
        async function formUrlEncoded() {
            const res = await axios.post('/api/person', Qs.stringify({
                name: '光',
                age: 20
            }), {
                headers: { 'content-type': 'application/x-www-form-urlencoded' }
            });
            console.log(res);  
        }

        formUrlEncoded();
    </script>
</body>
</html>
```

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2579657d1464c618e7ef7f5b1032f2d~tplv-k3u1fbpfcp-watermark.image?)

服务端成功的接收到了数据。

其实比起 form urlencoded，使用 json 来传输更常用一些：

## json

json 需要指定 content-type 为 `application/json`，内容会以 JSON 的方式传输：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e8cb55184943d9be3df6ccf9644f74~tplv-k3u1fbpfcp-watermark.image?)

后端代码同样使用 @Body 来接收，不需要做啥变动。form urlencoded 和 json 都是从 body 取值，Nest 内部会根据 content type 做区分，使用不同的解析方式。

```typescript
@Controller('api/person')
export class PersonController {
  @Post()
  body(@Body() createPersonDto: CreatePersonDto) {
    return `received: ${JSON.stringify(createPersonDto)}`
  }
}
```

前端代码使用 axios 发送 post 请求，默认传输 json 就会指定 content type 为 `application/json`，不需要手动指定：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <script>
        async function json() {
            const res = await axios.post('/api/person', {
                name: '光',
                age: 20
            });
            console.log(res);     
        }
        json();
    </script>
</body>
</html>
```

测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8976bc8696d846a58e4812a7ab5f6d2f~tplv-k3u1fbpfcp-watermark.image?)

服务端成功接收到了通过 json 传递的数据！

json 和 form urlencoded 都不适合传递文件，想传输文件要用 form data：

## form data

form data 是用 -------- 作为 boundary 分隔传输的内容的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e22d13b586a4d358cb569acd4cf35dc~tplv-k3u1fbpfcp-watermark.image?)

Nest 解析 form data 使用 FilesInterceptor 的拦截器，用 @UseInterceptors 装饰器启用，然后通过 @UploadedFiles 来取。非文件的内容，同样是通过 @Body 来取。

```typescript
import { AnyFilesInterceptor } from '@nestjs/platform-express';
import { CreatePersonDto } from './dto/create-person.dto';

@Controller('api/person')
export class PersonController {
  @Post('file')
  @UseInterceptors(AnyFilesInterceptor({
      dest: 'uploads/'
  }))
  body2(@Body() createPersonDto: CreatePersonDto, @UploadedFiles() files: Array<Express.Multer.File>) {
    console.log(files);
    return `received: ${JSON.stringify(createPersonDto)}`
  }
}
```

这一步需要

    npm i -D @types/multer

引入相关类型声明。

前端代码使用 axios 发送 post 请求，指定 content type 为 `multipart/form-data`：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://unpkg.com/axios@0.24.0/dist/axios.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file" multiple/>
    <script>
        const fileInput = document.querySelector('#fileInput');

        async function formData() {
            const data = new FormData();
            data.set('name','光');
            data.set('age', 20);
            data.set('file1', fileInput.files[0]);
            data.set('file2', fileInput.files[1]);

            const res = await axios.post('/api/person/file', data, {
                headers: { 'content-type': 'multipart/form-data' }
            });
            console.log(res);     
        }

        fileInput.onchange = formData;
    </script>
</body>
</html>
```

file input 指定 multiple 可以选择多个文件。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29fbb5ee24af48c1b1744c129c77fb7a~tplv-k3u1fbpfcp-watermark.image?)

服务端接收到了 name 和 age：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c56d6418815c4726a493d4f1ffef72b0~tplv-k3u1fbpfcp-watermark.image?)

去服务器控制台看下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8924b69b7c044b65a475ad8576f6c549~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78efe5d63a0846799583ca66f3dc5c39~tplv-k3u1fbpfcp-watermark.image?)

可以看到，服务器成功的接收到了我们上传的文件。

代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/five-transmission-method)里，可以跑跑试试。

## 总结

我们用 axios 发送请求，使用 Nest 起后端服务，实现了 5 种 http/https 的数据传输方式：

其中前两种是 url 中的：

*   **url param**： url 中的参数，Nest 中使用 @Param 来取
*   **query**：url 中 ? 后的字符串，Nest 中使用 @Query 来取

后三种是 body 中的：

*   **form urlencoded**： 类似 query 字符串，只不过是放在 body 中。Nest 中使用 @Body 来取，axios 中需要指定 content type 为 `application/x-www-form-urlencoded`，并且对数据用 qs 或者 query-string 库做 url encode
*   **json**： json 格式的数据。Nest 中使用 @Body 来取，axios 中不需要单独指定 content type，axios 内部会处理。
*   **form data**：通过 ----- 作为 boundary 分隔的数据。主要用于传输文件，Nest 中要使用 FilesInterceptor 来处理其中的 binary 字段，用 @UseInterceptors 来启用，其余字段用 @Body 来取。axios 中需要指定 content type 为 `multipart/form-data`，并且用 FormData 对象来封装传输的内容。

这 5 种 http 的传输数据的方式覆盖了绝大多数开发场景，如果你想进阶全栈，理解这 5 种接口是首先要做到的。


## 40.一对多、多对多关系的表设计

上节我们学了一对一，这节继续来学习一对多和多对多。

一对多关系在生活中随处可见：

一个作者可以写多篇文章，而每篇文章只属于一个作者。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/652efb6bbd7d4af1945b0fe912bd2d91~tplv-k3u1fbpfcp-watermark.image?)

一个订单有多个商品，而商品只属于一个订单。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37e82479d7ae4e7c88c4df4cf040c2d5~tplv-k3u1fbpfcp-watermark.image?)

一个部门有多个员工，员工只属于一个部门。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f79387f8934e468ca0406b7aca4ebfb6~tplv-k3u1fbpfcp-watermark.image?)

多对多的关系也是随处可见：

一篇文章可以有多个标签，一个标签可以多篇文章都有。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81b2e6cef1fc4480b98a760bd61ad21a~tplv-k3u1fbpfcp-watermark.image?)

一个学生可以选修多门课程，一门课程可以被多个学生选修。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a409a01fd32a431c9b378f4ebc7a12f6~tplv-k3u1fbpfcp-watermark.image?)

一个用户可以有多个角色，一个角色可能多个用户都有。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a70416ef1fbb49c393791a640417a217~tplv-k3u1fbpfcp-watermark.image?)

那在数据库里如何建模这种关系呢？

我们分别来看一下：

一对多的关系，比如一个部门有多个员工。

我们会有一个部门表和一个员工表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f5d802c0ba43edb12f9f42b2b1a164~tplv-k3u1fbpfcp-watermark.image?)

在员工表添加外键 department\_id 来表明这种多对一关系：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64756ca65ed24454a697dd63ad464665~tplv-k3u1fbpfcp-watermark.image?)

其实和一对一关系的数据表设计是一样的。

我们添加这两个表。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb781961d67349df83a62d1ea9d537fd~tplv-k3u1fbpfcp-watermark.image?)

分别指定 id 是 INT，约束为 primary key、not null、 auto increment 。

name 是 VARCHAR(45)，约束为 not null。

点击 apply。

建表 sql 如下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d800b3a5b52e4cd08021bb382ff7f046~tplv-k3u1fbpfcp-watermark.image?)

同样的方式创建 employee 表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c81a5a5fa9d444eb9879cc253ce96182~tplv-k3u1fbpfcp-watermark.image?)

添加 id、name、department\_id 这 3 列。

然后添加一个外键约束，department\_id 列引用 department 的 id 列。

设置级联删除和更新为 SET NULL。

因为部门没了员工不一定也没了，可能还会分配到别的部门。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11d37ef48b084490829dd6b95661f2a7~tplv-k3u1fbpfcp-watermark.image?)

点击 apply 就创建成功了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbcaab19008040de896a2b34ae6a6224~tplv-k3u1fbpfcp-watermark.image?)

sql 的最后这段，就是创建了一个外键约束，department\_id 引用了 department 表的 id，设置级联删除和更新方式为 SET NULL。

我们往部门表插入几条数据：

```sql
INSERT INTO `department` (`id`, `name`) 
    VALUES 
        (1, '人事部'),
        (2, '财务部'),
        (3, '市场部'),
        (4, '技术部'),
        (5, '销售部'),
        (6, '客服部'),
        (7, '采购部'),
        (8, '行政部'),
        (9, '品控部'),
        (10, '研发部');
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/160dc8d459a94f399d806fc20b11b43f~tplv-k3u1fbpfcp-watermark.image?)

查询下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fc0b543e81744379997379aff4be053~tplv-k3u1fbpfcp-watermark.image?)

插入成功了。

再往员工表里插入几条数据：

```sql
INSERT INTO `employee` (`id`, `name`, `department_id`)
    VALUES 
        (1, '张三', 1),
        (2, '李四', 2), 
        (3, '王五', 3),
        (4, '赵六', 4),
        (5, '钱七', 5),
        (6, '孙八', 5),
        (7, '周九', 5),
        (8, '吴十', 8),
        (9, '郑十一', 9),
        (10, '王十二', 10);
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb0f9cdf5da544c6be870a1567f2810b~tplv-k3u1fbpfcp-watermark.image?)

查询下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b747f3ce1a3d43f3932cec8252f4c9b8~tplv-k3u1fbpfcp-watermark.image?)

同样插入成功了。

我们通过 JOIN ON 关联查询下 id 为 5 的部门的所有员工：

```sql
select * from department
    join employee on department.id = employee.department_id
    where department.id = 5
```

可以看到，正确查找出了销售部的 3 个员工：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08df65c6051e47d09a61c0e7da966d0a~tplv-k3u1fbpfcp-watermark.image?)

JOIN ON 默认是 INNER JOIN。

我们再来试试 LEFT JOIN 和 RIGHT JOIN：

```sql
select * from department
    left join employee on department.id = employee.department_id
```

from 后的是左表，可以看到两个还没有员工的部门也显示在了结果里：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24843da482240e18cdadd6eebde39b5~tplv-k3u1fbpfcp-watermark.image?)

然后是 RIGHT JOIN：

```sql
select * from department
    right join employee on department.id = employee.department_id
```

因为所有的员工都是有部门的，所以和 inner join 结果一样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a840b3551493482eb34c1a1adc6040ec~tplv-k3u1fbpfcp-watermark.image?)

然后把 id 为 5 的部门删掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11531d9ed451400899f99b1b7c495492~tplv-k3u1fbpfcp-watermark.image?)

点击 apply。

再查看下员工表，可以看到销售部下的 3 个员工的部门被设置为 null 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4779de3dd6346e3ad5919064df95aff~tplv-k3u1fbpfcp-watermark.image?)

这就是 set null 的级联删除处理。

一对多是不是还挺简单的？

确实，它和一对一没啥本质的区别。

接下来我们来看多对多。

比如文章和标签：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81b2e6cef1fc4480b98a760bd61ad21a~tplv-k3u1fbpfcp-watermark.image?)

之前一对多关系是通过在多的一方添加外键来引用一的一方的 id。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64756ca65ed24454a697dd63ad464665~tplv-k3u1fbpfcp-watermark.image?)

但是现在是多对多了，每一方都是多的一方。这时候是不是双方都要添加外键呢？

一般我们是这样设计：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d79e2c5f5ec48a8952acbfb8803f986~tplv-k3u1fbpfcp-watermark.image?)

文章一个表、标签一个表，这两个表都不保存外键，然后添加一个中间表来保存双方的外键。

这样文章和标签的关联关系就都被保存到了这个中间表里。

我们试一下：

这次我们就直接通过 sql 建表了：

```sql
CREATE TABLE `article` (
 `id` INT NOT NULL AUTO_INCREMENT,
 `title` VARCHAR(50) NOT NULL,
 `content` TEXT NOT NULL,
 PRIMARY KEY (`id`)
) CHARSET=utf8mb4;
```

这里的 TEXT 是长文本类型，可以存储 65535 长度的字符串。

执行这个建表 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22b23ebf6220425cb8eb7be14c176f01~tplv-k3u1fbpfcp-watermark.image?)

查询下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9cc1e45c079457eb7c4a5f9ec8554e8~tplv-k3u1fbpfcp-watermark.image?)

插入几条数据：

```sql
INSERT INTO `article` (`title`, `content`)
    VALUES
            ('文章1', '这是文章1的内容。'),
            ('文章2', '这是文章2的内容。'),
            ('文章3', '这是文章3的内容。'),
            ('文章4', '这是文章4的内容。'),
            ('文章5', '这是文章5的内容。');
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b69641eec4e4028aed5c1f585d5ebe2~tplv-k3u1fbpfcp-watermark.image?)

再查询下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b7cee2d3ec6468f9a26c9f2a221ba56~tplv-k3u1fbpfcp-watermark.image?)

然后创建标签表：

```sql
CREATE TABLE `tag` (
 `id` INT NOT NULL AUTO_INCREMENT,
 `name` VARCHAR(50) NOT NULL,
 PRIMARY KEY (`id`)
);
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f51bd0fb499a4bd6b740baf668e9618e~tplv-k3u1fbpfcp-watermark.image?)

插入几条数据：

```sql
INSERT INTO `tag` (`name`)
    VALUES
            ('标签1'),
            ('标签2'),
            ('标签3'),
            ('标签4'),
            ('标签5');
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1415d1e4d20541588967e5beb89fe42d~tplv-k3u1fbpfcp-watermark.image?)

然后查询下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0895d5da88408abae571f7cbb5deef~tplv-k3u1fbpfcp-watermark.image?)

可以看到，建表和插入数据都成功了。

然后创建中间表：

中间表还是通过可视化的方式创建吧：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb5af2a291d1476a9d815b39908dc5f8~tplv-k3u1fbpfcp-watermark.image?)

点击创建表，添加 article\_id、tag\_id 这俩列，设置为 NOT NULL。

注意，这里同时指定这两列为 primary key，也就是复合主键。

添加 article\_id 和 tag\_id 的外键引用：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81aeca81fd1d44cc80178450616839bb~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e1d10b9202a4764b680db4d98078322~tplv-k3u1fbpfcp-watermark.image?)

**中间表的级联方式要设置为 CASCADE，这个是固定的。**

因为它就是用来保存关系的，如果关联的记录都没了，这个关系也就没存在的意义了。

点击 apply，可以看到生成的 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a4b0321e3d46bf834e7640c07e902f~tplv-k3u1fbpfcp-watermark.image?)

primary key (article\_id, tag\_id) 是指定复合主键。

后面分别是添加两个外键约束。

建表 sql 能看懂即可，不需要手写。

然后插入几条数据：

```sql
INSERT INTO `article_tag` (`article_id`, `tag_id`)
    VALUES
    (1,1), (1,2), (1,3),
    (2,2), (2,3), (2,4),
    (3,3), (3,4), (3,5),
    (4,4), (4,5), (4,1),
    (5,5), (5,1), (5,2);
```

点击左上角按钮，新建一条 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d69206f94ff465c96e407f1544e0b51~tplv-k3u1fbpfcp-watermark.image?)

输入 sql 后点击执行。

然后就可以看到插入的数据了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e02887aed3c5417d8e02521eeed104ff~tplv-k3u1fbpfcp-watermark.image?)

那现在有了 article、tag、article\_tag 3 个表了，怎么关联查询呢？

JOIN 3 个表呀！

```sql
SELECT * FROM article a 
    JOIN article_tag at ON a.id = at.article_id
    JOIN tag t ON t.id = at.tag_id
    WHERE a.id = 1
```

这样查询出的就是 id 为 1 的 article 的所有标签：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b8f66b2740d4ea7b004e0e73cb45cd5~tplv-k3u1fbpfcp-watermark.image?)

当然，一般我们会指定返回的列：

```sql
SELECT t.name AS 标签名, a.title AS 文章标题
    FROM article a 
    JOIN article_tag at ON a.id = at.article_id
    JOIN tag t ON t.id = at.tag_id
    WHERE a.id = 1
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/352ba7df50d249c08ce9154938f82ff2~tplv-k3u1fbpfcp-watermark.image?)

此外，我们把文章1 删除试试：

选中这条 sql 执行：

```sql
delete from article where id = 1;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a24abf73374414a5c469b1b775f30f~tplv-k3u1fbpfcp-watermark.image?)

然后再执行下面的查询：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fd4ce5aba3d4949a6d8800f06e8df8a~tplv-k3u1fbpfcp-watermark.image?)

可以看到关系也被级联删除了，这就是 CASCADE 的作用。

当然，删除的只是关系，并不影响 id=1 的标签：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49ef9619df3d440da167f387d08b43be~tplv-k3u1fbpfcp-watermark.image?)

这就是多对多数据的表设计、关联查询和级联方式。

## 总结

现实生活中有很多的一对多、多对多关系。

我们创建了部门、员工表，并在员工表添加了引用部门 id 的外键 department\_id 来保存这种一堆多关系。

并且设置了级联方式为 set null。

创建了文章表、标签表、文章标签表来保存多堆多关系，多对多不需要在双方保存彼此的外键，只要在中间表里维护这种关系即可。

中间表的外键级联方式一定为 CASCADE，因为数据没了关系就没必要还留着了。

此外，多对多的 join 需要连接 3 个表来查询。

一对多、多对多是非常常见的表之间的关系，要好好掌握它们的外键设置、关联查询、级联方式。


## 41.子查询和 EXISTS

我们学习了 select 的各种语法，包括 where、limit、order by、group by、having 等，再就是 avg、count、length 等函数。

还学了多个表的 join on 关联查询。

基于这些就已经可以写出复杂的查询了，但 sql 还支持更复杂的组合，sql 可以嵌套 sql，也就是子查询。

先看下现在 student 表的数据：

点击左上角新建 sql 按钮，输入查询的 sql，点击执行：

```sql
select * from student;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3a2561bbac74d50b3c8bf6fe1cd384f~tplv-k3u1fbpfcp-watermark.image?)

然后我们想查询学生表中成绩最高的学生的姓名和班级名称。

这是不是就要分成两个 sql 语句：

先查询最高分：

```sql
SELECT MAX(score) FROM student;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892a57f8561d41d3979cbf053e3f6ceb~tplv-k3u1fbpfcp-watermark.image?)

再查询这个分数为这个最高分的学生：

```sql
SELECT name, class FROM student WHERE score = 95;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b08754f4293948dab8f9a1795bda1e56~tplv-k3u1fbpfcp-watermark.image?)

能不能把这两个 sql 合并呢？

可以的，这就是子查询：

```sql
SELECT name, class FROM student WHERE score = (SELECT MAX(score) FROM student);
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa251b225374006bc01a9a802cf5de8~tplv-k3u1fbpfcp-watermark.image?)

比如查询成绩高于全校平均成绩的学生记录：

```sql
SELECT * FROM student WHERE score > (SELECT AVG(score) FROM student);
```

先一个 select 语句查询学生的平均分，然后查询分数大于这个平均分的学生。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f8792cc47648dbb81e3b2d7a9113dd~tplv-k3u1fbpfcp-watermark.image?)

此外，子查询还有个特有的语法 EXISTS、NOT EXISTS。

我们用部门表和员工表来试一下：

先查询下部门表和员工表的数据：

```sql
select * from department;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a8aedde390a49cf8ee855762bc4cf16~tplv-k3u1fbpfcp-watermark.image?)

```sql
select * from employee;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1462cd1a2ba145478e008e51a6fcb86e~tplv-k3u1fbpfcp-watermark.image?)

改一下员工的部门，点击 apply：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb130a226e6c423f9eb758de59d68a29~tplv-k3u1fbpfcp-watermark.image?)

这样就有的部门 2 个员工，有的部门 3 个员工，有的部门没有员工了。

然后实现这样一个查询：

查询有员工的部门。

sql 可以这么写：

```sql
SELECT name FROM department
    WHERE EXISTS (
        SELECT * FROM employee WHERE department.id = employee.department_id
    );
```

对每个 department，在子查询里查询它所有的 employee。

如果存在员工，那么条件成立，就返回这个部门的 name。

这就是 EXISTS 的作用：子查询返回结果，条件成立，反之不成立。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000c1407bc3c40a29aecc919abe21a88~tplv-k3u1fbpfcp-watermark.image?)

这就是所有有员工的部门。

还可以用 NOT EXISTS 来查询所有没有员工的部门：

```sql
SELECT name FROM department
    WHERE NOT EXISTS (
            SELECT * FROM employee WHERE department.id = employee.department_id
    );
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/042fadeba911425384a84db9f6de4918~tplv-k3u1fbpfcp-watermark.image?)

子查询不止 select 里可以用，insert、update、delete 语句同样可以。

我们建个产品表：

```sql
CREATE TABLE product (
     id INT PRIMARY KEY,
     name VARCHAR(50),
     price DECIMAL(10,2),
     category VARCHAR(50),
     stock INT
);
```

直接用这个 sql 建就好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/537162644bc64ac39385e7d3ef11ffa9~tplv-k3u1fbpfcp-watermark.image?)

然后插入几条数据：

```sql
INSERT INTO product (id, name, price, category, stock)
	VALUES 
		(1, 'iPhone12',6999.00, '手机',100),
		(2, 'iPad Pro',7999.00, '平板电脑',50),
		(3, 'MacBook Pro',12999.00, '笔记本电脑',30),
		(4, 'AirPods Pro',1999.00, '耳机',200),
		(5, 'Apple Watch',3299.00, '智能手表',80);
```

选中 sql，点击执行：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a62fa0d63314f6d90f18d00de1590d2~tplv-k3u1fbpfcp-watermark.image?)

然后查询下：

```sql
select * from product
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3941b22866c149c898b201469d427ce3~tplv-k3u1fbpfcp-watermark.image?)

查询的时候，可以用子查询，这个我们前面试过。

比如查询价格最高的产品的信息：

```sql
SELECT name, price FROM product WHERE price = (SELECT MAX(price) FROM product);
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2267eb1cb2ec463085ba9c7b3460198c~tplv-k3u1fbpfcp-watermark.image?)

通过一个子查询查最高的价格，然后外层查询查价格为最高价格的产品。

除了 select 之外，增删改也是可以用子查询的。

比如我们把每个产品分类的分类名、平均价格查出来放入另一个 avg\_price\_by\_category 表。

先创建这个表：

```sql
CREATE TABLE avg_price_by_category (
 id INT AUTO_INCREMENT,
 category VARCHAR(50) NOT NULL,
 avg_price DECIMAL(10,2) NOT NULL,
 PRIMARY KEY (id)
);
```

id 为主键，自增。

category 为 VARCHAR(50)，非空。

avg\_price 为 DECIMAL(10,2) 也就是一共 10 位，小数点后占 2 位的数字。

点击执行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a9635a5db3a41a6a5a41d2dbcc5566d~tplv-k3u1fbpfcp-watermark.image?)

然后把 product 产品表里的分类和平均价格查出来插入这个表：

```sql
INSERT INTO avg_price_by_category (category, avg_price) 
    SELECT category, AVG(price) FROM product GROUP BY category;
```

点击执行：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5349a4e6fd46f18c885160446edb19~tplv-k3u1fbpfcp-watermark.image?)

然后再查询现在的 avg\_price\_by\_category 表：

```sql
select * from avg_price_by_category
```

可以看到，确实插入了数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96d7f8d00d8a4acea2c61184d682288e~tplv-k3u1fbpfcp-watermark.image?)

这就是 insert + select 结合使用的场景。

update 同样也可以使用 select 子查询。

比如之前的 department 和 employee 表，我们想把技术部所有人的 name 前加上 “技术-”，就可以这么写：

```sql
UPDATE employee SET name = CONCAT('技术-', name) 
    WHERE department_id = (
        SELECT id FROM department WHERE name = '技术部'
    );
```

查询名字等于技术部的 department 的 id，然后更新 department_id 为这个 id 的所有 employee 的名字为 CONCAT("技术-", name)。


执行这个 sql:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2be7f89f39f46d8b447e81d9d8eebe7~tplv-k3u1fbpfcp-watermark.image?)

可以看到技术部的员工的名字都改了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64eb5edc79e3478c9a523fe3cdea964e~tplv-k3u1fbpfcp-watermark.image?)

接下来再试试 delete：

删除技术部所有的员工。

可以这么写：

```sql
DELETE FROM employee WHERE department_id = (
    SELECT id FROM department WHERE name = '技术部'
);
```
执行一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c51c7038190547d0a4e03e5e3d84e409~tplv-k3u1fbpfcp-watermark.image?)

然后再次查询：
```sql
select * from employee;
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2daa97264c5496db3175063da429a00~tplv-k3u1fbpfcp-watermark.image?)

可以看到技术部员工确实都没有了。

所以说，子查询在 select、insert、update、delete 里都可以用。

## 总结

sql 和 sql 可以组合来完成更复杂的功能，这种语法叫做子查询。

它还有个特有的关键字 EXISTS（和 NOT EXISTS），当子查询有返回结果的时候成立，没有返回结果的时候不成立。

子查询不止 select 可用，在 update、insert、delete 里也可以用。

灵活运用子查询，能写出功能更强大的 sql。



## 42.SQL 综合练习

前面我们把 select、update、insert、delete 的语法、函数、关联查询、子查询都过了一遍，sql 学的就差不多了。

这节我们来实战下，写一些复杂的 sql。

先创建个单独的数据库：

```sql
create database practice
```

执行它：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a2dcc41ee75443b8a755c82d00b4ddf~tplv-k3u1fbpfcp-watermark.image?)

点击刷新，就可以看到这个 database（也叫 schema）了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1fc20407740469cadcd696832cbeaec~tplv-k3u1fbpfcp-watermark.image?)

执行 use practice 切换数据库：

```sql
use practice;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf5110e9ef44d529a0463167b3a1080~tplv-k3u1fbpfcp-watermark.image?)

然后创建 3 个表：

```sql
-- 创建 customers 表，用于存储客户信息
CREATE TABLE IF NOT EXISTS `customers` (
 `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '客户ID，自增长',
 `name` varchar(255) NOT NULL COMMENT '客户姓名，非空',
 PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='客户信息表';

-- 创建 orders 表，用于存储订单信息
CREATE TABLE IF NOT EXISTS `orders` (
 `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '订单ID，自增长',
 `customer_id` int(11) NOT NULL COMMENT '客户ID，非空',
 `order_date` date NOT NULL COMMENT '订单日期，非空',
 `total_amount` decimal(10,2) NOT NULL COMMENT '订单总金额，非空',
 PRIMARY KEY (`id`),
 FOREIGN KEY (`customer_id`) REFERENCES `customers` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单信息表';

-- 创建 order_items 表，用于存储订单商品信息
CREATE TABLE IF NOT EXISTS `order_items` (
 `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '商品ID，自增长',
 `order_id` int(11) NOT NULL COMMENT '订单ID，非空',
 `product_name` varchar(255) NOT NULL COMMENT '商品名称，非空',
 `quantity` int(11) NOT NULL COMMENT '商品数量，非空',
 `price` decimal(10,2) NOT NULL COMMENT '商品单价，非空',
 PRIMARY KEY (`id`),
 FOREIGN KEY (`order_id`) REFERENCES `orders` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单商品信息表';
```

分别是顾客、订单、订单项。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4289811bbda44ba0845beab307b77f91~tplv-k3u1fbpfcp-watermark.image?)

一个顾客有多个订单，一个订单有多个订单项，通过外键存储这种关联关系。

级联方式为 CASCADE。

上面还涉及到注释的语法，sql 里的注释用 -- 开头：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b31edae2f6048eda5192b47b4a6abef~tplv-k3u1fbpfcp-watermark.image?)

执行建表 sql:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf0dfc99962497e843604a963d1306c~tplv-k3u1fbpfcp-watermark.image?)

点击刷新，就可以看到这三个表了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7a55ff76014497bad72f625333bb6fa~tplv-k3u1fbpfcp-watermark.image?)

然后插入一些数据：

```sql
-- 向 customers 表插入数据
INSERT INTO `customers` (`name`) 
    VALUES 
        ('张丽娜'),('李明'),('王磊'),('赵静'),('钱伟'),
        ('孙芳'),('周涛'),('吴洋'),('郑红'),('刘华'),
        ('陈明'),('杨丽'),('王磊'),('张伟'),('李娜'),
        ('刘洋'),('陈静'),('杨阳'),('王丽'),('张强');

-- 向 orders 表插入数据
INSERT INTO `orders` (`customer_id`, `order_date`, `total_amount`)
    VALUES
        (1, '2022-01-01',100.00),(1, '2022-01-02',200.00),
        (2, '2022-01-03',300.00),(2, '2022-01-04',400.00),
        (3, '2022-01-05',500.00),(3, '2022-01-06',600.00),
        (4, '2022-01-07',700.00),(4, '2022-01-08',800.00),
        (5, '2022-01-09',900.00),(5, '2022-01-10',1000.00);

-- 向 order_items 表插入数据
INSERT INTO `order_items` (`order_id`, `product_name`, `quantity`, `price`)
    VALUES
        (1, '耐克篮球鞋',1,100.00),
        (1, '阿迪达斯跑步鞋',2,50.00),
        (2, '匡威帆布鞋',3,100.00),
        (2, '万斯板鞋',4,50.00),
        (3, '新百伦运动鞋',5,100.00),
        (3, '彪马休闲鞋',6,50.00),
        (4, '锐步经典鞋',7,100.00),
        (5, '亚瑟士运动鞋',10,50.00),
        (5, '帆布鞋',1,100.00),
        (1, '苹果手写笔',2,50.00),
        (2, '电脑包',3,100.00),
        (3, '苹果手机',4,50.00),
        (4, '苹果耳机',5,100.00),
        (5, '苹果平板',7,100.00);
```

执行这些 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e364bfd057af491b94d0d3deaf9748d6~tplv-k3u1fbpfcp-watermark.image?)

然后查询下看看：

```sql
select * from customers
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d7725b873243ea9bdff55d5e21657b~tplv-k3u1fbpfcp-watermark.image?)

```sql
select * from orders
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daad6505a5f64567b43fd606c4271772~tplv-k3u1fbpfcp-watermark.image?)

```sql
select * from order_items
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abad04ccb4a543d4a35fc822f72d62e1~tplv-k3u1fbpfcp-watermark.image?)

顾客、订单、订单项三个表都成功插入了数据。

然后我们来实现下这些需求：

### 需求 1: 查询每个客户的订单总金额

客户的订单存在订单表里，可能有多个，这里需要 JOIN ON 关联两个表，然后用 GROUP BY 根据客户 id 分组，再通过 SUM 函数计算价格总和。

```sql
SELECT customers.name, SUM(orders.total_amount) AS total_amount 
    FROM customers
    INNER JOIN orders ON customers.id = orders.customer_id 
    GROUP BY customers.id;
```

这里的 INNER JOIN ON 也可以简化为 JOIN ON。

执行查询：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b7b519ba45645bbb97ce4df8aab009c~tplv-k3u1fbpfcp-watermark.image?)

成功查出了每个客户的订单总金额。

我们还可以再加上排序：

```sql
SELECT customers.name, SUM(orders.total_amount) AS total_amount 
    FROM customers
    INNER JOIN orders ON customers.id = orders.customer_id 
    GROUP BY customers.id
    ORDER BY total_amount DESC;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/267479f485034ba4a3dd767918ef2299~tplv-k3u1fbpfcp-watermark.image?)

如果想取前 3 的，可以用 LIMIT：

```sql
SELECT customers.name, SUM(orders.total_amount) AS total_amount 
    FROM customers
    JOIN orders ON customers.id = orders.customer_id
    GROUP BY customers.id
    ORDER BY total_amount DESC 
    LIMIT 0,3;
```

从第 0 个开始取 3 个：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36ccff514dec4afa8697c5310a1a536a~tplv-k3u1fbpfcp-watermark.image?)

### 需求 2: 查询每个客户的订单总金额，并计算其占比

每个客户的总金额的需求上面实现了，这里需要算占比，就需要通过一个子查询来计算全部订单的总金额，然后相除：

```sql
SELECT customers.name, SUM(orders.total_amount) AS total_amount, 
	SUM(orders.total_amount) / (SELECT SUM(total_amount) FROM orders) AS percentage 
    FROM customers
    INNER JOIN orders ON customers.id = orders.customer_id
    GROUP BY customers.id;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65abfdd6f5934773afa15e94246f5f00~tplv-k3u1fbpfcp-watermark.image?)

当然，这里每次都算一遍总金额性能不好，可以先算出总金额，然后把数值传入。

这里只是练习子查询。

### 需求 3：查询每个客户的订单总金额，并列出每个订单的商品清单

这里在总金额的基础上，多了订单项的查询，需要多关联一个表：

```sql
SELECT customers.name, orders.order_date, orders.total_amount, 
	order_items.product_name, order_items.quantity, order_items.price
    FROM customers
    JOIN orders ON customers.id = orders.customer_id
    JOIN order_items ON orders.id = order_items.order_id
    ORDER BY customers.name, orders.order_date;
```

内连接关联 3 个表，按照名字和下单日期排序。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8354b9cd7fe34661a0ac303863080567~tplv-k3u1fbpfcp-watermark.image?)

### 需求 4：查询每个客户的订单总金额，并列出每个订单的商品清单，同时只显示客户名字姓“张”的客户的记录：

总金额和商品清单的需求前面实现了，这里只需要加一个 WHERE 来过滤客户名就行：

```sql
SELECT customers.name, orders.order_date, orders.total_amount, 
	order_items.product_name, order_items.quantity, order_items.price
    FROM customers
    INNER JOIN orders ON customers.id = orders.customer_id
    INNER JOIN order_items ON orders.id = order_items.order_id
    WHERE customers.name LIKE '张%'
    ORDER BY customers.name, orders.order_date;
```

执行下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a34f165cd25e401b8e7c491fae4443ef~tplv-k3u1fbpfcp-watermark.image?)

### 需求 5:查询每个客户的订单总金额，并列出每个订单的商品清单，同时只显示订单日期在2022年1月1日到2022年1月3日之间的记录

这里比上面的需求只是多了日期的过滤，范围是一个区间，用 BETWEEN AND：

```sql
SELECT customers.name, orders.order_date,
	orders.total_amount, order_items.product_name,
    order_items.quantity, order_items.price
    FROM customers
    INNER JOIN orders ON customers.id = orders.customer_id
    INNER JOIN order_items ON orders.id = order_items.order_id
    WHERE orders.order_date BETWEEN '2022-01-01' AND '2022-01-03'
    ORDER BY customers.name, orders.order_date;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4e517a1d4648bfbac66cb88f1d93d8~tplv-k3u1fbpfcp-watermark.image?)

因为这里的 order\_date 是 date 类型，所以指定范围也只是用 2022-01-01 这种格式的。如果是 datetime，那就要用 2022-01-01 10:10:00 这种格式了。

### 需求 6：查询每个客户的订单总金额，并计算商品数量，只包含商品名称包含“鞋”的商品，商品名用-连接，显示前 3 条记录：

查询订单总金额和商品数量都需要用 group by 根据 customer.id 分组，过滤出只包含鞋的商品。

把分组的多条商品名连接起来需要用 GROUP\_CONCAT 函数。

然后 LIMIT 3

```sql
SELECT 
        c.name AS customer_name,
        SUM(o.total_amount) AS total_amount,
        COUNT(oi.id) AS total_quantity,
        GROUP_CONCAT(oi.product_name SEPARATOR '-') AS product_names
    FROM customers c
    JOIN orders o ON c.id = o.customer_id
    JOIN order_items oi ON o.id = oi.order_id
    WHERE oi.product_name LIKE '%鞋%'
    GROUP BY c.name
    ORDER BY total_amount DESC
    LIMIT 3;

```

GROUP\_CONCAT 函数是用于 group by 分组后，把多个值连接成一个字符串的。

LIMIT 3 就相当于 LIMIT 0,3 也就是从 0 开始 3 条记录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a644cd2f38c40e8b13d0132addf42eb~tplv-k3u1fbpfcp-watermark.image?)

## 需求 7: 查询存在订单的客户

这里使用子查询 + EXISTS 来实现：

```sql
SELECT * FROM customers c
    WHERE EXISTS (
            SELECT 1 FROM orders o WHERE o.customer_id = c.id
    );
```

如果从 orders 表中查出了当前 customer 的订单记录，EXISTS 就成立。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1cb97a9ff8841ecbaa97cf898604525~tplv-k3u1fbpfcp-watermark.image?)

当然，你也可以用 NO EXISTS 来查询没有下单过的客户：

```sql
SELECT * FROM customers c
    WHERE NOT EXISTS (
            SELECT 1 FROM orders o WHERE o.customer_id = c.id
    );
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ce4870cbadc4bb09a8f64758a0aaec1~tplv-k3u1fbpfcp-watermark.image?)

## 需求 8: 将王磊的订单总金额打九折

现在王磊的订单总金额是这些：

```sql
SELECT * FROM orders 
 JOIN customers ON orders.customer_id = customers.id
 WHERE customers.name = '王磊';
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753e18801602460d94c39ec13abd358b~tplv-k3u1fbpfcp-watermark.image?)

更新它们为 90%：

```sql
UPDATE orders o SET o.total_amount = o.total_amount * 0.9
    WHERE o.customer_id IN (
        SELECT id FROM customers WHERE name = '王磊'
    );
```

这里订单不止一条，所以用 IN 来指定一个集合。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a91dcaa374e842ef938f6f1fb1a28b8d~tplv-k3u1fbpfcp-watermark.image?)

再查询下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49be5e617e294d5a984c499c2f47f27e~tplv-k3u1fbpfcp-watermark.image?)

确实减少了。

## 总结

这节我们创建了一个新的 database 并且新增了 customers、orders、order_items 表来练习 sql。

customers 和 orders、orders 和 order_items 都是一对多的关系。

我们练习了 JOIN ON、WHERE、ORDER BY、GROUP BY、LIMIT 等语法，也练习了 SUM、COUNT、GROUP_CONCAT 等函数。

还有子查询和 EXISTS。

sql 常用的语法也就这些，把这些掌握了就能完成各种需求了。



## 43.MySQL 的事务和隔离级别

我们学习了增删改查的 sql 语句，并进行了大量的练习。

但有个问题：

如果是两个 update 的语句，一个把订单详情表数量修改了，一个把订单表的总金额修改了。但是改订单总金额的那个 sql 执行失败了。

这时候怎么办？

数量已经改了，但是总金额没改成功，就对不上了。

这种就需要事务（transaction）了。

它是这样用的：

比如 3 号订单的这三个商品，我们把它数量都改为 1。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5885c3c6204ad7be3074d56959a396~tplv-k3u1fbpfcp-watermark.image?)

那总金额就是 200，需要改 order 表的 total\_amount 为 200。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3f96bada39043db80e6403244fb8517~tplv-k3u1fbpfcp-watermark.image?)

我们先开启事务：

```sql
START TRANSACTION
```

然后执行两条 sql 语句：

```sql
UPDATE order_items SET quantity=1 WHERE order_id=3;

UPDATE orders SET total_amount=200 WHERE id=3;
```

分别修改了 order\_items 的商品数量和 orders 的订单总金额。

然后再查询下现在 orders 表和 order\_items 表的数据。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8af0e19c621496e8716415091d7bc03~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/696b943b02ee4dd4bb06844f520e2f86~tplv-k3u1fbpfcp-watermark.image?)

确实改了。

如果这时候你发现改错了，想再改回去，可你不记得之前的数据是啥了，怎么办呢？

别担心，这时候只要执行下 ROLLBACK 就好了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a3b0375015d4c3e9953b3e22007b5e9~tplv-k3u1fbpfcp-watermark.image?)

你会发现它们的数据恢复了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdfc9cdd127d49a6a08c5c96fc7a105d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e118f1008cea47a6a16e5e126442ae88~tplv-k3u1fbpfcp-watermark.image?)

如果你确实想提交，那可以执行 COMMIT：

```sql
START TRANSACTION;

UPDATE order_items SET quantity=1 WHERE order_id=3;

UPDATE orders SET total_amount=200 WHERE id=3;

COMMIT;
```

这时候数据就真正被修改，不能回滚了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dcbd8db05d841558b94878df722d250~tplv-k3u1fbpfcp-watermark.image?)

那如果我不是想回滚所有的 sql 语句，只是回滚一部分呢？

这需要手动告诉 mysql 一些保存的点：

```sql
START TRANSACTION;

SAVEPOINT aaa;

UPDATE order_items SET quantity=1 WHERE order_id=3;

SAVEPOINT bbb;

UPDATE orders SET total_amount=200 WHERE id=3;

SAVEPOINT ccc;

```

比如我设置了 3 个保存点。

执行这段 sql，数据确实修改了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daa1f65396244e10b9c42d8bd0d9d956~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f1bc6bfe7c4fdd94711a65cb5f853e~tplv-k3u1fbpfcp-watermark.image?)

这时候我们回滚到 bbb 的位置：

```sql
ROLLBACK TO SAVEPOINT bbb;
```

然后再查询下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/409590407c3a4531a554cccb8c90b17a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd3d76b94e74effae007b0affb8a25c~tplv-k3u1fbpfcp-watermark.image?)

这时候 order\_items 表修改成功了，但是 orders 表修改没成功。

这确实是这个点的状态：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3624c6256ba64b88a3a6c28cb0d5ff3d~tplv-k3u1fbpfcp-watermark.image?)

再回滚到 ccc：

```sql
ROLLBACK TO SAVEPOINT ccc;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b513594165d74aaaa8265482781c3acb~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04b52bfed97540308b3fac02ce561afa~tplv-k3u1fbpfcp-watermark.image?)

这时候就都修改成功了。

这就是事务：

**START TRANSACTION 开启事务后所有的 sql 语句都可以 ROLLBACK，除非执行了 COMMIT 完成这段事务。**

**还可以设置几个 SAVEPOINT，这样可以 ROLLBACK TO 任何一个 SAVEPOINT 的位置。**

当你修改多个表的时候，并且这些表的数据是有关联的时候，事务是必须的。要不全部成功，要不全部不成功。

那如果事务还没有 COMMIT，但是它修改了一些表，这时候我们能查到它修改后的数据么？

这就涉及到事务的隔离级别的概念了。

MYSQL 有 4 种事务隔离级别：

*   **READ UNCOMMITTED**：可以读到别的事务尚未提交的数据。

这就有个问题，你这个事务内第一次读的数据是 aaa，下次读可能就是 bbb 了，这个问题叫做**不可重复读**。

而且，万一你读到的数据人家又回滚了，那你读到的就是临时数据，这个问题叫做**脏读**。

*   **READ COMMITTED**：只读取别的事务已提交的数据。

这样是没有脏读问题了，读到的不会是临时数据。

但是还是有可能你这个事务内第一次读的数据是 aaa，下次读可能是 bbb ，也就是不可重复读的问题依然存在。

不只是数据不一样，可能你两次读取到的记录行数也不一样，这叫做**幻读**。

*   **REPEATABLE READ**：在同一事务内，多次读取数据将保证结果相同。

这个级别保证了读取到的数据一样，但是不保证行数一样，也就是说解决了不可重复读的问题，但仍然存在幻读的问题。

*   **SERIALIZABLE**：在同一时间只允许一个事务修改数据。

事务一个个执行，各种问题都没有了。

但是负面影响就是性能很差，只能一个个的事务执行。

这 4 种级别主要是数据一致性和性能的差别，一致性越好，并发性能就越差。

需要根据实际情况来权衡。

可以这样查询当前的事务隔离级别：

```sql
select @@transaction_isolation
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7baa2d25c6a4ddc963c9f54390bdfad~tplv-k3u1fbpfcp-watermark.image?)

这个了解就好，一般用默认的。

## 总结

事务内的几条 sql 要么全部成功，要么全部不成功，这样能保证数据的一致性。

它的使用方式是 START TRANSACTION; COMMIT; 或者 ROLLBACK;

还可以设置 SAVEPOINT，然后 ROLLBACK TO SAVEPOINT;

事务还没提交的数据，别的事务能不能读取到，这就涉及到隔离级别的概念了。

一般就用默认的隔离级别就行，也就是 REPEATABLE READ。

基本上，只要写增删改的 sql，那都是要开事务的。


## 44.MySQL 的视图、存储过程和函数

和 mysql server 建立连接之后，可以看到它下面所有的 database。

每个 database 包含表、视图、存储过程、函数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97557d444a2446769c21b93976c58121~tplv-k3u1fbpfcp-watermark.image?)

表的增删改查我们已经学会了。

那视图、存储过程、函数都是什么呢？

我们分别来看下：

用之前的 customers、orders 表来建立视图：

```sql
CREATE VIEW customer_orders AS 
    SELECT 
        c.name AS customer_name, 
        o.id AS order_id, 
        o.order_date, 
        o.total_amount
    FROM customers c
    JOIN orders o ON c.id = o.customer_id;
```

下面的 select 语句我们很熟悉，就是关联 customers、orders 表，查出一些字段。

然后加上 CREATE VIEW ... AS 就是把这个查询的结果建立一个视图。

我们查询下刚创建的视图：

```sql
select * from customer_orders
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a744c384856142cb9849d82839295fa8~tplv-k3u1fbpfcp-watermark.image?)

视图有什么好处呢？

明显感受到的就是能简化查询，之前要写一堆 sql，现在只要查这个视图就好了。

再就是还可以控制权限，让开发者只能看到需要的字段，其余的给隐藏掉。

视图一般只用来做查询，因为它增删改的限制比较多，比如只有单表的视图可以增删改，并且要求不在视图里的字段都有默认值等。

了解即可。

再就是存储过程。

这段 sql 就是创建了一个存储过程，传入 custom\_id 查询出所有关联的订单：

```sql
DELIMITER $$
CREATE PROCEDURE get_customer_orders(IN customer_id INT)
BEGIN
        SELECT o.id AS order_id, o.order_date, o.total_amount
        FROM orders o
		WHERE o.customer_id = customer_id;
END $$
DELIMITER ;
```

首先 DELIMITER \$\$ 定义分隔符为 \$\$，因为默认是 ;

这样中间就可以写 ; 了，不会中止存储过程的 sql。

最后再恢复为之前的分隔符：DELIMITER ;

存储过程内部执行了一个查询，用到的 customer\_id 是参数传入的。

创建这个存储过程：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/968a0bd7d21d44d9b50a3351e3b6e305~tplv-k3u1fbpfcp-watermark.image?)

刷新就可以看到这个刚创建的存储过程：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b357a81cae34c32bf0957e2d6c9c958~tplv-k3u1fbpfcp-watermark.image?)

点击第二个图标就可以传参数调用：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f800792e654f999b5c7e6183328b5c~tplv-k3u1fbpfcp-watermark.image?)

当然你可以在 sql 里调用：

```sql
CALL get_customer_orders(5);
```

调用使用 CALL 存储过程(参数) 的形式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1958a5c84d74e6690bc651e2908a70d~tplv-k3u1fbpfcp-watermark.image?)

可以看到，存储过程可以封装一些 sql，用的时候传入参数 CALL 一下就行。

此外，如果你想调用的时候返回值，可以使用函数：

比如一个求平方的函数：

```sql
DELIMITER $$
CREATE FUNCTION square(x INT)
RETURNS INT
BEGIN
    DECLARE result INT;
    SET result = x * x;
    RETURN result;
END $$
DELIMITER ;
```

还是先通过 DELIMITER 指定分隔符为 \$\$。

CREATE FUNCTION 声明函数的名字和参数 x，并且通过 RETURNS 声明返回值类型。

BEGIN、END 中间的是函数体。

先 DECLARE 一个 INT 类型的变量，然后 SET 它的值为 x \* x，之后通过 RETURN 返回这个结果。

但默认 mysql 是不允许创建函数的。

需要先设置下这个变量：

```sql
SET GLOBAL log_bin_trust_function_creators = 1;
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f3b5d2b695469b81c8cb742b3abc1b~tplv-k3u1fbpfcp-watermark.image?)

之后之后再创建 function：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/553524ecde574780bdf7250c5d1753b9~tplv-k3u1fbpfcp-watermark.image?)

创建成功之后就可以在 sql 里用它了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c5a5d773fd441848c84450b78b92dd3~tplv-k3u1fbpfcp-watermark.image?)

比如创建这个视图的 price 的平方：
```sql
CREATE VIEW order_items_view AS 
    SELECT product_name, price FROM practice.order_items;
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86a4e4b5291345db82a24af6645a8529~tplv-k3u1fbpfcp-watermark.image?)

就可以用上这个函数：

```sql
select product_name, square(price) from order_items_view
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d017e9a9dfb49c3aafa8a46df7cf3d8~tplv-k3u1fbpfcp-watermark.image?)

你也可以可视化的调用这个 function：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cdc27e41ff440d2b66529c3c817198a~tplv-k3u1fbpfcp-watermark.image?)

当然，这个函数没啥意义，我们再创建个有意义一点的：

```sql
DELIMITER $$
CREATE FUNCTION get_order_total(order_id INT)
RETURNS DECIMAL(10,2)
BEGIN
	DECLARE total DECIMAL(10,2);
	SELECT SUM(quantity * price) INTO total
		FROM order_items
		WHERE order_id = order_items.order_id;
	RETURN total;
END $$
DELIMITER ;
```

创建一个函数  get\_order\_total，参数为 INT 类型的 order\_id，返回值为 DECIMAL(10, 2) 类型。

声明 total 变量，执行查询订单详情表综合的 select 语句，把结果放到 total 变量里，也就是 SELECT INTO。

最后 RETURN 这个 total 变量。

然后我们调用下：
```sql
select id, get_order_total(id) from orders;
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f444958cfd846c48324e1d30e6ace83~tplv-k3u1fbpfcp-watermark.image?)

我们自己来算算对不对：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e7c71045af044508600b0d4f4c91f83~tplv-k3u1fbpfcp-watermark.image?)

id 为 3 的订单的总额是对的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d142d163654b4ab0b9147738a702e05e~tplv-k3u1fbpfcp-watermark.image?)

这就是自定义函数。

## 总结

这节我们了解了下视图、存储过程、函数。

视图就是把查询结果保存下来，可以对这个视图做查询，简化了查询语句并且也能隐藏一些字段。

它增删改的限制比较多，一般只是来做查询。

存储过程就是把一段 sql 封装起来，传参数调用。

函数也是把一段 sql 或者其他逻辑封装起来，传参数调用，但是它还有返回值。

这些概念了解即可，实际上用的并不多。


## 45.使用 Node 操作 MySQL 的两种方式

前面我们学习了 MySQL 的数据库、表、增删改查等，目的还是在 Node 应用里操作它。

这节我们就来学习下用 mysql2 和 typeorm 两种方式来操作 MysSQL 数据库。

先来看下 mysql2:

它是用的最多的连接 mysql 的 npm 包，是 mysql 包的升级版，有更多特性。

我们创建个目录，然后进入这个目录执行 npm init -y 创建 package.json。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/198e7a1ef31743f49799bbb42392d07c~tplv-k3u1fbpfcp-watermark.image?)

然后安装 mysql2

    npm install --save mysql2 

添加这样一个 index.js：

```javascript
const mysql = require('mysql2');

const connection = mysql.createConnection({
  host: 'localhost',
  port: 3306,
  user: 'root',
  password: 'guang',
  database: 'practice'
});

connection.query(
  'SELECT * FROM customers',
  function(err, results, fields) {
    console.log(results);
    console.log(fields.map(item => item.name)); 
  }
);
```

连接 mysql server，指定用户名、密码、要操作的数据库（这里要改成你自己的 mysql 连接密码）。

然后通过 query 方法跑一个查询 sql。

results 是结果，fields 是一些元信息，比如字段名这些。

node 执行下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39575fc93dfe4e468daa39de47aebc69~tplv-k3u1fbpfcp-watermark.image?)

和我们在 mysql workbench 里执行效果一样。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64a85415cb7f4e9cafdc2882c6ee8b0b~tplv-k3u1fbpfcp-watermark.image?)

查询也可以指定占位符：

```javascript
connection.query(
    'SELECT * FROM customers WHERE name LIKE ?',
    ['李%'],
    function(err, results, fields) {
        console.log(results);
        console.log(fields.map(item => item.name)); 
    }
);
```

我们查询了姓李的顾客有哪些：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/740183baff8a4df69d2fe245232a0fa8~tplv-k3u1fbpfcp-watermark.image?)

当然，增删改也是可以的。

比如我们插入一条数据：

```sql
connection.execute('INSERT INTO customers (name) VALUES (?)',
    ['光'], (err, results, fields) => {
    console.log(err);
});
```

在 mysql workbench 里可以看到，确实插入了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d479b595b70c4d5ca013db16e8d4a5ba~tplv-k3u1fbpfcp-watermark.image?)

再来试下修改。

```javascript
connection.execute('UPDATE customers SET name="guang" where name="光"',
(err) => {
    console.log(err);
});
```

把刚才插入的记录改个名字。

node 跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81ca6a47da704829bdebe38a158f156d~tplv-k3u1fbpfcp-watermark.image?)

点下刷新，可以看到确实修改了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/398da9cf22184817ba22c8e743c0160a~tplv-k3u1fbpfcp-watermark.image?)

再试试删除：

```javascript
connection.execute('DELETE  FROM customers where name=?',
    ['guang'],
    (err) => {
        console.log(err);
    });
```

执行后数据库中这条记录也删除了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cfa8bd7e0c94e46839a112260091478~tplv-k3u1fbpfcp-watermark.image?)

这就是用 mysql2 做增删改查的方式。

是不是还挺简单的，就和我们在 mysql workbench 里写 sql 差不多。

当然，这些 api 也都有 promise 版本。

这样写：

```sql
const mysql = require('mysql2/promise');

(async function() {

    const connection = await mysql.createConnection({
        host: 'localhost',
        port: 3306,
        user: 'root',
        password: 'guang',
        database: 'practice'
    });

    const [results, fields] = await connection.query('SELECT * FROM customers');

    console.log(results);
    console.log(fields.map(item => item.name)); 

})();
```

结果一样：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f05d163e3e9433b9b67090975adf221~tplv-k3u1fbpfcp-watermark.image?)

这是最基本的使用：需要操作数据库的时候，建立连接，用完之后释放连接。

但这样性能并不高。

因为数据库的连接建立还是很耗时的，而且一个连接也不够用。

我们一般都是用连接池来管理：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1958a1babf864c7abca8166dec40e97a~tplv-k3u1fbpfcp-watermark.image?)

连接池中放着好几个 mysql 的连接对象，用的时候取出来执行 sql，用完之后放回去，不需要断开连接。

mysql2 自然也封装了连接池的功能。

这样用：

```javascript
const mysql = require('mysql2/promise');

(async function() {
    const pool = mysql.createPool({
        host: 'localhost',
        user: 'root',
        password: 'guang',
        database: 'practice',
        waitForConnections: true,
        connectionLimit: 10,
        maxIdle: 10, 
        idleTimeout: 60000,
        queueLimit: 0,
        enableKeepAlive: true,
        keepAliveInitialDelay: 0
      });

    const [results] = await pool.query('select * from customers');
    console.log(results);
})();
```

只要把 createConnection 换成 createPool 就好了。query 或者 execute 的时候会自动从 pool 中取 connection 来用，用完会放回去。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/518eb14a89ca416e933318ca978260ac~tplv-k3u1fbpfcp-watermark.image?)

或者你也可以手动取：

```javascript
const connection = await pool.getConnection();

const [results] = await connection.query('select * from orders');
console.log(results);
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9afd05d94fbd4154acb805fa9656d17c~tplv-k3u1fbpfcp-watermark.image?)

回过头来再看看这些 option：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83ffc6c8dc646ac9f7180deb0895a7b~tplv-k3u1fbpfcp-watermark.image?)

connectionLimit 是指定最多有多少个连接，比如 10 个，那就是只能同时用 10个，再多需要排队等。

maxIdle 是指定最多有多少个空闲的，超过这个数量的空闲连接会被释放。

waitForConnections 是指如果现在没有可用连接了，那就等待，设置为 false 就是直接返回报错。

idleTimeout 是指空闲的连接多久会断开。

queueLimit 是可以排队的请求数量，超过这个数量就直接返回报错说没有连接了。设置为 0 就是排队没有上限。

enableKeepAlive、keepAliveInitialDelay 是保持心跳用的，用默认的就好。

这就是 mysql2 的用法，是不是还会挺简单的？

只要建立个连接或者连接池，就可以在 node 里执行 sql 了。

但是我们一般不会直接这样执行 sql，而是会用 ORM 框架。

**ORM 是 Object Relational Mapping，对象关系映射。也就是说把关系型数据库的表映射成面向对象的 class，表的字段映射成对象的属性映射，表与表的关联映射成属性的关联。**

其实这个想法也很自然，比如我们前面执行的这些 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e253cffe2fdb440d8a515e403510a9c4~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f0d16b99b824b03945d76d9616cd147~tplv-k3u1fbpfcp-watermark.image?)

返回的不就是 js 对象么。

那不如直接操作这个对象，让 ORM 框架自动执行 sql 去同步数据库。

TypeORM 就是一个流行的 ORM 框架。

我们来试一下：

新建一个项目：

    npx typeorm@latest init --name typeorm-mysql-test --database mysql

通过 typeorm 的 init 命令创建一个项目， --name 指定项目名，--database 指定连接的数据库。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9338fc5a7f5643e28e63a4cc49bd5ab3~tplv-k3u1fbpfcp-watermark.image?)

修改下 data-source.ts

```typescript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "practice",
    synchronize: true,
    entities: [User],
    migrations: [],
    subscribers: [],
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20311814f7a94017b919efc47163af3b~tplv-k3u1fbpfcp-watermark.image?)

用户名密码，要操作的数据库，这些很容易理解。

指定用 mysql2 包来连接，就是我们前面测试的那个。

然后添加一个验证的插件，sha256\_password，这个是切换密码的加密方式的，新版本 mysql 改成这种密码加密方式了。

还要手动安装下 mysql2 这个驱动包：

    npm install --save mysql2

然后执行 npm run start。

这时候你会发现 practice 数据库多了个表：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e165fdaf9a4494b8a65cc0a5a5628f~tplv-k3u1fbpfcp-watermark.image?)

打开看一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a3338303dfd49e69a58ddc7820979fe~tplv-k3u1fbpfcp-watermark.image?)

它还有一条数据。

而且控制台也打印了查询出来的这条数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/436b9fb2421c4e7cac7c86bc7f1118ce~tplv-k3u1fbpfcp-watermark.image?)

怎么做到的呢？

我们看下代码，有这样一个 entity，通过装饰器声明了主键列和其他的列：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16240ef5954c4a389d9eba0f6510121d~tplv-k3u1fbpfcp-watermark.image?)

在 index.ts 里创建了一个 User 的对象，调用 save 方法保存这个对象，通过 find 方法查询这个对象：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aea70c6020d54037b1083209fdc1b647~tplv-k3u1fbpfcp-watermark.image?)

然后数据库里就创建好了表、插入了数据，并且还把它查了出来。

这就是 ORM。

有没有感觉很神奇，它是怎么实现的呢？

我们看下它打印的 sql 就懂了。

加一个 logging 为 true 的选项：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8e7c12c0bf54c90b5f960e1b8979a2d~tplv-k3u1fbpfcp-watermark.image?)

然后去数据库把那个 user 表删掉。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40d1f18fa78c4cbebb0d0780f8355375~tplv-k3u1fbpfcp-watermark.image?)

再重新 npm run start：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c94579eec20a4efbb943f8f678d391c2~tplv-k3u1fbpfcp-watermark.image?)

看到它打印的 CREATE TABLE、INSERT INTO、SELECT 的 sql 语句了么？

这就是 ORM 的实现原理。

它会根据你在 class 的属性上加的装饰器来生成建表 sql。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13fa6a00c32f4fdf8e1c521da38a8d24~tplv-k3u1fbpfcp-watermark.image?)

然后 save 这个 class 的对象，就会执行 insert into 来插入数据。

find 方法会执行 select 来查询数据。

这样，对表的增删改查就变成了对对象的操作。

此外，可以看到每个涉及到修改的 sql 都包了一层事务，这样出了错可以回滚：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d975d42524a74d629e64b9f354c88b36~tplv-k3u1fbpfcp-watermark.image?)

[typeorm 案例代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-mysql-test) 和 [mysql2 案例代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/mysql2-test) 都在小册仓库。

## 总结

我们学习了 Node 里操作数据库的两种方式：

一种是直接用 mysql2 连接数据库，发送 sql 来执行。

一种是用 ORM 库，比如 typeorm，它是基于 class 和 class 上的装饰器来声明和表的映射关系的，然后对表的增删改查就变成了对象的操作以及 save、find 等方法的调用。它会自动生成对应的 sql。

主流的方案还是 ORM 的方案，下节我们继续深入学习 typeorm。


## 46.快速掌握 TypeORM

上节我们简单用了下 TypeORM，这节我们把它全部的概念过一遍。

新建一个 TypeORM 项目：
```shell
npx typeorm@latest init --name typeorm-all-feature --database mysql
```
然后改下用户名密码数据库，把连接 msyql 的驱动包改为 mysql2，并修改加密密码的方式：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e65e7022353432fb0e3b44505b547af~tplv-k3u1fbpfcp-watermark.image?)

```typescript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "practice",
    synchronize: true,
    logging: true,
    entities: [User],
    migrations: [],
    subscribers: [],
    poolSize: 10,
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})

```

然后安装 mysql2:
```shell
npm install --save mysql2
```
我们分别来过一遍这些配置：

type 是数据库的类型，因为 TypeORM 不只支持 MySQL 还支持 postgres、oracle、sqllite 等数据库。

host、port 是指定数据库服务器的主机和端口号。

user、password 是登录数据库的用户名和密码。

database 是要指定操作的 database，因为 mysql 是可以有多个 database 或者叫 schema 的。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3bd5f96b94741ff87b656584a4edaa3~tplv-k3u1fbpfcp-watermark.image?)

synchronize 是根据同步建表，也就是当 database 里没有和 Entity 对应的表的时候，会自动生成建表 sql 语句并执行。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3db666e0d544ed8a13939e80bb6ac4c~tplv-k3u1fbpfcp-watermark.image?)

当然，如果有对应的表就不会创建了。

logging 是打印生成的 sql 语句。

entities 是指定有哪些和数据库的表对应的 Entity。

除了 class，还可以通过这种方式指定：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e900f3ca41e4ec290afecb12921d69a~tplv-k3u1fbpfcp-watermark.image?)

migrations 是修改表结构之类的 sql，暂时用不到，就不展开了。

subscribers 是一些 Entity 生命周期的订阅者，比如 insert、update、remove 前后，可以加入一些逻辑：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd69bce785c74e63bf7c70b8a3881325~tplv-k3u1fbpfcp-watermark.image?)

poolSize 是指定数据库连接池中连接的最大数量。

connectorPackage 是指定用什么驱动包。

extra 是额外发送给驱动包的一些选项。

这些配置都保存在 DataSource 里。

DataSource 会根据你传入的连接配置、驱动包，来创建数据库连接，并且如果指定了 synchronize 的话，会同步创建表。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13574d2cbcab420594c68b22a5c76aa7~tplv-k3u1fbpfcp-watermark.image?)

而创建表的依据就是 Entity：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ad4d6c2c372447da02d9f2f745e6eac~tplv-k3u1fbpfcp-watermark.image?)

跑一下：
```
npm run start
```
比如这个 Entity 就会执行这样的 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43eabb8c38e64b3fbad642e8adb3d8af~tplv-k3u1fbpfcp-watermark.image?)

主键为 INT 自增、firstName 和 lastName 是 VARCHAR(255)，age 是 INT。

这是默认的映射关系。

那如果我 number 不是想映射到 INT 而是 DOUBLE 呢？

或者如果 string 不是想映射到 VARCHAR(255)，而是 TEXT （长文本）呢？

这样映射：

```javascript
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm"

@Entity({
    name: 't_aaa'
})
export class Aaa {

    @PrimaryGeneratedColumn({
        comment: '这是 id'
    })
    id: number

    @Column({
        name: 'a_aa',
        type: 'text',
        comment: '这是 aaa'
    })
    aaa: string

    @Column({
        unique: true,
        nullable: false,
        length: 10,
        type: 'varchar',
        default: 'bbb'
    })
    bbb: string

    @Column({
        type: 'double',
    })
    ccc: number
}

```

我们新增了一个 Entity Aaa。

@Entity 指定它是一个 Entity，name 指定表名为 t\_aaa。

@PrimaryGeneratedColumn 指定它是一个自增的主键，通过 comment 指定注释。

@Column 映射属性和字段的对应关系。

通过 name 指定字段名，type 指定映射的类型，length 指定长度，default 指定默认值。

nullable 设置 NOT NULL 约束，unique 设置 UNIQUE 唯一索引。

type 这里指定的都是数据库里的数据类型。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6d8d778ba3c4e569b5abd68e0c3a773~tplv-k3u1fbpfcp-watermark.image?)

然后在 DataSource 的 entities 里引入下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3431824d221481f91e3020a52bdeeb0~tplv-k3u1fbpfcp-watermark.image?)

重新跑 npm run start。

生成建表 sql 是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7092c94ea067447aadff8806f2bcb9dd~tplv-k3u1fbpfcp-watermark.image?)

格式化一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e5a0c83ad8344089b98788d55f99847~tplv-k3u1fbpfcp-watermark.image?)

对比着 Entity 看下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93bd5026335149edaa0809092e6a2ef5~tplv-k3u1fbpfcp-watermark.image?)

是不是就明白怎么映射了？

在 mysql workbench 里看下，确实生成了这个表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afcd64e6dba1446ab7a8114e1cad2444~tplv-k3u1fbpfcp-watermark.image?)

表创建好了，接下来就是增删改查了。

在 index.ts 里创建个 user 对象，然后调用 AppDataSource.manager.save 来保存：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const user = new User()
    user.firstName = "aaa"
    user.lastName = "bbb"
    user.age = 25

    await AppDataSource.manager.save(user)

}).catch(error => console.log(error))
```

删除 User 表重新跑 npm run start。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/084859cba8c74a17a0f404d6a60db9f2~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b93845bcf05b4270a1290ab4a8359320~tplv-k3u1fbpfcp-watermark.image?)

可以看到数据库插入了这条记录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d8c04d92394f379425f75c968465be~tplv-k3u1fbpfcp-watermark.image?)

如果你指定了 id，那就变成修改了：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const user = new User()
    user.id = 1;
    user.firstName = "aaa111"
    user.lastName = "bbb"
    user.age = 25

    await AppDataSource.manager.save(user)

}).catch(error => console.log(error))
```

重新跑下 npm run start。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/620f22208da34a76af7ebe3ec6d09ea0~tplv-k3u1fbpfcp-watermark.image?)

可以看到，生成的 sql 语句变成了 select 和 update：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/635bd50975a14fb79fd31142dc622503~tplv-k3u1fbpfcp-watermark.image?)

当你指定了 id 的时候，typeorm 会先查询这个 id 的记录，如果查到了，那就执行 update。

在 mysql workbench 里看下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ef46bd77a8d489a897348707b0f9dc1~tplv-k3u1fbpfcp-watermark.image?)

确实修改了。

那如果想批量插入和修改呢？

这样写：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    await AppDataSource.manager.save(User, [
        { firstName: 'ccc', lastName: 'ccc', age: 21},
        { firstName: 'ddd', lastName: 'ddd', age: 22},
        { firstName: 'eee', lastName: 'eee', age: 23}
    ]);


}).catch(error => console.log(error))

```

我们 npm run start 跑一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab4f3167d36f4e6da3e92969911e8aef~tplv-k3u1fbpfcp-watermark.image?)

可以看到确实生成了 3 条 insert into 的 sql 语句。

数据库中也能看到：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a4ea2f430be4f37a09901d271aa3991~tplv-k3u1fbpfcp-watermark.image?)

批量修改也很容易想到，是这样写：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    await AppDataSource.manager.save(User, [
        { id: 2 ,firstName: 'ccc111', lastName: 'ccc', age: 21},
        { id: 3 ,firstName: 'ddd222', lastName: 'ddd', age: 22},
        { id: 4, firstName: 'eee333', lastName: 'eee', age: 23}
    ]);

}).catch(error => console.log(error))

```

执行 npm run start，会看到一条 select 语句， 3 条 update 语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76aa394475a6459a83ece608184cd6c7~tplv-k3u1fbpfcp-watermark.image?)

在 workbench 里也可以看到数据被修改了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c39aa49edf94c32a52742ad8a12946e~tplv-k3u1fbpfcp-watermark.image?)

这就是 typeorm 里新增和修改的方式，使用 save 方法。

其实 EntityManager 还有 update 和 insert 方法，分别是修改和插入的，但是它们不会先 select 查询一次。而 save 方法会先查询一次数据库来确定是插入还是修改。

删除和批量删除用 delete 方法：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    await AppDataSource.manager.delete(User, 1);
    await AppDataSource.manager.delete(User, [2,3]);

}).catch(error => console.log(error))

```

执行下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b871457474e34430ac73ab50729dca7d~tplv-k3u1fbpfcp-watermark.image?)

数据库了对应记录就被删除了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/355ae75b691843d9a143525a7130f8ad~tplv-k3u1fbpfcp-watermark.image?)

这里也可以用 remove 方法：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const user = new User();
    user.id = 1;

    await AppDataSource.manager.remove(User, user);

}).catch(error => console.log(error))
```
**delete 和 remove 的区别是，delete 直接传 id、而 remove 则是传入 entity 对象。**

而查询是使用 find 方法：

先插入几条数据：

```javascript
await AppDataSource.manager.save(User, [
    { firstName: 'ccc', lastName: 'ccc', age: 21},
    { firstName: 'ddd', lastName: 'ddd', age: 22},
    { firstName: 'eee', lastName: 'eee', age: 23}
]);
```

再查一下：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const users = await AppDataSource.manager.find(User);
    console.log(users);
    
}).catch(error => console.log(error))

```

控制台打印了查询出的数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b35f9ecd71f427cbb08c4d361bccd28~tplv-k3u1fbpfcp-watermark.image?)

也可以通过 findBy 方法根据条件查询：

```javascript
import { In } from "typeorm";
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const users = await AppDataSource.manager.findBy(User, {
        age: 23
    });
    console.log(users);
   
}).catch(error => console.log(error))
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb9b2f24cbd7447b8e512bc32ce0edec~tplv-k3u1fbpfcp-watermark.image?)

此外，你还可以用 findAndCount 来拿到有多少条记录：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const [users, count] = await AppDataSource.manager.findAndCount(User);
    console.log(users, count);

}).catch(error => console.log(error))

```

会额外执行一个统计的 sql：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8579254a024945acb0cdb85a1133c70f~tplv-k3u1fbpfcp-watermark.image?)

count 是可以指定条件的：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const [users, count] = await AppDataSource.manager.findAndCountBy(User, {
        age: 23
    })
    console.log(users, count);

}).catch(error => console.log(error))
```

可以看到，生成的 sql 里多了一个 where 条件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b9ea24966784cfbb34d514ce6976d8d~tplv-k3u1fbpfcp-watermark.image?)

除了可以查询多条，还可以查询一条，使用 findOne：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const user = await AppDataSource.manager.findOne(User, {
        select: {
            firstName: true,
            age: true
        },
        where: {
            id: 4
        },
        order: {
            age: 'ASC'
        }
    });
    console.log(user);

}).catch(error => console.log(error))
```

指定查询的 where 条件是 id 为 4 ，指定 select 的列为 firstName 和 age，然后 order 指定根据 age 升序排列。

查询结果如下:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8a78ff10d6a44679ba516f47e6f54c7~tplv-k3u1fbpfcp-watermark.image?)

findOne 只是比 find 多加了个 LIMIT 1，其余的都一样。

```javascript
import { In } from "typeorm";
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const users = await AppDataSource.manager.find(User, {
        select: {
            firstName: true,
            age: true
        },
        where: {
            id: In([4, 8])
        },
        order: {
            age: 'ASC'
        }
    });
    console.log(users);

}).catch(error => console.log(error))
```

把它改为 find，id 改为 In(\[4, 8]) 之后，结果如下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8125186d186242a5808b1a229a93c4cb~tplv-k3u1fbpfcp-watermark.image?)

通过 findOneBy 也可以：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const user = await AppDataSource.manager.findOneBy(User, {
        age: 23
    });
    console.log(user);

}).catch(error => console.log(error))

```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac138e01557a4a62889dc64d5aeff80c~tplv-k3u1fbpfcp-watermark.image?)

此外，findOne 还有两个特殊的方法：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    try {
        const user = await AppDataSource.manager.findOneOrFail(User, {
            where: {
                id: 666
            }
        });
        console.log(user);
    }catch(e) {
        console.log(e);
        console.log('没找到该用户');
    }

}).catch(error => console.log(error))
```

findOneOrFail 或者 findOneByOrFail，如果没找到，会抛一个 EntityNotFoundError 的异常：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c99afb58485b4cd1a639705baaeea0e8~tplv-k3u1fbpfcp-watermark.image?)

此外，你还可以用 query 方法直接执行 sql 语句：

```javascript
import { AppDataSource } from "./data-source"

AppDataSource.initialize().then(async () => {

    const users = await AppDataSource.manager.query('select * from user where age in(?, ?)', [21, 22]);
    console.log(users);

}).catch(error => console.log(error))
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff2f8b7f751d4260ac96a813c3586514~tplv-k3u1fbpfcp-watermark.image?)

但复杂 sql 语句不会直接写，而是会用 query builder：

```javascript
const queryBuilder = await AppDataSource.manager.createQueryBuilder();

const user = await queryBuilder.select("user")
    .from(User, "user")
    .where("user.age = :age", { age: 21 })
    .getOne();

console.log(user);
```

生成的 sql 语句如下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe7d9cddd5104c2d96338594b0c37799~tplv-k3u1fbpfcp-watermark.image?)

有同学说，用 query builder 和我用 find 指定 where 有什么区别么？

比如这种复杂的关联查询：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/001dab3056554f77aa363f4d9b32c889~tplv-k3u1fbpfcp-watermark.image?)

涉及到多个表，也就是多个 Entity 的关联查询，就得用 query builder 了。

简单点查询直接 find 指定 where 条件就行。

此外，多条有关联的数据的增删改都离不开事务，怎么开启事务呢？

用 transaction 方法包裹下就好了。

```javascript
await AppDataSource.manager.transaction(async manager => {
    await manager.save(User, {
        id: 4,
        firstName: 'eee',
        lastName: 'eee',
        age: 20
    });
});
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fc82b394b94424dad6ae1124970d339~tplv-k3u1fbpfcp-watermark.image?)

还有，调用每个方法的时候都要先传入实体类，这也太麻烦了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d249eb48590b49db85284b9b4da6cdd8~tplv-k3u1fbpfcp-watermark.image?)

有没有什么简便方法呢？

有，可以先调用 getRepository 传入 Entity，拿到专门处理这个 Entity 的增删改查的类，再调用这些方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/621f7d87ca734963aff778b7e4ee454e~tplv-k3u1fbpfcp-watermark.image?)

具体的方法和 EntityManager 是一样的。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-all-feature)。

## 总结

我们过了一遍 TypeORM 的各种概念，画个图总结下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df762fa8ccb948f6ae3ca66a92640975~tplv-k3u1fbpfcp-watermark.image?)

DataSource 里管理着数据库连接配置，数据库驱动包，调用它的 intialize 方法会创建和 mysql 的连接。

连接创建的时候，如果指定了 synchronize，会根据 Entitiy 生成建表 sql。

Entity 里通过 @Entity 指定和数据库表的映射，通过 @PrimaryGeneratedColumn 和 @Column 指定和表的字段的映射。

对 Entity 做增删改查通过 EntityManager 的 save、delete、find、createQueryBuilder 等方法。

如果只是对单个 Entity 做 CRUD，那可以先 getRepository 拿到对具体 Entity 操作的工具类，再调用 save、delete、find 等方法。

具体的 EntityManager 和 Repository 的方法有这些：

*   save：新增或者修改 Entity，如果传入了 id 会先 select 再决定修改还新增
*   update：直接修改 Entity，不会先 select
*   insert：直接插入 Entity
*   delete：删除 Entity，通过 id
*   remove：删除 Entity，通过对象
*   find：查找多条记录，可以指定 where、order by 等条件
*   findBy：查找多条记录，第二个参数直接指定 where 条件，更简便一点
*   findAndCount：查找多条记录，并返回总数量
*   findByAndCount：根据条件查找多条记录，并返回总数量
*   findOne：查找单条记录，可以指定 where、order by 等条件
*   findOneBy：查找单条记录，第二个参数直接指定 where 条件，更简便一点
*   findOneOrFail：查找失败会抛 EntityNotFoundError 的异常
*   query：直接执行 sql 语句
*   createQueryBuilder：创建复杂 sql 语句，比如 join 多个 Entity 的查询
*   transaction：包裹一层事务的 sql
*   getRepository：拿到对单个 Entity 操作的类，方法同 EntityManager

这些概念和 api 在后面会经常用到，需要理解它们各自都是干啥的。


## 47.TypeORM 一对一的映射和关联 CRUD

在数据库里，表和表之间是存在关系的。

比如用户和身份证是一对一的关系，部门和员工是一对多的关系，文章和标签是多对多的关系。

我们是通过外键来存储这种关系的，多对多的话还要建立中间表。

TypeORM 是把表、字段、表和表的关系映射成 Entity 的 class、属性、Entity 之间的关系，那如何映射这种一对一、一对多、多对多的关系呢？

我们来试一下。

这次创建个新的 database 来用：

```sql
create database typeorm_test;
```

执行它：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/289f4e8f06344612b44eb5b1ea5da799~tplv-k3u1fbpfcp-watermark.image?)

点击刷新，就可以看到这个新的 database 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ba26fccc9e643349e556f183d453afb~tplv-k3u1fbpfcp-watermark.image?)

我们用 typeorm 连上它来自动创建表。

```sql
npx typeorm@latest init --name typeorm-relation-mapping --database mysql
```

创建个 typeorm 项目。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ecb2a5465d843c3bcec9e37734cf934~tplv-k3u1fbpfcp-watermark.image?)

修改 DataSource 的配置：

```javascript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "typeorm_test",
    synchronize: true,
    logging: true,
    entities: [User],
    migrations: [],
    subscribers: [],
    poolSize: 10,
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})
```

安装驱动包  mysql2

    npm install --save mysql2

然后跑起来：

    npm run start

可以看到，它生成了建表 sql 和插入数据的 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d95575452cd945fe8b974a537c64d17d~tplv-k3u1fbpfcp-watermark.image?)

点击刷新，在 workbench 里也可以看到这个新建的表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c83fa31ec754a6a87e3707d997db45c~tplv-k3u1fbpfcp-watermark.image?)

点击新建 sql，执行 select，也是可以看到插入的数据的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab5c65d2ae78484a9a5fbd52daa35aa9~tplv-k3u1fbpfcp-watermark.image?)

然后我们再创建个身份证表。

通过 typeorm entity:create 命令创建：

```sql
npx typeorm entity:create src/entity/IdCard
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8087008a6a334c78aedbb020ee3c0116~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8cd0fb941df47be9ae85cc56d3be346~tplv-k3u1fbpfcp-watermark.image?)

填入属性和映射信息：

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm"

@Entity({
    name: 'id_card'
})
export class IdCard {
    @PrimaryGeneratedColumn()
    id: number

    @Column({
        length: 50,
        comment: '身份证号'
    })
    cardName: string
}
```

在 DataSource 的 entities 里引入下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c8d991bff3e4d18a75f474088347a20~tplv-k3u1fbpfcp-watermark.image?)

重新 npm run start：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e98e1b98ee364976b612ca7f52330e30~tplv-k3u1fbpfcp-watermark.image?)

可以看到生成了这条建表 sql。

workbench 里也可以看到这个表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b89af9f78e1405fb0da310cd259a945~tplv-k3u1fbpfcp-watermark.image?)

现在 user 和 id\_card 表都有了，怎么让它们建立一对一的关联呢？

先把这两个表删除：

```sql
drop table id_card,user;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6cdd7a6e124c4c8295e55a9e478cb0~tplv-k3u1fbpfcp-watermark.image?)

在 IdCard 的 Entity 添加一个 user 列，指定它和 User 是 @OneToTone 一对一的关系。

还要指定 @JoinColum 也就是外键列在 IdCard 对应的表里维护：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df3d8610e46b44d7a12a55e807e8c401~tplv-k3u1fbpfcp-watermark.image?)

重新 npm run start：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c16cb9f63228424098ab34a79b005013~tplv-k3u1fbpfcp-watermark.image?)

仔细看生成的这 3 条 sql 语句。

前两个是建表 sql，创建 id\_card 和 user 表。

最后一个是给修改 id\_card 表，给 user\_id 列添加一个外建约束，引用 user 表的 id 列。

在 workbench 里看下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa9a0b1aa42349b79453e6acd2346a2a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01efc274a10a4f77b61578216bf24684~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a309c8bd67d64413bb732db91b3c6df0~tplv-k3u1fbpfcp-watermark.image?)

生成的表都是对的。

但是这个级联关系还是默认的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7986bb37929948c189d8ec285737830a~tplv-k3u1fbpfcp-watermark.image?)

如果我们想设置 CASCADE 应该怎么做呢？

在第二个参数指定：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d17a8c308384251a41858794235969a~tplv-k3u1fbpfcp-watermark.image?)

删除这两个表：

```sql
drop table id_card,user;
```

重新 npm run start：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52dbcec0657e4637912b2273bacd8b10~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7abe9bd2e0e0435291f3e779fea2fdd7~tplv-k3u1fbpfcp-watermark.image?)

这样就设置了级联删除和级联更新。

我们再来试下增删改查：

```javascript
import { AppDataSource } from "./data-source"
import { IdCard } from "./entity/IdCard"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const user = new User();
    user.firstName = 'guang';
    user.lastName = 'guang';
    user.age = 20;
    
    const idCard = new IdCard();
    idCard.cardName = '1111111';
    idCard.user = user;
    
    await AppDataSource.manager.save(user);
    await AppDataSource.manager.save(idCard);

}).catch(error => console.log(error))
```

创建 user 和 idCard 对象，设置 idCard.user 为 user，也就是建立关联。

然后先保存 user，再保存 idCard。

跑 npm run start，生成的 sql 如下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff2f5d922cc3438b97dda180e1624ea9~tplv-k3u1fbpfcp-watermark.image?)

可以看到后面插入 id\_card 的时候，已经有 userId 可以填入了。

数据都插入成功了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/725cfd2318a4447db556c989f0c1c09c~tplv-k3u1fbpfcp-watermark.image?)

但是我还要分别保存 user 和 idCard，能不能自动按照关联关系来保存呢？

可以的，在 @OneToOne 那里指定 cascade 为 true：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3c41fc3ef2d443497900c72f3945cb4~tplv-k3u1fbpfcp-watermark.image?)

这个 cascade 不是数据库的那个级联，而是告诉 typeorm 当你增删改一个 Entity 的时候，是否级联增删改它关联的 Entity。

这样我们就不用自己保存 user 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d301618a68b4220a9e9eb92ecabecb0~tplv-k3u1fbpfcp-watermark.image?)

重新 npm run start：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfbac4e51cd342dea93316582285343f~tplv-k3u1fbpfcp-watermark.image?)

可以看到它同样是先插入了 user，再插入了 id\_card，并且设置了正确的 userId。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b6980a7a59b418e994e56a43df71b0b~tplv-k3u1fbpfcp-watermark.image?)

保存了之后，怎么查出来呢？

我们用 find 来试下：

```javascript
const ics = await AppDataSource.manager.find(IdCard);
console.log(ics);
```

跑下 npm run start：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99bf23a8acb14c6eab552b7266b4d906~tplv-k3u1fbpfcp-watermark.image?)

可以看到 idCard 查出来了，但是关联的 user 没查出来。

只需要声明下 relations 关联查询就好了：

```javascript
const ics = await AppDataSource.manager.find(IdCard, {
    relations: {
        user: true
    }
});
console.log(ics);
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c652abacfca8496287338231701eb07a~tplv-k3u1fbpfcp-watermark.image?)

再跑一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22f1825077d54f46997f85207716e64d~tplv-k3u1fbpfcp-watermark.image?)

现在 idCard 关联的 user 就被查出来了。

当然，你也可以用 query builder 的方式来查询：

```javascript
const ics = await AppDataSource.manager.getRepository(IdCard)
    .createQueryBuilder("ic")
    .leftJoinAndSelect("ic.user", "u")
    .getMany();

console.log(ics);
```

先 getRepository 拿到操作 IdCard 的 Repository 对象。

再创建 queryBuilder 来连接查询，给 idCard 起个别名 ic，然后连接的是 ic.user，起个别名为 u：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8b2ead32b974f269b92fc0e8ce4f2ef~tplv-k3u1fbpfcp-watermark.image?)

或者也可以直接用 EntityManager 创建 queryBuilder 来连接查询：

```javascript
const ics = await AppDataSource.manager.createQueryBuilder(IdCard, "ic")
    .leftJoinAndSelect("ic.user", "u")
    .getMany();
console.log(ics);
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1713e7f2b184b92bbf0bdb62922efa6~tplv-k3u1fbpfcp-watermark.image?)

再来试下修改：

现在数据是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/038aaeed8c4740b0ae45628dda09601e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d33b24bcad5a470187dbb7a3a7f3991d~tplv-k3u1fbpfcp-watermark.image?)

我们给它加上 id 再 save：

```javascript
const user = new User();
user.id = 1;
user.firstName = 'guang1111';
user.lastName = 'guang1111';
user.age = 20;

const idCard = new IdCard();
idCard.id = 1;
idCard.cardName = '22222';
idCard.user = user;

await AppDataSource.manager.save(idCard);
```

这样数据就被修改了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bb5e3d383854283b27f41eb2bade7a8~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73602e594f1c4cdd90ac32b06dd46706~tplv-k3u1fbpfcp-watermark.image?)

看下生成的 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d415ee641574a188c713d7423312d96~tplv-k3u1fbpfcp-watermark.image?)

在一个事务内，执行了两条 update 的 sql。

最后再试试删除。

因为设置了外键的 onDelete 是 cascade，所以只要删除了 user，那关联的 idCard 就会跟着被删除。

```javascript
await AppDataSource.manager.delete(User, 1)
```

如果不是没有这种级联删除，就需要手动删了：

```javascript
const idCard = await AppDataSource.manager.findOne(IdCard, {
    where: {
        id: 1
    },
    relations: {
        user: true
    }
})
await AppDataSource.manager.delete(User, idCard.user.id)
await AppDataSource.manager.delete(IdCard, idCard.id)
```

不过现在我们只是在 idCard 里访问 user，如果想在 user 里访问 idCard 呢？

同样需要加一个 @OneToOne 的装饰器：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/130e467d600046bda18ad71a9134db12~tplv-k3u1fbpfcp-watermark.image?)

不过需要有第二个参数。

因为如果是维持外键的那个表，也就是有 @JoinColumn 的那个 Entity，它是可以根据外键关联查到另一方的。

但是没有外键的表怎么查到另一方呢？

所以这里通过第二个参数告诉 typeorm，外键是另一个 Entity 的哪个属性。

我们查一下试试：

```javascript
const user = await AppDataSource.manager.find(User, {
    relations: {
        idCard: true
    }
});
console.log(user);
```

可以看到，同样关联查询成功了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92b000c9b2404bccb478a2d373770178~tplv-k3u1fbpfcp-watermark.image?)

这就是一对一关系的映射和增删改查。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-relation-mapping)。

## 总结

TypeORM 里一对一关系的映射通过 @OneToOne 装饰器来声明，维持外键列的 Entity 添加 @JoinColumn 装饰器。

如果是非外键列的 Entity，想要关联查询另一个 Entity，则需要通过第二个参数指定外键列是另一个 Entity 的哪个属性。

可以通过 @OneToOne 装饰器的 onDelete、onUpdate 参数设置级联删除和更新的方式，比如 CASCADE、SET NULL 等。

还可以设置 cascade，也就是 save 的时候会自动级联相关 Entity 的 save。

增删改分别通过 save 和 delete 方法，查询可以通过 find 也可以通过 queryBuilder，不过要 find 的时候要指定 relations 才会关联查询。

这就是 TypeORM 里一对一的映射和增删改查，下节我们继续学习一对多的映射。


## 48.TypeORM 一对多的映射和关联 CRUD

这节我们继续来学习 TypeORM 的一对多关系的映射和 CRUD。

我们再创建个 typeorm 项目：

    npx typeorm@latest init --name typeorm-relation-mapping2 --database mysql

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dde5d6e41ad141319a2496d4d761ead7~tplv-k3u1fbpfcp-watermark.image?)

进入项目目录，安装驱动包 mysql2：

    npm install mysql2

然后修改 data-source.ts 的配置：

```javascript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "typeorm_test",
    synchronize: true,
    logging: true,
    entities: [User],
    migrations: [],
    subscribers: [],
    poolSize: 10,
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})
```

这些前面讲过，就不解释了。

这次我们创建 Department 和 Employee 两个实体：

    npx typeorm entity:create src/entity/Department
    npx typeorm entity:create src/entity/Employee

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0604b5a3cac4b2f8e6bad406c303265~tplv-k3u1fbpfcp-watermark.image?)

然后添加 Department 和 Employee 的映射信息：

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm"

@Entity()
export class Department {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    name: string;
}
```

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm"

@Entity()
export class Employee {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    name: string;
}

```

把这俩 Entity 添加到 DataSource 的 entities 里：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03a61bf59552446aa4350256e51da21d~tplv-k3u1fbpfcp-watermark.image?)

因为 index.ts 里用到了 User，我们用不到，把这些代码删掉：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74447a43f4684f26ba23e0b9f1e888cf~tplv-k3u1fbpfcp-watermark.image?)

然后 npm run start：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c92660e35454f9e8150d8eb3ee54d80~tplv-k3u1fbpfcp-watermark.image?)

可以看到，这两个表都创建成功了。

如何给它们添加一对多的映射呢？

通过 @ManyToOne 的装饰器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfa9952b7f154b889fadcf0cfe7e1170~tplv-k3u1fbpfcp-watermark.image?)

在多的一方使用 @ManyToOne 装饰器。

把这两个表删掉：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ac14654840f4316b4ed94f482f8b7c1~tplv-k3u1fbpfcp-watermark.image?)

重新 npm run start：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2475c4ecb6a49f791202d4153bd212c~tplv-k3u1fbpfcp-watermark.image?)

就可以看到创建了两个表，并且在 employee 表添加了外建约束。

workbench 里也可以看到这个外键：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2591f81f48c24601a0acbc0bfe03d99f~tplv-k3u1fbpfcp-watermark.image?)

改下 index.ts，新增一些数据，调用 save 保存：

```javascript
import { Department } from './entity/Department';
import { Employee } from './entity/Employee';
import { AppDataSource } from "./data-source"

AppDataSource.initialize().then(async () => {

    const d1 = new Department();
    d1.name = '技术部';

    const e1 = new Employee();
    e1.name = '张三';
    e1.department = d1;

    const e2 = new Employee();
    e2.name = '李四';
    e2.department = d1;

    const e3 = new Employee();
    e3.name = '王五';
    e3.department = d1;

    await AppDataSource.manager.save(Department, d1);
    await AppDataSource.manager.save(Employee,[e1, e2, e3]);


}).catch(error => console.log(error))

```

再跑下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be620ad3f954e669b145d404f50be10~tplv-k3u1fbpfcp-watermark.image?)

可以看到被 transaction 包裹的 4 条 insert 语句，分别插入了 Department 和 3 个 Employee。

当然，如果是设置了 cascade，那就只需要保存 empolyee 就好了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/745f52949d64473d8eb2d7933e5d5af5~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bca5a6471ba490cb5dc47e89be08025~tplv-k3u1fbpfcp-watermark.image?)

department 会自动级联保存。

不过一对多关系更多还是在一的那一方来保持关系，我们改下 Department：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b15bc0a2d4844769fba04375a9e6c04~tplv-k3u1fbpfcp-watermark.image?)

这里要通过第二个参数指定外键列在 employee.department 维护。

一对一的时候我们还通过 @JoinColumn 来指定外键列，为什么一对多就不需要了呢？

因为一对多的关系只可能是在多的那一方保存外键呀！

所以并不需要 @JoinColumn。

不过你也可以通过 @JoinColumn 来修改外键列的名字：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5de7e821f8f14236b9f03c22f68fb699~tplv-k3u1fbpfcp-watermark.image?)

加上 @OneToMany 装饰器，再设置下 cascade：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e9078f868684211a03bf09c8c491917~tplv-k3u1fbpfcp-watermark.image?)

这样当你保存 department 的时候，关联的 employee 也都会保存了。

不过这时候要把 @ManyToOne 的 cascade 去掉。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3b1a6a929c549d5bc613bb2fdf251fd~tplv-k3u1fbpfcp-watermark.image?)

不然，双方都级联保存，那不就无限循环了么？

然后修改下 index.ts

```javascript
import { Department } from './entity/Department';
import { Employee } from './entity/Employee';
import { AppDataSource } from "./data-source"

AppDataSource.initialize().then(async () => {
    const e1 = new Employee();
    e1.name = '张三';

    const e2 = new Employee();
    e2.name = '李四';

    const e3 = new Employee();
    e3.name = '王五';

    const d1 = new Department();
    d1.name = '技术部';
    d1.employees = [e1, e2, e3];

    await AppDataSource.manager.save(Department, d1);

}).catch(error => console.log(error))
```

只需要设置 department 的 employees 属性，然后 save 这个 department。

这样关联的 employee 就会自动保存：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c72d102c8b524a9882f20fff0b47425f~tplv-k3u1fbpfcp-watermark.image?)

然后再来试下查询：

```javascript
const deps = await AppDataSource.manager.find(Department);
console.log(deps);
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84912b3adb084482a8bb78252feb61a2~tplv-k3u1fbpfcp-watermark.image?)

想要关联查询需要声明下 relations：

```javascript
const deps = await AppDataSource.manager.find(Department, {
    relations: {
        employees: true
    }
});
console.log(deps);
console.log(deps.map(item => item.employees))
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa1c72281bf84b6e810505951c3f8c3d~tplv-k3u1fbpfcp-watermark.image?)

这个 relations 其实就是 left join on，或者通过 query builder 来手动关联：

```javascript
const es = await AppDataSource.manager.getRepository(Department)
            .createQueryBuilder('d')
            .leftJoinAndSelect('d.employees', 'e')
            .getMany();

console.log(es);
console.log(es.map(item => item.employees))
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0923a93bc67344dfb0f1c5ba07aed1cc~tplv-k3u1fbpfcp-watermark.image?)

先 getRepository 再创建 query builder。

也可以直接用 EntityManager 来创建 query builder：
```javascript
const es = await AppDataSource.manager
    .createQueryBuilder(Department, 'd')
    .leftJoinAndSelect('d.employees', 'e')
    .getMany();

console.log(es);
console.log(es.map(item => item.employees))
```
删除的话，需要先把关联的 employee 删了，再删除 department：

```javascript
const deps = await AppDataSource.manager.find(Department, {
    relations: {
        employees: true
    }
});
await AppDataSource.manager.delete(Employee, deps[0].employees);
await AppDataSource.manager.delete(Department, deps[0].id);
```

当然，如果你设置了 onDelete 为 SET NULL 或者 CASCADE：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc3d68fe32de4d9b81599b19b1c6563f~tplv-k3u1fbpfcp-watermark.image?)

那就不用自己删 employee 了，只要删了 department，mysql 会自动把关联的 employee 记录删除，或者是把它们的外键 id 置为空。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd78e822ae5b47c09d18e02c534247c0~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-relation-mapping2)。

## 总结

这节我们学了一对多关系的映射，通过 @ManyToOne 或者 @OneToMany 装饰器。

TypeORM 会自动在多的那一方添加外键，不需要通过 @JoinColumn 指定，不过你可以通过 @JoinColumn 来修改外键列的名字。

双方只能有一方 cascade，不然会无限循环。设置了 cascade 之后，只要一方保存，关联的另一方就会自动保存。

删除的话，如果设置了外键的 CASCADE 或者 SET NULL，那只删除主表（一的那一方）对应的 Entity 就好了，msyql 会做后续的关联删除或者 id 置空。

否则就要先删除所有的从表（多的那一方）对应的 Entity 再删除主表对应的 Entity。

这就是 typeorm 的一对多关系的映射和 CRUD。


## 49.TypeORM 多对多的映射和关联 CRUD

一对一我们是通过 @OneToOne 和 @JoinColumn 来把 Entity 映射成数据库表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c40b8c521165441991a762e9c7cc3395~tplv-k3u1fbpfcp-watermark.image?)

Entity 之间的引用关系，转换为数据库表之间的外键关联的关系。

一对多我们是通过 @OneToMany 和 @ManyToOne 来把 Entity 映射成数据库表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d18957782a1d4dbcac78b8cdc865b407~tplv-k3u1fbpfcp-watermark.image?)

它并不需要 @JoinColumn 来指定外键列，因为外键一定在多的那一边。

那多对多呢？

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e664bb6f14743729dd67f7b870d8a06~tplv-k3u1fbpfcp-watermark.image?)

前面讲过，在数据库里，我们是通过中间表来保存这种多对多的关系的：

把多对多拆成了两个一对多：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac6f99b6f208400d8061f16bbde3e3e4~tplv-k3u1fbpfcp-watermark.image?)

那在 TypeORM 里如何映射这种关系呢？

我们新建个项目试一下：

    npx typeorm@latest init --name typeorm-relation-mapping3 --database mysql

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6be12f3d655242d791245f9311571bf8~tplv-k3u1fbpfcp-watermark.image?)

进入项目目录，安装驱动包 mysql2：

    npm install mysql2

然后修改 data-source.ts 的配置：

```javascript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "typeorm_test",
    synchronize: true,
    logging: true,
    entities: [User],
    migrations: [],
    subscribers: [],
    poolSize: 10,
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})
```

这次我们创建 Article 和 Tag 两个实体：

    npx typeorm entity:create src/entity/Article
    npx typeorm entity:create src/entity/Tag

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd3a67aa516543b7a5a4591ae27ecbb2~tplv-k3u1fbpfcp-watermark.image?)

添加一些属性：

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm"

@Entity()
export class Article {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 100,
        comment: '文章标题'
    })
    title: string;

    @Column({
        type: 'text',
        comment: '文章内容'
    })
    content: string;
}
```

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm"

@Entity()
export class Tag {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 100
    })
    name: string;
}
```

然后在 data-source.ts 里引入这俩 Entity：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42be5aed5ca44586b6aebdf15c365c62~tplv-k3u1fbpfcp-watermark.image?)

把 index.ts 的代码去掉：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a00e5ff72efd4b3993146e9f56cbd113~tplv-k3u1fbpfcp-watermark.image?)

然后 npm run start

可以看到它生成了两个 Entity 的建表 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac374c12012b4eddbcad023f86132b99~tplv-k3u1fbpfcp-watermark.image?)

然后把这两个表删掉，我们来添加多对多的关联关系：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07c79c344e5341d7884874b616cf06f8~tplv-k3u1fbpfcp-watermark.image?)

在 Entity 里通过 @ManyToMany 关联。

比如一篇文章可以有多个标签：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d52e7c12b55f43c99bf77f5a5548f906~tplv-k3u1fbpfcp-watermark.image?)

然后再 npm run start

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daac35c8e10147719fcf818d28d30576~tplv-k3u1fbpfcp-watermark.image?)

你会看到 3 条建表 sql，分别是 article、tag 和中间表 article\_tags\_tag

并且 article\_tags\_tag 还有 2 个外键分别引用着两个表。

级联删除和级联更新都是 CASCADE，也就是说这两个表的记录删了，那它在中间表中的记录也会跟着被删。

就这样就映射成功了。

你也可以自己指定中间表的名字：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e941d66ca6444cfb1b9be079decfa04~tplv-k3u1fbpfcp-watermark.image?)

我们插入点数据试试：

```javascript
import { AppDataSource } from "./data-source"
import { Article } from "./entity/Article"
import { Tag } from "./entity/Tag";

AppDataSource.initialize().then(async () => {

    const a1 = new Article();
    a1.title = 'aaaa';
    a1.content = 'aaaaaaaaaa';

    const a2 = new Article();
    a2.title = 'bbbbbb';
    a2.content = 'bbbbbbbbbb';

    const t1 = new Tag();
    t1.name = 'ttt1111';

    const t2 = new Tag();
    t2.name = 'ttt2222';

    const t3 = new Tag();
    t3.name = 'ttt33333';

    a1.tags = [t1,t2];
    a2.tags = [t1,t2,t3];

    const entityManager = AppDataSource.manager;

    await entityManager.save(t1);
    await entityManager.save(t2);
    await entityManager.save(t3);

    await entityManager.save(a1);
    await entityManager.save(a2);

}).catch(error => console.log(error))
```

创建了两篇文章，3 个标签，建立它们的关系之后，先保存所有的 tag，再保存 article。

跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9eede1ca003742cca0435b005e9928ec~tplv-k3u1fbpfcp-watermark.image?)

可以看到，3 个标签、2 篇文章，还有两者的关系，都插入成功了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd75621331b422f937dd32a20d1a546~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3eddc2d736aa48f297b3817e81067d9d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30e5cc2e8767462c914de819305e3138~tplv-k3u1fbpfcp-watermark.image?)

再来查询：

```javascript
const article = await entityManager.find(Article, {
    relations: {
        tags: true
    }
});

console.log(article);
console.log(article.map(item=> item.tags))
```

同样是通过 relations 指定关联查询：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2241f97590c416c8e574d4f011384e5~tplv-k3u1fbpfcp-watermark.image?)

也可以手动用 query builder 来 join 查询：

```javascript
const article = await entityManager
    .createQueryBuilder(Article, "a")
    .leftJoinAndSelect("a.tags", "t")
    .getMany()
    
console.log(article);
console.log(article.map(item=> item.tags))
```

结果一样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12653fa1b3cf4d0597fad9dec012b9d0~tplv-k3u1fbpfcp-watermark.image?)

或者先拿到 Article 的 Repository 再创建 query builder 来查询也行：

```javascript
const article = await entityManager
    .getRepository(Article)
    .createQueryBuilder( "a")
    .leftJoinAndSelect("a.tags", "t")
    .getMany()

console.log(article);
console.log(article.map(item=> item.tags))
```

那如果文章多加了一些标签或者删除了一些标签，怎么修改呢？

比如我把 id 为 2 的文章的标签只保留包含 111 的，并且还改了标题：

```javascript
const article = await entityManager.findOne(Article, {
    where: {
        id: 2
    },
    relations: {
        tags: true
    }
});

article.title = "ccccc";

article.tags = article.tags.filter(item => item.name.includes('ttt111'));

await entityManager.save(article);
```

之前它是有 3 个标签的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b620f462cab048ea876594595a1c03f0~tplv-k3u1fbpfcp-watermark.image?)

npm run start 跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/961aeb4deaef44e8a463edb3481a4a36~tplv-k3u1fbpfcp-watermark.image?)

它会先查出 id 为 2 的 article 有哪些标签，查出了 1、2、3。

然后会把他和 id 为 2 的 article 的关系，(2, 2) (2, 3) 从中间表中删除。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/815df41dc4a74463b56419d29e075a2d~tplv-k3u1fbpfcp-watermark.image?)

这样就这个 article 就只有 id 为 1 的 tag 了。

此外，更新 article.title 的是另一个 update 语句：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/264fcc9452a743638b412d67fd69a2c6~tplv-k3u1fbpfcp-watermark.image?)

至于删除就简单了，因为中间表的外键设置了 CASCADE 的级联删除，这样只要你删除了 article 或者 tag，它都会跟着删除关联记录。

```javascript
await entityManager.delete(Article, 1);
await entityManager.delete(Tag, 1);
```

如果 tag 里也想有文章的引用呢？

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/360a971be7c449e3841c89325473245d~tplv-k3u1fbpfcp-watermark.image?)

那就加一个 @ManyToMany 的映射属性。

只不过它还需要第二个参数指定外键列在哪里。

而且不止这里要加，article 里也要加：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/284dd14811dd4d6cb964711dd83c2549~tplv-k3u1fbpfcp-watermark.image?)

为什么呢？

因为如果当前 Entity 对应的表是包含外键的，那它自然就知道怎么找到关联的 Entity。

但如果当前 Entity 是不包含外键的那一方，怎么找到对方呢？

这时候就需要手动指定通过哪个外键列来找当前 Entity 了。

之前 OneToOne、OnToMany 都是这样：

比如一对一的 user 那方，不维护外键，所以需要第二个参数来指定通过哪个外键找到 user。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d52c74903154221be13daf6df188671~tplv-k3u1fbpfcp-watermark.image?)

一对多的 department 那方，不维护外键，所以需要第二个参数来指定通过哪个外键找到 department：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0ccf65f61694282b130fcc0f8831ff0~tplv-k3u1fbpfcp-watermark.image?)

而多对多的时候，双方都不维护外键，所以都需要第二个参数来指定外键列在哪里，怎么找到当前 Entity。

然后我们通过 tag 来关联查询下：

```javascript
const tags = await entityManager.find(Tag, {
    relations: {
        articles: true
    }
});

console.log(tags);
```

也是能成功关联查出来的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1bbab6da23c464da16f1f5c81b77450~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-relation-mapping3)。

## 总结

这节我们学了多对多关系在 Entity 里怎么映射，是通过 @ManyToMany 和 @JoinTable 来声明的。

但如果双方都保留了对方的引用，需要第二个参数来指定关联的外键列在哪，也就是如何查找当前 entity。

多对多关系的修改只要查出来之后修改下属性，然后 save，TypeORM 会自动去更新中间表。

至此，一对一、一对多、多对多关系的 Entity 如何映射到数据库的 table，如何增删改查，我们就都学会了。


## 5.IoC 解决了什么痛点问题？

后端系统中，会有很多对象：

- Controller 对象：接收 http 请求，调用 Service，返回响应
- Service 对象：实现业务逻辑
- Repository 对象：实现对数据库的增删改查

此外，还有数据库链接对象 DataSource，配置对象 Config 等等。

这些对象有着错综复杂的关系：

Controller 依赖了 Service 实现业务逻辑，Service 依赖了 Repository 来做增删改查，Repository 依赖 DataSource 来建立连接，DataSource 又需要从 Config 对象拿到用户名密码等信息。

这就导致了创建这些对象是很复杂的，你要理清它们之间的依赖关系，哪个先创建哪个后创建。

比如这样：
```javascript
const config = new Config({ username: 'xxx', password: 'xxx'});

const dataSource = new DataSource(config);

const repository = new Repository(dataSource);

const service = new Service(repository);

const controller = new Controller(service);
```

要经过一系列的初始化之后才可以使用 Controller 对象。

而且像 config、dataSource、repository、service、controller 等这些对象不需要每次都 new 一个新的，一直用一个就可以，也就是保持单例。

在应用初始化的时候，需要理清依赖的先后关系，创建一大堆对象组合起来，还要保证不要多次 new，是不是很麻烦？

没错，这是一个后端系统都有的痛点问题。

解决这个痛点的方式就是 IoC（Inverse of Control）。

java 的 Spring 就实现了 IoC，Nest 也同样实现了。

那什么是 IoC 呢？

之前我们手动创建和组装对象不是很麻烦么，我能不能在 class 上声明依赖了啥，然后让工具去分析我声明的依赖关系，根据先后顺序自动把对象创建好了并组装起来呢？

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a02ad15e2504619920e06730a00fedb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932&h=550&s=103716&e=png&b=1f1f1f)

比如这样声明 AppController 依赖了这两个 Service，然后让工具分析依赖自动帮我创建好这三个对象并设置依赖关系。

这就是 IoC 的实现思路。

它有一个放对象的容器，程序初始化的时候会扫描 class 上声明的依赖关系，然后把这些 class 都给 new 一个实例放到容器里。

创建对象的时候，还会把它们依赖的对象注入进去。

这样不就完成了自动的对象创建和组装么？

这种依赖注入的方式叫做 Dependency Injection，简称 DI。

而这种方案为什么叫 IoC 也很容易理解了，本来是手动 new 依赖对象，然后组装起来，现在是声明依赖了啥，等待被注入。

从主动创建依赖到被动等待依赖注入，这就是 Inverse of Control，反转控制。

在 class 上声明依赖的方式，大家都选择了装饰器的方式（在 java 里这种语法叫做注解）。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d890fa5e94e49beb7b296589afb4452~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=540&s=101458&e=png&b=1f1f1f)

比如上面就是声明这个 class 要放到 IOC 容器里，然后它的依赖是啥。

这样 IOC 容器扫描到它就知道怎么创建它的对象了。

知道了 IOC 是啥，下面我们来看看真实的 Nest 项目里是怎么用 IoC 的：

```
npx nest new nest-ioc
```

执行上面的命令，它会创建一个 nest 项目：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c646a1a3d6e346dab7cc4ed507997ba7~tplv-k3u1fbpfcp-watermark.image?)

选择一个 npm 包管理工具，然后 nest cli 会自动创建项目结构并安装依赖：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e06a93b361f49888d95bd78a05b55eb~tplv-k3u1fbpfcp-watermark.image?)

然后进入这个目录，执行 npm run start，把服务跑起来：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4b95248dbd4a9493e6b3e05d407f1a~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问 http://localhost:3000 就可以看到 nest 服务返回的 hello world：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60b7f8ba57a84eebaf895b818a494416~tplv-k3u1fbpfcp-watermark.image?)

我们看看代码里它是怎么创建对象的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08429e4340cf4baf851b2bacb1359cd0~tplv-k3u1fbpfcp-watermark.image?)

它有一个 AppService 声明了 @Injectable，代表这个 class 可注入，那么 nest 就会把它的对象放到 IOC 容器里。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/362872afddcc4a6d8b45e73926c95fe7~tplv-k3u1fbpfcp-watermark.image?)

AppController 声明了 @Controller，代表这个 class 可以被注入，nest 也会把它放到 IoC 容器里。

AppController 的构造器参数依赖了 AppService。

或者这样通过属性的方式声明依赖：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1145a8a972404fc9a68a5207f7a236bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=586&h=392&s=58460&e=png&b=1f1f1f)

前者是构造器注入，后者是属性注入，两种都可以。

为什么 Controller 是单独的装饰器呢？

因为 Service 是可以被注入也是可以注入到别的对象的，所以用 @Injectable 声明。

而 Controller 只需要被注入，所以 nest 单独给它加了 @Controller 的装饰器。

然后在 AppModule 里引入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bddbc6b4da34e87bfbaea8245c4b634~tplv-k3u1fbpfcp-watermark.image?)

通过 @Module 声明模块，其中 controllers 是控制器，只能被注入。

providers 里可以被注入，也可以注入别的对象，比如这里的 AppService。

然后在入口模块里跑起来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8862d45d9c04adc98230c81042e9b4a~tplv-k3u1fbpfcp-watermark.image?)

那么 nest 就会从 AppModule 开始解析 class 上通过装饰器声明的依赖信息，自动创建和组装对象。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5245830454164037a3001c6c4288a8b3~tplv-k3u1fbpfcp-watermark.image?)

所以 AppController 只是声明了对 AppService 的依赖，就可以调用它的方法了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a0ad84c4cec43bc8c0bbbc2de99e8f5~tplv-k3u1fbpfcp-watermark.image?)

nest 在背后自动做了对象创建和依赖注入的工作。

nest 还加了模块机制，可以把不同业务的 controller、service 等放到不同模块里。

```
nest g module other
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ee471d1a60e4c428046a2dac1ff0b82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=644&h=106&s=26693&e=png&b=191919)

会生成如下代码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d33f113a003b4738a5642240df83535e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1204&h=326&s=66266&e=png&b=1d1d1d)

用 nest cli 的 generate 命令生成一个模块。

会在 AppModule 里自动 imports 这个模块：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49df422f1ac842f3b3b1f27089ef029f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=928&h=452&s=97333&e=png&b=1f1f1f)

当 import 别的模块后，那个模块 exports 的 provider 就可以在当前模块注入了。

比如我们再生成 OtherService：

```
nest g service other
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41684f4682384465bc0a7697318bdbc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=752&h=138&s=34546&e=png&b=191919)

会生成 Service 的代码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/484501bfb1404c55a4ac311183782541~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=254&s=39504&e=png&b=1f1f1f)

并自动添加到 OtherModule 的 providers 中：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc073d7985964d66ac58d02ad1dd50e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=836&h=320&s=57692&e=png&b=1f1f1f)

我们改下 OtherService，添加一个方法：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c35a8d474b44d029d8ebbd465e22b7a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=774&h=418&s=50522&e=png&b=1f1f1f)

然后在 OtherModule 里 exports：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14a2fe1b44ed4373a1c619a8ba69a679~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=814&h=334&s=64784&e=png&b=1f1f1f)

那当 AppModule 引用了 OtherModule 之后，就可以注入它 exports 的 OtherService 了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7166b487dde24df6988e8358c0b1cd23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1336&h=902&s=76285&e=png&b=fefaf9)

我们在 AppService 里注入下：

```javascript
import { OtherService } from './other/other.service';
import { Inject, Injectable } from '@nestjs/common';

@Injectable()
export class AppService {

  @Inject(OtherService) 
  private otherService:OtherService;

  getHello(): string {
    return 'Hello World!' + this.otherService.xxx();
  }
}

```
把服务跑起来：

```
npm run start:dev
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/110accc85c7a409395c52f33f44ba9ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1450&h=410&s=127228&e=png&b=181818)


浏览器访问下，可以看到 AppModule 的 AppService 调用 OtherModule 的 OtherService 成功了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6bea726dbab477da9cbeca914e296b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=560&h=222&s=18540&e=png&b=ffffff)

这就是 Nest 的 IoC 机制。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-ioc)。
## 总结

后端系统有很多的对象，这些对象之间的关系错综复杂，如果手动创建并组装对象比较麻烦，所以后端框架一般都提供了 IoC 机制。

IoC 机制是在 class 上标识哪些是可以被注入的，它的依赖是什么，然后从入口开始扫描这些对象和依赖，自动创建和组装对象。

Nest 里通过 @Controller 声明可以被注入的 controller，通过 @Injectable 声明可以被注入也可以注入别的对象的 provider，然后在 @Module 声明的模块里引入。

并且 Nest 还提供了 Module 和 Module 之间的 import，可以引入别的模块的 provider 来注入。

虽然 Nest 这套实现了 IoC 的模块机制看起来繁琐，但是却解决了后端系统的对象依赖关系错综复杂的痛点问题。


## 50.在 Nest 里集成 TypeORM

TypeORM 怎么用我们已经学会了，在 Nest 里用那不就是再封装一层的事情么？

那怎么封装呢？

先回忆下 TypeORM 的流程：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df762fa8ccb948f6ae3ca66a92640975~tplv-k3u1fbpfcp-watermark.image?)

DataSource 里存放着数据库连接的配置，比如用户名、密码、驱动包、连接池配置等等。

而 Entity 里通过 @Entity、@PrimaryGeneratedColumn、@Column 等装饰器来建立数据库表的映射关系。

同时还有 Entity 之间的 @OneToOne、@OneToMany、@ManyToMany 的关系，这些会映射成数据库表通过外键、中间表来建立的关系。

DataSource.initialize 的时候，会和数据库服务建立连接，如果配置了 synchronize，还会生成建表 sql 语句来创建表。

DataSource 初始化之后就可以拿到 EntityManager 了，由它负责对各种 Entity 进行增删改查，比如 find、delete、save 等方法，还可以通过 query builder 来创建复杂的查询。

如果你只是想做对单个 Entity 的 CRUD，那可以拿到这个 Entity 的 Repository 类，它同样有上面的那些方法，只是只能用来操作单个 Entity。

这就是 TypeORM 的流程。

那如果让你把 TypeORM 的 api 封装一层，做成一个 TypeOrmModule，你会怎么封装呢？

很明显，这里的 datasource 的配置是需要手动传入的，也就是说需要做成动态模块，支持根据传入的配置来动态产生模块内容。

而动态模块的规范里就 3 种方法名： register、forRoot、forFeature。

这里很明显要用 forRoot，也就是只需要注册一次，然后这个模块会在各处被使用。

类似这样：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from 'xxx';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: 'localhost',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      entities: [],
      synchronize: true,
    }),
  ],
})
export class AppModule {}
```

然后内部就根据传入的配置来创建 DataSource，调用 intialize 方法，之后就拿到 EntityManager，可以做 CRUD 了。

但是 Entity 肯定会分散在各个业务模块，每个模块都通过 forRoot 引入那个模块太麻烦，我们干脆把它用 @Global 声明成全局的。

这样每个模块里就都可以注入 EntityManager 来用了，不需要 imports。

那如果我想用 Repository 的方式来 CRUD 呢？

那可以先注入 EntityManager，然后再通过 EntityManager.getRepository(XxxEntity) 来拿呀。

或者可以再做一个动态模块，传入 Entity，返回它的 Repository。

这种局部的动态模块，一般都是用 forFeature 的名字：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from 'xxxx';
import { UsersService } from './users.service';
import { User } from './user.entity';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService],
  controllers: [],
})
export class UsersModule {}
```

比如传入 User，内部通过 EntityManager.getRepository(User) 来拿到 UserEntity。

这样 UserService 里就可以通过 UserRepository 来实现增删改查了。

这个封装思路貌似挺完美。

那我们来看看 @nestjs/typeorm 是怎么封装的吧。

创建个 Nest 项目：
```bash
nest new nest-typeorm -p npm
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a6e9e36f3ca4a14b0fd3de776a95dfd~tplv-k3u1fbpfcp-watermark.image?)

然后创建一个 crud 的模块：
```bash
nest g resource user
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5075fae10254d63bd2cf8ad91f94122~tplv-k3u1fbpfcp-watermark.image?)

生成的 service 里的 crud 并没有真正实现：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46fc3a67e2ec4316adfaec375eccf1ea~tplv-k3u1fbpfcp-watermark.image?)

我们引入 typeorm 来实现下：
```bash
npm install --save @nestjs/typeorm typeorm mysql2
```
typeorm、mysql2 的包我们很熟悉了，而 @nestjs/typeorm 就是把 typeorm api 封装了一层的包。

它提供了一个模块，我们在入口引入下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e13329a222840aba51eaeeac4bfc923~tplv-k3u1fbpfcp-watermark.image?)

连接配置和前几节一样，引入 User 的 Entity。

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { User } from './user/entities/user.entity';
import { UserModule } from './user/user.module';

@Module({
  imports: [UserModule, 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "typeorm_test",
      synchronize: true,
      logging: true,
      entities: [User],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后在 User 的 Entity 里加一些映射的信息：

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity({
    name: 'aaa_user'
})
export class User {

    @PrimaryGeneratedColumn()
    id: number;


    @Column({
        name: 'aaa_name',
        length: 50
    })
    name: string;
}
```

给映射的表给个名字叫 aaa\_user，然后有两个字段，分别是 id 和 name。

我们跑一下试试：
```bash
npm run start:dev
```
看到建表 sql 了没：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e9cf1c9bb64b24a284e31aae3ad137~tplv-k3u1fbpfcp-watermark.image?)

这部分和我们单独跑 typeorm 没啥区别：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96316f78b76c4e52b7866e61f26ebea4~tplv-k3u1fbpfcp-watermark.image?)

然后是增删改查，我们可以注入 EntityManager：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d2e561b1e2d4c9ebd0883e8bc290c45~tplv-k3u1fbpfcp-watermark.image?)

用它来做增删改查：

```javascript
import { Injectable } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { EntityManager } from 'typeorm';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { User } from './entities/user.entity';

@Injectable()
export class UserService {
  
  @InjectEntityManager()
  private manager: EntityManager;

  create(createUserDto: CreateUserDto) {
    this.manager.save(User, createUserDto);
  }

  findAll() {
    return this.manager.find(User)
  }

  findOne(id: number) {
    return this.manager.findOne(User, {
      where: { id }
    })
  }

  update(id: number, updateUserDto: UpdateUserDto) {
    this.manager.save(User, {
      id: id,
      ...updateUserDto
    })
  }

  remove(id: number) {
    this.manager.delete(User, id);
  }
}
```

这里的 save、findOne、delete 方法我们都用过。

然后我们用 postman 来试一下：

发个 post 请求，带上要添加的数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ef0c48d0fe040d88820706200f2fb92~tplv-k3u1fbpfcp-watermark.image?)

服务端打印了 insert 的 sql 语句：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2af612ecebe440719493cf640fe5e2f6~tplv-k3u1fbpfcp-watermark.image?)

表里也可以看到这条数据了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/740b205a84904e968c7d07633fa19055~tplv-k3u1fbpfcp-watermark.image?)

对应的是这个 handler：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16fe1d2698ad4a379249a89b1134bd5d~tplv-k3u1fbpfcp-watermark.image?)

然后再试下查询：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76a51c3c8a1041e48ea52afc270af1ff~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edb12e9e2725428d98d17464cb7fe7b2~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a8f0dc6e05e4afcadd494803b5e713e~tplv-k3u1fbpfcp-watermark.image?)

单个查询和全部查询都是可以的。

再就是修改：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a6f759f88c64506a410f0207762f4b9~tplv-k3u1fbpfcp-watermark.image?)

在 controller 里是接受 patch 的请求。


在 postman 里发一下：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f929e6895c404f3aba17ece1fa5de823~tplv-k3u1fbpfcp-watermark.image?)



可以看到生成了 update 的 sql 语句：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/031bd62a97e64098a91d9851cc4d8a1d~tplv-k3u1fbpfcp-watermark.image?)

数据库中的数据也被修改了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e464da1c56ed441685fb49d1e7b57131~tplv-k3u1fbpfcp-watermark.image?)

再试试删除：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dd221fef5fb4da99ab1bbe5e42f46b5~tplv-k3u1fbpfcp-watermark.image?)

在 postman 里发送 delete 的请求：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34165ecd295344aeb2546a997c2e2cac~tplv-k3u1fbpfcp-watermark.image?)

可以看到生成了 delete 的 sql 语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cece97ea84f04b45b68bb56e2e06ed82~tplv-k3u1fbpfcp-watermark.image?)

数据库里的数据确实被删除了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b0c6f2bad648f9861f9496cbe50a48~tplv-k3u1fbpfcp-watermark.image?)

至此，我们就正式打通了从请求到数据库的整个流程！

这里的 CRUD 部分用到的 api 我们都用过好多遍了。

只不过现在是通过 TypeOrm.forRoot 来传入的数据源的配置，通过 @InjectEntityManager 来注入的 entityManager 对象。

直接用 EntityManager 的缺点是每个 api 都要带上对应的 Entity：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfc252a1a7c243c88aa16481f5af5cd9~tplv-k3u1fbpfcp-watermark.image?)

简便方法就是先 getRepository(User) 拿到 user 对应的 Repository 对象，再调用这些方法。

比如这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e9ebb1b29024f34bd9186d5f44cc09c~tplv-k3u1fbpfcp-watermark.image?)

那还不如直接注入 User 对应的 Respository 就好了。

Nest 对这个做了封装，在 user 模块引入 TypeOrmModule.forFeature 对应的动态模块，传入 User 的 Entity：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e4981aa0cc4f32bf60ffaf427bd6bd~tplv-k3u1fbpfcp-watermark.image?)

就可以在模块里注入 Repository 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d96a2ff1caa84f9692b91da3b00588cc~tplv-k3u1fbpfcp-watermark.image?)

它有的方法和 EntityManager 一样，只是只能用来操作当前 Entity。

此外，你还可以注入 DataSource：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfe11daae44d47f0bfd9016ca98c3823~tplv-k3u1fbpfcp-watermark.image?)

不过这个不常用。

这就是 Nest 里集成 TypeOrm 的方式。

有了 TypeOrm 的使用基础之后，学起来还是非常简单的。

那它是怎么实现的呢？

我们来看下源码：

首先，我们通过引入 TypeOrmModule.forRoot 的动态模块的时候：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e4244a962614d9795249a596336fd1b~tplv-k3u1fbpfcp-watermark.image?)

它会引入 TypeOrmCoreModule.forRoot 的动态模块：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/284f2b11ae7d420a8307ce1467d4a022~tplv-k3u1fbpfcp-watermark.image?)

这里面根据 options 创建 DataSource 和 EntityManager 放到模块的 provider 里，并放到了 exports 里。

而且，更重要的是这个模块是 @Global 的全局模块。

因此，dataSource 和 entityManager 就可以在任意的地方注入了。

上面那两个方法里，创建 DataSource 的过程就是传入参数，调用 intialize 方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a86d1bde720542af9a9755faf97c3ee2~tplv-k3u1fbpfcp-watermark.image?)

而创建 entityManager，则是注入 dataSource 取 manager 属性就好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/216ad7d4a6344478852e7b5dc87e73f7~tplv-k3u1fbpfcp-watermark.image?)

然后 TypeOrmModule.forFeature 则是通过全局的 dataSource.getRepository 拿到参数对应的 Repository 对象，作为模块内的 provider。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5aa2a1ad90894ae6b574fccb83b2ff52~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/527455f570c246caa184ed8695e0308c~tplv-k3u1fbpfcp-watermark.image?)

这样引入这个动态模块的模块内就可以注入这些 Entity 对应的 Repository 了。

这就是 @nestjs/typeorm 的 TypeOrmModule.forRoot 和 TypeOrmModule.forFeature 的实现原理。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-typeorm)。

## 总结

我们会了用 TypeOrm 来连接和增删改查数据库表，在 Nest 里集成只是对 TyprOrm 的 api 封装了一层。

使用方式是在根模块 TypeOrmModule.forRoot 传入数据源配置。

然后就可以在各处注入 DataSource、EntityManager 来做增删改查了。

如果想用 Repository 来简化操作，还可以在用到的模块引入 TypeOrmModule.forFeature 的动态模块，传入 Entity，会返回对应的 Repository。

这样就可以在模块内注入该 Repository 来用了。

它的原理是 TypeOrmModule.forRoot 对应的动态模块是全局的，导出了 dataSource、entityManager，所以才可以到处注入。

而 TypeOrmModule.forFeature 则会根据吧传入 Entity 对应的 Repository 导出，这样就可以在模块内注入了。

这就是 Nest 里集成 TypeOrm 的方式和实现原理。

至此，我们就可以打通从请求到数据库的流程了。


## 51.TypeORM 如何保存任意层级的关系？

我们经常会见到一些多级分类的场景：

比如京东的商品分类：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec05bb2792fb4de7a3f9033ccdcb2a69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1450&h=618&s=172213&e=png&b=fcfcfc)

新闻网站的新闻分类：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/880d4154f083438d95a4aacca95ac235~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1684&h=504&s=165044&e=png&b=fcfcfc)

这种多层级的数据怎么存储呢？

有同学会说，很简单啊，这不就是一对多么，二级分类就用两个表，三级分类就用三个表。

这样是可以，但是都是分类，表结构是一样的，分到多个表里是不是有点冗余。

更重要的是，如果层级关系经常调整呢？

比如有的时候会变成二级分类，有的时候会更多级分类呢？

这时候用普通的多表之间的一对多就不行了。

一般这种多级分类的业务，我们都会在一个表里存储，然后通过 parentId 进行子关联来实现。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09005167be4b44c4919a1505a1c48a8a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082&h=166&s=64518&e=png&b=fcfcfc)

在 TypeORM 里也对这种场景做了支持。

我们新建个项目：

```
nest new typeorm-tree-entity-test
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2192b95684e2424fa3e8fc7c7508ab54~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1056&h=684&s=172605&e=png&b=010101)

进入项目目录，创建一个 CRUD 模块：

```
nest g resource city --no-spec
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a78595f650ff47af952c458a4797814f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&h=362&s=92907&e=png&b=181818)

然后安装 TypeORM 的包：
```bash
npm install --save @nestjs/typeorm typeorm mysql2
```
在 app.module.ts 引入下 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { CityModule } from './city/city.module';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [
    CityModule,
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "tree_test",
      synchronize: true,
      logging: true,
      entities: [City],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    })
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
在 mysql workbench 里创建这个 database：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ff3e4978327485f8fbd4d71c937b87e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1576&h=1108&s=227443&e=png&b=e8e8e8)

指定字符集为 utf8mb4，点击 apply。

然后改下 city.entity.ts

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, Tree, TreeChildren, TreeParent, UpdateDateColumn } from "typeorm";

@Entity()
@Tree('closure-table')
export class City {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({ default: 0 })
    status: number;

    @CreateDateColumn()
    createDate: Date;

    @UpdateDateColumn()
    updateDate: Date;
    
    @Column()
    name: string;

    @TreeChildren()
    children: City[];

    @TreeParent()
    parent: City;
}
```
把服务跑起来：

```
npm run start:dev
```
可以看到，自动创建了 2 个表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01d1a8bd802749b29d5cce1f96937dc9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1496&h=810&s=365517&e=png&b=191919)

我们在 mysql workbench 里看下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c97d6b09c6b4a539fd347041e0ce915~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1494&h=738&s=283914&e=png&b=eeeceb)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5f3a9e2fe0c47b6a2fc61659598d5d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=660&s=184583&e=png&b=f2f0ef)

可以看到 parentId 引用了自身的 id。

并且还有个 city_closure 表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa891eb34ad14823ab89e2bf97d19779~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1184&h=502&s=134674&e=png&b=eeebea)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6e18421386140bdaabd25e7918141c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=978&h=928&s=116043&e=png&b=f7f7f7)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3b23f5f994b49f2b81cd42490944b5a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=884&s=138591&e=png&b=f8f8f8)

两个外键都引用了 city 表的 id。

先不着急解释为什么是这样的，我们插入一些数据试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bd72cd660104d2db6dba0b1dfdf16e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1150&h=974&s=179655&e=png&b=1f1f1f)

在 CityService 的 findAll 方法里插入数据，然后再查出来。

```javascript
@InjectEntityManager()
entityManager: EntityManager;

async findAll() {
    const city = new City();
    city.name = '华北';
    await this.entityManager.save(city);

    const cityChild = new City()
    cityChild.name = '山东'
    const parent = await this.entityManager.findOne(City, {
      where: {
        name: '华北'
      }
    });
    if(parent){
      cityChild.parent = parent
    }
    await this.entityManager.save(City, cityChild)

    return this.entityManager.getTreeRepository(City).findTrees();
}
```
这里创建了两个 city 的 entity，第二个的 parent 指定为第一个。

用 save 保存。

然后再 getTreeRepository 调用 findTrees 把数据查出来。

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3db93902b4414325a22ddb8ff390a898~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1000&h=848&s=101783&e=png&b=ffffff)

可以看到数据插入成功了，并且返回了树形结构的结果。

在 mysql workbench 里看下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8aebbf1b5ac40f98a0e59f5fcb9da34~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1566&h=304&s=135656&e=png&b=f0eeed)

在 city 表里保存着 city 记录之间的父子关系，通过 parentId 关联。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b8848e1726f4c9798b2881bd214eade~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074&h=346&s=94811&e=png&b=ebe7e6)

在 city_closure 表里记录了也记录了父子关系。

把插入数据的代码注释掉：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/309af302c46246bab265e2866dc5daa3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1060&h=840&s=138982&e=png&b=1f1f1f)

重新插入数据：

```javascript
async findAll() {
    const city = new City();
    city.name = '华南';
    await this.entityManager.save(city);

    const cityChild1 = new City()
    cityChild1.name = '云南'
    const parent = await this.entityManager.findOne(City, {
      where: {
        name: '华南'
      }
    });
    if(parent){
      cityChild1.parent = parent
    }
    await this.entityManager.save(City, cityChild1)

    const cityChild2 = new City()
    cityChild2.name = '昆明'

    const parent2 = await this.entityManager.findOne(City, {
      where: {
        name: '云南'
      }
    });
    if(parent){
      cityChild2.parent = parent2
    }
    await this.entityManager.save(City, cityChild2)

return this.entityManager.getTreeRepository(City).findTrees();
}
```

跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/969dedc554804eb4afb6270732b566ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1212&h=1530&s=225036&e=png&b=ffffff)

可以看到，二层和三层的关系都可以正常的存储和查询。

把插入数据的代码注释掉，我们测试下其他方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85e1af4043864252b935ec5b20d44bad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&h=566&s=84302&e=png&b=1f1f1f)

findRoots 查询的是所有根节点：

```javascript
async findAll() {
    return this.entityManager.getTreeRepository(City).findRoots()
}
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eec4a40bb8f94373a7e10b26b2d9b37e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=928&h=766&s=89965&e=png&b=ffffff)

```javascript
async findAll() {
    const parent = await this.entityManager.findOne(City, {
      where: {
        name: '云南'
      }
    });
    return this.entityManager.getTreeRepository(City).findDescendantsTree(parent)
}
```

findDescendantsTree 是查询某个节点的所有后代节点。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/405114be08374b68a7243b4ac25df582~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=774&s=96677&e=png&b=ffffff)

```javascript
async findAll() {
    const parent = await this.entityManager.findOne(City, {
      where: {
        name: '云南'
      }
    });
    return this.entityManager.getTreeRepository(City).findAncestorsTree(parent)
}
```

findAncestorsTree 是查询某个节点的所有祖先节点。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6280a2b801f94413b438b03f3d842b29~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=862&h=668&s=88188&e=png&b=ffffff)

这里换成 findAncestors、findDescendants 就是用扁平结构返回：
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e0e019184c4ebfaa1003a59d7796d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=938&h=790&s=92170&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ada83b0f7374f27aa81567b144bd6ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=748&s=90133&e=png&b=ffffff)

把 findTrees 换成 find 也是会返回扁平的结构：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1c36560d40b424ca478fe243137e0a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1036&h=1506&s=205030&e=png&b=ffffff)

还可以调用 countAncestors 和 countDescendants 来计数：

```javascript
async findAll() {
    const parent = await this.entityManager.findOne(City, {
      where: {
        name: '云南'
      }
    });
    return this.entityManager.getTreeRepository(City).countAncestors(parent)
}
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/121deae269254913b4688aa22d288af7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=724&h=192&s=18501&e=png&b=ffffff)

这些 api 都是很实用的。

回过头来，再看下 @Tree 的 entity：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5411b6d46ed8449fab93a04324cc4f69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=1008&s=130946&e=png&b=1f1f1f)

通过 @TreeChildren 声明的属性里存储着它的 children 节点，通过 @TreeParent 声明的属性里存储着它的 parent 节点。

并且这个 entity 要用 @Tree 声明。

参数可以指定 4 中存储模式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7169db370cfb447087144e5230fd3a14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=522&h=224&s=33445&e=png&b=202020)

我们一般都是用 closure-table，或者 materialized-path。

其余两种有点问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ee820886cd542789afe9f1237d2eac4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2282&h=588&s=180913&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bef3d51a5364b1ea95ac6ce80a3bad7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2298&h=704&s=177666&e=png&b=ffffff)

把两个表删掉：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e80203993df42bb930aee3a81997769~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=734&h=682&s=205244&e=png&b=e7e3e2)

改成 materialized-path 重新跑：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e681d533cba4e37bf3f32a996d86e99~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=424&s=66894&e=png&b=202020)

可以看到，现在只生成了一个表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e1ad9fef9d40ee9ec10d8a68698b6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1394&h=294&s=100451&e=png&b=e7e4e3)

只是这个表多了一个 mpath 字段。

我们添加点数据：

```javascript
async findAll() {
    const city = new City();
    city.name = '华北';
    await this.entityManager.save(city);

    const cityChild = new City()
    cityChild.name = '山东'
    const parent = await this.entityManager.findOne(City, {
      where: {
        name: '华北'
      }
    });
    if(parent){
      cityChild.parent = parent
    }
    await this.entityManager.save(City, cityChild)

    return this.entityManager.getTreeRepository(City).findTrees();
}
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0325a3bcde3b4bbfb0f18506f51337ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=834&s=99746&e=png&b=ffffff)

可以看到，它通过 mpath 路径存储了当前节点的访问路径，从而实现了父子关系的记录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70fb53967f1c49e789b13e618c5e257a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=928&h=260&s=72682&e=png&b=f7f7f7)

其实这些存储细节我们不用关心，不管是 closure-table 用两个表存储也好，或者 materialized-path 用一个表多加一个 mpath 字段存储也好，都能完成同样的功能。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-tree-entity-test)。

## 总结

这节我们基于 TyepORM 实现了任意层级的关系的存储。

在 entity 上使用 @Tree 标识，然后通过 @TreeParent 和 @TreeChildren 标识存储父子节点的属性。

之后可以用 getTreeRepository 的 find、findTrees、findRoots、findAncestorsTree、findAncestors、findDescendantsTree、findDescendants、countDescendants、countAncestors 等 api 来实现各种关系的查询。

存储方式可以指定 closure-table 或者 materialized-path，这两种方式一个用单表存储，一个用两个表，但实现的效果是一样的。

以后遇到任意层级的数据的存储，就是用 Tree Entity 吧。


## 52.为什么生产环境要用 TypeORM 的 migration 迁移功能？

前面我们基于 TypeORM 操作数据库都是开启了 synchronize，只要创建或者修改了 Entity，那就会自动创建表和修改表结构。

在开发时这样很方便，只要关注代码就好了，不用管修改表结构的事情。

但是在生产环境下，用 synchronize 很危险，很容易丢数据。

我们试一下：

新建一个 TypeORM 项目：

```shell
npx typeorm@latest init --name typeorm-migration --database mysql
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bd55f80d3f94d628c951bc6fe56a356~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1268&h=160&s=61319&e=png&b=000000)

改下 data-source.ts 的配置：

```typescript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "migration-test",
    synchronize: true,
    logging: true,
    entities: [User],
    migrations: [],
    subscribers: [],
    poolSize: 10,
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})

```
安装用到的 mysql2:

```shell
npm install --save mysql2
```
在 mysql workbench 里创建这个 database：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5907f0ad5f04a89826213687a3c5693~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=1136&s=274049&e=png&b=e7e5e5)

指定名字和字符集，点击 apply.

或者也可以执行这个 sql 来创建：

```sql
CREATE SCHEMA `migration-test` DEFAULT CHARACTER SET utf8mb4 ;
```
跑一下：

```
npm run start
```

可以看到，会自动创建 Entity 对应的表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afe862ae970649efb7b968a72b15e006~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1314&h=884&s=206847&e=png&b=181818)

在 mysql workbench 里也可以看到这个表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7a0540ead1a40bdabcfeab85f0e23e6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158&h=662&s=229379&e=png&b=f0eceb)

把插入数据的代码注释掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67cf55eccb264f0c9cca726db3b8678c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1242&h=814&s=170883&e=png&b=1f1f1f)

改下 Entity：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00d955f21b824acd907ecae731d4d210~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=824&h=714&s=83490&e=png&b=1f1f1f)

重新跑下：

```
npm run start
```
可以看到 TypeORM 检测到 Entity 的变更，修改了表结构：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff7b09363e5a4945bd0f64bf39897d8e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=856&h=710&s=92513&e=png&b=181818)

在 mysql workbench 里可以看到，之前的 age 列就没了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16cf5ea62185424881f61cc7706c60d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1048&h=564&s=187440&e=png&b=efecea)

数据是不是就全丢了！

更何况跑 nest 项目的时候都是用 npm run start:dev，代码改动立刻重新跑，所以很容易丢数据。

所以说，synchronize 在开发环境下确实很方便，但是在生产环境下不能用，不安全。

那不用 synchonize 用啥呢，手动去数据库执行 sql 么？

那倒也不用。

可以用 TypeORM 的 migration 功能。

migration 是迁移的意思，其实前面的 create table、alter table 这些都是 migration：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afe862ae970649efb7b968a72b15e006~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1314&h=884&s=206847&e=png&b=181818)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff7b09363e5a4945bd0f64bf39897d8e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=856&h=710&s=92513&e=png&b=181818)

只不过之前是自动跑，而现在我们要管理起来，手动跑。

把 package.json 里的 type 改为 module，也就是指定 node 跑的是 es module 的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee065f42ac404c84b47a15fff3b7ff2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=638&h=326&s=53011&e=png&b=202020)

然后执行 migration:create 的命令：

```shell
npx typeorm-ts-node-esm migration:create ./src/migration/Aaa
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ebf9261e46e41a9a51cf3e3f681d222~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592&h=192&s=48413&e=png&b=181818)

生成了 “时间戳-Aaa.ts” 文件，这个就是放迁移代码的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73b0041a8f54139a0b582e783728020~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1536&h=530&s=143425&e=png&b=1e1e1e)

迁移就是 create table、alter table 这些。

我们在 mysql workbench 里导出下建表 sql 语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52255a427e3a42da80dec8709acd8b2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2194&h=1328&s=598835&e=png&b=efefef)

点击左侧的 Data Export，选中要导出的表，指定一个 sql 文件保存位置，点击 Export。

可以看到，生成的 sql 里就包括了 create table 建表语句和插入数据的 insert into 语句：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9997eaf909de49a1b17b09b775449afb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1366&h=1030&s=212632&e=png&b=1f1f1f)

我们把建表 sql 拿过来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a5662c9da5f4bde91ac9e2d7fa619ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1312&h=726&s=152394&e=png&b=1f1f1f)

```javascript
import { MigrationInterface, QueryRunner } from "typeorm";

export class Aaa1708136448263 implements MigrationInterface {

    public async up(queryRunner: QueryRunner): Promise<void> {
        await queryRunner.query(`
            CREATE TABLE user (
                id int NOT NULL AUTO_INCREMENT,
                firstName varchar(255) NOT NULL,
                lastName varchar(255) NOT NULL,
                PRIMARY KEY (id)
            ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;    
        `)
    }

    public async down(queryRunner: QueryRunner): Promise<void> {
    }

}
```
然后把 synchronize 关掉，用 migration 来手动建表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08f60a08ae094c8096a91710392aec6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=854&h=730&s=125184&e=png&b=1f1f1f)

```javascript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "migration-test",
    synchronize: false,
    logging: true,
    entities: [User],
    migrations: ['./src/migration/**.ts'],
    subscribers: [],
    poolSize: 10,
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})
```
先在 mysql workbench 里把之前的表删掉：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94244a2e659d437eb85c356718e47ad5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=692&h=742&s=212217&e=png&b=e8e3e1)

把 index.ts 注释放开，但 age 去掉：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f93582406ad405dab7e6ecf32655be0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1144&h=734&s=171397&e=png&b=1f1f1f)

然后再跑 npm run start

这时候因为 synchronize 关掉了，不会自动建表，所以 报错了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f360f578c92943138f36ec33aab18802~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1006&h=596&s=146980&e=png&b=191919)

然后我们用 migration:run 来手动建表：

```
npx typeorm-ts-node-esm migration:run -d ./src/data-source.ts
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2ca0da981524e0ab41914ace616159d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1756&h=680&s=200786&e=png&b=191919)

可以看到，执行了 migration 里的 create table 语句，并且还在 migration 表里插入了一条记录。

这时候数据库中就有这个表了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3f19da4a3654f048ad6c07178a305c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1060&h=534&s=179560&e=png&b=efeceb)

并且还在 migrations 表里记录了什么时间执行了什么迁移：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7c55b2a46644e4b1c2b9ce5b3235f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1092&h=404&s=121847&e=png&b=eeeae9)

这时候再跑 npm run start

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3011c37d0024400184bf4a6675601022~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1218&h=526&s=110172&e=png&b=191919)

这时候 insert、select 就都成功了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/129aa88d5f1a459ebba501b860361106~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932&h=318&s=83367&e=png&b=ede9e8)

生产环境，我们不会用 synchronize 自动同步，就是用的 migration 的方式来建表。

但是导出建表 sql 再复制到 migration 的 up 方法里挺麻烦的。

有没有简便的方法呢？

有，这就是 migration:generate 命令。

把这两个表删掉：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56fb40cc805d45caad0a2b68313debe2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=660&h=648&s=193656&e=png&b=e9e5e2)

把之前那个 migration 也删掉：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc1c1c870682444ca4498666c90eb13f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450&h=146&s=19162&e=png&b=1f1f1f)

我们这次用 migration:generate 来生成：

```shell
npx typeorm-ts-node-esm migration:generate ./src/migration/Aaa -d ./src/data-source.ts
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90d9eadb066747b9999c973546f86eb5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1964&h=294&s=110500&e=png&b=191919)

生成的 migration 文件如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5436f71ca2c4b9e85750614126c8943~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1734&h=576&s=141769&e=png&b=1f1f1f)

用 migration:run 执行下：

```
npx typeorm-ts-node-esm migration:run -d ./src/data-source.ts
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c6c0622bd8d4179944a52a3e8ab1ace~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1554&h=508&s=159936&e=png&b=191919)

然后再跑下 npm run start：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df3966e223c496a81b9163ca84e8ab4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1428&h=516&s=115993&e=png&b=181818)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/212f5cf26088447f9619889d22f7b82b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=934&h=224&s=60496&e=png&b=eeeae9)

没啥问题。

这样，就不用自己写 migration 文件了，就很方便。

当然，不只是建表算是 migration，修改表结构也算。

我们在 User 里加一个字段：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75a626605ed44c798f596c2462004ff4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=648&h=710&s=83839&e=png&b=1f1f1f)

```javascript
@Column()
email: string
```
再执行下 migration:generate

```
npx typeorm-ts-node-esm migration:generate ./src/migration/Bbb -d ./src/data-source.ts
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e8a64bcf85a4ad69b89e7a6d48bf244~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1724&h=420&s=92573&e=png&b=181818)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f2de8d2405d4d0b81d6f17a28801174~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1496&h=524&s=138384&e=png&b=1f1f1f)

这时候生成的 migration 就是 alter table 语句。

跑下 migration:run
```
npx typeorm-ts-node-esm migration:run -d ./src/data-source.ts
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee6caee979624b128b39b2565a41a182~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1684&h=458&s=150524&e=png&b=191919)

在 migrations 表里记录了 Aaa 跑过，所以这次只会跑 Bbb 的 migration。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/772842295a18453fa138b0b9192bb323~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1046&h=240&s=76276&e=png&b=ede9e8)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/719211ad884b4d729d6889fdefc46747~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&h=252&s=94275&e=png&b=ede9e8)

可以跑 migration 也同样可以撤销：

```
npx typeorm-ts-node-esm migration:revert -d ./src/data-source.ts
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60ad07e42e1a46ef840a1724eeec80d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1460&h=416&s=130222&e=png&b=191919)

执行 migration:revert 会执行上次的 migration 的 down 方法，并且从 migrations 表里删掉执行记录。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d5203a159f34bd5beeac6810a09b440~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1244&h=514&s=132772&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592003038c9742229b6e51b3609ce383~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1142&h=228&s=78542&e=png&b=efebea)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/440a8e23d5cf4e9ea4f7ebf413767d8f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1064&h=218&s=73362&e=png&b=eeeae9)

再次 revert，会撤销上一次的 migration，删掉 user 表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498436cc8eeb4ea8a1d4243fe81e96f5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1492&h=422&s=129300&e=png&b=191919)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94abd68ef6164d7c95569e6c0b80ca43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=938&h=224&s=60919&e=png&b=ece8e6)

所以说，每一次的 migration 都是可控的，可以手动执行、也可以撤销。生产环境我们就是用 migration 来修改表结构，而不是 synchronize

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/typeorm-migration)。

## 总结

开发环境我们会用 synchronize 来同步 Entity 和数据库表，它会自动执行 create table、alter table，不用手动修改表结构，很方便。

但是它并不安全，因为很容易丢失数据。所以生产环境下我们会把它关掉，用 migration 来管理。

migration 就是把 create table、alter table 等封装成一个个的 migration，可以一步步执行、也可以一步步撤销回去。

有 4 个常用命令：

- migration:create：生成空白 migration 文件
- migration:generate：连接数据库，根据 Entity 和数据库表的差异，生成 migration 文件
- migration:run：执行 migration，会根据数据库 migrations 表的记录来确定执行哪个
- migration:revert：撤销上次 migration，删掉数据库 migrations 里的上次执行记录

这样就把生产环境里的建表和修改表的操作管理了起来。


## 53.快速入门 Redis

前面我们学了 mysql，它是通过表和字段来存储信息的，表和表之间通过 id 关联，叫做关系型数据库。

它提供了 sql 语言，可以通过这种语言来描述对数据的增删改查。

mysql 是通过硬盘来存储信息的，并且还要解析并执行 sql 语句，这些决定了它会成为性能瓶颈。

也就是说服务端执行计算会很快，但是等待数据库查询结果就很慢了。

那怎么办呢？

计算机领域最经常考虑到的性能优化手段就是缓存了。

能不能把结果缓存在内存中，下次只查内存就好了呢？

内存和硬盘的速度差距还是很大的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc9adf9ac5ec440db7f975e70f39df65~tplv-k3u1fbpfcp-watermark.image?)

所以做后端服务的时候，我们不会只用 mysql，一般会结合内存数据库来做缓存，最常用的是 redis。

因为需求就是缓存不同类型的数据，所以 redis 的设计是 key、value 的键值对的形式。

并且值的类型有很多：字符串（string）、列表（list）、集合（set）、有序集合（sorted set)、哈希表（hash）、地理信息（geospatial）、位图（bitmap）等。

我们分别来试一下。

redis 是分为服务端和客户端的，它提供了一个 redis-cli 的命令行客户端。

首先我们把 redis 服务跑起来。

在 docker desktop 搜索框搜索 redis，点击 run，把 redis 官方镜像下载并跑起来。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bed90e72ce364a439e4f45d5e865c5db~tplv-k3u1fbpfcp-watermark.image?)

它会让你填一些容器的信息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b257277421a7436a8017fe0dbe7521fd~tplv-k3u1fbpfcp-watermark.image?)

端口映射就是把主机的 6379 端口映射到容器内的 6379 端口，这样就能直接通过本机端口访问容器内的服务了。

指定数据卷，用本机的任意一个目录挂载到容器内的 /data 目录，这样数据就会保存在本机。

跑起来之后是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582d0b65347146c1acbebe5a7d62b049~tplv-k3u1fbpfcp-watermark.image?)

容器内打印的日志说明 redis 服务跑起来了。

files 里可以看到所有的容器内的文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71fab8f1376c4d4ebbb3a3e58e99cfce~tplv-k3u1fbpfcp-watermark.image?)

看到这个 mounted 的标志了没？

就代表这个目录是挂载的本地的一个目录。

我们在本地目录添加一个文件。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab7489be4ecf443c9605727b6e778ca9~tplv-k3u1fbpfcp-watermark.image?)

在容器内的 data 目录就能访问到这个文件了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4da5d4a3869b47a89bc14b70854a802c~tplv-k3u1fbpfcp-watermark.image?)

同样，在容器内修改了 data 目录，那本机目录下也会修改。

redis 服务跑起来之后，我们用 redis-cli 操作下。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5511d77862c4df0be4c870610d3013a~tplv-k3u1fbpfcp-watermark.image?)

在 terminal 输入 redis-cli，进入交互模式：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f535910a85940d6aa855cbb89809699~tplv-k3u1fbpfcp-watermark.image?)

我们在这里做下 string 相关的操作：

[文档](https://redis.io/docs/data-types/strings/)里的命令有这么几个：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee25f15454884d529d5c1354716ae125~tplv-k3u1fbpfcp-watermark.image?)

set、get 都挺简单：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6666f2c01194f00ad7f45d33a7dfd47~tplv-k3u1fbpfcp-watermark.image?)

incr 是用于递增的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3391bda1ff4967abecbd2a0da7e8c5~tplv-k3u1fbpfcp-watermark.image?)

平时我们用的阅读量、点赞量等都是通过这个来计数的。

当我存了几个 key 后，可以通过 keys 来查询有哪些 key:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc2a4df46a7743fcaf63217b4e0f8cc1~tplv-k3u1fbpfcp-watermark.image?)

keys 后加一个模式串来过滤，常用的是 '\*' 来查询所有 key。

然后再来看看 list。

这里我们切换成 GUI 工具吧，那个更直观一些。

这个就像 git 有人喜欢用命令行，有人喜欢用 GUI 工具一样。只是习惯问题，都可以。

我用的是官方的 [RedisInsight](https://redis.com/redis-enterprise/redis-insight/#insight-form)，它号称是最好的 Redis GUI 工具：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb76c702a6274f8f9767e2d7edf595e6~tplv-k3u1fbpfcp-watermark.image?)

输入操作系统信息，还有邮箱、姓名、职业、手机号等信息，就可以下载安装包了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/819a084a320b4c53b48f6ce23917db31~tplv-k3u1fbpfcp-watermark.image?)

安装后就是这个东西：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0f60959a963417ea77766d14a441e43~tplv-k3u1fbpfcp-watermark.image?)

点击 add database：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a4f9bedead8425f9806486e48e92036~tplv-k3u1fbpfcp-watermark.image?)

连接信息用默认的就行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fccc01b22378427583f85ed9e8ca7a41~tplv-k3u1fbpfcp-watermark.image?)

然后就可以看到新建的这个链接：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e2102f71b1d4995a2b9180c57fdb131~tplv-k3u1fbpfcp-watermark.image?)

点击它就可以可视化看到所有的 key 和值：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c61e73c06a614455a1354a46c0a8f9c9~tplv-k3u1fbpfcp-watermark.image?)

同样也可以执行命令：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98feb670ed9f4014b3954009990e7be7~tplv-k3u1fbpfcp-watermark.image?)

然后我们继续看 list 类型的数据结构：

文档中有这么几个命令：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1619e89d2f334e2da2d7e8e1ed1ef76b~tplv-k3u1fbpfcp-watermark.image?)

我们试一下：

    lpush list1 111
    lpush list1 222
    lpush list1 333

输入上面的命令，点击执行：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c73596768cf74c7a9107ac963de3bd0a~tplv-k3u1fbpfcp-watermark.image?)

然后回到浏览页面，点击刷新，就可以看到新的 key 和它的值：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f04cf5f768461cbd142679f4c19d7e~tplv-k3u1fbpfcp-watermark.image?)

这就是一个列表的结构。

lpush 是 left push 的意思，执行后会从左到右添加到列表中。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f2032f702e44bb49b1b12075cc7db43~tplv-k3u1fbpfcp-watermark.image?)

rpush 是 right push 的意思，执行后会从右往左添加到列表中：

    rpush list1 444
    rpush list1 555

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c54cb760ee8148b2a45ab8482acf1e45~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0f11e4877dd43d3943767ed063e269e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5374c51a12474341b9a045ba58d91e87~tplv-k3u1fbpfcp-watermark.image?)

lpop 和 rpop 自然是从左边和从右边删除数据。

    lpop list1

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e971457747f0414690a0dd19d2d63d6b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/793c9c1ded3247d98f978de84eb03ab7~tplv-k3u1fbpfcp-watermark.image?)

    rpop list1

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5daa6dd06fc45489e270efde4f9f6b1~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/664ec4d6e2914c2bb17908f90190fc68~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/207a39a598cb4cf3bd2497abcbd38a03~tplv-k3u1fbpfcp-watermark.image?)

如果想查看 list 数据呢？

在 GUI 里直接点开看就行，但在命令行里呢？

有同学说，不就是 get 么？

是不行的，get 只适用于 string 类型的数据，list 类型的数据要用 lrange。

    lrange list1 0 -1

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba71621755334dffa10bed76254db23c~tplv-k3u1fbpfcp-watermark.image?)

输入一段 range，结尾下标为 -1 代表到最后。lrange list1 0 -1 就是查询 list1 的全部数据。

接下来我们再来看看 set：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c733928d5b33434b89c3ba7a09cce86a~tplv-k3u1fbpfcp-watermark.image?)

set 的特点是无序并且元素不重复。

当我添加重复数据的时候：

    sadd set1 111
    sadd set1 111
    sadd set1 111
    sadd set1 222
    sadd set1 222
    sadd set1 333

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9acf78d68543b090cc42ccbb6dde07~tplv-k3u1fbpfcp-watermark.image?)

刷新之后可以看到它只保留去重后的数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b4429201a94414ab1fd75ae0b399622~tplv-k3u1fbpfcp-watermark.image?)

可以通过 sismember 判断是否是集合中的元素：

    sismember set1 111

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b659743242241488c2cd288d28080b6~tplv-k3u1fbpfcp-watermark.image?)

    sismember set1 444

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30cfd618e1d04e48850256231ea10aae~tplv-k3u1fbpfcp-watermark.image?)

set 只能去重、判断包含，不能对元素排序。

如果排序、去重的需求，比如排行榜，可以用 sorted set，也就是 zset，：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce19772e642b4919b7ff886d93e652cb~tplv-k3u1fbpfcp-watermark.image?)

它每个元素是有一个分数的：

    zadd zset1 5 guang
    zadd zset1 4 dong
    zadd zset1 3 xxx
    zadd zset1 6 yyyy

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2176bf6d7fe74830ab7d5c2bf7438c10~tplv-k3u1fbpfcp-watermark.image?)

会按照分数来排序：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/421cd8e02b4e4afe94aa0940308f7cc4~tplv-k3u1fbpfcp-watermark.image?)

通过 zrange 命令取数据，比如取排名前三的数据：

    zrange zset1 0 2

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c395196654484daf8acc91efc2a767e4~tplv-k3u1fbpfcp-watermark.image?)

接下来是 hash：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a2fd64df4f841b1a4f4df07ff06fb1c~tplv-k3u1fbpfcp-watermark.image?)

和我们用的 map 一样，比较容易理解：

    hset hash1 key1 1
    hset hash1 key2 2
    hset hash1 key3 3
    hset hash1 key4 4
    hset hash1 key5 5

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec227c5bcc1843e9a98a230c79655618~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ad826127a444973ad8afdfb0d702163~tplv-k3u1fbpfcp-watermark.image?)

    hget hash1 key3

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb46984a777b4570882afb133f404a14~tplv-k3u1fbpfcp-watermark.image?)

再就是 geo 的数据结构，就是经纬度信息，根据距离计算周围的人用的。

我们试一下：

    geoadd loc 13.361389 38.115556 "guangguang" 15.087269 37.502669 "dongdong" 

用 loc 作为 key，分别添加 guangguang 和 dongdong 的经纬度

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb961a2e40804fb0ae70ed649a2b8d39~tplv-k3u1fbpfcp-watermark.image?)

你会发现 redis 实际使用 zset 存储的，把经纬度转化为了二维平面的坐标：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc97092460c24503970b0a5fbb19b871~tplv-k3u1fbpfcp-watermark.image?)

你可以用 geodist 计算两个坐标点的距离：

    geodist loc guangguang dogndong

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee479af37ee3401e8fc71ba8b24c5e3a~tplv-k3u1fbpfcp-watermark.image?)

用 georadius 搜索某个半径内的其他点，传入经纬度、半径和单位：

    georadius loc 15 37 100 km
    georadius loc 15 37 200 km

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d971789fad64b4c8ae0cdb7ff188d9c~tplv-k3u1fbpfcp-watermark.image?)

平时我们查找周围的人、周围的 xxx 都可以通过 redis 的 geo 数据结构实现。

一般 redis 的 key 我们会设置过期时间，通过 expire 命令。

比如我设置 dong1 的 key 为 30 秒过期：

    expire dogn1 30

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93eacff53464d4996aa59dc7f1f806c~tplv-k3u1fbpfcp-watermark.image?)

等到了过期时间就会自动删除：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16598c625f604d8589ae55630509d220~tplv-k3u1fbpfcp-watermark.image?)

想查剩余过期时间使用 ttl：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c7f89da9ea8483eb0f23673fca5718f~tplv-k3u1fbpfcp-watermark.image?)

一些有时效的数据可以设置个过期时间。

redis 的数据结构就先介绍到这里。

所有的命令都可以在官方文档查： <https://redis.io/commands/>

是不是感觉还挺简单的。

确实，redis 学习成本挺低的，过一遍就会了。

回到最开始的问题，我们完全可以查出数据来之后放到 redis 中缓存，下次如果 redis 有数据就直接用，没有的话就查数据库然后更新 redis 缓存。

这是 redis 的第一种用途，作为数据库的缓存，也是主要的用途。

第二种用途就是直接作为存储数据的地方了，因为 redis 本身是会做持久化的，也可以把数据直接保存在 redis 里，不存到 mysql。

当然，因为 redis 在内存存储数据，这样成本还是比较高的，需要经常扩容。

最后，还记得我们跑 redis 的 docker 镜像时指定了数据卷么：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b2f3a64ea04b228be37ab058ade0d9~tplv-k3u1fbpfcp-watermark.image?)

可以看到它确实把数据保存到了宿主机，这样就不怕再跑一个容器数据会丢了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb00a12ef7d04eee9797bea00a5c070c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/430f1805625440308a37f8e2db9cce51~tplv-k3u1fbpfcp-watermark.image?)

## 总结

这节我们学习了 redis。

因为 mysql 存在硬盘，并且会执行 sql 的解析，会成为系统的性能瓶颈，所以我们要做一些优化。

常见的就是在内存中缓存数据，使用 redis 这种内存数据库。

它是 key、value 的格式存储的，value 有很多种类型，比如 string、list、set、sorted set(zset)、hash、geo 等。

灵活运用这些数据结构，可以完成各种需求，比如排行榜用 zset、阅读数点赞数用 string、附近的人用 geo 等。

而且这些 key 都可以设置过期时间，可以完成一些时效性相关的业务。

用官方 GUI 工具 RedisInsight 可以可视化的操作它，很方便。

redis 几乎和 mysql 一样是后端系统的必用中间件了，它除了用来做数据库的缓存外，还可以直接作为数据存储的地方。

学会灵活使用 redis，是后端开发很重要的一步。


## 54.在 Nest 里操作 Redis

我们通过 redis-cli 命令行和 RedisInsight 的 GUI 工具入门了 redis。

那在 Node 里怎么操作 redis 呢？

这就需要用 redis 的 node 的客户端了。

redis 有很多的 [node 客户端的包](https://redis.io/resources/clients/#nodejs)：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ee372edb494479a868020cda99a4a0b~tplv-k3u1fbpfcp-watermark.image?)

最流行的就是 redis 和 ioredis 这两个。

我们创建个项目来试一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b60006cd719b4652abf5b8c75f13d52a~tplv-k3u1fbpfcp-watermark.image?)

我们先试一下 redis，它是官方提供的 npm 包：

    npm install redis

然后在代码里连接 redis 服务，并执行命令：

```javascript
import { createClient } from 'redis';

const client = createClient({
    socket: {
        host: 'localhost',
        port: 6379
    }
});

client.on('error', err => console.log('Redis Client Error', err));

await client.connect();

const value = await client.keys('*');

console.log(value);

await client.disconnect();
```

这里执行 keys 命令，获取所有的 key。

因为用到了 es module、顶层 await，这些的启用需要在 package.json 里添加 type: module

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbf7b44d9a5d417aa6b35f67e0fdcca8~tplv-k3u1fbpfcp-watermark.image?)

然后 node 执行下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82bc3c74c1214f708d29eb861cdb881a~tplv-k3u1fbpfcp-watermark.image?)

用 RedisInsight 看下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/097ecb127c7a46d6afa2bc8b67850921~tplv-k3u1fbpfcp-watermark.image?)

确实现在是有这些 key。

我们再执行其他命令试试，比如 hset 创建一个 hash 表：

```javascript
await client.hSet('guangguang1', '111', 'value111');
await client.hSet('guangguang1', '222', 'value222');
await client.hSet('guangguang1', '333', 'value333');
```

执行以后是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08e56096e39749e8be32c52a3e5ba1e7~tplv-k3u1fbpfcp-watermark.image?)

所有的 redis 命令都有对应的方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7078ce4313954be0824981edd72b8e01~tplv-k3u1fbpfcp-watermark.image?)

和我们在命令行客户端里操作一样。

这样我们就完成了 node 里操作 redis 的功能。

再来试下 ioredis：

    npm install ioredis

然后连接 redis server 并执行 keys 命令：

```javascript
import Redis from "ioredis";

const redis = new Redis();

const res = await redis.keys('*');

console.log(res);
```

结果如下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ecadf44c9e3494a9980d62a03151649~tplv-k3u1fbpfcp-watermark.image?)

其他命令也是这样执行：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c5f633c97a8483bbd947e639c71a81d~tplv-k3u1fbpfcp-watermark.image?)

这些 node 包用起来还是很简单的，没啥学习成本。

那 nest 里怎么操作 redis 呢？

其实也是一样的：

执行 nest new nest-redis 创建一个 nest 项目：

    nest new nest-redis -p npm

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52d74f217d9a40da8aa0537345234e52~tplv-k3u1fbpfcp-watermark.image?)

当然，要先安装用到的 redis 的包。

    npm install redis 

然后在 AppModule 添加一个自定义的 provider：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/204f0b6bb67a46eaa74cc27c0a30e64c~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { createClient } from 'redis';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
})
export class AppModule {}
```

通过 useFactory 的方式动态创建 provider，token 为 REDIS\_CLIENT。

然后注入到 service 里用就好了：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class AppService {

  @Inject('REDIS_CLIENT')
  private redisClient: RedisClientType;

  async getHello() {
    const value = await this.redisClient.keys('*');
    console.log(value);

    return 'Hello World!';
  }
}
```

因为 service 里加了 async、await，那 controller 里也得加一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1a51c317eca405d82defe4d626aece4~tplv-k3u1fbpfcp-watermark.image?)

这样就能在 nest 里操作 redis 了。

我们把它跑起来，浏览器访问下：

    nest start --watch

可以看到控制台打印了 redis 命令的执行结果：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d51073000fef4d49a3b47f332d4a4676~tplv-k3u1fbpfcp-watermark.image?)

这就是在 Nest 里操作 redis 的方式。

案例代码在小册仓库：

[node 操作 redis](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/redis-node-test)

[nest 操作 redis](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-redis)

## 总结

通过 redis 的 npm 包（redis、ioredis 等）可以连接 redis server 并执行命令。

如果在 nest 里，可以通过 useFactory 动态创建一个 provider，在里面使用 redis 的 npm 包创建连接。

redis 是必备的中间件，后面的项目实战会大量用到。


## 55.为什么不用 cache-manager 操作 Redis？

上节我们学了在 Nest 里操作 Redis，很多同学会问，为什么不用 cache-manager 呢？

[官方文档](https://docs.nestjs.com/techniques/caching)里就是用的 cache-manger：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5f906d5c884a7097eaeb9aaf3c2f49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1734&h=848&s=127296&e=png&b=fafafa)

确实，cache-manger 有它好用的地方，但是它的缺点更多。

为什么这么说呢？

我们试一下就知道了：

```
nest new cache-manager-test
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a282c3c6cc684f70a9e3351345c92961~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=964&h=698&s=165646&e=png&b=010101)

创建个 nest 项目。

进入项目，把它跑起来：

```
npm run start:dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1ad82a40f6455182b49aea9bda3c2c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1580&h=346&s=114543&e=png&b=181818)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d417d9c539d4785be600a9760327976~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=152&s=15987&e=png&b=ffffff)

然后引入 cache-manager：

```javascript
npm install @nestjs/cache-manager cache-manager
```
在 AppModule 注册下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf910d79a6543adb55b4851a77603e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=888&h=438&s=99701&e=png&b=1f1f1f)

之后在 AppController 加几个路由：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e034daa98ee434d8bc8afbceaea1a9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=1200&s=228053&e=png&b=1f1f1f)

注入 CacheManager，分别测试下它的 get、set、del 方法。

```javascript
import { Controller, Get, Inject, Param, Query } from '@nestjs/common';
import { AppService } from './app.service';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Cache } from 'cache-manager';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject(CACHE_MANAGER)
  private cacheManager: Cache;

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('set')
  async set(@Query('value') value: string) {
    await this.cacheManager.set('kkk', value);
    return 'done'
  }

  @Get('get')
  async get() {
    return this.cacheManager.get('kkk');
  }

  @Get('del')
  async del() {
    await this.cacheManager.del('kkk');
    return 'done';
  }

}
```

浏览器访问下：

首先 get 没有数据：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6327531b1a4e4aeb9a4812208969d6a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=632&h=200&s=15474&e=png&b=ffffff)

然后 set 设置为 111：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76d60561883d4b528f7de7733861766c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=742&h=198&s=19175&e=png&b=ffffff)

再次 get 就有数据了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a1c1d14207a44aa86f9e941e65ce82f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=612&h=190&s=15558&e=png&b=ffffff)

之后 del 删掉：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e5cea6d4524046aa1f8757a6a2d15c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=614&h=160&s=15945&e=png&b=ffffff)

再次 get 就为空了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f09be1d28c64466b4aae5fdb560e1d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=608&h=170&s=14784&e=png&b=ffffff)

这个缓存的用法很简单。

此外，你还可以把它加到 handler 上，自动对结果缓存。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ec8759b36634adab88210743bd88faf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=678&h=442&s=69269&e=png&b=1f1f1f)

```javascript
@Get('aaa')
@UseInterceptors(CacheInterceptor)
aaa(@Query('a') a: string){
    console.log('aaa', a);
    return 'aaa';
}
```
参数不变的情况下，刷新几次，可以看到控制台只打印了一次：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d18306414584abbb57881fbaf87e629~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=706&h=192&s=16848&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2b2569b411d48c2b5dbe59f5f394303~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=380&h=456&s=66532&e=png&b=181818)

改变参数再刷新几次：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ac4c1ef57574689ae31822b7b677602~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=678&h=188&s=16877&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d083d3c25a0a42ee86634adc77cab680~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=458&s=83866&e=png&b=181818)

这时候控制台再次打印了，说明 handler 又被执行了。

其余的情况，都是直接拿缓存。

有同学说，缓存数据都在哪呢？好像也没引入 redis 呀？

确实，cache-manager 默认是在内存里的。

如果想存在 redis，要这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a75b104005041a294ff35799c94dc3f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982&h=1048&s=198581&e=png&b=1f1f1f)

使用 cache-manager-redis-store，然后添加下连接配置：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { CacheModule } from '@nestjs/cache-manager';
import { redisStore } from 'cache-manager-redis-store';

import { RedisClientOptions } from 'redis';

@Module({
  imports: [
    CacheModule.register<RedisClientOptions>({
      // @ts-ignore
      store: async () => await redisStore({
        socket: {
          host: 'localhost',
          port: 6379,
        },
        database: 2
      }),
      host: 'localhost',
      port: 6379
    })
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

这里的 cache-manager-redis-store 要安装下：

```
npm install cache-manager-redis-store
```

然后再次访问之前的 url：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a34a68dccfc41168281f2600afc1636~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=756&h=182&s=18973&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e602c057669469dae966b366e8a6972~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=744&h=230&s=18051&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c65e928537274f7e9622640884fd9162~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=686&h=162&s=16171&e=png&b=ffffff)

这时候在 redis 里就可以看到缓存的数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0de8a6755a334810a5db949b32357e49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1570&h=666&s=95461&e=png&b=131313)

注意，连接的时候我们指定 database为 2，所以在 RedisInsight 里要切到 db2 才可以看到这些数据。

缓存的过期时间也是可以配置的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e2bfc79840f4bff9442bfa67d80a604~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=890&s=144295&e=png&b=1f1f1f)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/499c54f86f6344419bb8066f36c24483~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=746&h=234&s=18292&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3ef4b9a932848c3a11f45b6c26e4fc2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1254&h=560&s=60213&e=png&b=1b1b1b)

有同学会说，这个 CacheManager 不是很好用么？

确实，只做 set、get 的话，用 CacheManager 还是可以的，而且还有 CacheInterceptor 可以对接口做缓存。

但是，redis 还有 list、hash、zset 等数据结构，支持非常多的命令。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bea0047201f432d9a678f8fb2c6a67e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=290&s=50209&e=png&b=212121)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b65c0ddef948ee95ef64b3cd71578b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=648&h=240&s=41781&e=png&b=212121)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53e32c9431f647fb9ac188d3e4f0b996~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=686&h=248&s=48930&e=png&b=212121)

而用 CacheManager 的话，只支持 get、set：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1dfbfad0c0e4f109e0063278a25f75c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=618&h=276&s=38615&e=png&b=212121)

这时候如果你想用 list、hash、zset 等数据结构，还是要自己封装。

那何必用 CacheManager 呢？

直接自己封装下 RedisService，实现 get、set 和其它操作，不是更香么？

有同学可能会说，但它带的 CacheInterceptor 也很方便呀。

确实，但我们一般不会对接口做缓存，如果要做的话，自己实现也不麻烦。

就是拼接这样一个 key 就好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd49d4d9ba3743519eaed4d76bbb731d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=376&s=38372&e=png&b=1f1f1f)

我们实现下试试：

先安装用到的 redis 的包。
```
npm install redis 
```
然后在 AppModule 添加一个自定义的 provider：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/562ccc08514248c3baed61510253e817~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=1050&s=170634&e=png&b=1f1f1f)

```javascript
{
  provide: 'REDIS_CLIENT',
  async useFactory() {
    const client = createClient({
        socket: {
            host: 'localhost',
            port: 6379
        },
        database: 2
    });
    await client.connect();
    return client;
  }
}
```
然后创建一个 interceptor：

```
nest g interceptor my-cache --no-spec --flat
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5394121e75cb4c258b8bb54c7bdc9418~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790&h=78&s=23845&e=png&b=191919)

这样写：

```javascript
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { CallHandler, ExecutionContext, Inject, Injectable, NestInterceptor } from '@nestjs/common';
import { HttpAdapterHost } from '@nestjs/core';
import { RedisClientType } from 'redis';
import { of, tap } from 'rxjs';

@Injectable()
export class MyCacheInterceptor implements NestInterceptor {

  @Inject('REDIS_CLIENT')
  private redisClient: RedisClientType;

  @Inject(HttpAdapterHost)
  private httpAdapterHost: HttpAdapterHost;

  async intercept(context: ExecutionContext, next: CallHandler) {
    
    const request = context.switchToHttp().getRequest();

    const key = this.httpAdapterHost.httpAdapter.getRequestUrl(request);

    const value = await this.redisClient.get(key);

    if(!value) {
      return next.handle().pipe(tap((res) => {
        this.redisClient.set(key, res);
      }));
    } else {
      return of(value);
    }    
  }
}
```
redisClient 是我们前面创建的 provider，注入到这里来操作 redis。

HttpAdapterHost 前面没用过。我们知道 Nest 底层可以切换 express、fastify 等库，而这些库都会实现一个通用的适配器，就是 HttpAdapter。

我们这里用到这个适配器的方法来拿到 requestUrl，也就是 /aaa?a=3 这种。

具体的逻辑比较容易看懂，就是如果查到了 key，就直接返回 value，这里要返回 rxjs 的 Observable 对象，所以用 of 包一下。

否则，执行 handler 并且设置到 redis 里。

在 aaa 上应用我们自己写的 interceptor：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b02051921948d890a6e765f337d96e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=440&s=72934&e=png&b=1f1f1f)

跑一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca6b0938dcbb4f4fb2d151f3e73f0a62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=680&h=198&s=17009&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a3219ce94d346c6b9b32926ad38c13b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=548&s=90713&e=png&b=191919)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a38b9f715a44ffebab0bb6b737cfcc3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1206&h=632&s=74637&e=png&b=151515)

多次刷新只执行了一次 handler，并且在 redis 里存储了对应的 key、value。

这样，我们就自己实现了 CacheInterceptor。

回过头来看下，用 cache-manager 真的有必要么？

我觉得不如自己封装。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/cache-manager-test)

## 总结

Nest 文档里操作 Redis 是通过 cache-manager，它可以切换内存存储和 redis 存储，支持 get、set，并且还有 CacheInterceptor 可以对接口做缓存。

但是它并不支持各种 Redis 的命令，绝大多数情况下是不够用的，需要自己再封装。

所以，不如干脆不用那个，自己连接 redis 然后操作它就好。

用到需要 CacheInterceptor 的话也可以自己实现。

后面我们操作 Redis 都是用自己封装个 RedisModule 的方式。


## 56.两种登录状态保存方式：JWT、Session

基本所有网站都有登录功能，登录之后再次请求依然是登录状态。

但 http 是无状态的，也就是说上一次请求和下一次请求之间没有任何关联。

那如何实现的这种登录状态的保存呢？

这个问题的解决有两种方案：

*   服务端存储的 session + cookie 的方案
*   客户端存储的 jwt token 的方案

但这两种方式也都有各自的缺点。

## 服务端存储的 session + cookie

给 http 添加状态，那就给每个请求打上个标记，然后在服务端存储这个标记对应的数据。这样每个被标记的请求都可以找到对应的数据，自然可以做到登录、权限等状态的存储。

这个标记应该是自动带上的，所以 http 设计了 cookie 的机制，在里面存储的数据是每次请求都会带上的。

然后根据 cookie 里的标记去查找的服务端对应的数据叫做 session，这个标记就是 session 的 id。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a447e0090f047c5ba6d5ed4df8d3207~tplv-k3u1fbpfcp-watermark.image?)

如图，因为请求自动带上 cookie，那两次请求就都可以找到 id 为 1 对应的 session，自然就知道当前登录的用户是谁，也可以存储其他的状态数据。

这就是 session + cookie 的给 http 添加状态的方案。

大家觉得这种方案有问题么？

有问题，而且问题还挺多的。

最大的一个问题就是臭名昭著的 CSRF（跨站请求伪造）：

### CSRF

因为 cookie 会在请求时自动带上，那你在一个网站登录了，再访问别的网站，万一里面有个按钮会请求之前那个网站的，那 cookie 依然能带上。而这时候就不用再登录了。

这样万一点了这个按钮之后做了一些危险的操作呢？

是不是就很危险。

而且一般这种利用 CSRF 漏洞的网站都会伪装的很好，让你很难看出破绽来，这种网站叫做钓鱼网站。

为了解决这个问题，我们一般会验证 referer，就是请求是哪个网站发起的，如果发起请求的网站不对，那就阻止掉。

但这样依然不能完全解决问题，万一你用的浏览器也是有问题的，能伪造 referer 呢？

所以一般会用随机值来解决，每次随机生成一个值返回，后面再发起的请求需要包含这个值才行，否则就认为是非法的。

这个随机值叫做 token，可以放在参数中，也可以放在 header 中，因为钓鱼网站拿不到这个随机值，就算带了 cookie 也没发通过服务端的验证。

这是 session + cookie 这种方案的一个缺点，但是是有解决方案的。

它还有别的缺点，比如分布式的时候：

### 分布式 session

session 是把状态数据保存在服务端，那么问题来了，如果有多台服务器呢？

当并发量上去了，单台服务器根本承受不了，自然需要做集群，也就需要多台服务器来提供服务。

而且现在后端还会把不同的功能拆分到不同的服务中，也就是微服务架构，自然也需要多台服务器。

那不同服务器之间的 session 怎么同步？

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84a780b5c8ba496b8c72bd60c7d7e1cc~tplv-k3u1fbpfcp-watermark.image?)

登录之后 session 是保存在某一台服务器的，之后可能会访问到别的服务器，这时候那台服务器是没有对应的 session 的，就没法完成对应的功能。

这个问题的解决有两种方案：

一种是 session 复制，也就是通过一种机制在各台机器自动复制 session，并且每次修改都同步下。这个有对应的框架来做，比如 java 的 spring-session。

各台服务器都做了 session 复制了，那你访问任何一台都能找到对应的 session。

还有一种方案是把 session 保存在 redis，这样每台服务器都去那里查，只要一台服务器登录了，其他的服务器也就能查到 session，这样就不需要复制了。

分布式会话的场景，redis + session 的方案更常用一点。

还好，session 在分布式时的这个问题也算是有解决方案的。

但你你以为这就完了么？session + cookie 还有跨域的问题：

### 跨域

cookie 为了安全，是做了 domain 的限制的，设置 cookie 的时候会指定一个 domain，只有这个 domain 的请求才会带上这个 cookie。

而且还可以设置过期时间、路径等：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d04f84f204e64ae48e94579b1e21a19f~tplv-k3u1fbpfcp-watermark.image?)

那万一是不同 domain 的请求呢？也就是跨域的时候，怎么带 cookie 呢？

a.xxx.com 和 b.xxx.com 这种还好，只要把 domain 设置为顶级域名 xxx.com 就可以了，那二三级域名不同也能自动带上。

但如果顶级域名也不同就没办法了，这种只能在服务端做下中转，把这俩个域名统一成同一个。

上面说的不是 ajax 请求，ajax 请求有额外的机制：

ajax 请求跨域的时候是不会挟带 cookie 的，除非手动设置 withCredentials 为 true 才可以。

而且也要求后端代码设置了对应的 header：

    Access-Control-Allow-Origin: "当前域名";
    Access-Control-Allow-Credentials: true

这里的 allow origin 设置 \* 都不行，必须指定具体的域名才能接收跨域 cookie。

这是 session + cookie 方式的第三个坑，好在也是有解决方案的。

我们做下小结：

**session + cookie 的给 http 添加状态的方案是服务端保存 session 数据，然后把 id 放入 cookie 返回，cookie 是自动携带的，每个请求可以通过 cookie 里的 id 查找到对应的 session，从而实现请求的标识。这种方案能实现需求，但是有 CSRF、分布式 session、跨域等问题，不过都是有解决方案的。**

session + cookie 的方案确实不太完美，我们再来看另一种方式怎么样：

## 客户端存储的 token

session + cookie 的方案是把状态数据保存在服务端，再把 id 保存在 cookie 里来实现的。

既然这样的方案有那么多的问题，那我反其道而行之，不把状态保存在服务端了，直接全部放在请求里，也不放在 cookie 里了，而是放在 header 里，这样是不是就能解决那一堆问题了呢？

token 的方案常用 json 格式来保存，叫做 json web token，简称 JWT。

JWT 是保存在 request header 里的一段字符串（比如用 header 名可以叫 authorization），它分为三部分：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fc3b58e61d34f4a9096c55aad5bd8c7~tplv-k3u1fbpfcp-watermark.image?)

如图 JWT 是由 header、payload、verify signature 三部分组成的：

header 部分保存当前的加密算法，payload 部分是具体存储的数据，verify signature 部分是把 header 和 payload 还有 salt 做一次加密之后生成的。（salt，盐，就是一段任意的字符串，增加随机性）

这三部分会分别做 Base64，然后连在一起就是 JWT 的 header，放到某个 header 比如 authorization 中：

    authorization: Bearer xxxxx.xxxxx.xxxx

请求的时候把这个 header 带上，服务端就可以解析出对应的 header、payload、verify signature 这三部分，然后根据 header 里的算法也对 header、payload 加上 salt 做一次加密，如果得出的结果和 verify signature 一样，就接受这个 token。

把状态数据都保存在 payload 部分，这样就实现了有状态的 http:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b161071501442dfa83e639dac13a89b~tplv-k3u1fbpfcp-watermark.image?)

而且这种方式是没有 session + cookie 那些问题的，不信我们分别来看一下：

**CSRF**：因为不是通过自动带的 cookie 来关联服务端的 session 保存的状态，所以没有 CSRF 问题。

**分布式 session**： 因为状态不是保存在服务端，所以无论访问哪台服务器都行，只要能从 token 里解析出状态数据就行。

**跨域**：因为不是 cookie 那一套，自然也没有跨域的限制，只要手动带上 JWT 的 header 就行。

看起来这种方式好像很完美？

其实也不是，JWT 有 JWT 的问题：

### 安全性

因为 JWT 把数据直接 Base64 之后就放在了 header 里，那别人就可以轻易从中拿到状态数据，比如用户名等敏感信息，也能根据这个 JWT 去伪造请求。

所以 JWT 要搭配 https 来用，让别人拿不到 header。

### 性能

JWT 把状态数据都保存在了 header 里，每次请求都会带上，比起只保存个 id 的 cookie 来说，请求的内容变多了，性能也会差一些。

所以 JWT 里也不要保存太多数据。

### 没法让 JWT 失效

session 因为是存在服务端的，那我们就可以随时让它失效，而 JWT 不是，因为是保存在客户端，那我们是没法手动让他失效的。

比如踢人、退出登录、改完密码下线这种功能就没法实现。

但也可以配合 redis 来解决，记录下每个 token 对应的生效状态，每次先去 redis 查下 jwt 是否是可用的，这样就可以让 jwt 失效。

所以说，JWT 的方案虽然解决了很多 session + cookie 的问题，但也不完美。

小结下：

**JWT 的方案是把状态数据保存在 header 里，每次请求需要手动携带，没有 session + cookie 方案的 CSRF、分布式、跨域的问题，但是也有安全性、性能、没法控制等问题。**

## 总结

http 是无状态的，也就是请求和请求之间没有关联，但我们很多功能的实现是需要保存状态的。

给 http 添加状态有两种方式：

**session + cookie**：把状态数据保存到服务端，session id 放到 cookie 里返回，这样每次请求会带上 cookie ，通过 id 来查找到对应的 session。这种方案有 CSRF、分布式 session、跨域的问题。

**jwt**：把状态保存在 json 格式的 token 里，放到 header 中，需要手动带上，没有 cookie + session 的那些问题，但是也有安全性、性能、没法手动控制失效的问题。

上面这两种方案都不是完美的，但那些问题也都有解决方案。

常用的方案基本是 session + redis、jwt + redis 这种。

软件领域很多情况下都是这样的，某种方案都解决了一些问题，但也相应的带来了一些新的问题。没有银弹，还是要熟悉它们的特点，根据不同的需求灵活选用。


## 57.Nest 里实现 Session 和 JWT

上节我们知道了保存登录状态的两种方式，session + cookie、jwt，这节我们用 Nest 来实现下吧。

首先用 @nest/cli 快速创建一个 Nest.js 项目

    nest new jwt-and-session -p npm

我们先实现 session  + cookie 的方式：

Nest 里实现 session 实现还是用的 express 的中间件 express-session。

安装 express-session 和它的 ts 类型定义：

    npm install express-session @types/express-session

然后在入口模块里启用它：

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as session from 'express-session';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.use(session({
    secret: 'guang',
    resave: false,
    saveUninitialized: false
  }));
  await app.listen(3000);
}
bootstrap();

```

使用 express-session 中间件，指定加密的密钥 secret。

resave 为 true 是每次访问都会更新 session，不管有没有修改 session 的内容，而 false 是只有 session 内容变了才会去更新 session。

saveUninitalized 设置为 true 是不管是否设置 session，都会初始化一个空的 session 对象。比如你没有登录的时候，也会初始化一个 session 对象，这个设置为 false 就好。

然后在 controller 里就可以注入 session 对象：

```javascript
@Get('sss')
sss(@Session() session) {
    console.log(session)
    session.count = session.count ? session.count + 1 : 1;
    return session.count;
}
```

我在 session 里放了个 count 的变量，每次访问加一，然后返回这个 count。

这样就可以判断 http 请求是否有了状态。

把它跑起来：

    nest start --watch

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74f805d6f4954fba8bbf5a070e08c31e~tplv-k3u1fbpfcp-watermark.image?)

然后用 postman 测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a533a453fe45496fb61084e9409345f9~tplv-k3u1fbpfcp-watermark.image?)

可以看到每次请求返回的数据都不同，而且返回了一个 cookie 是 connect.sid，这个就是对应 session 的 id。

因为 cookie 在请求的时候会自动带上，就可以实现请求的标识，给 http 请求加上状态。

session + cookie 的方式用起来还是很简单的，我们再来看下 jwt 的方式：

jwt 需要引入 @nestjs/jwt 这个包

    npm install @nestjs/jwt

然后在 AppModule 里引入 JwtModule：

```javascript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    JwtModule.register({
      secret: 'guang',
      signOptions: {
        expiresIn: '7d'
      }
    })
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

JwtModule 是一个动态模块，通过 register 传入 option。

或者是 registerAsync，然后通过 useFactory 异步拿到 option 传入：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0690af4482204510857f640ec11f1b9c~tplv-k3u1fbpfcp-watermark.image?)

这部分是动态模块的知识，忘了的同学可以看看动态模块那节。

指定 secret，也就是加密 jwt 的密钥，还有 token 过期时间 expiresIn，设置 7 天。

然后在 controller 里注入 JwtModule 里的 JwtService：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66c2384eacb14d4795d359f9f58f8f18~tplv-k3u1fbpfcp-watermark.image?)

然后添加一个 handler：

```javascript
@Get('ttt')
ttt(@Res({ passthrough: true}) response: Response) {
    const newToken = this.jwtService.sign({
      count: 1
    });

    response.setHeader('token', newToken);
    return 'hello';
}
```

这里使用 jwtService.sign 来生成一个 jwt token，放到 response header 里。

因为注入 response 对象之后，默认不会把返回值作为 body 了，需要设置 passthrough 为 true 才可以。

然后访问下试试看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a622591c25041c2bec8b2c73630aa97~tplv-k3u1fbpfcp-watermark.image?)

可以看到，返回的响应确实带上了这个 header。

后面的请求需要带上这个 token，在服务端取出来，然后 +1 之后再放回去：

```javascript
@Get('ttt')
ttt(@Headers('authorization') authorization: string, @Res({ passthrough: true}) response: Response) {
    if(authorization) {
      try {
        const token = authorization.split(' ')[1];
        const data = this.jwtService.verify(token);

        const newToken = this.jwtService.sign({
          count: data.count + 1
        });
        response.setHeader('token', newToken);
        return data.count + 1
      } catch(e) {
        console.log(e);
        throw new UnauthorizedException();
      }
    } else {
      const newToken = this.jwtService.sign({
        count: 1
      });

      response.setHeader('token', newToken);
      return 1;
    }
}
```

通过 @Headers 装饰器取出 autorization 的 header，然后通过 jwtService.verify 对它做验证。

如果验证失败，那就抛出 UnauthorizedException 异常，让 Nest 内置的 Exception Filter 来处理。

验证成功就重新生成 jwt 放到 header 里返回。

如果没有 autorization 的 header，那就生成一个 jwt 放到 header 里返回。

然后我们测试下。

第一次访问，会返回 jwt token，把它复制下来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f40b87a16e344006a58a29a95e3dee33~tplv-k3u1fbpfcp-watermark.image?)

放到请求的 header 里：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/825a4a3bba2c445a80ae0df3bb2316a9~tplv-k3u1fbpfcp-watermark.image?)

这时候响应为 2，并且返回一个新的 token：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a73e766c8b04e58a93d22fac74e7861~tplv-k3u1fbpfcp-watermark.image?)

把它复制下来放到 header 里再次请求：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65a1cd5c2144432bb077c39faf7ffe11~tplv-k3u1fbpfcp-watermark.image?)

这时候返回的就是 3 了。

这就是通过 jwt 保存状态的方式。

那我们带一个错误的 token 呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04d7d1d5150c445a92ce331dec24ebb1~tplv-k3u1fbpfcp-watermark.image?)

这时候 jwtService.verify 方法就会抛异常，然后我们返回了 401 错误。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf2a2485c3641e7ae0c8883f3825f34~tplv-k3u1fbpfcp-watermark.image?)

这样，我们就分别用 Nest 分别实现了 session + cookie 和 jwt 两种保存 http 状态的方式。

**携带 jwt 需要加载 authorization 的 header 里，以 Bearer xxx 的格式，但是返回 jwt 可以放在任何地方，header、cookie 或者 body 里都可以。**

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/jwt-and-session)。

## 总结

我们分别在 nest 里实现了 session、jwt 两种给 http 添加状态的方式。

session 使用的是 express 的 express-session 中间件，通过 @Session 装饰器取出来传入 controller 里。

jwt 需要引入 @nestjs/jwt 包的 JwtModule，注入其中的 JwtService，然后通过 jwtService.sign 生成 token，通过 jwtService.verify 验证 token。

token 放在 authorization 的 header 里。

session 或者 jwt 都是非常常用的给 http 添加状态的方式，下节我们用这两种方式实现下登录注册功能。


## 58.MySQL + TypeORM + JWT 实现登录注册

学完了 mysql、typeorm、jwt/session 之后，我们来做个综合案例：登录注册。

首先，创建个新的 database：

```sql
CREATE SCHEMA login_test DEFAULT CHARACTER SET utf8mb4;
```

create schema 或者 create database 都可以，一个意思。

指定默认字符集 ，这样创建表的时候就不用指定字符集了。

utf8 最多存 3 个字节的字符，而 utf8mb4 最多 4 个字符，可以存储一些 emoji 等特殊字符。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22a3ca51398d46cb8b30356ecd92d45e~tplv-k3u1fbpfcp-watermark.image?)

刷新后就可以看到这个数据库了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b90e820fb3f94f52b7e24cd3b56e4f0f~tplv-k3u1fbpfcp-watermark.image?)

然后我们创建个 nest 项目：

    nest new login-and-register -p npm

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9dd4f0be61742b28d442924882d2a92~tplv-k3u1fbpfcp-watermark.image?)

安装 typeorm 相关的包：

    npm install --save @nestjs/typeorm typeorm mysql2

然后在 AppModule 里引入 TypeOrmModule，传入 option：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [ 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "login_test",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

之后创建个 user 的 CRUD 模块：

    nest g resource user

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f25a7036e4c49cbbaba230d3d359cf3~tplv-k3u1fbpfcp-watermark.image?)

引入 User 的 entity：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1124e12a05242dfaaf91c77b7718779~tplv-k3u1fbpfcp-watermark.image?)

然后给 User 添加一些属性：

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class User {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50,
        comment: '用户名'
    })
    username: string;

    @Column({
        length:50,
        comment: '密码'
    })
    password: string;

    @CreateDateColumn({
        comment: '创建时间'
    })
    createTime: Date;

    @UpdateDateColumn({
        comment: '更新时间'
    })
    updateTime: Date;

}
```

id 列是主键、自动递增。

username 和 password 是用户名和密码，类型是 VARCHAR(50)。

createTime 是创建时间，updateTime 是更新时间。

这里的 @CreateDateColumn 和 @UpdateDateColumn 都是 datetime 类型。

@CreateDateColumn 会在第一次保存的时候设置一个时间戳，之后一直不变。

而 @UpdateDateColumn 则是每次更新都会修改这个时间戳。

用来保存创建时间和更新时间很方便。

然后我们跑一下：

    npm run start:dev

npm run start:dev 就是 nest start --watch：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fbae5dbf8d44233a691330c917f8770~tplv-k3u1fbpfcp-watermark.image?)

可以看到打印了 create table 的建表 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e401ac99761848019e1d2b481fd8031c~tplv-k3u1fbpfcp-watermark.image?)

用 mysql workbench 可以看到生成的表是对的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd79d09772cc4750a01bafea98fe7352~tplv-k3u1fbpfcp-watermark.image?)

然后我们在 UserModule 引入 TypeOrm.forFeature 动态模块，传入 User 的 entity。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d5bb9e2d5144c3c87ce7954a253b0cd~tplv-k3u1fbpfcp-watermark.image?)

这样模块内就可以注入 User 对应的 Repository 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fddd883cc1f9460197b25f9b053949f6~tplv-k3u1fbpfcp-watermark.image?)

然后就可以实现 User 的增删改查。

我们在 UserController 里添加两个 handler：

```javascript
import { Controller, Get, Post, Body, Patch, Param, Delete } from '@nestjs/common';
import { UserService } from './user.service';

@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post('login')
  login() {

  }

  @Post('register')
  register() {

  }
}
```

其余的 handler 用不到，都可以去掉。

然后添加两个 dto：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2d3e8414d784352a51fb74825ae10c8~tplv-k3u1fbpfcp-watermark.image?)

```javascript
export class LoginDto {
    username: string;
    password: string;
}
```

```javascript
export class RegisterDto {
    username: string;
    password: string;
}
```

在 handler 里使用这两个 dto 来接收参数：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a466ad45b744b26b04e5a2f6f40dc98~tplv-k3u1fbpfcp-watermark.image?)

我们先在 postman 里测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f0a6a04db664af59868cff08184bebd~tplv-k3u1fbpfcp-watermark.image?)

post 请求 /user/login 接口，body 传入用户信息。

服务端打印了收到的 user：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd8f7273f275459bb38d598d6d2f6171~tplv-k3u1fbpfcp-watermark.image?)

然后 post 请求 /user/register：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17a4c7ea658a45aea6094c14b1e3d65a~tplv-k3u1fbpfcp-watermark.image?)

也是一样的。

虽然都是 user，但是 login 和 register 的处理不同：

*   register 是把用户信息存到数据库里
*   login 是根据 username 和 password 取匹配是否有这个 user

先实现注册：

```javascript
@Post('register')
async register(@Body() user: RegisterDto) {
    return await this.userService.register(user);
}
```

在 UserSerice 里实现 register 方法：

```javascript
import { RegisterDto } from './dto/register.dto';
import { HttpException, HttpStatus, Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import * as crypto from 'crypto';

function md5(str) {
  const hash = crypto.createHash('md5');
  hash.update(str);
  return hash.digest('hex');
}

@Injectable()
export class UserService {

  private logger = new Logger();

  @InjectRepository(User)
  private userRepository: Repository<User>;


  async register(user: RegisterDto) {
    const foundUser = await this.userRepository.findOneBy({
      username: user.username
    });

    if(foundUser) {
      throw new HttpException('用户已存在', 200);
    }

    const newUser = new User();
    newUser.username = user.username;
    newUser.password = md5(user.password);

    try {
      await this.userRepository.save(newUser);
      return '注册成功';
    } catch(e) {
      this.logger.error(e, UserService);
      return '注册失败';
    }
  }
}
```
先根据 username 查找下，如果找到了，说明用户已存在，抛一个 HttpException 让 exception filter 处理。

否则，创建 User 对象，调用 userRepository 的 save 方法保存。

password 需要加密，这里使用 node 内置的 crypto 包来实现。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb9f79abb69a4741a91b305a76cf8417~tplv-k3u1fbpfcp-watermark.image?)

我们测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf8806fa194d477c9631bba3c797c568~tplv-k3u1fbpfcp-watermark.image?)

服务返回了注册成功，并且打印了 insert 的 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be54c8b944334883a7b23e9a1051192d~tplv-k3u1fbpfcp-watermark.image?)

可以看到，数据库 user 表插入了这个用户的信息，并且指定了 createTime 和 udpateTime。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bc7ecdccb7741fa82025ae9428c4e4d~tplv-k3u1fbpfcp-watermark.image?)

然后我们再次调用：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b770d0c28b9647ea8c9bf68f1efa0787~tplv-k3u1fbpfcp-watermark.image?)

会提示用户已经存在。

这就是注册。

然后再实现下登录：

添加一个 handler：
```javascript
@Post('login')
async login(@Body() user: LoginDto) {
    const foundUser = await this.userService.login(user);

    if(foundUser) {
      return 'login success';
    } else {
      return 'login fail';
    }
}
```
然后再添加对应的 service：

```javascript
async login(user: LoginDto) {
    const foundUser = await this.userRepository.findOneBy({
      username: user.username,
    });

    if(!foundUser) {
      throw new HttpException('用户名不存在', 200);
    }
    if(foundUser.password !== md5(user.password)) {
      throw new HttpException('密码错误', 200);
    }
    return foundUser;
}
```
根据用户名查找用户，没找到就抛出用户不存在的 HttpException、找到但是密码不对就抛出密码错误的 HttpException。

否则，返回找到的用户。

我们试一下：

用户名、密码正确：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8e459bcd190434cad2561abe2d58110~tplv-k3u1fbpfcp-watermark.image?)

用户名不存在：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d99407ad2754704988883072602a360~tplv-k3u1fbpfcp-watermark.image?)

用户名存在但密码错误：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6076835d50bb4820b452ae3aeef5aabf~tplv-k3u1fbpfcp-watermark.image?)

可以看到，服务端打印了 3 条 select 的 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff6de1d221044b0dadeb92d95c9b1a20~tplv-k3u1fbpfcp-watermark.image?)

登录成功之后我们要把用户信息放在 jwt 或者 session 中一份，这样后面再请求就知道已经登录了。

安装 @nestjs/jwt 的包：

```
npm install @nestjs/jwt
```

在 AppModule 里引入 JwtModule：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d256e8eb46a1489eaba895961d9a8fed~tplv-k3u1fbpfcp-watermark.image?)

global:true 声明为全局模块，这样就不用每个模块都引入它了，指定加密密钥，token 过期时间。

在 UserController 里注入 JwtService：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adf4d0525c1e420bb13af65f35ea06e0~tplv-k3u1fbpfcp-watermark.image?)

然后在登录成功后，把 user 信息放到 jwt 通过 header 里返回。

```javascript
@Post('login')
async login(@Body() user: LoginDto,  @Res({passthrough: true}) res: Response) {
    const foundUser = await this.userService.login(user);

    if(foundUser) {
      const token = await this.jwtService.signAsync({
        user: {
          id: foundUser.id,
          username: foundUser.username
        }
      })
      res.setHeader('token', token);
      return 'login success';
    } else {
      return 'login fail';
    }
}
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1373793c3a844089a4f9ac57e1ab50fb~tplv-k3u1fbpfcp-watermark.image?)

再次访问：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b0dc8c99c154c07861cf809b8229456~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8348a1774d043b584413e0b7a2a185b~tplv-k3u1fbpfcp-watermark.image?)

登录成功之后返回了 jwt 的 token。

我们有一些接口是只有登录才能访问的。

我们在 AppController 里添加两个路由：

```javascript
@Get('aaa')
aaa() {
    return 'aaa';
}

@Get('bbb')
bbb() {
    return 'bbb';
}
```

现在不需要登录就可以访问：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46bbf461981f44549152546a5f586b39~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d57dab4f66a644e3a35d40f6f623aa06~tplv-k3u1fbpfcp-watermark.image?)

我们可以加个 Guard 来限制访问：

```
nest g guard login --no-spec --flat
```

然后实现 jwt 校验的逻辑：

```javascript
import { JwtService } from '@nestjs/jwt';
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { Request } from 'express';
import { Observable } from 'rxjs';

@Injectable()
export class LoginGuard implements CanActivate {
  @Inject(JwtService)
  private jwtService: JwtService;

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request: Request = context.switchToHttp().getRequest();

    const authorization = request.header('authorization') || '';

    const bearer = authorization.split(' ');
    
    if(!bearer || bearer.length < 2) {
      throw new UnauthorizedException('登录 token 错误');
    }

    const token = bearer[1];

    try {
      const info = this.jwtService.verify(token);
      (request as any).user = info.user;
      return true;
    } catch(e) {
      throw new UnauthorizedException('登录 token 失效，请重新登录');
    }
  }
}
```
取出 authorization 的 header，验证 token 是否有效，token 有效返回 true，无效的话就返回 UnauthorizedException。

把这个 Guard 应用到 handler：

```javascript
@Get('aaa')
@UseGuards(LoginGuard)
aaa() {
    return 'aaa';
}

@Get('bbb')
@UseGuards(LoginGuard)
bbb() {
    return 'bbb';
}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46e3831b35064794bc019e939cb6dfc8~tplv-k3u1fbpfcp-watermark.image?)

我们先登录一下，拿到 token：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f169358e6aca45c08493399af0a437dd~tplv-k3u1fbpfcp-watermark.image?)

然后请求 /aaa 的时候通过 authorization 的 header 带上 token：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d82ed2502b4ddbb77c7a5930e3098d~tplv-k3u1fbpfcp-watermark.image?)

访问成功。

如果不带 token，就失败了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9af28df874ef4c038d51c259b4113c82~tplv-k3u1fbpfcp-watermark.image?)


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28b919ac0a224a248d0ed3ef20018306~tplv-k3u1fbpfcp-watermark.image?)

这样我们就实现了登录注册的流程。

但是，现在我们并没有对参数做校验，这个用 ValidationPipe + class-validator 来做。

安装 class-validator 和 class-transformer 的包：

```
npm install class-validator class-transformer
```

然后给 /user/login 和 /user/register 接口添加 ValidationPipe：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3cff47a0364352b1ff071dac011492~tplv-k3u1fbpfcp-watermark.image?)

在 dto 里声明参数的约束：

```javascript
import { IsNotEmpty, IsString, Length, Matches } from "class-validator";

export class RegisterDto {
    @IsString()
    @IsNotEmpty()
    @Length(6, 30)
    @Matches(/^[a-zA-Z0-9#$%_-]+$/, {
        message: '用户名只能是字母、数字或者 #、$、%、_、- 这些字符'
    })
    username: string;

    @IsString()
    @IsNotEmpty()
    @Length(6, 30)
    password: string;
}
```
注册的时候，用户名密码不能为空，长度为 6-30，并且限定了不能是特殊字符。

登录就不用限制了，只要不为空就行：
```javascript
import { IsNotEmpty } from "class-validator";

export class LoginDto{
    @IsNotEmpty()
    username: string;

    @IsNotEmpty()
    password: string;
}
```

我们测试下：


![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd83d85eac984b9e94008c320ed1f632~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bea937994404abe84ef86f0ee774973~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16242a279c924280afc1c45ca01d390b~tplv-k3u1fbpfcp-watermark.image?)

ValidationPipe 生效了。

这样，我们就实现了登录、注册和鉴权的完整功能。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f65a172a4cce440aa9b5cad5fa9979d2~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43cb79b2d63046e6856417489832c81f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4ef812d409492d90ab8c9ac72ccefd~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/login-and-register)。

## 总结

这节我们通过 mysql + typeorm + jwt + ValidationPipe 实现了登录注册的功能。

typeorm 通过 @PrimaryGeneratedKey、@Column、@CreateDateColumn、@UpdateDateColumn 声明和数据库表的映射。

通过 TypeOrmModule.forRoot、TypeOrmModule.forFeature 的动态模块添加数据源，拿到 User 的 Repository。

然后用 Repository 来做增删改查，实现注册和登录的功能。

登录之后，把用户信息通过 jwt 的方式放在 authorization 的 header 里返回。

然后 LoginGuard 里面取出 header 来做验证，token 正确的话才放行。

此外，参数的校验使用 ValidationPipe + class-validator 来实现。

这样，就实现了注册和基于 JWT 的登录功能。



## 59.基于 ACL 实现权限控制

上节我们实现了注册和登录，有的接口只有登录可以访问，会在 Guard 里做身份验证（Authentication）。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a196d25e18c8443cbc22a3ddb07bca43~tplv-k3u1fbpfcp-watermark.image?)

但有的接口，不只需要登录，可能还需要一定的权限，这时就需要鉴权（Authorization）。

比如管理员登录后，可以调用用户管理的接口，但普通用户登录后就不可以。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a363d08394dc4a5ab4a0d7d17aafc0c2~tplv-k3u1fbpfcp-watermark.image?)

也就是说，身份验证通过之后还需要再做一步权限的校验，也就是鉴权。

这俩单词也比较相似：身份验证（Authentication）、鉴权（Authorization）。

那怎么给不同用户分配权限呢？

最简单的方式自然是直接给用户分配权限：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/064d13d33b0442cdb9bedba7bc78dbc6~tplv-k3u1fbpfcp-watermark.image?)

比如用户 1 有权限 A、B、C，用户 2 有权限 A，用户 3 有权限 A、B。

这种记录每个用户有什么权限的方式，叫做访问控制表（Access Control List）

用户和权限是多对多关系，存储这种关系需要用户表、角色表、用户-角色的中间表。

这节我们就来实现下 ACL 的权限控制。

在数据库中创建 acl_test 的 database。

```sql
CREATE DATABASE acl_test DEFAULT CHARACTER SET utf8mb4;
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d344cc84b364bc4b0f941a4ccddeed9~tplv-k3u1fbpfcp-watermark.image?)

刷新可以看到这个 database：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d70317e2c057429c9440eb6d795d257d~tplv-k3u1fbpfcp-watermark.image?)

创建个 nest 项目：

```
nest new acl-test -p npm
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5b56ce0fbd74d6fa76fbc43d69e4861~tplv-k3u1fbpfcp-watermark.image?)

安装 typeorm 的依赖：

```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [ 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "acl_test",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后添加创建 user 模块：

```
nest g resource user
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d6d66d7feca42a79ff2eabe6fa08e83~tplv-k3u1fbpfcp-watermark.image?)

添加 User 和 Permission 的 Entity：

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    username: string;

    @Column({
        length: 50
    })
    password: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
}
```
User 有 id、username、password、createTime、updateTime 5 个字段。

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class Permission {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    name: string;
    
    @Column({
        length: 100,
        nullable: true
    })
    desc: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
}

```
permission 有 id、name、desc、createTime、updateTime 5 个字段，desc 字段可以为空。

然后在 User 里加入和 Permission 的关系，也就是多对多：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe05ed5e3798496dad4e49c0a607b50b~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ManyToMany(() => Permission)
@JoinTable({
    name: 'user_permission_relation'
})
permissions: Permission[] 
```

通过 @ManyToMany 声明和 Permisssion 的多对多关系。

多对多是需要中间表的，通过 @JoinTable 声明，指定中间表的名字。

然后在 TypeOrm.forRoot 的 entities 数组加入这俩 entity：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44becf70f95a4f1f9357cc722b5f8ffe~tplv-k3u1fbpfcp-watermark.image?)

把 Nest 服务跑起来试试：

```
npm run start:dev
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d91b0520440c45fabd88492fe30edd15~tplv-k3u1fbpfcp-watermark.image?)

可以看到生成了 user、permission、user_permission_relation 这 3 个表。

并且中间表 user_permission_relation 还有 userId、permissionId 两个外键。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/658d01e1a2af4e5aa7367d8d3a01ed98~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1231ccfeb4b24c9b8c2b180d4c061598~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea177aef34254a12bce1b3d650280549~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9093458e13484a90b891d94328ef7b47~tplv-k3u1fbpfcp-watermark.image?)

可以看到，3个表生成的都是对的，并且中间表的两个外键也都是主表删除或者更新时，从表级联删除或者更新。

然后我们插入一些数据，不用 sql 插入，而是用 TypeORM 的 api 来插入：

修改下 UserService，添加这部分代码：


```javascript
@InjectEntityManager()
entityManager: EntityManager;

async initData() {
    const permission1 = new Permission();
    permission1.name = 'create_aaa';
    permission1.desc = '新增 aaa';

    const permission2 = new Permission();
    permission2.name = 'update_aaa';
    permission2.desc = '修改 aaa';

    const permission3 = new Permission();
    permission3.name = 'remove_aaa';
    permission3.desc = '删除 aaa';

    const permission4 = new Permission();
    permission4.name = 'query_aaa';
    permission4.desc = '查询 aaa';

    const permission5 = new Permission();
    permission5.name = 'create_bbb';
    permission5.desc = '新增 bbb';

    const permission6 = new Permission();
    permission6.name = 'update_bbb';
    permission6.desc = '修改 bbb';

    const permission7 = new Permission();
    permission7.name = 'remove_bbb';
    permission7.desc = '删除 bbb';

    const permission8 = new Permission();
    permission8.name = 'query_bbb';
    permission8.desc = '查询 bbb';

    const user1 = new User();
    user1.username = '东东';
    user1.password = 'aaaaaa';
    user1.permissions  = [
      permission1, permission2, permission3, permission4
    ]

    const user2 = new User();
    user2.username = '光光';
    user2.password = 'bbbbbb';
    user2.permissions  = [
      permission5, permission6, permission7, permission8
    ]

    await this.entityManager.save([
      permission1, 
      permission2,
      permission3,
      permission4,
      permission5,
      permission6,
      permission7,
      permission8
    ])
    await this.entityManager.save([
      user1, 
      user2
    ]);
}

```
注入 EntityManager，实现权限和用户的保存。

aaa 增删改查、bbb增删改查，一个 8 个权限。

user1 有 aaa 的 4 个权限，user2 有 bbbb 的 4 个权限。

调用 entityManager.save 来保存。

然后改下 UserController：

```javascript
@Get('init')
async initData() {
    await this.userService.initData();
    return 'done'
}
```
添加 init 的路由。

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e7ba556235844e997cadab8dcb57345~tplv-k3u1fbpfcp-watermark.image?)

服务端打印了一堆 sql，包了一层事务：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89fe670fa90f41ae8912e2f6403d5ac6~tplv-k3u1fbpfcp-watermark.image?)

分别向 user、permission、user_permission_relation 中插入了数据。

我们在 mysql workbench 里刷新下：

permission 表插入了 8 条权限记录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e3c16d3526a47619b6d004ea9437296~tplv-k3u1fbpfcp-watermark.image?)

user 表插入了 2 条用户记录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c81915c173346448ba2ccf224332861~tplv-k3u1fbpfcp-watermark.image?)

中间表插入了 8 条记录，两个用户各拥有 4 个权限：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d8480ea103449cab6f6d9c9970d6940~tplv-k3u1fbpfcp-watermark.image?)

然后我们再实现登录的接口，这次通过 session + cookie 的方式。

安装 session 相关的包：

```
npm install express-session @types/express-session
```

在 main.ts 里使用这个中间件：

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as session from 'express-session';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.use(session({
    secret: 'guang',
    resave: false,
    saveUninitialized: false
  }));
  await app.listen(3000);
}
bootstrap();
```
secret 是加密 cookie 的密钥。

resave 是 session 没变的时候要不要重新生成 cookie。

saveUninitialized 是没登录要不要也创建一个 session。

然后在 UserController 添加一个 /user/login 的路由：

```javascript
@Post('login')
login(@Body() loginUser: LoginUserDto, @Session() session){
    console.log(loginUser)
    return 'success'
}
```
然后先去创建 dto 对象：

```javascript
export class LoginUserDto {
    username: string;

    password: string;
}
```

安装 ValidationPipe 用到的包：

```
npm install --save class-validator class-transformer
```

然后给 dto 对象添加 class-validator 的装饰器：

```javascript
import { IsNotEmpty, Length } from "class-validator";

export class LoginUserDto {
    @IsNotEmpty()
    @Length(1, 50)
    username: string;

    @IsNotEmpty()
    @Length(1, 50)
    password: string;
}
```

全局启用 ValidationPipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5385c95d0e42bbafe1258482411da1~tplv-k3u1fbpfcp-watermark.image?)

然后在 postman 里测试下：

ValidationPipe 不通过的时候，会返回错误信息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26a2488fd1f248de9b2f6eabf5d38135~tplv-k3u1fbpfcp-watermark.image?)

ValidationPipe 通过之后，就会执行 handler 里的方法：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6dae7b1cad345f7bd9b2cf1d0d033dc~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13f0636ae79f4398ac6e21b80d79d3bc~tplv-k3u1fbpfcp-watermark.image?)

接下来实现查询数据库的逻辑，在 UserService 添加 login 方法：

```javascript
async login(loginUserDto: LoginUserDto) {
    const user = await this.entityManager.findOneBy(User, {
      username: loginUserDto.username
    });

    if(!user) {
      throw new HttpException('用户不存在', HttpStatus.ACCEPTED);
    }

    if(user.password !== loginUserDto.password) {
      throw new HttpException('密码错误', HttpStatus.ACCEPTED);
    }

    return user;
}
```
然后改下 UserController 的 login 方法：

```javascript
@Post('login')
async login(@Body() loginUser: LoginUserDto, @Session() session){
    const user = await this.userService.login(loginUser);

    session.user = {
      username: user.username
    }

    return 'success';
}
```

调用 userService，并且把 user 信息放入 session。

再用 postman 登录下：

用户不存在：
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba3a8e3cf1a4c2b9f9b670ea0610607~tplv-k3u1fbpfcp-watermark.image?)

密码错误：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/181c6e66611e49849c443ce2b20f6b74~tplv-k3u1fbpfcp-watermark.image?)

登录成功：
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ecc33112b7644378bc3e22133b39ba1~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c325f5a8f92457cb491f7629354c24c~tplv-k3u1fbpfcp-watermark.image?)

登录成功之后会返回 cookie，之后只要带上这个 cookie 就可以查询到服务端的对应的 session，从而取出 user 信息。

然后添加 aaa、bbb 两个模块，分别生成 CRUD 方法：
```
nest g resource aaa 
nest g resource bbb 
```
![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f355fb75d254ce8ba1f284a182bb806~tplv-k3u1fbpfcp-watermark.image?)


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c91016bc4be4ee0b6a4445d0d357ab5~tplv-k3u1fbpfcp-watermark.image?)

现在这些接口可以直接访问：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a9724b76fae4a16965bf58f27295d38~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e96a5281a094eeeaaba535bc2ead0cc~tplv-k3u1fbpfcp-watermark.image?)

而实际上这些接口是要控制权限的。

用户东东有 aaa 的增删改查权限，而用户光光拥有 bbb 的增删改查权限。

所以要对接口的调用做限制。

先添加一个 LoginGuard，限制只有登录状态才可以访问这些接口： 

```
nest g guard login --no-spec --flat
```

然后增加登录状态的检查：

```javascript
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common';
import { Request } from 'express';
import { Observable } from 'rxjs';

declare module 'express-session' {
  interface Session {
    user: {
      username: string
    }
  }
}

@Injectable()
export class LoginGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request: Request = context.switchToHttp().getRequest();
    
    if(!request.session?.user){
      throw new UnauthorizedException('用户未登录');
    }

    return true;
  }
}
```

因为默认的 session 里没有 user 的类型，所以需要扩展下：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e85bbb6f837441f6bbe8d146fb519e54~tplv-k3u1fbpfcp-watermark.image?)

利用同名 interface 会自动合并的特点来扩展 Session。

然后给接口都加上这个 Guard：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/486fb3ea083b440dbbfa5985389787c1~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d1d8aec3553440581807ddd9ce1492e~tplv-k3u1fbpfcp-watermark.image?)

再访问下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/472ce143701547a4b9ac10343b78a204~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/678b5caa977a47ef90fe102fdb38f30b~tplv-k3u1fbpfcp-watermark.image?)

在 postman 里带上 cookie 访问：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f911b77516a447048fc4c7392f515f71~tplv-k3u1fbpfcp-watermark.image?)

你访问登录接口之后，服务端返回 set-cookie 的 header，postman 会自动带上 cookie，不需要手动带：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db9879eeeb043af89e303ab03ec14a1~tplv-k3u1fbpfcp-watermark.image?)

行为和浏览器里一致。

这时候再访问 aaa、bbb 的接口，就可以访问了：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c7e856dd0a44d77a4a949d0bd011d4d~tplv-k3u1fbpfcp-watermark.image?)

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a73efa81077d4afa844905f304582f97~tplv-k3u1fbpfcp-watermark.image?)

但是这样还不够，我们还需要再做登录用户的权限控制，所以再写个 PermissionGuard:

```
nest g guard permission --no-spec --flat
```

因为 PermissionGuard 里需要用到 UserService 来查询数据库，所以把它移动到 UserModule 里：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b72c7d8ea224dce8500044d209af933~tplv-k3u1fbpfcp-watermark.image?)

注入 UserService：

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable } from '@nestjs/common';
import { Request } from 'express';
import { Observable } from 'rxjs';
import { UserService } from './user.service';

@Injectable()
export class PermissionGuard implements CanActivate {

  @Inject(UserService) 
  private userService: UserService;

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {

    console.log(this.userService);

    return true;
  }
}
```

在 UserModule 的 providers、exports 里添加 UserService 和 PermissionGuard

```javascript
import { Module, UseGuards } from '@nestjs/common';
import { UserService } from './user.service';
import { UserController } from './user.controller';
import { PermissionGuard } from './permission.guard';

@Module({
  controllers: [UserController],
  providers: [UserService, PermissionGuard],
  exports: [UserService, PermissionGuard]
})
export class UserModule {}
```

这样就可以在 PermissionGuard 里注入 UserService 了。

我们在 AaaModule 里引入这个 UserModule：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7899f5435e40a5b5b64aa7f5bd3dcd~tplv-k3u1fbpfcp-watermark.image?)

然后在 /aaa 的 handler 里添加 PermissionGuard：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44212b21eace4f758cabf73d2ef5a408~tplv-k3u1fbpfcp-watermark.image?)

postman 访问下：

首先重新登录，post 方式请求 /user/login：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85f16a5e304f43f5bb54d6011c3865ed~tplv-k3u1fbpfcp-watermark.image?)

然后 get 访问 /aaa，postman 会自动带上 cookie。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f18514508c0c46e9a2834ffe03f70511~tplv-k3u1fbpfcp-watermark.image?)

服务端打印了 UserService：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3245408c702d4290a20c1da3f7ccc755~tplv-k3u1fbpfcp-watermark.image?)

说明在 PermissionGuard 里成功注入了 UserService。

然后来实现权限检查的逻辑。

在 UserService 里添加一个方法：

```javascript
async findByUsername(username: string) {
  const user = await this.entityManager.findOne(User, {
    where: {
      username,
    },
    relations: {
      permissions: true
    }
  });
  return user;
}
```
根据用户名查找用户，并且查询出关联的权限来。

在 PermissionGuard 里调用下：

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { Request } from 'express';
import { Observable } from 'rxjs';
import { UserService } from './user.service';

@Injectable()
export class PermissionGuard implements CanActivate {

  @Inject(UserService) 
  private userService: UserService;

  async canActivate(
    context: ExecutionContext,
  ): Promise<boolean> {
    const request: Request = context.switchToHttp().getRequest();

    const user = request.session.user;
    if(!user) {
      throw new UnauthorizedException('用户未登录');
    }

    const foundUser = await this.userService.findByUsername(user.username);

    console.log(foundUser);

    return true;
  }
}

```

打印了下查找到的登录用户的信息。

我们试试看：

先登录，拿到 cookie：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2bae0bf498947d99eae592ab32497d6~tplv-k3u1fbpfcp-watermark.image?)

然后请求 /aaa 接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc3318344252469595fd4b23d5a26e11~tplv-k3u1fbpfcp-watermark.image?)

服务端打印了当前用户的权限信息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f88fc1ffeeb04ce583db10c34feabc50~tplv-k3u1fbpfcp-watermark.image?)

然后我们就根据当前 handler 需要的权限来判断是否返回 true 就可以了。

那怎么给当前 handler 标记需要什么权限呢？

很明显是通过 metadata。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a37d0fc82cc948bf800d7afd9a38fe0e~tplv-k3u1fbpfcp-watermark.image?)

给 /aaa 接口声明需要 query_aaa 的 permission。

然后在 PermissionGuard 里通过 reflector 取出来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c091aed2ebdc4cde9dbc3f31bef12dee~tplv-k3u1fbpfcp-watermark.image?)

取出 handler 声明的 metadata，如果用户权限里包含需要的权限，就返回 true，否则抛出没有权限的异常。

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Request } from 'express';
import { Observable } from 'rxjs';
import { UserService } from './user.service';

@Injectable()
export class PermissionGuard implements CanActivate {

  @Inject(UserService) 
  private userService: UserService;

  @Inject(Reflector)
  private reflector: Reflector;

  async canActivate(
    context: ExecutionContext,
  ): Promise<boolean> {
    const request: Request = context.switchToHttp().getRequest();

    const user = request.session.user;
    if(!user) {
      throw new UnauthorizedException('用户未登录');
    }

    const foundUser = await this.userService.findByUsername(user.username);

    const permission = this.reflector.get('permission', context.getHandler());

    if(foundUser.permissions.some(item => item.name === permission)) {
       return true;
    } else {
      throw new UnauthorizedException('没有权限访问该接口');
    }
  }
}
```

我们试一下：

这次用光光的账号登录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c43adc7704de405da2a4c88a53d3cce4~tplv-k3u1fbpfcp-watermark.image?)
访问 /aaa，会提示没有权限：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/574c1dfaa54c4ec985dd4c8b871f26ac~tplv-k3u1fbpfcp-watermark.image?)

然后登录东东的账号：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/508eb4822ade476e819407c554178e06~tplv-k3u1fbpfcp-watermark.image?)

然后访问 /aaa：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc68336205224687b806e3e1ffc64333~tplv-k3u1fbpfcp-watermark.image?)

东东是有 query_aaa 的权限的，就可以正常访问了。

这样我们就通过 ACL 的方式完成了接口权限的控制。

但是不知道同学们有没有发现一个问题：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57f610b77fd84ec7b35e0a3f66c2db46~tplv-k3u1fbpfcp-watermark.image?)

每次访问接口，都会触发这样 3 个表的关联查询。

效率太低了。

怎么优化一下呢？

有的同学说，登录的时候把权限也查出来放到 session 里不就行了么？

确实，可以在登录的时候做这件事情，把权限放到 session 里，之后就直接从 session 取就好了。

那还是延续现在的访问时查询权限的方案，怎么优化呢？

这时就需要 redis 了，redis 的缓存就是用来做这种优化的。

我们引入下 redis：

```
npm install redis 
```

然后新建一个模块来封装 redis 操作：
```
nest g module redis
```
![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727764f2b6ba4b91a4af6e9ef3793fe2~tplv-k3u1fbpfcp-watermark.image?)

然后新建一个 service：

```
nest g service redis --no-spec
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51ddb549dfdf4eeda08e540c9a9ce33a~tplv-k3u1fbpfcp-watermark.image?)

然后在 RedisModule 里添加 redis 的 provider：

```javascript
import { Global, Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [RedisService, 
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```

并使用 @Global 把这个模块声明为全局的。

这样，各个模块就都可以注入这个 RedisService 了。

然后在 RedisService 里添加一些 redis 操作方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType

    async listGet(key: string) {
        return await this.redisClient.lRange(key, 0, -1);
    }

    async listSet(key: string, list: Array<string>, ttl?: number) {
        for(let i = 0; i < list.length;i++) {
            await this.redisClient.lPush(key, list[i]);
        }
        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}

```
注入 redisClient，封装 listGet 和 listSet 方法，listSet 方法支持传入过期时间。

底层用的命令是 lrange 和 lpush、exprire。

然后在 PermissionGuard 里注入来用下：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06d2f828cda34659a5d9d94b5b0086aa~tplv-k3u1fbpfcp-watermark.image?)

先查询 redis、没有再查数据库并存到 redis，有的话就直接用 redis 的缓存结果。

key 为 user_${username}_permissions，这里的 username 是唯一的。

缓存过期时间为 30 分钟。

```javascript
import { RedisService } from './../redis/redis.service';
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Request } from 'express';
import { Observable } from 'rxjs';
import { UserService } from './user.service';

@Injectable()
export class PermissionGuard implements CanActivate {

  @Inject(UserService) 
  private userService: UserService;

  @Inject(Reflector)
  private reflector: Reflector;

  @Inject(RedisService)
  private redisService: RedisService;

  async canActivate(
    context: ExecutionContext,
  ): Promise<boolean> {
    const request: Request = context.switchToHttp().getRequest();

    const user = request.session.user;
    if(!user) {
      throw new UnauthorizedException('用户未登录');
    }

    let permissions = await this.redisService.listGet(`user_${user.username}_permissions`); 

    if(permissions.length === 0) {
      const foundUser = await this.userService.findByUsername(user.username);
      permissions = foundUser.permissions.map(item => item.name);

      this.redisService.listSet(`user_${user.username}_permissions`, permissions, 60 * 30)
    }

    const permission = this.reflector.get('permission', context.getHandler());

    if(permissions.some(item => item === permission)) {
      return true;
    } else {
      throw new UnauthorizedException('没有权限访问该接口');
    }
  }
}
```

我们试一下：

这里如果你没跑 redis server，需要先通过 docker 把它跑起来。具体怎么跑可以翻一下 redis 入门那节

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcb8305988cb4d02b9202d78b9e7fd8e~tplv-k3u1fbpfcp-watermark.image?)

然后先登录：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bccee4b04b640ddb585925193c971a1~tplv-k3u1fbpfcp-watermark.image?)

服务端打印了查询用户数据的 sql：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7407bb32b8cf48cca8db7fb66b3d08b7~tplv-k3u1fbpfcp-watermark.image?)

然后再访问 /aaa

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d83f0d5ad6a84fda9e7540aba30d8981~tplv-k3u1fbpfcp-watermark.image?)

又打印了 2 条关联查询的 sql：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b97963211994c5b93e02a4ab674b9cc~tplv-k3u1fbpfcp-watermark.image?)

我们去 RedisInsight 里看下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d34a91cc4d44cfc8600f787b01ad42a~tplv-k3u1fbpfcp-watermark.image?)

可以看到这条缓存。

这时候你刷新多少次，都不会再产生 sql 了：

![2023-06-22 17.16.43.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b13658f11cf5457a843a66e3bf5c7635~tplv-k3u1fbpfcp-watermark.image?)

这时候查的就是 redis 缓存。

redis 是基于内存的，访问速度会比 mysql 快很多。这就是为什么要用 redis。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/acl-test)。

## 总结

有的接口除了需要登录外，还需要权限。

只有登录用户有调用该接口的权限才能正常访问。

这节我们通过 ACL （Access Control List）的方式实现了权限控制，它的特点是用户直接和权限关联。

用户和权限是多对多关系，在数据库中会存在用户表、权限表、用户权限中间表。

登录的时候，把用户信息查出来，放到 session 或者 jwt 返回。

然后访问接口的时候，在 Guard 里判断是否登录，是否有权限，没有就返回 401，有的话才会继续处理请求。

我们采用的是访问接口的时候查询权限的方案，通过 handler 上用 SetMetadata 声明的所需权限的信息，和从数据库中查出来的当前用户的权限做对比，有相应权限才会放行。

但是这种方案查询数据库太频繁，需要用 redis 来做缓存。

当然，你选择登录的时候把权限一并查出来放到 session 或者 jwt 里也是可以的。

这就是通过 ACL 实现的权限控制。


## 6.如何调试 Nest 项目

不少同学都是用 console.log 调试的，哪怕工作很多年依然是这样，这样有个致命的缺点：

你只能看到某个点的变量值，而看不到代码的整个执行路线。

对于复杂的项目来说，会用断点调试是必须的，因为这样可以看到作用域、调用栈，也就是代码的执行路线，然后单步运行来看变量的变化。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e376b1cd01d4a43b34c05c177952903~tplv-k3u1fbpfcp-watermark.image?)

所以这一节我们来学下如何调试 nest 项目。

首先，先看下 node 调试：

创建个项目：

```
mkdir debug-test
cd debug-test
npm init -y
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8555770f2fa74c529023f4920b43a04f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=892&h=672&s=124406&e=png&b=000000)

添加 index.js

```javascript
const os = require('os');

const homedir = os.homedir();

console.log(homedir);
```

通过 os 模块拿到了 home 目录的路径。

直接 node 执行会输出结果：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2e2faa32e1f46489ccfe6ee6d5db6d3~tplv-k3u1fbpfcp-watermark.image?)

我们以调试模式跑起来：
```
node --inspect-brk index.js
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef8dd30711ae45719f3d46cfefa4b3c3~tplv-k3u1fbpfcp-watermark.image?)

\--inspect 是调试模式运行，而 --inspect-brk 还会在首行断住。

可以看到，它起了一个 ws 服务。

然后我们用调试客户端连上它，比如用 Chrome DevTools。

打开 <chrome://inspect/>，可以看到可以调试的目标：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a0ff69dc97e47ef9d6eccd1ae9d8501~tplv-k3u1fbpfcp-watermark.image?)

如果没有，就配置下 network target，加上 localhost:9229

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9ae4e138a374a62b5dd67b4e7592210~tplv-k3u1fbpfcp-watermark.image?)

点击 inspect 就可以看到调试界面了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5e10075d4804aa4bf7cab08f4bf22cc~tplv-k3u1fbpfcp-watermark.image?)

代码在首行断住了，右侧也可以看到作用域和调用栈。

可以单步调试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da8603e1e18e43f988bba07e93cd7aee~tplv-k3u1fbpfcp-watermark.image?)

nest 也是 node 项目，自然也是这样来调试的。

nest start 有个 --debug 的选项，

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe1572f2de6423abb4a27e77043b45c~tplv-k3u1fbpfcp-watermark.image?)

原理就是 node --inspect。

这时候 inspect 发现啥也没：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/814e6b094e654fa8aed52cac73fb9d31~tplv-k3u1fbpfcp-watermark.image?)

因为 --inspect 并不会和 --inspect-brk 一样在首行断住。

我们在 controller 里加个 debugger：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d7bc6bb0ccc4e379d93da1a21567742~tplv-k3u1fbpfcp-watermark.image?)

然后访问下 <http://localhost:3000>

这时候你会发现代码在断点处断住了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e245746530145f298811a224c59756c~tplv-k3u1fbpfcp-watermark.image?)

可以看到代码的整个执行路线：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b498721bcd354d258c08135f1022aea6~tplv-k3u1fbpfcp-watermark.image?)

这样，就可以调试 nest 项目了。

但是这样调试还是太麻烦，我们一般在 VSCode 里写代码，能不能直接在 VSCode 里边写代码边调试呢？

当然是可以的。

VSCode 也实现了 Debugger 的客户端。

点击调试面板的 create launch.json file，它会创建 .vscode/launch.json 的调试配置文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/541ac1195d0643789f05b1751ad27d71~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78bc8144014b43a2a048f12e27b4e8d4~tplv-k3u1fbpfcp-watermark.image?)

然后输入 node，快速创建一个 node 调试配置：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da1e7bb4b6424696befb7383ff9ae035~tplv-k3u1fbpfcp-watermark.image?)

我们先调试下前面那个 index.js 文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0700c7834864508b37671f89b352ddb~tplv-k3u1fbpfcp-watermark.image?)

stopOnEntry 是在首行断住，和 --inspect-brk 一样的效果。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/022601d2f94b4bb6a971ad223a76dd16~tplv-k3u1fbpfcp-watermark.image?)

这样，就可以在 vscode 里调试 node 代码了。

在 vscode 里调试代码，最爽的是可以边改代码边调试。

比如你调试的过程中修改了代码，然后点击重新调试，就可以马上看到改动之后的效果：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be09f4fc43d34bc495017b1772f754fb~tplv-k3u1fbpfcp-watermark.image?)

调试体验就很棒！

nest 自然也可以这样调试：

还是 nest start --debug 来启动 nest 服务：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e42a6dcf256d4afdbab003c0cdf36533~tplv-k3u1fbpfcp-watermark.image?)

添加一个 attach 类型的调试配置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ac920d5e2b404f9c208515bc754952~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/276a82c43f8749d587d12df02c9281c1~tplv-k3u1fbpfcp-watermark.image?)

然后在 controller 里打个断点，访问 <http://localhost:3000>

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7ddd8570424d9595bced0c9de12124~tplv-k3u1fbpfcp-watermark.image?)

代码同样会在断点处断住。

这样就可以直接在 vscode 里打断点了。

不过如果是用 VSCode 调试，可以不用 nest start --debug，有更简便的方式：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/665a71a9a9c34dfa94a01a750c614152~tplv-k3u1fbpfcp-watermark.image?)

创建 npm scripts 的调试配置：

（如果创建出的调试配置 type 是 pwa-node 也可以，和 node 类型差不多，据说 pwa-node 功能多一点）

```json
{
    "type": "node",
    "request": "launch",
    "name": "debug nest",
    "runtimeExecutable": "npm",
    "args": [
        "run",
        "start:dev",
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "console": "integratedTerminal",
}
```

和我们命令行执行 npm run start:dev 一样。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7deaeb270bd4b86b91d4678079dbfba~tplv-k3u1fbpfcp-watermark.image?)

这里的 runtimeExecutable 代表执行什么命令，args 传参数。

要指定 console 为 integratedTerminal，也就是用 vscode 的内置终端来打印日志，不然默认会用 debug console 跑，那个没有颜色：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/472522d9bd1c4ca1b29aaa37653fff5c~tplv-k3u1fbpfcp-watermark.image?)

点击调试模式启动：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a5fab63d75b4cf6beafeddaf7afc597~tplv-k3u1fbpfcp-watermark.image?)

然后浏览器访问 <http://localhost:3000>

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b152079795134165bd9c0acc235eb38f~tplv-k3u1fbpfcp-watermark.image?)

代码同样会在断点处断住。

这是最方便的调试 nest 项目的方式。

最后，介绍几种断点的类型，也是挺常用的：

有的时候只想打印日志，不想断住，又不想加 console.log 污染代码，这时候可以用 logpoint：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/344268ffabc14dd49d3c7aa0c2cc1fce~tplv-k3u1fbpfcp-watermark.image?)

右键选择 logpoint：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f583cc4130264d31a6712b2c1e04106d~tplv-k3u1fbpfcp-watermark.image?)

输入打印的信息，变量用 {} 包裹。

代码执行到这里就会打印：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4aea40c7ad2944fea65bc19c6470d1da~tplv-k3u1fbpfcp-watermark.image?)

这样适合不需要断住，但想打印日志的情况。不用在代码里加 console.log。

再就是条件断点：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae6ba8c9fefa4224a0885080fb8e67b7~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26d3656eae6843968d9b92e174f77467~tplv-k3u1fbpfcp-watermark.image?)

表达式成立才会断住。

再就是异常断点，可以在没有处理的异常处自动断住：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dca459750454907969d3c9ec2343b07~tplv-k3u1fbpfcp-watermark.image?)

这些断点类型只要有个印象，用到的时候能想起来就行。

## 总结

复杂的代码需要用断点调试查看调用栈和作用域，也就是代码的执行路线，然后单步执行。

node 代码可以加上 --inspect 或者 --inspect-brk 启动调试 ws 服务，然后用 Chrome DevTools 或者 vscode debugger 连上来调试。

nest 项目的调试也是 node 调试，可以使用 nest start --debug 启动 ws 服务，然后在 vscode 里 attach 上来调试，也可以添加个调试配置来运行 npm run start:dev。

nest 项目最方便的调试方式还是在 VSCode 里添加 npm run start:dev 的调试配置。

此外，我们还理解了 logpoint、条件断点、异常断点等断点类型。

学会了 nest 项目的调试，就可以直接在代码里打断点了。


## 60.基于 RBAC 实现权限控制

上节实现了基于 ACL 的权限控制，这节来实现 RBAC 权限控制。

RBAC 是 Role Based Access Control，基于角色的权限控制。

上节我们学的 ACL 是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/782aa95188114311bf09706428c92270~tplv-k3u1fbpfcp-watermark.image?)

直接给用户分配权限。

而 RBAC 是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6df45dc5d1ef4ba881a9974bf635f828~tplv-k3u1fbpfcp-watermark.image?)

给角色分配权限，然后给用户分配角色。

这样有什么好处呢？

比如说管理员有 aaa、bbb、ccc 3 个权限，而张三、李四、王五都是管理员。

有一天想给管理员添加一个 ddd 的权限。

如果给是 ACL 的权限控制，需要给张三、李四、王五分别分配这个权限。

而 RBAC 呢？

只需要给张三、李四、王五分配管理员的角色，然后只更改管理员角色对应的权限就好了。

所以说，当用户很多的时候，给不同的用户分配不同的权限会很麻烦，这时候我们一般会先把不同的权限封装到角色里，再把角色授予用户。

下面我们就用 Nest 实现一下 RBAC 权限控制吧。

创建 rbac_test 的 database：

```sql
CREATE DATABASE rbac_test DEFAULT CHARACTER SET utf8mb4;
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8b509f1367145c791e9a285824c7268~tplv-k3u1fbpfcp-watermark.image?)

可以看到创建出的 database：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d7793d4faf849129943e2d0138fe6e9~tplv-k3u1fbpfcp-watermark.image?)

然后创建 nest 项目：

```
nest new rbac-test -p npm
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35066d285daa4fd18ee672d6636db0ce~tplv-k3u1fbpfcp-watermark.image?)

安装 typeorm 的依赖：

```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [ 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "rbac_test",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后添加创建 user 模块：

```
nest g resource user
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d6d66d7feca42a79ff2eabe6fa08e83~tplv-k3u1fbpfcp-watermark.image?)

添加 User、Role、Permission 的 Entity：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bbade0f25c94049b3a5ff0362ecaa82~tplv-k3u1fbpfcp-watermark.image?)

用户、角色、权限都是多对多的关系。

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    username: string;

    @Column({
        length: 50
    })
    password: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
    
    @ManyToMany(() => Role)
    @JoinTable({
        name: 'user_role_relation'
    })
    roles: Role[] 
}
```
User 有 id、username、password、createTime、updateTime 5 个字段。

通过 @ManyToMany 映射和 Role 的多对多关系，并指定中间表的名字。

然后创建 Role 的 entity：

```javascript
import { Column, CreateDateColumn, Entity,PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class Role {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 20
    })
    name: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
    
    @ManyToMany(() => Permission)
    @JoinTable({
        name: 'role_permission_relation'
    })
    permissions: Permission[] 
}

```
Role 有 id、name、createTime、updateTime 4 个字段。

通过 @ManyToMany 映射和 Permission 的多对多关系，并指定中间表的名字。

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

@Entity()
export class Permission {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    name: string;
    
    @Column({
        length: 100,
        nullable: true
    })
    desc: string;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
}
```
Permission 有 id、name、createTime、updateTime 4 个字段。

然后在 TypeOrm.forRoot 的 entities 数组加入这三个 entity：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/473156a1bb154c9ebb5a6aab0dbd9d38~tplv-k3u1fbpfcp-watermark.image?)

把 Nest 服务跑起来试试：

```
npm run start:dev
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f73b90864b9546c596120da55e82e40d~tplv-k3u1fbpfcp-watermark.image?)

可以看到生成了 user、role、permission 这 3 个表，还有 user_roole_relation、role_permission_relation 这 2 个中间表。

两个中间表的外键约束也是对的。

在 mysql workbench 里看下这 5 个表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c16f960e04b444b85fd116c88b0c0c2~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2067c6648d65480dbd14684e93440b2e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58c805339829499a916c265b5e5fc0c4~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd68bf843a1b408a93668bde85387f35~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2cf2c5285154c6d8885584463c86a47~tplv-k3u1fbpfcp-watermark.image?)

还有外键：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40146db63eb54a5c8a5ede096243218e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a85552c665548678304f8fb2cdc2845~tplv-k3u1fbpfcp-watermark.image?)

都没啥问题。

然后我们来添加一些数据，同样是用代码的方式。

修改下 UserService，添加这部分代码：


```javascript
@InjectEntityManager()
entityManager: EntityManager;

async initData() {
    const user1 = new User();
    user1.username = '张三';
    user1.password = '111111';

    const user2 = new User();
    user2.username = '李四';
    user2.password = '222222';

    const user3 = new User();
    user3.username = '王五';
    user3.password = '333333';

    const role1 = new Role();
    role1.name = '管理员';

    const role2 = new Role();
    role2.name = '普通用户';

    const permission1 = new Permission();
    permission1.name = '新增 aaa';

    const permission2 = new Permission();
    permission2.name = '修改 aaa';

    const permission3 = new Permission();
    permission3.name = '删除 aaa';

    const permission4 = new Permission();
    permission4.name = '查询 aaa';

    const permission5 = new Permission();
    permission5.name = '新增 bbb';

    const permission6 = new Permission();
    permission6.name = '修改 bbb';

    const permission7 = new Permission();
    permission7.name = '删除 bbb';

    const permission8 = new Permission();
    permission8.name = '查询 bbb';


    role1.permissions = [
      permission1,
      permission2,
      permission3,
      permission4,
      permission5,
      permission6,
      permission7,
      permission8
    ]

    role2.permissions = [
      permission1,
      permission2,
      permission3,
      permission4
    ]

    user1.roles = [role1];

    user2.roles = [role2];

    await this.entityManager.save(Permission, [
      permission1, 
      permission2,
      permission3,
      permission4,
      permission5,
      permission6,
      permission7,
      permission8
    ])

    await this.entityManager.save(Role, [
      role1,
      role2
    ])

    await this.entityManager.save(User, [
      user1,
      user2
    ])  
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca846a099f4243b2a44faff1632ff576~tplv-k3u1fbpfcp-watermark.image?)

然后在 UserController 里添加一个 handler：

```javascript
@Get('init')
async initData() {
    await this.userService.initData();
    return 'done';
}
```
然后把 nest 服务跑起来：

```
npm run start:dev
```
浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/644029ffacfc4de3acf170d6df5e53df~tplv-k3u1fbpfcp-watermark.image?)

服务端控制台打印了一堆 sql：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/356705c44c78489388ad6d3cfb2eab03~tplv-k3u1fbpfcp-watermark.image?)

可以看到分别插入了 user、role、permission 还有 2 个中间表的数据。

在 mysql workbench 里看下：

permission 表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/841bdfcd3c914d54850d4dd9c1efd66e~tplv-k3u1fbpfcp-watermark.image?)

role 表：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af139f124d742929ea14c06de7eb797~tplv-k3u1fbpfcp-watermark.image?)

user 表：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1745c9474b4a43f2ad05da7461ddb929~tplv-k3u1fbpfcp-watermark.image?)

role_permission_relation 中间表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc600565951247988191a9ae64b82bbb~tplv-k3u1fbpfcp-watermark.image?)

user_role_relation 中间表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8beb4f2e5ea74ee6a4dec47da5502446~tplv-k3u1fbpfcp-watermark.image?)

都没啥问题。

然后我们实现下登录，通过 jwt 的方式。

在 UserController 里增加一个 login 的 handler：

```javascript
@Post('login')
login(@Body() loginUser: UserLoginDto){
    console.log(loginUser)
    return 'success'
}
```
添加 user/dto/user-login.dto.ts：

```javascript
export class UserLoginDto {
    username: string;

    password: string;
}
```
安装 ValidationPipe 用到的包：

```
npm install --save class-validator class-transformer
```

然后给 dto 对象添加 class-validator 的装饰器：

```javascript
import { IsNotEmpty, Length } from "class-validator";

export class UserLoginDto {
    @IsNotEmpty()
    @Length(1, 50)
    username: string;

    @IsNotEmpty()
    @Length(1, 50)
    password: string;
}
```

全局启用 ValidationPipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed775c910a84e5294fc51d393965998~tplv-k3u1fbpfcp-watermark.image?)

然后在 postman 里测试下：

ValidationPipe 不通过的时候，会返回错误信息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df202c93f6d643f9a1a009d38b6de2a7~tplv-k3u1fbpfcp-watermark.image?)

ValidationPipe 通过之后，就会执行 handler 里的方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c823ec87861a4eeea897f66dbe2e3f74~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ceff4fea046e4a66b5942589293d836b~tplv-k3u1fbpfcp-watermark.image?)

接下来实现查询数据库的逻辑，在 UserService 添加 login 方法：

```javascript
async login(loginUserDto: UserLoginDto) {
    const user = await this.entityManager.findOne(User, {
      where: {
        username: loginUserDto.username
      },
      relations: {
        roles: true
      }
    });

    if(!user) {
      throw new HttpException('用户不存在', HttpStatus.ACCEPTED);
    }

    if(user.password !== loginUserDto.password) {
      throw new HttpException('密码错误', HttpStatus.ACCEPTED);
    }

    return user;
}
```

这里把 user 的 roles 也关联查询出来。

我们在 UserController 的 login 方法里调用下试试：

```javascript
@Post('login')
async login(@Body() loginUser: UserLoginDto){
    const user = await this.userService.login(loginUser);

    console.log(user);

    return 'success'
}
```

可以看到，user 信息和 roles 信息都查询出来了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b917fdfd1f2a4c32bffb984bbb52916a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef10e46be0ef472eb23b290a0d840662~tplv-k3u1fbpfcp-watermark.image?)

我们要把 user 信息放到 jwt 里，所以安装下相关的包：

    npm install --save @nestjs/jwt
 
然后在 AppModule 里引入 JwtModule：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d468382f52544f44bfebcfddcc713783~tplv-k3u1fbpfcp-watermark.image?)

设置为全局模块，这样不用每个模块都引入。

然后在 UserController 里注入 JwtModule 里的 JwtService：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c432c2bec944ae5996e74f5f903daa6~tplv-k3u1fbpfcp-watermark.image?)

把 user 信息放到 jwt 里，然后返回：

```javascript
@Post('login')
async login(@Body() loginUser: UserLoginDto){
  const user = await this.userService.login(loginUser);

  const token = this.jwtService.sign({
    user: {
      username: user.username,
      roles: user.roles
    }
  });

  return {
      token
  }
}
```

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba388f4965e6436497bff42234713aad~tplv-k3u1fbpfcp-watermark.image?)

服务端在登录后返回了 jwt 的 token。

然后在请求带上这个 token 才能访问一些资源。

我们添加 aaa、bbb 两个模块，分别生成 CRUD 方法：
```
nest g resource aaa 
nest g resource bbb 
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a06b3ef207e4eb3b91ac07ad48b9819~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c91016bc4be4ee0b6a4445d0d357ab5~tplv-k3u1fbpfcp-watermark.image?)

现在这些接口可以直接访问：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a9724b76fae4a16965bf58f27295d38~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e96a5281a094eeeaaba535bc2ead0cc~tplv-k3u1fbpfcp-watermark.image?)

而实际上这些接口是要控制权限的。

管理员的角色有 aaa、bbb 的增删改查权限，而普通用户只有 bbb 的增删改查权限。

所以要对接口的调用做限制。

先添加一个 LoginGuard，限制只有登录状态才可以访问这些接口： 

```
nest g guard login --no-spec --flat
```

然后增加登录状态的检查：

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';
import { Observable } from 'rxjs';

@Injectable()
export class LoginGuard implements CanActivate {
  
  @Inject(JwtService)
  private jwtService: JwtService;
  
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    const request: Request = context.switchToHttp().getRequest();
    
    const authorization = request.headers.authorization;

    if(!authorization) {
      throw new UnauthorizedException('用户未登录');
    }

    try{
      const token = authorization.split(' ')[1];
      const data = this.jwtService.verify(token);

      return true;
    } catch(e) {
      throw new UnauthorizedException('token 失效，请重新登录');
    }
  }
}
```
这里不用查数据库了，因为 jwt 是用密钥加密的，只要 jwt 能 verify 通过就行了。

然后把它放到 request 上：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dd353f6eaf14ff795d2312f900b593b~tplv-k3u1fbpfcp-watermark.image?)

但这时候会报错 user 不在 Request 的类型上。

扩展下就好了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04b5bf978da74390983d44189cf01ed7~tplv-k3u1fbpfcp-watermark.image?)

```typescript
declare module 'express' {
  interface Request {
    user: {
      username: string;
      roles: Role[]
    }
  }
}
```
因为 typescript 里同名 module 和 interface 会自动合并，可以这样扩展类型。

上节我们是一个个加的 Guard：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/486fb3ea083b440dbbfa5985389787c1~tplv-k3u1fbpfcp-watermark.image?)

这样太麻烦了，这次我们全局加：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8281ab12a654bd9ae05d1f86020a824~tplv-k3u1fbpfcp-watermark.image?)

前面讲过，通过 app.userGlobalXxx 的方式不能注入 provider，可以通过在 AppModule 添加 token 为 APP_XXX 的 provider 的方式来声明全局 Guard、Pipe、Intercepter 等：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efd69b23eecf4b1f96f009795b6d9117~tplv-k3u1fbpfcp-watermark.image?)

再访问下 aaa、bbb 接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb743fcf74184c539050f24133f1d261~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/965d59386b1a477782cfc731b5d21aa2~tplv-k3u1fbpfcp-watermark.image?)

但这时候你访问 /user/login 接口也被拦截了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efc12f8ee98542249fe52c3272714c4b~tplv-k3u1fbpfcp-watermark.image?)

我们需要区分哪些接口需要登录，哪些接口不需要。

这时候就可以用 SetMetadata 了。

我们添加一个 custom-decorator.ts 来放自定义的装饰器：

```typescript
import { SetMetadata } from "@nestjs/common";

export const  RequireLogin = () => SetMetadata('require-login', true);
```
声明一个 RequireLogin 的装饰器。

在 aaa、bbb 的 controller 上用一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a5656697a5e499f8648e3bfb0225a31~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91023de50de42a288b8adaa3bd86a2c~tplv-k3u1fbpfcp-watermark.image?)

我们支持在 controller 上添加声明，不需要每个 handler 都添加，这样方便很多。

然后需要改造下 LoginGuard，取出目标 handler 的 metadata 来判断是否需要登录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ebc51e075c14e7d973bafc39c5abb42~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const requireLogin = this.reflector.getAllAndOverride('require-login', [
  context.getClass(),
  context.getHandler()
]);

console.log(requireLogin)

if(!requireLogin) {
  return true;
}
```

如果目标 handler 或者 controller 不包含 require-login 的 metadata，那就放行，否则才检查 jwt。

我们再试下：

现在登录接口能正常访问了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a38a45faddf454f926c337f9fd9e127~tplv-k3u1fbpfcp-watermark.image?)

因为没有 require-login 的 metadata：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8df2766d29984b4b941ef887ca84bc95~tplv-k3u1fbpfcp-watermark.image?)

而 aaa、bbb 是需要登录的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42222c343ce144b2a9e2681a049c1398~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5228c44bafd4764a93e771bb3a7894c~tplv-k3u1fbpfcp-watermark.image?)

因为它们包含 require-login 的metadata：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6c35ef9d5184fab91a98c00774ea4c5~tplv-k3u1fbpfcp-watermark.image?)

然后我们登录下，带上 token 访问试试：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5330bbbfce0f4874aa8cd99faca56148~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9d4581b5824437aac91a32f3e929fc6~tplv-k3u1fbpfcp-watermark.image?)

带上 token 就能正常访问了。

然后我们再进一步控制权限。

但是这样还不够，我们还需要再做登录用户的权限控制，所以再写个 PermissionGuard:

```
nest g guard permission --no-spec --flat
```
同样声明成全局 Guard：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab462c4d0b644b7bbce3832b7a30808c~tplv-k3u1fbpfcp-watermark.image?)

PermissionGuard 里需要用到 UserService，所以在 UserModule 里导出下 UserService：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c8158f0210946bebe6a12f2e289f121~tplv-k3u1fbpfcp-watermark.image?)

注入 UserService：

```javascript
import { CanActivate, ExecutionContext, Inject, Injectable } from '@nestjs/common';
import { Request } from 'express';
import { Observable } from 'rxjs';
import { UserService } from './user.service';

@Injectable()
export class PermissionGuard implements CanActivate {

  @Inject(UserService) 
  private userService: UserService;

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {

    console.log(this.userService);

    return true;
  }
}
```

然后在 userService 里实现查询 role 的信息的 service：

```typescript
async findRolesByIds(roleIds: number[]) {
    return this.entityManager.find(Role, {
      where: {
        id: In(roleIds)
      },
      relations: {
        permissions: true
      }
    });
}
```

关联查询出 permissions。

然后在 PermissionGuard 里调用下：

```typescript
import { CanActivate, ExecutionContext, Inject, Injectable } from '@nestjs/common';
import { Request } from 'express';
import { UserService } from './user/user.service';

@Injectable()
export class PermissionGuard implements CanActivate {

  @Inject(UserService) 
  private userService: UserService;

  async canActivate(
    context: ExecutionContext,
  ): Promise<boolean> {
    const request: Request = context.switchToHttp().getRequest();

    if(!request.user) {
      return true;
    }

    const roles = await this.userService.findRolesByIds(request.user.roles.map(item => item.id))

    const permissions: Permission[]  = roles.reduce((total, current) => {
      total.push(...current.permissions);
      return total;
    }, []);

    console.log(permissions);

    return true;
  }
}
```
因为这个 PermissionGuard 在 LoginGuard 之后调用（在 AppModule 里声明在 LoginGuard 之后），所以走到这里 request 里就有 user 对象了。

但也不一定，因为 LoginGuard 没有登录也可能放行，所以要判断下 request.user 如果没有，这里也放行。

然后取出 user 的 roles 的 id，查出 roles 的 permission 信息，然后合并到一个数组里。

我们试试看：

带上 token 访问：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edce48228f664ebc866b1a5ab8f9d017~tplv-k3u1fbpfcp-watermark.image?)

可以看到打印了这个用户拥有的角色的所有 permission 信息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e72abec4874844e2a21e47552adaaaa9~tplv-k3u1fbpfcp-watermark.image?)

再增加个自定义 decorator：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3202ef8fd95f40208dcf173ffea6b1fc~tplv-k3u1fbpfcp-watermark.image?)

```typescript
export const  RequirePermission = (...permissions: string[]) => SetMetadata('require-permission', permissions);
```

然后我们在 BbbController 上声明需要的权限。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53bbafe2e8044568afe0ca91c958f251~tplv-k3u1fbpfcp-watermark.image?)

在 PermissionGuard 里取出来判断：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c2fe257fec34293881f66744a458814~tplv-k3u1fbpfcp-watermark.image?)


```javascript
const requiredPermissions = this.reflector.getAllAndOverride<string[]>('require-permission', [
  context.getClass(),
  context.getHandler()
])

console.log(requiredPermissions);
```
先打印下试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8fb77e7e1b44a9391eccf4a77c303fc~tplv-k3u1fbpfcp-watermark.image?)

带上 token 访问：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a162f4f285464092bbcdcdf425445b0a~tplv-k3u1fbpfcp-watermark.image?)

可以看到打印了用户有的 permission 还有这个接口需要的 permission。

那这两个一对比，不就知道有没有权限访问这个接口了么？

添加这样的对比逻辑：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/399a549210db4c95bf785bda6b443115~tplv-k3u1fbpfcp-watermark.image?)

```javascript
for(let i = 0; i < requiredPermissions.length; i++) {
  const curPermission = requiredPermissions[i];
  const found = permissions.find(item => item.name === curPermission);
  if(!found) {
    throw new UnauthorizedException('您没有访问该接口的权限');
  }
}
```

测试下：

当前用户是李四，是没有访问 bbb 的权限的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57ed01373705498fb6e8d951997dc6f3~tplv-k3u1fbpfcp-watermark.image?)

我们再登录下张三账号：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3408c41c38d4dd4bfb30b1bf46b973f~tplv-k3u1fbpfcp-watermark.image?)

用这个 token 去访问下 bbb 接口，就能正常访问了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf67dc7a42b4e6fab09fb1018226aaf~tplv-k3u1fbpfcp-watermark.image?)

他是有这个权限的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f08e5980ebe74e95a27e19094c682b4d~tplv-k3u1fbpfcp-watermark.image?)

这样，我们就实现了基于 RBAC 的权限控制。

有的同学说，这和 ACL 的差别也不大呀？

检查权限的部分确实差别不大，都是通过声明的需要的权限和用户有的权限作对比。

但是分配权限的时候，是以角色为单位的，这样如果这个角色的权限变了，那分配这个角色的用户权限也就变了。

这就是 RBAC 相比 ACL 更方便的地方。

此外，这里查询角色需要的权限没必要每次都查数据库，可以通过 redis 来加一层缓存，减少数据库访问，提高性能。（具体写法参考上节）

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/rbac-test)。

## 总结

这节我们学了 RBAC（role based access control） 权限控制，它相比于 ACL （access control list）的方式，多了一层角色，给用户分配角色而不是直接分配权限。

当然，检查权限的时候还是要把角色的权限合并之后再检查是否有需要的权限的。

我们通过 jwt 实现了登录，把用户和角色信息放到 token 里返回。

添加了 LoginGuard 来做登录状态的检查。

然后添加了 PermissionGuard 来做权限的检查。

LoginGuard 里从 jwt 取出 user 信息放入 request，PermissionGuard 从数据库取出角色对应的权限，检查目标 handler 和 controller 上声明的所需权限是否满足。

LoginGuard 和 PermissionGuard 需要注入一些 provider，所以通过在 AppModule 里声明 APP_GUARD 为 token 的 provider 来注册的全局 Gard。

然后在 controller 和 handler 上添加 metadata 来声明是否需要登录，需要什么权限，之后在 Guard 里取出来做检查。

这种方案查询数据库也比较频繁，也应该加一层 redis 来做缓存。

这就是基于 RBAC 的权限控制，是用的最多的一种权限控制方案。

当然，这是 RBAC0 的方案，更复杂一点的权限模型，可能会用 RBAC1、RBAC2 等，那个就是多角色继承、用户组、角色之间互斥之类的概念，会了 RBAC0，那些也就是做一些变形的事情。

绝大多数系统，用 RBAC0 就足够了。





## 61.基于 access_token 和 refresh_token 实现无感刷新登录状态

前面我们实现了基于 JWT 的登录，流程是这样的：

登录认证通过之后，把用户信息放到 jwt 里返回：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43cb79b2d63046e6856417489832c81f~tplv-k3u1fbpfcp-watermark.image?)

访问接口的时候带上 jwt，在 Guard 里取出来判断是否有效，有效的话才能继续访问：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b4ef812d409492d90ab8c9ac72ccefd~tplv-k3u1fbpfcp-watermark.image?)

但是这样有个问题：

jwt 是有有效期的，我们设置的是 7 天，实际上为了安全考虑会设置的很短，比如 30 分钟。

这时候用户可能还在访问系统的某个页面，结果访问某个接口返回 token 失效了，让重新登录。

体验是不是就很差？

为了解决这个问题，服务端一般会返回两个 token：access_token 和 refresh_token

access_token 就是用来认证用户身份的，之前我们返回的就是这个 token。

而 refresh_token 是用来刷新 token 的，服务端会返回新的 access_token 和 refresh_token

也就是这样的流程：

登录成功之后，返回两个 token：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f3b502a99545b7ac05e74ea2283089~tplv-k3u1fbpfcp-watermark.image?)

access_token 用来做登录鉴权：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae93c8a46d04169bc1c85fd387cd550~tplv-k3u1fbpfcp-watermark.image?)

而 refresh_token 用来刷新，拿到新 token：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de50c9a6f381499182f4ffb49a0cad0c~tplv-k3u1fbpfcp-watermark.image?)

access_token 设置 30 分钟过期，而 refresh_token 设置 7 天过期。

这样 7 天内，如果 access_token 过期了，那就可以用 refresh_token 刷新下，拿到新 token。、

只要不超过 7 天未访问系统，就可以一直是登录状态，可以无限续签，不需要登录。

如果超过 7 天未访问系统，那 refresh_token 也就过期了，这时候就需要重新登录了。

想想你常用的 app，登录过几次？

是不是常用的 app 基本不用重新登录？

如果你超过一段时间没使用这个 app，是不是又会让你重新登录了？

一般 app 里用的就是这种双 token 来做登录鉴权。

下面我们也来实现下这种机制。

创建个 nest 项目：

```
nest new access_token_and_refresh_token -p npm
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/657be2eda39b4a429165c5fac2db2d9e~tplv-k3u1fbpfcp-watermark.image?)

添加 user 模块：

```
nest g resource user --no-spec
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7db563e3020443e8c779e181d0b8ada~tplv-k3u1fbpfcp-watermark.image?)

安装 typeorm 的依赖：

```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [ 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "refresh_token_test",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
在 mysql workbench 里创建用到的 database：

```sql
CREATE DATABASE refresh_token_test DEFAULT CHARACTER SET utf8mb4;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5755fb1c9a4fa3b5750ad63784aa13~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a6e7ff89f304ed9a0264359167d19f1~tplv-k3u1fbpfcp-watermark.image?)

然后新建 User 的 entity：

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    username: string;

    @Column({
        length: 50
    })
    password: string;
}
```
在 entities 里添加 User：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c56b1e4736f6423f9c589d18e6ea2446~tplv-k3u1fbpfcp-watermark.image?)

然后把服务跑起来：

```
npm run start:dev
```
会生成建表 sql：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02a37f11e95242ac8619cf213f923ca3~tplv-k3u1fbpfcp-watermark.image?)

在 mysql workbench 里可以看到 user 表：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bd36dfe0fef4e11b860a5c972bc0aa5~tplv-k3u1fbpfcp-watermark.image?)

然后在 UserController 添加 login 的 post 接口：

```javascript
@Post('login')
login(@Body() loginUser: LoginUserDto) {
    console.log(loginUser);
    return 'success';
}
```
创建 src/user/dto/login-user.dto.ts

```javascript
export class LoginUserDto {
    username: string;
    password: string;
}
```
测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b29e977b52641b5883c945deb124cfb~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0afdbe417fba42efa44f66b9239d845c~tplv-k3u1fbpfcp-watermark.image?)

然后实现下登录逻辑。

在 UserService 里添加 login 方法：

```javascript
import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { EntityManager } from 'typeorm';
import { LoginUserDto } from './dto/login-user.dto';
import { User } from './entity/user.entity';

@Injectable()
export class UserService {

    @InjectEntityManager()
    private entityManager: EntityManager;

    async login(loginUserDto: LoginUserDto) {
        const user = await this.entityManager.findOne(User, {
            where: {
                username: loginUserDto.username
            }
        });

        if(!user) {
            throw new HttpException('用户不存在', HttpStatus.OK);
        }

        if(user.password !== loginUserDto.password) {
            throw new HttpException('密码错误', HttpStatus.OK);
        }

        return user;
    }
}
```
然后登录成功之后要返回两个 token

我们引入下 jwt 的包：

```
npm install --save @nestjs/jwt
```
在 AppModule 引入 JwtModule，设置为全局模块，指定默认过期时间和密钥：

```javascript
JwtModule.register({
  global: true,
  signOptions: {
    expiresIn: '30m'
  },
  secret: 'guang'
})
```

然后在 UserController 生成两个 token 返回：

```javascript
@Inject(JwtService)
private jwtService: JwtService;

@Post('login')
async login(@Body() loginUser: LoginUserDto) {
    const user = await this.userService.login(loginUser);

    const access_token = this.jwtService.sign({
      userId: user.id,
      username: user.username,
    }, {
      expiresIn: '30m'
    });

    const refresh_token = this.jwtService.sign({
      userId: user.id
    }, {
      expiresIn: '7d'
    });

    return {
      access_token,
      refresh_token
    }
}
```

access_token 里存放 userId、username，refresh_token 里只存放 userId 就好了。

过期时间一个 30 分钟，一个 7 天。

访问下试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af1f0c032086496796c03726f6269583~tplv-k3u1fbpfcp-watermark.image?)

接下来再实现 LoginGuard 来做登录鉴权：

```
nest g guard login --flat --no-spec
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc482472355e463aa009336770218333~tplv-k3u1fbpfcp-watermark.image?)

登录鉴权逻辑和之前一样：

```javascript
import { JwtService } from '@nestjs/jwt';
import { CanActivate, ExecutionContext, Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { Request } from 'express';
import { Observable } from 'rxjs';

@Injectable()
export class LoginGuard implements CanActivate {

  @Inject(JwtService)
  private jwtService: JwtService;

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {

    const request: Request = context.switchToHttp().getRequest();

    const authorization = request.headers.authorization;

    if(!authorization) {
      throw new UnauthorizedException('用户未登录');
    }

    try{
      const token = authorization.split(' ')[1];
      const data = this.jwtService.verify(token);

      return true;
    } catch(e) {
      throw new UnauthorizedException('token 失效，请重新登录');
    }
  }
}
```

取出 authorization header 中的 jwt token，这个就是 access_token，对它做校验。

jwt 有效就可以继续访问，否则返回 token 失效，请重新登录。

然后在 AppController 添加个接口加上登录鉴权：

```javascript
@Get('aaa')
aaa() {
    return 'aaa';
}

@Get('bbb')
@UseGuards(LoginGuard)
bbb() {
    return 'bbb';
}
```

aaa 接口可以直接访问，bbb 接口需要登录后才能访问。

在 user 表添加条记录：

```sql
INSERT INTO `refresh_token_test`.`user` (`id`, `username`, `password`)
  VALUES ('1', 'guang', '123456');
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/152d619a0f4a475299ab92b3a3af6184~tplv-k3u1fbpfcp-watermark.image?)

我们测试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34d1f3b5594e42d28c4111553f2e79b6~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b121aa10e5e4ba882b8f0c7f6d90424~tplv-k3u1fbpfcp-watermark.image?)

鉴权逻辑生效了。

然后我们登录下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3770ea8e3e474424ac8c458b405d6a36~tplv-k3u1fbpfcp-watermark.image?)

把 access_token 复制下来，加到 header 里再访问：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a5889d842654a5d811b4ce7054e76cc~tplv-k3u1fbpfcp-watermark.image?)

这样就能访问了。

现在的 access_token 是 30 分钟过期，30分钟之后就需要重新登录了。

这样显然体验不好，接下来实现用 refresh_token 来刷新的逻辑：

```javascript
  @Get('refresh')
  async refresh(@Query('refresh_token') refreshToken: string) {
    try {
      const data = this.jwtService.verify(refreshToken);

      const user = await this.userService.findUserById(data.userId);

      const access_token = this.jwtService.sign({
        userId: user.id,
        username: user.username,
      }, {
        expiresIn: '30m'
      });

      const refresh_token = this.jwtService.sign({
        userId: user.id
      }, {
        expiresIn: '7d'
      });

      return {
        access_token,
        refresh_token
      }
    } catch(e) {
      throw new UnauthorizedException('token 已失效，请重新登录');
    }
  }
```
取出 refresh_token 里的 userId，从数据库中把 user 信息查出来，然后生成新的 access_token 和 refresh_token 返回。

如果 jwt 校验失败，就返回 token 已失效，请重新登录。

在 UserService 实现下这个 findUserById 的方法：

```javascript
async findUserById(userId: number) {
    return await this.entityManager.findOne(User, {
        where: {
            id: userId
        }
    });
}
```
测试下：

带上有效的 refresh_token，能够拿到新的 access_token 和 refresh_token：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c724094705c4ed784e2e83271c70ef4~tplv-k3u1fbpfcp-watermark.image?)

refresh_token 失效或者错误时，会返回 401 的响应码，提示需要重新登录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72bffc1901d649eeb94a85103504c4e3~tplv-k3u1fbpfcp-watermark.image?)

这样，我们就实现了双 token 的登录鉴权机制。

只要 7 天内带上 refresh_token 来拿到新的 token，就可以一直保持登录状态。

那前端代码里访问接口的时候怎么用这俩 token 呢？

我们新建个 react 项目试一下：

```
npx create-react-app --template=typescript refresh_token_test
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02680261eced4af7bea581ead9d8a7c5~tplv-k3u1fbpfcp-watermark.image?)

安装 axios：

```
npm install --save axios
```

在 App.tsx 里访问下 /aaa、/bbb 接口：

```javascript
import axios from 'axios';
import { useEffect, useState } from 'react';

function App() {
  const [aaa, setAaa] = useState();
  const [bbb, setBbb] = useState();

  async function query() {
    const { data: aaaData } = await axios.get('http://localhost:3000/aaa');
    const { data: bbbData } = await axios.get('http://localhost:3000/bbb');

    setAaa(aaaData);
    setBbb(bbbData);
  }
  useEffect(() => {
    query();
  }, [])
  

  return (
    <div>
      <p>{aaa}</p>
      <p>{bbb}</p>
    </div>
  );
}

export default App;
```
在服务端开启跨域支持：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bfe81dd830f42d4b8c81c8278e0212c~tplv-k3u1fbpfcp-watermark.image?)

把开发服务跑起来：

```
npm run start
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e96bf4d718b49f5854522fd0d2f0294~tplv-k3u1fbpfcp-watermark.image?)

可以看到 /aaa 访问成功，返回了数据，/bbb 返回了 401

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2101b928c63e402ba50b7abfe105122f~tplv-k3u1fbpfcp-watermark.image?)

这里请求两次是因为 index.tsx 里面有个 React.StrictMode，把它去掉就好了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea0cf38f69ed45ae93839d0854bfd73f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e7da697f3544200951a4ba83608027b~tplv-k3u1fbpfcp-watermark.image?)

我们先登录一下，拿到 access_token，然后在请求的时候带上：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71609c4adff2484081cfa301dbc952ba~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import axios from 'axios';
import { useEffect, useState } from 'react';

function App() {
  const [aaa, setAaa] = useState();
  const [bbb, setBbb] = useState();

  async function login() {
    const res = await axios.post('http://localhost:3000/user/login', {
        username: 'guang',
        password: '123456'
    });
    localStorage.setItem('access_token', res.data.access_token);
    localStorage.setItem('refresh_token', res.data.refresh_token);
  }

  async function query() {
    await login();

    const { data: aaaData } = await axios.get('http://localhost:3000/aaa');
    const { data: bbbData } = await axios.get('http://localhost:3000/bbb', {
      headers: {
        Authorization: 'Bearer ' + localStorage.getItem('access_token') 
      }
    });

    setAaa(aaaData);
    setBbb(bbbData);
  }
  useEffect(() => {
    query();
  }, [])
  

  return (
    <div>
      <p>{aaa}</p>
      <p>{bbb}</p>
    </div>
  );
}

export default App;
```

刷新下，可以看到现在请求了 3 个接口，bbb 也正确拿到了数据：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdd8e596ac5e49a4a039f71b62553506~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/311dd7a87c604aa48d4754cf6cad7853~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6d8c93ed61e420bafaeefda287d8f03~tplv-k3u1fbpfcp-watermark.image?)

如果很多接口都要添加这个 header，可以把它放在 interceptors 里做：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/338068bb91c14b859f58a80394aac14a~tplv-k3u1fbpfcp-watermark.image?)

```javascript
axios.interceptors.request.use(function (config) {
  const accessToken = localStorage.getItem('access_token');

  if(accessToken) {
    config.headers.authorization = 'Bearer ' + accessToken;
  }
  return config;
})
```
测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd270d2f6c74078a4cc9dddfa96dfed~tplv-k3u1fbpfcp-watermark.image?)

效果是一样的。

再就是当 token 失效的时候，要自动刷新，这个也可以在 interceptors 里做：

```javascript

async function refreshToken() {
  const res = await axios.get('http://localhost:3000/user/refresh', {
      params: {
        refresh_token: localStorage.getItem('refresh_token')
      }
  });
  localStorage.setItem('access_token', res.data.access_token || '');
  localStorage.setItem('refresh_token', res.data.refresh_token || '');
  return res;
}

axios.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    let { data, config } = error.response;

    if (data.statusCode === 401 && !config.url.includes('/user/refresh')) {
        
      const res = await refreshToken();

      if(res.status === 200) {
        return axios(config);
      } else {
        alert('登录过期，请重新登录');
        return Promise.reject(res.data)
      }
        
    } else {
      return error.response;
    }
  }
)
```
如果返回的错误是 401 就刷新 token，这里要排除掉刷新的 url，刷新失败不继续刷新。

如果刷新接口返回的是 200，就用新 token 调用之前的接口

如果返回的是 401，那就返回这个错误。

判断下如果没有 access_token 才登录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9641ed559ce47989158165b286f0af1~tplv-k3u1fbpfcp-watermark.image?)
```javascript
if(!localStorage.getItem('access_token')) {
  await login();
}
```
然后手动改下 access_token 的值，让它失效：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21d410307aa44e029a3d394ea2b3787b~tplv-k3u1fbpfcp-watermark.image?)

刷新下页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc5526d926334de794c7582fa6943626~tplv-k3u1fbpfcp-watermark.image?)

访问了 aaa、bbb 接口，bbb 接口 401 了，于是 refresh token，之后再次访问 bbb。

这样，我们就实现了 access_token 的无感刷新。

但这样还不完美，比如当并发多个请求的时候，如果都失效了，是不是要刷新多次?

我们加个并发请求试一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b94dc9b07fb494eb82701e5d7b5876c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1110&h=512&e=png&b=1f1f1f)

```javascript
await [
  axios.get('http://localhost:3000/bbb'),
  axios.get('http://localhost:3000/bbb'),
  axios.get('http://localhost:3000/bbb')
];
```
手动让 access_token 失效，然后刷新页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24de1e46d7c3485f85182b2567c52827~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1526&h=508&e=png&b=fefefe)

确实刷新了多次，并发的 3 次，还有后面又访问了一次：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4c9027ab51541a4be0eaff34d7fd718~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=716&h=558&e=png&b=fafafa)

其实这样不处理也行，多刷几次也不影响功能。

但做的完美点还是要处理下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14993808b8847448745dcaf022c3eeb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=862&h=834&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45c681fff3ab42d8abac906e87272459~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=826&e=png&b=1f1f1f)

加一个 refreshing 的标记，如果在刷新，那就返回一个 promise，并且把它的 resolve 方法还有 config 加到队列里。

当 refresh 成功之后，修改 refreshing 的值，重新发送队列中的请求，并且把结果通过 resolve 返回。

```javascript
interface PendingTask {
  config: AxiosRequestConfig
  resolve: Function
}
let refreshing = false;
const queue: PendingTask[] = [];

axios.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    let { data, config } = error.response;

    if(refreshing) {
      return new Promise((resolve) => {
          queue.push({
              config,
              resolve
          });
      });
    }

    if (data.statusCode === 401 && !config.url.includes('/user/refresh')) {
        refreshing = true;

        const res = await refreshToken();

        refreshing = false;

        if(res.status === 200) {

          queue.forEach(({config, resolve}) => {
              resolve(axios(config))
          })
  
          return axios(config);
        } else {
          alert('登录过期，请重新登录');
          return Promise.reject(res.data);
        }
        
    } else {
      return error.response;
    }
  }
)
```
测试下：

手动让 access_token 失效然后刷新：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/454182ffa7324b21aba649cf5677065b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1376&h=424&e=png&b=fefefe)

现在就只刷新一次 token 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27ee2f8d316f46d9994e0cfd0d687233~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=422&e=png&b=fafafa)

最后，为什么说双 token 会更安全呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ca1505657c4907aca4d75751d57388~tplv-k3u1fbpfcp-watermark.image?)

案例代码在小册仓库：

[后端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/access_token_and_refresh_token)

[前端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/refresh_token_test)

## 总结

这节我们实现了基于 access_token 和 refresh_token 的无感刷新登录状态，也就是无感续签。

access_token 用于身份认证，refresh_token 用于刷新 token，也就是续签。

在登录接口里同时返回 access_token 和 refresh_token，access_token 设置较短的过期时间，比如 30 分钟，refresh_token 设置较长的过期时间，比如 7 天。

当 access_token 失效的时候，可以用 refresh_token 去刷新，服务端会根据其中的 userId 查询用户数据，返回新 token。

在前端代码里，可以在登录之后，把 token 放在 localstorage 里。

然后用 axios 的 interceptors.request 给请求时自动带上 authorization 的 header。

用 intercetpors.response 在响应是 401 的时候，自动访问 refreshToken 接口拿到新 token，然后再次访问失败的接口。

我们还支持了并发请求时，如果 token 过期，会把请求放到队列里，只刷新一次，刷新完批量重发请求。

这就是 token 无感刷新的前后端实现，是用的特别多的一种方案。




## 62.使用 passport 做身份认证

我们实现过登录和身份认证，登录的时候基于用户名密码，后续基于 jwt。

像这种身份认证逻辑其实很通用，每个项目都会有，自然可以抽取成一个库。

先不看第三方库是怎么做的，思考下，如果让你做一个身份认证的库，你会怎么设计呢？

首先，身份认证有多种方式，比如用户名密码、jwt、google 登录、github 登录等。

这多种方式都可以实现身份认证，那我们就可以用策略模式把它们封装成一个个策略类（Strategy）。

简单看下策略模式的介绍：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a61d415919c94c6287c2a2f92a215859~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1484&h=1814&s=352175&e=png&b=fefefe)

其实它就是实现了一个接口的多个类，这些类可以相互替换。

这里我们就可以用策略模式来做。

然后每个策略类里封装什么呢？

其实不同的认证方式虽然逻辑不同，但做的事情很类似：

- 用户名密码登录就是从 request 的 body 里取出 username、password 来认证。
- jwt 是从 request 的 Authorization 的 header 取出 token 来认证。

**不同策略都会从 request 中取出一些东西来认证，如果认证就在 request.user 上存放认证后的 user 信息**，这就是它们的共同点。

比如身份认证库 passport 的两种策略：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5bb06800a4f4d3f8b082dcc6e88e230~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1120&h=546&s=105492&e=png&b=1f1f1f)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98742b56090242089178eda25ab90cf4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&h=560&s=100048&e=png&b=1f1f1f)

可以看到，不管是用户名密码的身份认证，还是 jwt 的身份认证，都会从 request 的 body 或者 header 中取出一些信息来，然后认证通过之后返回 user 的信息，passport 会设置到 request.user 上。

这个封装思路你理解了，那 passport 这个库也就差不多掌握了。

然后我们在 nest 里用一下 passport 这个库：

```
nest new nest-passport
```

![2.3.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/895567963a604e14a2e77ab6810e8539~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=934&h=586&s=365351&e=png&b=fefefe)
进入项目，安装 passport：

```
npm install --save @nestjs/passport passport
```
然后我们首先实现用户名密码的认证。

这用到 passport-local 的策略，安装下：

```
npm install --save passport-local
npm install --save-dev @types/passport-local
```
然后创建一个认证模块：

```
nest g module auth
nest g service auth --no-spec
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dff2212906444ef8453cff548f080c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=186&s=54890&e=png&b=191919)
添加用户名密码认证的策略：

```javascript
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super();
  }

  async validate(username: string, password: string) {
    const user = await this.authService.validateUser(username, password);
    return user;
  }
}
```

在 AuthModule 引入下：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09d8b29792d84e329598aeec6149b2af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=892&h=374&s=74826&e=png&b=202020)

这个 LocalStrategy 的逻辑就像前面分析的：


从 reqeust 的 body 中取出 username 和 password 交给你去认证，认证过了之后返回 user，它会把 user 放到 request.user 上，如果认证不通过，就抛异常，由 exception filter 处理。

我们在 AuthService 里实现这个 validateUser 方法：

```javascript
import { Inject, Injectable, UnauthorizedException } from '@nestjs/common';
import { UserService } from 'src/user/user.service';

@Injectable()
export class AuthService {

    @Inject()
    private userService: UserService;

    async validateUser(username: string, pass: string) {
        const user = await this.userService.findOne(username);

        if(!user) {
            throw new UnauthorizedException('用户不存在');
        }
        if(user.password !== pass) {
            throw new UnauthorizedException('密码错误');
        }

        const { password, ...result } = user;
        return result;
    }
}
```

AuthService 里根据用户名密码去校验，但是查询用户的逻辑应该在 UserModule 里，我们写一下：

```
nest g module user
nest g service user --no-spec
```

UserService：

```javascript
import { Injectable } from '@nestjs/common';

@Injectable()
export class UserService {
    private readonly users = [
        {
            userId: 1,
            username: '神说要有光',
            password: 'guang',
        },
        {
            userId: 2,
            username: '东东东',
            password: 'dong',
        },
    ];

    async findOne(username: string) {
        return this.users.find(user => user.username === username);
    }
}
```
在 UserModule 里导出 UserService：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95ae3305ca0b4d03b7201d9a3c87513b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=830&h=368&s=65366&e=png&b=1f1f1f)

然后在 AuthModule 里引入下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f4e72bd571545be84096b2e5a961fdc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=436&s=93319&e=png&b=1f1f1f)

这样，passport 的流程就完成了，它会从 request 中取出 body 的 username 和 password 交给我们的 validate 方法去认证，认证完会返回 user 信息，放到 request.user 上。

那怎么应用这个策略呢？

很明显，这里适合用 Guard。

@nestjs/passport 已经做了封装了。

我们在 AppController 里加个 login 方法：

```javascript
import { Controller, Get, Post, Req, UseGuards } from '@nestjs/common';
import { AppService } from './app.service';
import { AuthGuard } from '@nestjs/passport';
import { Request } from 'express';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @UseGuards(AuthGuard('local'))
  @Post('login')
  async login(@Req() req: Request) {
    console.log(req.user);
    return req.user;
  }

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```
把服务跑起来：

```
npm run start:dev
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/758a0a51f4b84e218e6693203cbdbb25~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592&h=436&s=184646&e=png&b=181818)

postman 里测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c94aec9bdd6147169b1b25c25248ae98~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=836&s=101583&e=png&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b859cdc48f9f4481a9abec213df2b561~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=796&s=100824&e=png&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80858ddf870c44488d35e5997c13b540~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=798&s=93187&e=png&b=fdfdfd)

这样，基于 passport 的登录就完成了。

不用我们自己从 request 取 body 中的 username 和 password，也不用我们把查询结果放到 request.user 上，更不用自己实现 Guard。

确实减少了不少代码。

接下来继续做 JWT 的认证：

登录的时候通过用户名、密码认证，这时候登录认证成功会返回 jwt，然后再次访问会在 Authorization 的 header 携带 jwt，然后通过 header 的 jwt 来认证。

这是一种新的认证方式，需要用新的策略。

我们首先在登录成功之后返回 jwt。

安装用到的包：

```
npm install --save @nestjs/jwt
```

在 AppModule 里引入下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22e2c21fd8854c4abe2a592aff039ee9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=772&s=145432&e=png&b=1f1f1f)

```javascript
JwtModule.register({
    secret: "guang"
}),
```
然后在 AppController 里 login 接口返回 jwt 的 token：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66040af35eed436db182e2b720312a0f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1246&h=1440&s=253523&e=png&b=1f1f1f)

这里需要扩展下 express 的 request.user 的类型。

```javascript
import { Controller, Get, Inject, Post, Req, UseGuards } from '@nestjs/common';
import { AppService } from './app.service';
import { AuthGuard } from '@nestjs/passport';
import { Request } from 'express';
import { JwtService } from '@nestjs/jwt';

interface JwtUserData {
  userId: number;
  username: string;
}

declare module 'express' {
  interface Request {
    user: JwtUserData
  }
}

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject()
  jwtService: JwtService;

  @UseGuards(AuthGuard('local'))
  @Post('login')
  async login(@Req() req: Request) {
    console.log(req.user);
    const token = this.jwtService.sign({
      userId: req.user.userId,
      username: req.user.username
    }, {
      expiresIn: '0.5h'
    });

    return {
      token
    }
  }

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}

```
试一下：


![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c62988bb8eef4f37a7a76f8c2f47f715~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=824&s=154588&e=png&b=fefefe)

这样，登录之后返回 jwt 就完成了。

然后添加 jwt.strategy.ts

```javascript
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable } from '@nestjs/common';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: 'guang',
    });
  }

  async validate(payload: any) {
    return { userId: payload.userId, username: payload.username };
  }
}
```
指定从 request 的 header 里提取 token，然后取出 payload 之后会传入 validate 方法做验证，返回的值同样会设置到 request.user。

安装用到的包：

```
npm install --save passport-jwt
npm install --save-dev @types/passport-jwt
```
在 AuthModule 引入下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c6f592bd6cd41dfb9e64a7738d659f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=934&h=462&s=107470&e=png&b=1f1f1f)

在 AppController 里添加一个新的需要登录认证的接口：

```javascript
@UseGuards(AuthGuard('jwt'))
@Get("list")
list(@Req() req: Request) {
    console.log(req.user);
    return ['111', '222', '333', '444', '555']
}
```
首先不带 token 访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5a9d8c7b2b4078adc2153ecbbb9382~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=998&h=824&s=82528&e=png&b=fdfdfd)

然后通过 Authorization 的 header 带上 Bearer xxx 的 token 访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/582a3a55c09c42dc95e1ea7ab11daa90~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1186&h=866&s=101767&e=png&b=fdfdfd)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db21c92d5d29476e810d21e2892b81e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1012&h=538&s=173360&e=png&b=191919)

可以看到，jwt 的认证生效了。

对比下用 passport 和不用有啥区别呢？

不用我们自己从 request 的 header 里取 token 了，也不用自己从 token 提取的信息放到 request.user 里了，也不用自己写 Guard 了。

确实方便了很多。

这样，我们就用了两个 local 和 jwt 两个策略了。

其他策略也是类似的流程，从 request 取一些信息，交给 validate 方法去验证，返回 user 放到 request.user 里。

那如果我想对 Guard 的流程做一些扩展呢？

比如 jwt 的 Guard，现在需要在每个 controller 上手动应用，我想通过一个 @IsPublic 的装饰器来标识，如果有 @IsPublic 的装饰器就不需要身份认证，否则就需要。

这就需要继承 AuthGuard('jwt') 做一些扩展了：

首先，生成一个自定义装饰器：

```
nest g decorator is-public --flat --no-spec
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85ed3cabe56c48edb0672ab350cfd32c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1342&h=148&s=38054&e=png&b=181818)
它的实现就是给被装饰对象添加一个 metadata：

```javascript
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const IsPublic = () => SetMetadata(IS_PUBLIC_KEY, true);
```
然后在 AppController 里加几个路由：

```javascript
@IsPublic()
@Get('aaa')
aaa() {
    return 'aaa';
}

@Get('bbb')
bbb() {
    return 'bbb';
}
```
aaa 是 public 的，不需要身份认证，而 bbb 需要。

这时就需要对 AuthGuard('jwt') 做下扩展。

新建 auth/JwtAuthGuard.ts

```javascript
import { ExecutionContext, Injectable } from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { AuthGuard } from "@nestjs/passport";
import { IS_PUBLIC_KEY } from "src/is-public.decorator";

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (isPublic) {
      return true;
    }
    return super.canActivate(context);
  }
}
```
实现就是从目标 controller、handler 上取 public 的 meatadata，如果有就直接放行，否则才做认证。

然后在 AppModule 里注册为全局 Guard：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/010386453de4464ea7ffe2d332201881~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=958&h=1050&s=191342&e=png&b=202020)

```javascript
{
    provide: APP_GUARD,
    useClass: JwtAuthGuard
}
```
测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6614fe16949347d6a06f26408f61f7f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=940&h=694&s=73035&e=png&b=fdfdfd)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9852fff2ee944128485716bc6faa5c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=754&s=87469&e=png&b=fdfdfd)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98e582bbbe2546bda930701ebed27719~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=928&h=686&s=73037&e=png&b=fdfdfd)

没啥问题，这样，对 AuthGuard('jwt') 的扩展就完成了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-passport)

## 总结

之前我们都是自己实现身份认证，比如基于用户名密码的认证，基于 jwt 的认证，今天我们基于 passport 库来实现了一遍。

passport 把不同的认证逻辑封装成了不同 Strategy，每个 Stategy 都有 validate 方法来验证。

**每个 Strategy 都是从 request 取出一些东西，交给 validate 方法验证，validate 方法返回 user 信息，自动放到 request.user 上。**

并且 @nestjs/passport 提供了 Guard 可以直接用，如果你想扩展，继承 AuthGuard('xxx')  然后重写下 canActivate 方法就好了。

细想一下，你做各种认证的时候，是不是也在做同样的事情呢？

那既然每次都是做这些事情，那为啥不用 passport 库来简化呢？

## 63.passport 实现 GitHub 三方账号登录

我们每天都会登录各种网站，这些网站除了用户名、密码登录外，一般也都支持三方登录。

比如 google 登录、github 登录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/725ac02344fb4a939ef66777c077c941~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=564&h=808&s=126271&e=png&b=faf9f9)

这样免去了输入用户名密码的麻烦，直接用别的账号来登录当前网站。

那这种三方登录是怎么实现的呢？

今天我们做一下基于 github 的登录来体验下。

我们还是用 passport 这个包。

它提供了非常多的[策略](https://www.passportjs.org/packages/)。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23d094ef71dd4c9ca46f4aa4e1105247~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2270&h=1788&s=453315&e=png&b=131313)

上节我们用的 passport-local（用户名密码认证）、passport-jwt（jwt 认证）只是最基础的。

这节用 [passport-github2](https://www.passportjs.org/packages/passport-github2/) 来实现基于 github 的三方登录。

这个的关键是要拿到 client id 和 secret。

我们来生成一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f812ffa5df8d49169fff7aaf6522cff3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1102&h=1174&s=281398&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ac307ba0aa8408ab2d07dbc1e581894~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=776&s=89173&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37b7ae17dc65469690c47e40ba586fc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2474&h=700&s=114679&e=png&b=ffffff)

点击 settings > developer settings > new OAuth App

填入信息后，点击 register application：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f3a349ae7674fae9e44376a6b145c55~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2056&h=1520&s=237169&e=png&b=ffffff)

现在 client id 有了，点击生成 secret

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc140c8e15bb4786bf12577c06934834~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2204&h=1118&s=193621&e=png&b=ffffff)

提示你了，这里的 secret 只能看见这一次，复制保存下来（当然，丢了也没啥，可以再次生成）：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f382063da4e46d99e9e44272475ef7f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592&h=734&s=116886&e=png&b=ffffff)

有了 client id 和 secret 之后，就能实现 github 登录了。

我们新建个 nest 项目：

```
nest new github-login
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/085f9becea2f4f01a0097bf238e5588d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=890&h=584&s=354080&e=png&b=fefdfd)

进入项目，安装 passport 的包：

```
npm install --save passport @nestjs/passport
```
然后安装 passport-github2 的策略：

```
npm install --save passport-github2
npm install --save-dev @types/passport-github2
```

生成一个 auth 模块：

```
nest g module auth
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/663ea234321b4b4d823e2ae9eb187d42~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=746&h=146&s=38226&e=png&b=191919)

然后添加 auth/auth.strategy.ts

```javascript
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Profile, Strategy } from 'passport-github2';

@Injectable()
export class GithubStrategy extends PassportStrategy(Strategy, 'github') {
  constructor() {
    super({
      clientID: 'Ov23liPsg7pxupYsMXah',
      clientSecret: 'ad3604a0147924406fcd2f597fb234a188cae1f9',
      callbackURL: 'http://localhost:3000/callback',
      scope: ['public_profile'],
    });
  }

  async validate(accessToken: string, refreshToken: string, profile: Profile) {
    return profile;
  }
}
```
这里的 clientID 和 clientSecret 要换成你自己的。

callbackURL 是登录成功后回调的 url。

scope 是请求的数据的范围。

在 AuthModule 引入下这个 GithubStategy：

```javascript
import { Module } from '@nestjs/common';
import { GithubStrategy } from './auth.strategy';

@Module({
    providers: [GithubStrategy]
})
export class AuthModule {}
```

然后在 AppController 添加两个路由：

```javascript

import { Controller, Get, Req, UseGuards } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller('')
export class AppController {
  constructor(private appService: AppService) {}

  @Get('login')
  @UseGuards(AuthGuard('github'))
  async login() {
  }

  @Get('callback')
  @UseGuards(AuthGuard('github'))
  async authCallback(@Req() req) {
    return req.user;
  }
}
```

login 是触发 github 登录的，然后 callback 是回调的 url。

前面讲过 passport 的策略会在验证过后把 validate 的返回值放在 request.user 上。

所以这里可以从 req.user 取到返回的用户信息。

跑一下：

当你访问 http://localhost:3000/login ，会跳转 github 登录授权页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5329de71f7684e00a4f394a4ddb5a1c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1394&h=1402&s=213381&e=png&b=f5f7f9)

然后点击 authorize，会回调 callback 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7729404b0da247a082c70e9c12e9f3cf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2130&h=1840&s=584010&e=png&b=fefefe)

这样我们拿到 id 就可以唯一标识这个用户。

可以在用户表里添加一个 githubId 的字段，第一次用 github 登录的时候，记录返回的 id、username、avater 等信息，然后打开一个页面让用户完善其他信息，比如 email、password 等，。

然后后续用 github 登录的时候，直接根据 githubId 来查询用户即可。

我们改下 AppService：

```javascript
import { Injectable } from '@nestjs/common';

const users = [
  {
    username: 'guangguang',
    githubId: '80755847',
    email: 'yyy@163.com',
    hobbies: ['sleep', 'writting']
  }, 
  {
    username: 'dongdong',
    email: 'xxx@xx.com',
    hobbies: ['swimming']
  }
]

@Injectable()
export class AppService {

  findUserByGithubId(githubId: string){
    return users.find(item => item.githubId === githubId);
  }

  getHello(): string {
    return 'Hello World!';
  }
}
```
guanggaung 用户用 github 登录过，记录了他的 githubId。

然后在 AppController 里取出 github 返回的 id 来，查询用户信息，即可登录。

```javascript
@Get('callback')
@UseGuards(AuthGuard('github'))
async authCallback(@Req() req) {
    return this.appService.findUserByGithubId(req.user.id);
}
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3c93e536a2749f183022b2aa96f8d14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2570&h=1502&s=280659&e=gif&f=39&b=fdfdfd)

可以看到，现在访问 http://localhost:3000/login 会跳转 github 登录，然后授权后访问 callback，我们根据 id 查询出了用户信息返回。

这样就实现了 github 的登录。

当然，这里应该是返回 jwt，然后后续直接用 jwt 来认证就好了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/github-login)

## 总结

很多网站都支持三方登录，这样，不用每次都输入用户名密码，可以用别的账号来登录。

我们基于 passport 的 GitHub 策略实现了三方登录。

它核心就是要获取 clientID、clientSecret。

然后在 GithubStrategy 的构造函数传入这些信息，在 validate 方法里就可以拿到返回的 profile。

我们只要在用户表存一个 githubId 的字段，用 github 登录之后根据 id 查询用户信息，实现登录就好了。

这样就免去了每次登录都输入用户名密码的麻烦。

你平时用的三方登录就是这么实现的。


## 64.passport 实现 Google 三方账号登录

上节我们实现了 Github 登录，这节继续来实现下 Google 登录。

创建个 nest 项目：

```
nest new google-login
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f67384306a1148a89212ba8e5b0a984a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=858&h=568&s=353032&e=png&b=fefdfd)

进入项目，安装 passport 的包：

```
npm install --save passport @nestjs/passport
```
然后安装 google 的策略包。

这个可以去 [passport 的网站](https://www.passportjs.org/packages/)搜索：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2912fbdf8bf645579f2b51fdfab70107~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2376&h=1446&s=283080&e=png&b=131313)


找下载量最多的那个。

然后安装下：

```
npm install --save passport-google-oauth20
npm install --save-dev @types/passport-google-oauth20
```

我们先做 google 登录，很明显，最关键的也是要获取 client id 和 client secret。

打开 google cloud 的[控制台页面]([console.cloud.google.com/welcome](https://console.cloud.google.com/welcome))：

点击左上角的按钮，然后点击 new project：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/210641057bd44f828df63751785986ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2506&h=1700&s=800910&e=gif&f=23&b=fdfdfd)

填入项目名后点击 create：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2bf674dbee8948ac8716cb01e442d6dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1546&h=930&s=115955&e=png&b=fdfdfd)

点击左上角的按钮切换到你刚刚创建的 project：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6225765a7e94a448d9e3dc8a8510818~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2114&h=1120&s=175954&e=png&b=e0e0e0)

进入 api & service 页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3865c448e8fe4ffbb2a90118a2b56cbd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1982&h=1436&s=172304&e=png&b=fefefe)

点击 OAuth consent screen，然后勾选 external，点击 create：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd675dd9c1094ceda5d93e1de9ec4051~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1634&h=1124&s=216029&e=png&b=fefefe)

输入三个必填信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c3e26198f0f43f983e5d4a4180dda21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1526&h=888&s=203343&e=png&b=fefefe)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8e0c32cadf4440285a984586a3a35a6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1444&h=1366&s=286594&e=png&b=fefefe)

点击 save and continue。

然后点击 Credentials 创建凭证：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7172b64f410347c0a24ebf61a1e7ea1f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1982&h=950&s=200182&e=png&b=fdfdfd)

输入应用类型、name、填入授权的域名、回调的 url，点击 create：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd52dfd2e7224fba92e6b5da86d03a54~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1338&h=1626&s=206530&e=png&b=fefefe)

这样 client id 和 client secret 就生成好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d957e6036feb401f9cc180572dd53517~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1388&h=1216&s=156829&e=png&b=f0f0f0)

接下来写代码：

```
nest g module auth
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4742b06a2dd743c192a61779f4987319~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=810&h=124&s=35816&e=png&b=191919)

生成 auth 模块，然后创建 auth/google.strategy.ts

```javascript
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { Strategy } from 'passport-google-oauth20';

@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor() {
    super({
      clientID: '122695705559-9nr9alq0s53e2pr3vkiv2h7vau917ic4.apps.googleusercontent.com',
      clientSecret: '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',
      callbackURL: 'http://localhost:3000/callback/google',
      scope: ['email', 'profile'],
    });
  }

  validate (accessToken: string, refreshToken: string, profile: any) {
    const { name, emails, photos } = profile
    const user = {
      email: emails[0].value,
      firstName: name.givenName,
      lastName: name.familyName,
      picture: photos[0].value,
      accessToken
    }
    return user;
  }
}
```

这里填入刚刚的 clientID、clientSecret、callbackURL。

然后在 AuthModule 引入：

```javascript
import { Module } from '@nestjs/common';
import { GoogleStrategy } from './google.strategy';

@Module({
    providers: [GoogleStrategy]
})
export class AuthModule {}
```

之后在 AppController 添加两个路由：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac9d39f3bd34ba39572bf8a976afb7b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1002&s=176135&e=png&b=1f1f1f)

```javascript
import { Controller, Get, Req, UseGuards } from '@nestjs/common';
import { AppService } from './app.service';
import { AuthGuard } from '@nestjs/passport';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('google')
  @UseGuards(AuthGuard('google'))
  async googleAuth() {}

  @Get('callback/google')
  @UseGuards(AuthGuard('google'))
  googleAuthRedirect(@Req() req) {
    if (!req.user) {
      return 'No user from google'
    }

    return {
      message: 'User information from google',
      user: req.user
    }
  }
}
```
一个是登录的，一个是回调的。

把服务跑起来：

```
npm run start:dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fb757f301124cb5bb86eae1a3007d78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1596&h=450&s=180282&e=png&b=181818)
测试下：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54e890bfdbdb434599c742ffa459fa4c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2612&h=1736&s=814485&e=gif&f=34&b=fefefe)

可以看到，google 的用户信息拿到了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3da71bfe66da4eed8dcefa62abe087ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1288&h=492&s=111102&e=png&b=fdfdfd)

这里没有 github 返回的那种有 id，但这里返回了 email，同样可以唯一标识用户。

你可以试下 [medium.com](https://medium.com/) 的三方登录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/452f486d7935427c9a5ce7e25def8445~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2552&h=1482&s=806348&e=gif&f=38&b=f3bd3e)

用 google 账号登录之后，会让你完善一些信息，然后 create count。

也就是基于你 google 账号里的东西，再让你填一些东西之后，完成账号注册。

之后你 google 登录，就会查到这个账号，从而直接登录，不用输密码。

或者 [hub.docker.com](https://hub.docker.com/signup) 的三方登录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ce241a87494a328cf2444abde81781~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672&h=1468&s=168105&e=gif&f=19&b=fcfefe)

也是在 github 账号登录后，让你填一些其余信息，完成注册。

之后三方账号授权后，直接登录。

我们也来实现下：

引入下 TypeORM 来操作数据库：

```bash
npm install --save @nestjs/typeorm typeorm mysql2
```
AppModule 里引入 TypeOrmModule：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f7db7c2005342e8b013ab9d9e5e6f64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=968&h=1036&s=198273&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './auth/auth.module';
import { TypeOrmModule } from '@nestjs/typeorm';

@Module({
  imports: [
    AuthModule, 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "google-login",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    })
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```

在 mysql workbench 创建这个 database：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f1bcfa1fc19426f84405c150745cf05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1856&h=1300&s=337021&e=png&b=e7e7e7)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d287ad8618459d97dac43ca796bc2d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=394&h=252&s=50757&e=png&b=cecdcc)

添加 src/user.entity.ts

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn, UpdateDateColumn } from "typeorm";

export enum RegisterType {
    normal = 1,
    google = 2
}
@Entity()
export class User {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50
    })
    email: string;

    @Column({
        length: 20
    })
    password: string;

    @Column({
        comment: '昵称',
        length: 50
    })
    nickName: string;

    @Column({
        comment: '头像 url',
        length: 200
    })
    avater: string;

    @Column({
        comment: '注册类型: 1.用户名密码注册 2. google自动注册',
        default: 1
    })
    registerType: RegisterType;

    @CreateDateColumn()
    createTime: Date;

    @UpdateDateColumn()
    updateTime: Date;
}
```

有 id、email、nickName、avater、registerType、createTime、updateTime 7 个字段。

registerType 用来标识哪种注册方式，正常注册是 1，google 账号自动注册是 2。

这里要区分是因为 google 方式注册就不用 password 了，验证逻辑不一样。

在 entities 里引入：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3341f7af04044e82b2fddf378dae3764~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=898&h=882&s=167229&e=png&b=1f1f1f)

跑一下试试：

```
npm run start:dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17e9cf1c9bb64b24a284e31aae3ad137~tplv-k3u1fbpfcp-watermark.image?)

这部分和我们单独跑 typeorm 没啥区别：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96316f78b76c4e52b7866e61f26ebea4~tplv-k3u1fbpfcp-watermark.image?)

然后是增删改查，我们可以注入 EntityManager：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d13629e0c2d24afbae695fb75e8580f8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2206&h=824&s=339649&e=png&b=181818)

自动创建了对应的表。

在 mysql workbench 里也可以看到：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3004cda60b1949bd9e46c85f8e585867~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1138&h=690&s=266076&e=png&b=e8e7e7)

然后在 AppService 里注入 EntityManager 来操作 user 表：

```javascript
import { Injectable } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { EntityManager } from 'typeorm';
import { User } from './user.entity';

export interface GoogleInfo {
  email: string;
  firstName: string;
  lastName: string;
  picture: string;
}

@Injectable()
export class AppService {

  @InjectEntityManager()
  entityManager: EntityManager;

  getHello(): string {
    return 'Hello World!';
  }

  async registerByGoogleInfo(info: GoogleInfo) {
    const user = new User();

    user.nickName = `${info.firstName}_${info.lastName}`;
    user.avater = info.picture;
    user.email = info.email;
    user.password = '';
    user.registerType = 2;

    return this.entityManager.save(User, user);
  }

  async findGoogleUserByEmail(email: string) {
    return this.entityManager.findOneBy(User, {
      registerType: 2,
      email
    });
  }
}
```

实现了 findGoogleUserByEmail 方法，可以根据 email 查询 google 注册的账号。

实现了 registerByGoogleInfo 方法，根据 google 返回的信息自动注册账号。

然后在 AppController 里改下 callback 的逻辑：

```javascript
@Get('callback/google')
@UseGuards(AuthGuard('google'))
async googleAuthRedirect(@Req() req) {
    const user = await this.appService.findGoogleUserByEmail(req.user.email);

    if(!user) {
      const newUser = this.appService.registerByGoogleInfo(req.user);
      return newUser;
    } else {
      return user;
    }
}
```
首先根据 email 查询 google 方式登录的 user，如果有，就自动登录。

否则自动注册然后登录。

这里因为 google 返回的信息是全的，就直接自动注册了。

如果不全，需要再跳转一个页面填写其余信息之后再自动注册。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77f9e162fadf4c94b5e3d517be92b7f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2330&h=1398&s=144441&e=gif&f=30&b=fefefe)

因为前面登录过 google 账号并授权了，短时间内不需要再次授权，所以这里直接触发了注册并登录了。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e01546f398984de5b36439419e12c811~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1692&h=512&s=183485&e=png&b=191919)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ef4739eec79426fa3c0296ca4d16da9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1486&h=692&s=327631&e=png&b=f1f0f0)

当你用这个 google 账号登录，就会直接登录，不需要再注册了。

这就是三方账号登录的实现原理。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/google-login)

## 总结

我们实现了基于 google 的三方账号登录。

首先搜索对应的 passport 策略，然后生成 client id 和 client secret。

在 nest 项目里使用这个策略，添加登录和 callback 的路由。

之后基于 google 返回的信息来自动注册，如果信息不够，可以重定向到一个 url 让用户填写其余信息。

之后再次用这个 google 账号登录的话，就会自动登录。

现在，你可以在你的应用中加上 docker.com 这种三方账号登录了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fddf163690c4a25886d4beda26556fb~tplv-k3u1fbpfcp-watermark.image?)


## 66.如何动态读取不同环境的配置？

连接数据库的时候，我们指定了用户名、密码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b052d2f7f4754d469d33c441422e1ef1~tplv-k3u1fbpfcp-watermark.image?)

应用启动的时候，我们指定了端口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e4f0d2af1bd4d7981a262b758b2be59~tplv-k3u1fbpfcp-watermark.image?)

而这些其实都是可以变的，在代码里写死显然不太好。

能不能抽取出来放到配置文件里呢？

自然是可以的。

node 里最常用的是 .env 格式的配置文件，它有一个专门的 npm 包 dotenv。

我们创建个项目来试一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c10a9997ff0d46c9ba5744a89e30ae1b~tplv-k3u1fbpfcp-watermark.image?)
进入这个目录，安装 dotenv：

```
npm install dotenv
```

然后添加一个 .env 配置文件：
```
aaa=1
bbb=2
```

在 index.js 里通过 dotenv 来加载：

```javascript
require('dotenv').config({
    path: './.env',
})

console.log(process.env) 
```
node 执行下：

```
node index.js
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a089073eaee49cbbcff21394cc014a0~tplv-k3u1fbpfcp-watermark.image?)

他打印的环境变量里就包含了配置文件里的。

那如果我还有个生产环境的配置文件呢？

比如 .production.env

```
aaa=111
bbb=222
```
我们可以通过 NODE_ENVIRONMENT 环境变量来切换：

```javascript
require('dotenv').config({
    path: process.env.NODE_ENVIRONMENT === 'production' ? '.production.env' : '.env',
})

console.log('aaa', process.env.aaa);
console.log('bbb', process.env.bbb)
```
生产环境设置 NODE_ENVIRONMENT 为 production，就可以切换到对应的配置了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc43c399056047d7a8c062ab18de6628~tplv-k3u1fbpfcp-watermark.image?)

如果你手动置顶了环境变量，那以手动指定的优先：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fba677fe10478e807fe3b589d3ff54~tplv-k3u1fbpfcp-watermark.image?)

此外，如果你想用 yaml 格式的配置文件也可以。

安装 js-yaml 包：

```
npm install js-yaml
```

然后添加一个 hello.yaml 配置文件：

```yaml
application:
  host: 'localhost'
  port: 8080

db:
   mysql:
    url: 'localhost'
    port: 3306
    database: 'aaa'
    password: 'guang'
```
然后在 index2.js 里用一下：

```javascript
const yaml = require('js-yaml');
const fs = require('fs');

const config = fs.readFileSync('./hello.yaml');

console.log(yaml.load(config));
```
跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d15a010cee4b1b868c59dc4c6af405~tplv-k3u1fbpfcp-watermark.image?)

可以看到，用对象的方式把 yaml 的配置给返回了。

**yaml 的格式更适合有层次关系的配置，而 .env 更适合简单的配置。**

同样，也可以通过 NODE_ENVIRMENT 环境变量来切换生产、开发的配置文件。

node 里的配置一般就用这两种方式。

那在 Nest 里怎么用呢？

其实上面的这两种配置方式，自己封装也不麻烦，封装个动态模块就好。

不过 Nest 提供了现成的封装：@nestjs/config

我们创建个 nest 项目来试下：

```
nest new nest-config-test -p npm
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b50004bd4ad44a24aa22b1654f12e6a5~tplv-k3u1fbpfcp-watermark.image?)

安装 @nestjs/config 包：

```
npm install --save @nestjs/config
```

这个包同样是动态模块的方式，他有 forRoot 和 forFeature 两个方法。

我们在根目录加一个配置文件 .env：

```
aaa=1
bbb=2
```
然后在 AppModule 里面引入：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a154e71c6054642906944a2f5bf7c9e~tplv-k3u1fbpfcp-watermark.image?)

然后在 AppController 里注入 ConfigService 来读取配置：

```javascript
import { Controller, Get, Inject } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject(ConfigService)
  private configService: ConfigService;

  @Get()
  getHello() {
    return {
      aaa: this.configService.get('aaa'),
      bbb: this.configService.get('bbb')
    }
  }
}

```
把 Nest 服务跑起来：
```
npm run start:dev
```
浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/246bae916869459a953101f87c02c5ec~tplv-k3u1fbpfcp-watermark.image?)

可以看到，nest 读取到了 .env 里的配置。

如果有多个配置文件，比如还有个 .aaa.env：

```
aaa=3
```
在 AppModule 里面这样指定：

```javascript
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import * as path from 'path';

@Module({
  imports: [
    ConfigModule.forRoot({
      envFilePath: [path.join(process.cwd(), '.aaa.env'), path.join(process.cwd(), '.env')]
    })
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

前面的配置会覆盖后面的配置。

重新跑一下：

```
npm run start:dev
```
浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46e104548f364a93ad4b8078393558b7~tplv-k3u1fbpfcp-watermark.image?)

可以看到 aaa 是 .aaa.env 里的，bbb 是 .env 里的。

那如果我嫌 .env 里配置不够灵活，想在 ts 文件里配置呢？

@nestjs/config 也是支持的。

我们写一个 config.ts：

```javascript
export default async () => {
    const dbPort = await 3306;

    return {
        port: parseInt(process.env.PORT, 10) || 3000,
        db: {
          host: 'localhost',
          port: dbPort
        }
    }
}
```
这里可以写异步逻辑。

然后引入下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dcfd2a328214392934247f30509b69a~tplv-k3u1fbpfcp-watermark.image?)

在 Controller 里取出来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b19b558b240a47848fcec84d74629fef~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/992a52ef531a4d788756055c86d57d92~tplv-k3u1fbpfcp-watermark.image?)

这样，你可以动态加载配置。

后面将讲微服务的时候，会讲到配置中心，比如 nacos、etcd 这种中间件，到时候配置就是动态获取的。

而且这个配置文件里，你完全可以自己实现 yaml 文件的加载。

```
npm install js-yaml
```
添加一个配置文件 aaa.yaml

```yaml
application:
  host: 'localhost'
  port: 8080

aaa:
   bbb:
    ccc: 'ccc'
    port: 3306
```
然后在 config2.ts 里加载下：

```javascript
import { readFile } from 'fs/promises';
import * as yaml from 'js-yaml';
import { join } from 'path';


export default async () => {
    const configFilePath = join(process.cwd(), 'aaa.yaml');

    const config = await readFile(configFilePath, {
        encoding: 'utf-8'
    });

    return yaml.load(config);
};
```
在 AppModule 引入：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89fee1b48cab4765b577dc25ebbda2b9~tplv-k3u1fbpfcp-watermark.image?)

同样，前面覆盖后面的。

改下 Controller：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/062c1afd220143b081308142547ef6be~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2dce07081404764b3f2cc619729158a~tplv-k3u1fbpfcp-watermark.image?)

这样就正确读取了 yaml 配置。

同理，其他格式的配置也可以这样来自己解析。

此外，@nestjs/config 还提供了 forFeature 方法来返回动态模块。

如果别的模块也需要用到 config 咋办呢？

我们新建一个模块：

```
nest g resource bbb --no-spec
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ddde61b734548789b0ee9ca2f2c9494~tplv-k3u1fbpfcp-watermark.image?)

在 BbbModule 里注入下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0511ebef3004c269086d1becabe14ff~tplv-k3u1fbpfcp-watermark.image?)

跑起来你会发现报错了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a766120890474820a122b4e5122dfe74~tplv-k3u1fbpfcp-watermark.image?)

这个模块找不到 ConfigModule。

这时候把 ConfigModule.forRoot 注册为全局模块就好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4834cef339cd421ebcaf599bd44d6325~tplv-k3u1fbpfcp-watermark.image?)

这样就可以在 BbbModule 读取到配置了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef25346ebe7349f595c36950598e1049~tplv-k3u1fbpfcp-watermark.image?)

此外，你还可以通过 ConfigModule.forFeautrue 来注册局部配置：
```javascript
import { Module } from '@nestjs/common';
import { BbbService } from './bbb.service';
import { BbbController } from './bbb.controller';
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forFeature(() => {
      return {
        ddd: 222
      }
    })
  ],
  controllers: [BbbController],
  providers: [BbbService]
})
export class BbbModule {}
```

BbbController 里读取下：
```javascript
@Get()
findAll() {
    return {
      ccc: this.configService.get('aaa.bbb.ccc'),
      ddd: this.configService.get('ddd')
    }
}
```
可以看到，Nest 读取到了这个局部注册的配置。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af24598541f8481c8165f33e58ba3822~tplv-k3u1fbpfcp-watermark.image?)

这里是再次验证了**动态模块的 forRoot 用于在 AppModule 里注册，一般指定为全局模块，forFeature 用于局部配置，在不同模块里 imports，而 register 用于一次性的配置。**

比如 JwtModule.register、TypeOrmModule.ForRoot、TypeOrmModule.forFeature。

对动态模块不太理解的同学建议回过头去看看第 15 节。

最后我们简单看一下 @nestjs/config 的源码：

先是 forFeature：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/455632aacf7c484f873bf79c289fcc06~tplv-k3u1fbpfcp-watermark.image?)

动态返回模块定义，也就是 providers、exports 这些。

用 useFactory 动态创建了 provider，merge 了局部配置和全局配置。

然后是 forRoot：

它就是根据 options 读取 env 配置，然后用 useFactory 创建 ConfigService 的 provider：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd1558aa3da047a9a98d2812709968e5~tplv-k3u1fbpfcp-watermark.image?)

之后动态返回模块定义：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed008a877f534f5f805a28eb153e6c30~tplv-k3u1fbpfcp-watermark.image?)

还是动态模块那些知识。

案例代码：

[Node 读取 env、yaml 配置文件](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/config-test)

[Nest 通过 Config 模块读取配置文件](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nest-config-test)

## 总结

这节我们学习了配置文件的使用方式，基于 dotenv、js-yaml 可以读取 .env 和 yaml 的配置文件。

我们可以通过 NODE_ENVIRONMENT 来切换不同路径的配置文件，实现开发、生产环境的配置切换。

Nest 提供了 @nestjs/config 包来封装，使用 ConfigModule.forRoot 可以读取 .env 配置文件，然后注入 ConfigService 来取配置。

还可以通过 ConfigModule.forFeature 来注册局部配置。

它的原理也很简单，就是通过 useFactory 动态产生 provider，然后在 forRoot、forFeature 里动态返回模块定义。

学习了 ConfigModule 之后，我们就可以把数据库连接信息、应用启动端口等抽离到配置文件了。


## 67.为什么要使用 Docker Compose ？

我们学习了 Nest、Mysql、Redis，并且在 Nest 里远程连接 Mysql 和 Redis 来做数据存储、增删改查。

Mysql 和 Redis 都是跑在 Docker 容器里的。

部署 Nest 项目的时候也是跑的 dockerfile + docker build 产生的镜像。

这就涉及到了 3 个 Docker 容器：Nest、Mysql、Redis。

后面可能还会涉及到更多的 Docker 容器。

那么问题来了，每次想把项目跑起来都要 docker run 一堆镜像也太麻烦了，有没有什么简便方式呢？

而且，这么多的容器怎么保证启动顺序呢？

解决方式是有的，就是 Docker Compose。

我们先来看看不用 Docker Compose 的时候怎么部署：

```
nest new docker-compose-test -p npm
```

创建个 nest 项目：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/605cf4824e2e47b1bb6ff94efb0941d6~tplv-k3u1fbpfcp-watermark.image?)

安装 tyeporm、mysql2；

```
npm install --save @nestjs/typeorm typeorm mysql2
```
然后在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "aaa",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

```
这里的 database 我们在 mysql workbench 里创建下：

```sql
CREATE DATABASE `aaa` DEFAULT CHARACTER SET utf8mb4 ;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4432b2d708245a4bd0c7af9f5e80491~tplv-k3u1fbpfcp-watermark.image?)

添加一个 aaa.entity.ts

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class Aaa {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 30
    })
    aaa: string;

    @Column({
        length: 30
    })
    bbb: string;
}

```
在 entities 里注册下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffab8b23a32f4fd8979cb48490a7a66a~tplv-k3u1fbpfcp-watermark.image?)

然后把 nest 服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f67676d48e3845c0904e3bb3ae349f57~tplv-k3u1fbpfcp-watermark.image?)

可以看到，执行了 create table 的 sql。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5379c95af8cc4817b937bdd986ecf66c~tplv-k3u1fbpfcp-watermark.image?)

说明 mysql 是连接成功了。

然后再引入 redis：

```
npm install redis 
```

添加一个 redis client 的 provider：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ce80e15241042b8ae8620ef7aa56838~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
  provide: 'REDIS_CLIENT',
  async useFactory() {
    const client = createClient({
        socket: {
            host: 'localhost',
            port: 6379
        }
    });
    await client.connect();
    return client;
  }
}
```

在 AppService 里注入下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb1480197e14ddd8134828b7da1b05a~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { Controller, Get, Inject } from '@nestjs/common';
import { RedisClientType } from 'redis';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject('REDIS_CLIENT')
  private redisClient: RedisClientType;

  @Get()
  async getHello() {
    const keys = await this.redisClient.keys('*');
    console.log(keys);

    return this.appService.getHello();
  }
}

```

这里用到的 mysql、redis 都是之前通过 docker 跑的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1924de5ae5a4a0caa02ede4850aa9da~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f9d8c2c694f436088bea0a027936824~tplv-k3u1fbpfcp-watermark.image?)

忘记怎么跑 msyql 和 redis 的 docker 容器的同学去翻一下这两个的入门章节。

然后访问下 http://localhost:3000

打印了 redis 里的 key：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d67ee74577644431aed5c8f931e1c5bd~tplv-k3u1fbpfcp-watermark.image?)

在 RedisInsight 里看到的也是这些：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b22ee301fd0a4004aef56cd20fff23eb~tplv-k3u1fbpfcp-watermark.image?)

这就说明 redis 服务连接成功了。

这里就不写具体的业务逻辑了。

假设我们 nest 服务开发完了，想部署，那就要写这样的 dockerfile：

```docker
FROM node:18.0-alpine3.14 as build-stage

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18.0-alpine3.14 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm install --production

EXPOSE 3000

CMD ["node", "/app/main.js"]
```
用多阶段构建的方式，最后只保留生产阶段的镜像。

用 alpine 的基础镜像，体积会减小很多。

这些前面讲过。

在根目录添加这个 Dockerfile，然后 docker build 一下：

```
docker build -t eee .
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94a3329575324bc0a0c02011a7cac33a~tplv-k3u1fbpfcp-watermark.image?)

（我这里稍微有点久，用了 200 多秒）

在 docker desktop 里可以看到这个镜像：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3c1ce7e132d4982bc342844ce51d18a~tplv-k3u1fbpfcp-watermark.image?)

那假设在服务器上，要怎么部署这个 nest 应用呢？

我们先把 mysql、redis 的容器停掉。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f6b24fc03b4839a5ea28e286517d71~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671d1a8ee3f4414a8eba2596360273c0~tplv-k3u1fbpfcp-watermark.image?)

在服务器上，是没有 docker desktop 的，所以接下来我们通过命令行的方式：

先跑 mysql 的 docker 容器：

```
docker run -d -p 3306:3306 -v /Users/guang/mysql-data:/var/lib/mysql --name mysql-container mysql
```
-d 是 deamon，放到后台运行的意思。

-p 是端口映射

-v 是挂载数据卷，把宿主机目录映射到容器内的目录（这里要换成你自己的）

-name 是容器名

可能还需要指定环境变量：

-e MYSQL\_ROOT\_PASSWORD=xxx 设置 root 用户的密码

因为我之前跑过，在数据卷的那个目录有之前的设置，所以不用设置了。

跑起来可以看到容器 id：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cb7a522c2b54c21af4d20f6f2c43bca~tplv-k3u1fbpfcp-watermark.image?)

然后再跑下 redis 的 docker 容器：

```
docker run -d -p 6379:6379 -v /Users/guang/aaa:/data --name redis-container redis
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d3b54904a3546268e8a2ac4239d1f3d~tplv-k3u1fbpfcp-watermark.image?)

之后跑 nest 的：
```
docker run -d -p 3000:3000 --name nest-container eee
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7d176fbfecb4c7e9d1ef4a7d147f220~tplv-k3u1fbpfcp-watermark.image?)

看下 3个容器的日志

```
docker logs mysql-container
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1637f6b2408c4cf298bcd29c16bc34e0~tplv-k3u1fbpfcp-watermark.image?)
```
docker logs redis-container
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0a9bdd7e7f649c7be8a487384dbf74a~tplv-k3u1fbpfcp-watermark.image?)

```
docker logs nest-container
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f40f55af90a8457c9ab46a20d98571e6~tplv-k3u1fbpfcp-watermark.image?)

这时候你会发现报错了，说是 127.0.0.1 的 6379 端口连不上。

为什么呢？

因为这时候 127.0.0.1 就是容器内的端口了，不是宿主机的。

所以要把 ip 换成宿主机 ip 才行。

查一下本机的 ip 地址：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e9a55534fcf4378bcf3a937334e81ca~tplv-k3u1fbpfcp-watermark.image?)

然后把 AppModule 里的 redis 和 mysql 连接信息改一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e73db614ebfc41d9a3ad32206755446a~tplv-k3u1fbpfcp-watermark.image?)

之后重新 build 一个镜像：
```
docker build -t fff .
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6f2ae1846d84028828b6ee20309f750~tplv-k3u1fbpfcp-watermark.image?)

这次构建用了 120s，比上次快，因为本地有缓存了。

把之前的容器删掉：

```
docker rm nest-container
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8efc3eea23c14e2d8e3251c0125c571f~tplv-k3u1fbpfcp-watermark.image?)

然后在数据库里把 aaa这个表删掉：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/274afd50569d42cd87f63b9d95fd0925~tplv-k3u1fbpfcp-watermark.image?)

再跑 nest 容器：

```
docker run -d -p 3000:3000 --name nest-container fff
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cabd753e7f404c868ad883e2fa00dca0~tplv-k3u1fbpfcp-watermark.image?)


这时候再查看日志：

```
docker logs nest-container
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a446a7c7e1b147e6b4769188198c039d~tplv-k3u1fbpfcp-watermark.image?)

这时候就正常了。

可以看到 sql 打印是正确的。

表也创建成功了：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e04bed2e7c4e82b7b94ffa473c83e5~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下 http://localhost:3000

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a8c60731a694f61a6121ce61568c5cb~tplv-k3u1fbpfcp-watermark.image?)

再次 docker logs 看看：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b65399e20ab5413385bb1d83d784ef59~tplv-k3u1fbpfcp-watermark.image?)

可以看到 redis 服务也连接成功了。

这样我们就把 mysql、redis、nest 3个 docker 容器跑了起来。

可以发现我们跑了 3 次  docker build，而且还要注意顺序，不然 nest 服务跑起来了，但是 mysql 服务没跑起来，就会报错。

前面说，docker compose 可以解决这种问题。

怎么解决呢？

把 3 个容器停掉：

```
docker stop nest-container mysql-container redis-container
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e5ab3e72ccb47d9bd144fdf785ec4d2~tplv-k3u1fbpfcp-watermark.image?)

然后在根目录添加一个 docker-compose.yml

```yaml
services:
  nest-app:
    build:
      context: ./
      dockerfile: ./Dockerfile
    depends_on:
      - mysql-container
      - redis-container
    ports:
      - '3000:3000'
  mysql-container:
    image: mysql
    ports:
      - '3306:3306'
    volumes:
      - /Users/guang/mysql-data:/var/lib/mysql
    environment:
      MYSQL_DATABASE: aaa
      MYSQL_ROOT_PASSWORD: guang
  redis-container:
    image: redis
    ports:
      - '6379:6379'
    volumes:
      - /Users/guang/aaa:/data
```
每个 services 都是一个 docker 容器，名字随便指定。

这里指定了 nest-app、mysql-container、reids-container 3 个service：

然后 nest-app 配置了 depends_on 其他两个 service。

这样 docker-compose 就会先启动另外两个，再启动这个，这样就能解决顺序问题。

然后 mysql-container、redis-container 的 service 指定了 image 和 ports、volumes 的映射，这些都很容易看懂。

mysql 容器跑的时候还要指定 MYSQL_DATABASE 和 MYSQL_ROOT_PASSWORD 环境变量。

MYSQL_ROOT_PASSWORD 是 root 用户的密码，MYSQL_DATABASE 是会自动创建的 database。

nest-app 指定了 context 下的 dockerfile 路径，端口映射。

然后我们通过 docker-compose 把它跑起来：

```
docker-compose up
```
docker-compose 和 docker 命令是一起的，docker 能用，docker-compose 就能用。


它会把所有容器的日志合并输出：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/263e9946b8584f129f59bb1b2c0ddc40~tplv-k3u1fbpfcp-watermark.image?)

可以看到是先跑的 mysql、redis，再跑的 nest。

只不过 mysql 服务启动有点慢，会连接失败几次。

最后是会成功的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/385d1bf97b8f4afa81e61d1d42cd9ba5~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下 http://localhost:3000


![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/110be8842ddf493489526791d351dd88~tplv-k3u1fbpfcp-watermark.image?)

可以看到 redis 也连接成功了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bc2e7573a9b424aa10551ad3d6bdfe4~tplv-k3u1fbpfcp-watermark.image?)

这样，我们只需要定义 docker-compose.yaml 来声明容器的顺序和启动方式，之后执行 docker-compose up 一条命令就能按照顺序启动所有的容器。

启动流程就简便了很多。

这就是 docker-compose 的意义。

这时候如果你去 docker desktop 里看下，会发现它有专门的显示方式：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ed7de84c738426caf96b938b8a8018e~tplv-k3u1fbpfcp-watermark.image?)

多个容器可以一起管理。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/docker-compose-test)。

## 总结

这节我们通过 docker、docker-compose 两种方式来部署了 nest 项目。

docker 的方式需要手动 docker build 来构建 nest 应用的镜像。

然后按顺序使用 docker run 来跑 mysql、redis、nest 容器。

（要注意 nest 容器里需要使用宿主机 ip 来访问 mysql、redis 服务）

而 docker compose 就只需要写一个 docker-compose.yml 文件，配置多个 service 的启动方式和 depends_on 依赖顺序。

然后 docker-compose up 就可以批量按顺序启动一批容器。

基本上，我们跑 Nest 项目都会依赖别的服务，所以在单台机器跑的时候都是需要用 Docker Compose 的。


## 68.Docker 容器通信的最简单方式：桥接网络

上节我们讲 Docker Compose 的时候，涉及到多个 docker 容器的通信，我们是通过指定宿主机 ip 和端口的方式。

因为 mysql、redis 的 Docker 容器都映射到了宿主机的端口，那 nest 的容器就可以通过宿主机来实现和其他容器的通信。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ec74df386ed40b288a6dfad49189207~tplv-k3u1fbpfcp-watermark.image?)

Docker 的实现原理那节我们讲过，Docker 通过 Namespace 的机制实现了容器的隔离，其中就包括 Network Namespace。

因为每个容器都有独立的 Network Namespace，所以不能直接通过端口访问其他容器的服务。

那如果这个 Network Namespace 不只包括一个 Docker 容器呢？？

可以创建一个 Network Namespace，然后设置到多个 Docker 容器，这样这些容器就在一个 Namespace 下了，不就可以直接访问对应端口了？

Docker 确实支持这种方式，叫做桥接网络。

通过 docker network 来创建：

```
docker network create common-network
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b0581641e5434bb7d39f52bad1dcab~tplv-k3u1fbpfcp-watermark.image?)

然后把之前的 3 个容器停掉、删除，我们重新跑：

```
docker stop mysql-container redis-container nest-container
docker rm mysql-container redis-container nest-container
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83ed97967b064613a7580c3bfa4776b8~tplv-k3u1fbpfcp-watermark.image?)

这次跑的时候要指定 --network：

```
docker run -d --network common-network -v /Users/guang/mysql-data:/var/lib/mysql --name mysql-container mysql
```

通过 --network 指定桥接网络为我们刚创建的 common-network。

不需要指定和宿主机的端口映射。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76daaa4894f54a5babcc1c9eb0024716~tplv-k3u1fbpfcp-watermark.image?)

然后跑 redis 容器：

```
docker run -d --network common-network -v /Users/guang/aaa:/data --name redis-container redis
```

同样也不需要指定和宿主机的端口映射，只需要指定挂载的数据卷就行：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6a084dc7a1f451c94ef591530a1b1eb~tplv-k3u1fbpfcp-watermark.image?)

然后 nest 的部分我们要改下代码：

修改 AppModule 的代码，改成用容器名来访问：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfd1c28f8d8f467398fdaae85387dab0~tplv-k3u1fbpfcp-watermark.image?)

然后 docker build：

```
docker build -t mmm .
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfa5e880fcb7409194a0f7cefee04c5e~tplv-k3u1fbpfcp-watermark.image?)

之后 docker run：

```
docker run -d --network common-network -p 3000:3000 --name nest-container mmm
```
nest 容器是要指定和宿主机的端口映射的，因为宿主机要访问这个端口的网页。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72e7c09eae574150910c0e1091f8cb00~tplv-k3u1fbpfcp-watermark.image?)

然后 docker logs 看下日志：

```
docker logs nest-container
```
可以看到打印了 sql 语句，说明 mysql 连接成功了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da2df480dfd543eb8e082d1e196c3c82~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问 http://localhost:3000

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9793e4d7c6fd4643b3daab58a2419b31~tplv-k3u1fbpfcp-watermark.image?)

然后再看下日志：

```
docker logs nest-container
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25f6c35c4f5a440da7eff023b5859651~tplv-k3u1fbpfcp-watermark.image?)

打印了 redis 的 key 说明 redis 服务也连接成功了。

这就是桥接网络。

之前我们是通过宿主机 ip 来互相访问的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0bde70cdfc84cc0bb5c34b315e720a6~tplv-k3u1fbpfcp-watermark.image?)

现在可以通过容器名直接互相访问了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe510871bfe463e91d5bcf0c62bd10f~tplv-k3u1fbpfcp-watermark.image?)

原理前面讲过，就是 Namespace。

本来是 3 个独立的 Network Namespace：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfd1e150584e474abded84fc4d723f36~tplv-k3u1fbpfcp-watermark.image?)

桥接之后就这样了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5399801f540f4ec685bbe4826f1ecb4d~tplv-k3u1fbpfcp-watermark.image?)

Namespace 下包含多个子 Namespace，互相能通过容器名访问。

比起端口映射到宿主机，再访问宿主机 ip 的方式，简便太多了。

那在 Docker Compose 里怎么使用这种方式呢？

之前我们是这样写的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34ef19cd837f4ea384455edb1d5be88e~tplv-k3u1fbpfcp-watermark.image?)

现在改成这样：

```yml
version: '3.8'
services:
  nest-app:
    build:
      context: ./
      dockerfile: ./Dockerfile
    depends_on:
      - mysql-container
      - redis-container
    ports:
      - '3000:3000'
    networks:
      - common-network
  mysql-container:
    image: mysql
    volumes:
      - /Users/guang/mysql-data:/var/lib/mysql
    environment:
      MYSQL_DATABASE: aaa
      MYSQL_ROOT_PASSWORD: guang
    networks:
      - common-network
  redis-container:
    image: redis
    volumes:
      - /Users/guang/aaa:/data
    networks:
      - common-network
networks:
  common-network:
    driver: bridge
```
version 是指定 docker-compose.yml 的版本，因为不同版本配置不同。

把 mysql-container、redis-container 的 ports 映射去掉，指定桥接网络为 common-network。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595343b3d0d8486c89956efacebcc0bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=1092&s=139769&e=png&b=1f1f1f)

然后下面通过 networks 指定创建的 common-network 桥接网络，网络驱动程序指定为 bridge。

其实我们一直用的网络驱动程序都是 bridge，它的含义是容器的网络和宿主机网络是隔离开的，但是可以做端口映射。比如 -p 3000:3000、-p 3306:3306 这样。

然后执行：

```
docker-compose down --rmi all
```

就会删除 3 个容器和它们的镜像：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e414c34add64f10a3409775e9028143~tplv-k3u1fbpfcp-watermark.image?)

之后再 

```
docker-compose up
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047d3b091aff45d0bf09ae7e01a1ed06~tplv-k3u1fbpfcp-watermark.image?)

可以看到，会先 build dockerfile 产生镜像，然后把 3 个镜像跑起来。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d8b98c4077f44f0ad7886d184d11a27~tplv-k3u1fbpfcp-watermark.image?)

看到打印的 sql 说明 mysql 服务连接成功了。

（这个过程可能因为 mysql 容器没跑起来而连接失败几次，等一会就好了）

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b7e105654dd489aa5b3cecc915d1b4e~tplv-k3u1fbpfcp-watermark.image?)

也拿到了 redis 的 key，说明 redis 服务跑成功了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1018ec77ff224a438bcb09f6d7744b58~tplv-k3u1fbpfcp-watermark.image?)

这就是在 docker-compose 里使用桥接网络的方式。

不过，其实不指定 networks 也可以，docker-compose 会创建个默认的。

先把容器、镜像删掉：
```
docker-compose down --rmi all
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/809e549f3c4c45bfa53b8f5b39402348~tplv-k3u1fbpfcp-watermark.image?)

把 networks 部分注释掉，重新跑：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eef9726f71e347be8cb8ae6cd94a10f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=738&h=1094&s=135173&e=png&b=1f1f1f)

你会发现它创建了一个默认的 network：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb214c9e8ab24a01ba79eac6f4b09148~tplv-k3u1fbpfcp-watermark.image?)

mysql 和 redis 的访问都是正常的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/263868b2d76b4c5ba842a82dc140e0b9~tplv-k3u1fbpfcp-watermark.image?)

所以，不手动指定 networks，也是可以用桥接网络的。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/docker-compose-test)。

## 总结

上节我们是把 mysql、redis 的端口映射到宿主机，然后 nest 的容器里通过宿主机 ip 访问这两个服务的。

但其实有更方便的方式，就是桥接网络。

通过 docker network create 创建一个桥接网络，然后 docker run 的时候指定 --network，这样 3 个容器就可以通过容器名互相访问了。

在 docker-compose.yml 配置下 networks 创建桥接网络，然后添加到不同的 service 上即可。

或者不配置 networks，docker-compose 会生成一个默认的。

实现原理就是对 Network Namespace 的处理，本来是 3个独立的 Namespace，当指定了 network 桥接网络，就可以在 Namespace 下访问别的 Namespace 了。

多个容器之间的通信方式，用桥接网络是最简便的。


## 69.Docker 支持重启策略，是否还需要 PM2

前面我们学习了 Docker、Docker Compose，并在 Docker 容器里通过 pm2-runtime 来跑的 node 服务。

主要是用 pm2 可以在进程崩溃的时候重启进程的功能。

而其实这个功能 Docker 也是有的。

我们来试一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79d19e3ae36b43db873c883bfed5e831~tplv-k3u1fbpfcp-watermark.image?)

```javascript
setTimeout(() => {
    throw new Error('xxx');
}, 1000);
```
1s 以后抛一个错误，进程会终止。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b01b5671e64c49d8bbac08b0351a6937~tplv-k3u1fbpfcp-watermark.image?)

然后我们把它放到 Docker 容器里跑。

写个 dockerfile：

```docker
FROM node:18-alpine3.14

WORKDIR /app

COPY ./index.js .

CMD ["node", "/app/index.js"]
```
然后构建成镜像：

```shell
docker build -t restart-test:first .
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30be5a3744f6419a835911a927f6e0d9~tplv-k3u1fbpfcp-watermark.image?)

在 docker desktop 里可以看到：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/442eb01bbb4f480199d473cf41d87c0e~tplv-k3u1fbpfcp-watermark.image?)

然后把它跑起来：

```
docker run --name=restart-test-container restart-test:first
```
可以看到，容器 1s 后就停掉了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b27ad9f647c84e7c8b52644a5831f0cd~tplv-k3u1fbpfcp-watermark.image?)

当进程退出的时候，容器也会停止。

docker run 的时候也可以指定重启策略：
```
docker run -d --restart=always --name=restart-test-container2 restart-test:first
```
这次加上 -d 把它放到后台跑。

--restart 指定总是重启。

然后你在 docker desktop 里就可以看到它一直在 restart：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3588c2f8a4964de09fb232ce2b1d172e~tplv-k3u1fbpfcp-watermark.image?)

打印了很多次错误日志：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d9da6312cb0441bbe32c69d0f787564~tplv-k3u1fbpfcp-watermark.image?)

你可以点击停止，就不会再重启了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4d553a0a8cf465ab25bc1b1eaa40f51~tplv-k3u1fbpfcp-watermark.image?)

这就是 docker 的自动重启功能。

前面说过，pm2 也可以自动重启。

我们试试：

新建个 222.Dockerfile:

```docker
FROM node:18-alpine3.14

WORKDIR /app

COPY ./index.js .

RUN npm install -g pm2

CMD ["pm2-runtime", "/app/index.js"]

```
然后 build 一下，生成镜像：

```
docker build -t restart-test:second -f 222.Dockerfile .
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eae0f072c6ce4622b6c46733dd27db78~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9fcfa27f56a4cb69ea935a28679b29b~tplv-k3u1fbpfcp-watermark.image?)

然后跑一下：
```
docker run -d --name=restart-test-container3 restart-test:second
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ad67906ce364991acbe830204e06aff~tplv-k3u1fbpfcp-watermark.image?)

这时候你会发现容器一直是运行状态，但是内部的进程一直在重启：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caf61e221d2c4f76a5efc38e0694f5e5~tplv-k3u1fbpfcp-watermark.image?)

也就是说，Docker 的自动重启功能和 PM2 的自动重启功能是重合的。

那还有必要用 PM2 么？

其实 PM2 诞生的时候是没有 Docker 这种容器技术的，那时候都是直接部署在机器上，这时候自然需要一个进程管理工具来做进程的重启、负载均衡等功能。这是 PM2 当年很流行的原因。

但后来有了 Docker，里面跑的进程崩溃之后，Docker 容器支持自动重启。

所以，大多数情况下，没必要再用 PM2 了。

而且如果你用了 K8S 这种容器编排工具，那更没必要用 PM2 了，直接让 K8S 去调度、重启容器就可以。

但也有另一种说法，Docker 重新跑容器的成本，是比容器内 PM2 重新跑进程的成本高的，所以用 PM2 来管理进程更好一点。

综上，有了 Docker 基本没大有必要用 PM2 了。但如果单独跑 Docker 容器，还是可以结合 pm2-runtime 来提高重启速度的。

然后我们继续来看 Docker 的重启策略：

默认是 no，也就是不自动重启。

我们测试了 always，是容器退出时总是重启。

其实还有 on-failure 和 unless-stopped 这两种：

on-failure 是只有在非正常退出的时候才重启，相比之下，always 不管是不是非正常退出都重启。

而且 on-failure 还可以指定最多重启几次，比如 on-failure:3 是最多重启三次。

我们试一下：

```
docker run -d --restart=on-failure:2 --name=restart-test-container4 restart-test:first
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2f20974e8414438baf8e031343884fd~tplv-k3u1fbpfcp-watermark.image?)

可以看到容器重启了 2 次，一共打印了 3 次错误就不再重启了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aecb683f615e4df5817857492d662dcd~tplv-k3u1fbpfcp-watermark.image?)

再来试试 unless-stopped：

unless-stopped 是除非手动停止，否则总是会重启。

```
docker run -d --restart=unless-stopped --name=restart-test-container5 restart-test:first
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44c481d7b3a14646afeeca1869242df1~tplv-k3u1fbpfcp-watermark.image?)

可以看到容器一直在重启：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ee727df0f3c4255b288997a0bacd872~tplv-k3u1fbpfcp-watermark.image?)

除非点击停止按钮，也就是执行 docker stop 才会停止：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23e73caafe1f4b8d9da4fa258043fa37~tplv-k3u1fbpfcp-watermark.image?)

```
docker stop restart-test-container5
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37f82a673df44b2dba54dad27b47406c~tplv-k3u1fbpfcp-watermark.image?)


![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cb0ae15b4864ca2bc211e985e86522e~tplv-k3u1fbpfcp-watermark.image?)

那看起来和 always 也没啥区别呀，都是只有手动 stop 才能停止，否则一直重启。

还是有区别的，就是在 Docker Deamon 重启的时候。

现在 docker-test-container2 是用的 always 的重启策略，docker-test-container5 是用的 unless-stopped 的重启策略:

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c10f4ad725ac4f949ca99d498df45cfe~tplv-k3u1fbpfcp-watermark.image?)

这俩容器都停掉了。

现在我们重启 Docker：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c795fc3e9b67418eb32ccc804f7148d5~tplv-k3u1fbpfcp-watermark.image?)

他会重启跑 Docker Engine ，也就是 Docker Deamon 的后台进程。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86d55f34b6e5426f87d014a701f97578~tplv-k3u1fbpfcp-watermark.image?)

这时候你会发现，always 重启策略的容器又跑起来了，而 unless-stopped 的容器没有重启。这就是这俩的区别：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daf46a72601f43af877f5b6eee7dff41~tplv-k3u1fbpfcp-watermark.image?)

Docker Compose 是用于同时跑多个 Docker 容器的，它自然也支持 restart 的配置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c171bb5150949c5b1657523e6b96799~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/docker-restart-test)。

## 总结

Docker 是支持自动重启的，可以在 docker run 的时候通过 --restart 指定重启策略，或者 Docker Compose 配置文件里配置 restart。

有 4 种重启策略：

- no: 容器退出不自动重启（默认值）
- always：容器退出总是自动重启，除非 docker stop。
- on-failure：容器非正常退出才自动重启，还可以指定重启次数，如 on-failure:5
- unless-stopped：容器退出总是自动重启，除非 docker stop

重启策略为 always 的容器在 Docker Deamon 重启的时候容器也会重启，而 unless-stopped 的不会。

其实我们用 PM2 也是主要用它进程崩溃的时候重启的功能，而在有了 Docker 之后，用它的必要性就不大了。

当然，进程重启的速度肯定是比容器重启的速度快一些的，如果只是 Docker 部署，可以结合 pm2-runtime 来做进程的重启。

绝大多数情况下，直接用 Docker 跑 node 脚本就行，不需要 PM2。


## 7.使用多种 Provider，灵活注入对象

Nest 实现了 IoC 容器，会从入口模块开始扫描，分析 Module 之间的引用关系，对象之间的依赖关系，自动把 provider 注入到目标对象。

而这个 provider 也有好几种，这节我们就来看一下。

我们创建个 nest 项目：

```
nest new custom-provider
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5387a7abd38847dd81d041295bc9752f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=848&h=686&s=275790&e=png&b=020202)

可以看到 AppService 是被 @Injectable 修饰的 class：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/503ed384731f4ec2b3ffcd7398884917~tplv-k3u1fbpfcp-watermark.image?)

在 Module 的 providers 里声明：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6d42361e0b547ec848f337f674c27ec~tplv-k3u1fbpfcp-watermark.image?)

这就是 provider。

其实这是一种简写，完整的写法是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d89fe1295f4898b8efb818cbcf022e~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
  provide: AppService,
  useClass: AppService
}
```

通过 provide 指定 token，通过 useClass 指定对象的类，Nest 会自动对它做实例化后用来注入。

在 AppController 的构造器里参数里声明了 AppService 的依赖，就会自动注入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eecb757fc96c43d9ad3bb166eeec2393~tplv-k3u1fbpfcp-watermark.image?)

如果不想用构造器注入，也可以属性注入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10fad8a2e44c466999a1615b6b561166~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Inject(AppService)
private readonly appService: AppService;
```

通过 @Inject 指定注入的 provider 的 token 即可。

有的同学说，在构造器参数里指定 AppService 的依赖的时候也没指定 token 啊？

那是因为 AppService 这个 class 本身就是 token。

当然，这个 token 也可以是字符串：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0805d65c9d074b5c85288d73928f6e39~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
    provide: 'app_service',
    useClass: AppService
}
```

如果 token 是字符串的话，注入的时候就要用 @Inject 手动指定注入对象的 token 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb6d3baa60634eb1845d6759e90c51c5~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Inject('app_service') private readonly appService: AppService
```

我们调试下：

点击调试面板的 create launch.json file，创建调试配置文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/541ac1195d0643789f05b1751ad27d71~tplv-k3u1fbpfcp-watermark.image?)

添加这样一个调试配置：

```json
{
    "type": "node",
    "request": "launch",
    "name": "debug nest",
    "runtimeExecutable": "npm",
    "args": [
        "run",
        "start:dev",
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "console": "integratedTerminal",
}
```
在 getHello 方法打个断点，点击调试启动：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c4ead0a6f2f4090bfbdae01458094d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1446&h=1080&s=136411&e=png&b=1c1c1c)

浏览器访问 http://localhost:3000 ，代码会在断点处断住。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a56e26fbc724b3ebcc184eb7eb7dd5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1872&h=1310&s=328087&e=png&b=1c1c1c)

可以看到，这时候 appService 就有值了。

也就是说，用字符串或者 class 做 token 的 provider，都可以正确被注入到目标对象。

相比之下，用 class 做 token 可以省去 @Inject，比较简便。

除了指定 class 外，还可以直接指定一个值，让 IoC 容器来注入。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/572363326c364b05ac54a72b0c84b2b7~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
    provide: 'person',
    useValue: {
        name: 'aaa',
        age: 20
    }
}
```

使用 provide 指定 token，使用 useValue 指定值。

然后在对象里注入它：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/861e16c386de4bc783d0c617414afc1d~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Inject('person') private readonly person: {name: string, age: number}
```

调试一下可以看到，确实是注入了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4111c661544e43e8b84cd55aa64a3891~tplv-k3u1fbpfcp-watermark.image?)

provider 的值可能是动态产生的，Nest 也同样支持：

```javascript
{
    provide: 'person2',
    useFactory() {
        return {
            name: 'bbb',
            desc: 'cccc'
        }
    }
}
```

我们可以使用 useFactory 来动态创建一个对象。

在对象里注入：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1533e1b359f48268f04a15849242849~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Inject('person2') private readonly person2: {name: string, desc: string}
```

类型是 {name: string, age: number} 。

调试下，也是可以拿到创建出的对象的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3700565f2434399a4debd44cd7890fe~tplv-k3u1fbpfcp-watermark.image?)

这个 useFactory 支持通过参数注入别的 provider：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6f2d3acc1144107bd8c20e8f0c6a1dc~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
  provide: 'person3',
  useFactory(person: { name: string }, appService: AppService) {
    return {
      name: person.name,
      desc: appService.getHello()
    }
  },
  inject: ['person', AppService]
}
```

通过 inject 声明了两个 token，一个是字符串 token 的 person，一个是 class token 的 AppService。

也就是注入这两个 provider：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16f838981da41838058d98c46ed28b2~tplv-k3u1fbpfcp-watermark.image?)

在 return 那里打个断点。

可以看到，在调用 useFactory 方法的时候，Nest 就会注入这两个对象：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d5adad4b3243c0938373a8ec7fc614~tplv-k3u1fbpfcp-watermark.image?)

useFactory 支持异步：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/395855d591fa4170a3b6cf22c5b6e16e~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
  provide: 'person5',
  async useFactory() {
    await new Promise((resolve) => {
      setTimeout(resolve, 3000);
    });
    return {
      name: 'bbb',
      desc: 'cccc'
    }
  },
},
```
Nest 会等拿到异步方法的结果之后再注入：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feec815403a24b4a876edebc9d766786~tplv-k3u1fbpfcp-watermark.image?)

这样就可以更灵活的创建注入对象。

此外，provider 还可以通过 useExisting 来指定别名：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b7c4ae6ba8a49fdbea47270b7745c01~tplv-k3u1fbpfcp-watermark.image?)

```javascript
{
  provide: 'person4',
  useExisting: 'person2'
}
```

这里就是给 person2 的 token 的 provider 起个新的 token 叫做 person4。

然后就可以用新 token 来注入了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84b3884c85434ee78f9ec36c4584798d~tplv-k3u1fbpfcp-watermark.image?)

这些自定义 provider 的方式里，最常用的是 useClass，不过我们一般会用简写，也就是直接指定 class。

useClass 的方式由 IoC 容器负责实例化，我们也可以用 useValue、useFactory 直接指定对象。

useExisting 只是用来起别名的，有的场景下会用到。

比如 @nestjs/typeorm 里就用到了 useValue、useFactory、useExisting：

它用 useValue 来[注入一段字符串](https://github.com/nestjs/typeorm/blob/153da09a384fdbf797b66e4500b69a72a7a47b78/lib/typeorm-core.module.ts#L113-L116)：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15215da691aa4fb5b52e38c20b7cdaa7~tplv-k3u1fbpfcp-watermark.image?)

用 useFactory 根据传入的 options [动态创建数据库连接对象](https://github.com/nestjs/typeorm/blob/153da09a384fdbf797b66e4500b69a72a7a47b78/lib/typeorm-core.module.ts#L83-L101)：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cbc4ddcecee4f8e89f089af85fa77a1~tplv-k3u1fbpfcp-watermark.image?)

用 useExisting 给 DataSource 起了一个 Connection 的[别名](https://github.com/nestjs/typeorm/blob/153da09a384fdbf797b66e4500b69a72a7a47b78/lib/typeorm-core.module.ts#L68-L71)：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f45fa90bb49943e18db58300fc5cf8ad~tplv-k3u1fbpfcp-watermark.image?)

这里是一个版本用了 Connection，一个版本用了 DataSource，通过 useExisting 起别名就可以兼容两者。

此外，如果觉得构造器注入写起来不方便，可以使用属性注入，效果一样：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a058deb301c0444fa650bd68cde366fb~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1754ddc10e9144efbd79921cfb62ea05~tplv-k3u1fbpfcp-watermark.image?)

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/custom-provider)。

## 总结

一般情况下，provider 是通过 @Injectable 声明，然后在 @Module 的 providers 数组里注册的 class。

默认的 token 就是 class，这样不用使用 @Inject 来指定注入的 token。

但也可以用字符串类型的 token，不过注入的时候要用 @Inject 单独指定。

除了可以用 useClass 指定注入的 class，还可以用 useValue 直接指定注入的对象。

如果想动态生成对象，可以使用 useFactory，它的参数也注入 IOC 容器中的对象，然后动态返回 provider 的对象。

如果想起别名，可以用 useExisting 给已有的 token，指定一个新 token。

灵活运用这些 provider 类型，就可以利用 Nest 的 IOC 容器中注入任何对象。




## 70.快速掌握 Nginx 的 2 大核心用法

Nginx 是流行的服务器，一般用它对静态资源做托管、对动态资源做反向代理。

Docker 是流行的容器技术，里面可以跑任何服务。

那 Docker + Nginx 如何结合使用呢？

我们来试一下：

搜索 nginx（这一步需要科学上网，因为要访问 hub.docker.com 这个网站），点击 run：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00e5aee594134afaa61f694318f5e5bc~tplv-k3u1fbpfcp-watermark.image?)

输入容器名和要映射的端口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdd09b12aa0f44cb81391d4fa6f01c6d~tplv-k3u1fbpfcp-watermark.image?)

这里把宿主机的 81 端口映射到容器内的 80 端口，点击 run。

这时候就可以看到 docker 容器跑起来了，并且打印了日志：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1b47a61ffd84ff898466f5f4654c0dd~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下 http://localhost:81 可以看到 nginx 欢迎页面：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380ba9b4dd2d4498902b283388b4b3e8~tplv-k3u1fbpfcp-watermark.image?)

这很明显是容器里跑的服务。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd728ed4ac9d431ba4cf54e1bceae23d~tplv-k3u1fbpfcp-watermark.image?)

但是现在的页面是默认的，我想用 nginx 来托管我的一些静态 html 页面怎么做呢？

首先我们要知道现在的配置文件和页面都存在哪里。

在 files 面板可以看到容器内的文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b8ade092f38457db1008e9a55297fd3~tplv-k3u1fbpfcp-watermark.image?)

里面的 /usr/share/nginx/html/ 目录下面就是所有的静态文件。

双击点开 index.html 看看：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73d1299c10e240f0ad1a1f1785f2e13e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cc53d2060d34cfcaed74eb31f86e5cf~tplv-k3u1fbpfcp-watermark.image?)

和我们浏览器看到的页面一毛一样。

也就是说，这个目录就是保存静态文件的目录。

那我们在这个目录下放我们自己的 html 不就行了？

我们先把这个目录复制出来：

```
docker cp  nginx1:/usr/share/nginx/html ~/nginx-html
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b38b7faccaa4752985f081949c04792~tplv-k3u1fbpfcp-watermark.image?)

docker cp 这个命令就是用于在宿主机和容器之间复制文件和目录的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc75fa0808d94a38bd70c2ea2ec4a17b~tplv-k3u1fbpfcp-watermark.image?)

比如我们把这个目录再复制到容器里：

```
docker cp  ~/nginx-html nginx1:/usr/share/nginx/html-xxx
```

可以看到容器内就多了这个目录：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9d8e208251844b2a3575c62abaac702~tplv-k3u1fbpfcp-watermark.image?)

然后我们在这个目录下添加两个 html 来试试看：

```
echo aaa > aaa.html

echo bbb > bbb.html

docker cp  ~/nginx-html nginx1:/usr/share/nginx/html
````
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7daa21fa354e42adbdfa34faf75403a6~tplv-k3u1fbpfcp-watermark.image?)

但当目标目录存在的时候，docker 会把他复制到目标目录下面：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bb689cf738f4647ab093fa723b9b77e~tplv-k3u1fbpfcp-watermark.image?)

我们需要先删除容器的这个目录，再复制：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99795389649d4cd3b5c6c884d0cafef9~tplv-k3u1fbpfcp-watermark.image?)

```
docker cp  ~/nginx-html nginx1:/usr/share/nginx/html
```
这样就好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8207eb74aef344d89cc22bb6b6cee6a0~tplv-k3u1fbpfcp-watermark.image?)

然后浏览器访问下试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9bb908bd3ad4a46b9d82c46e29d0a49~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1cc464e9b624b5e91da817f6c29e481~tplv-k3u1fbpfcp-watermark.image?)

现在就可以访问容器内的这些目录了。

也就是说只要放到 /usr/share/nginx/html 下的文件，都可以通过被访问到。

可是为什么呢？

这是因为 nginx 的默认配置。

我们看下 nginx 配置文件，也就是 /etc/nginx/nginx.conf。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e68093260f174d06baedfb91a4577cf8~tplv-k3u1fbpfcp-watermark.image?)

复制出来看看：

```
docker cp  nginx1:/etc/nginx/nginx.conf ~/nginx-html
```

这是就是 nginx 的默认配置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/034c6eddb15049ff97bc2d82ba9737ea~tplv-k3u1fbpfcp-watermark.image?)

其实这个 nginx.conf 叫做主配置文件，里面一般做一些全局的配置，比如错误日志的目录等等。

可以看到 http 下面有个 include 引入了 /etc/nginx/conf.d/*.conf 的配置。

一般具体的路由配置都是在这些子配置文件里。

目录 conf.d 是 configuration directory 的意思。

我们把这个目录也复制出来看看：

```
docker cp  nginx1:/etc/nginx/conf.d ~/nginx-html
```

这里面就配置了 localhost:80 的虚拟主机下的所有路由。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0c567876af4ce8862b20c213d31613~tplv-k3u1fbpfcp-watermark.image?)

虚拟主机是什么呢？

就是可以用一台 nginx 服务器来为多个域名和端口的提供服务。

只要多加几个 server 配置就可以。

这里我们就配置 localhost:80 这一个虚拟主机。

下面的 location 就是路由配置。

比如这个配置：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a090ca1b6a184825870c24c92929dd53~tplv-k3u1fbpfcp-watermark.image?)

它就配置了 / 下的所有路由，都是在 root 指定的目录查找。

所以 http://localhost/aaa.html 就是从 /usr/share/nginx/html/aaa.html 找的。

location 支持的语法有好几个，我们分别试一下：
```nginx
location = /111/ {
    default_type text/plain;
    return 200 "111 success";
}

location /222 {
    default_type text/plain;
    return 200 $uri;
}

location ~ ^/333/bbb.*\.html$ {
    default_type text/plain;
    return 200 $uri;
}

location ~* ^/444/AAA.*\.html$ {
    default_type text/plain;
    return 200 $uri;
}
```
把之前的 location / 删掉，添加这样几个路由配置。

具体这些配置都是什么意思待会再说。

把这个文件复制到容器内：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```
然后在容器内的 terminal 执行：

```
nginx -s reload
```
重新加载配置文件。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/343fc8ca6d8240c5873575aaf3007734~tplv-k3u1fbpfcp-watermark.image?)

然后来看第一条路由：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e55e5e48280486b95587b19ae087544~tplv-k3u1fbpfcp-watermark.image?)

location 和路径之间加了个 =，代表精准匹配，也就是只有完全相同的 url 才会匹配这个路由。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ecc55b43604c1cb2f7918125871e76~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6a14c0dfc84b3fac127d1b3ba6ba1e~tplv-k3u1fbpfcp-watermark.image?)

不带 = 代表根据前缀匹配，后面可以是任意路径。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ff67c9f669b415bb99bb19652677767~tplv-k3u1fbpfcp-watermark.image?)

这里的 $uri 是取当前路径。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d682ce69cba4d05b4ea5adbdff7cd56~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c39332791374cb7a09d462fd638a79b~tplv-k3u1fbpfcp-watermark.image?)

然后如果想支持正则，就可以加个 ~。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b263205a29844ade884e8bf0f61ae21c~tplv-k3u1fbpfcp-watermark.image?)

这里的正则语法不难看懂，就是 /333/bbb 开头，然后中间是任意字符，最后 .html 结尾的 url。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a18793fc15d43eb9a5de1a1464905ea~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61a43a791da44bf596a523f2acbefe73~tplv-k3u1fbpfcp-watermark.image?)

但是它是区分大小写的，比如这样就不行了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21bdf43ba7414bd0a8761992aed80a72~tplv-k3u1fbpfcp-watermark.image?)

换成小写就可以：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0eed6101d4c40bab2a28c8182dde164~tplv-k3u1fbpfcp-watermark.image?)

如果想让正则不区分大小写，可以再加个 \*

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0ac2ad52e0c4187bd8760b4e02f7ccc~tplv-k3u1fbpfcp-watermark.image?)

试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58600f38f1324bfe89bdb43f89327bc0~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f55941ba3ff4b3b828e2bdd96944bd4~tplv-k3u1fbpfcp-watermark.image?)

任意的大小写都是可以的。

此外，还有一种语法：

在配置文件加上这个配置：

```
location /444 {
    default_type text/plain;
    return 200 'xxxx';
}
```

然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23967f110d1f4d2ca1831b8c605a1eef~tplv-k3u1fbpfcp-watermark.image?)

这时候就有两个 /444 的路由了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63203172626a4e97ac836631c0ecd864~tplv-k3u1fbpfcp-watermark.image?)

这时候浏览器访问，还是匹配上面的那个路由：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34cd4b0e3c2c46ce9c3dc080ca13bed7~tplv-k3u1fbpfcp-watermark.image?)

如果想提高优先级，可以使用 ^~

改成这样：

```
location ^~ /444 {
    default_type text/plain;
    return 200 'xxxx';
}
```
然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a432fa547246b4a26d41408d4c38f8~tplv-k3u1fbpfcp-watermark.image?)

这时候同一个 url，匹配的就是下面的路由了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b7ab371a63341f6b66f68650d38e55f~tplv-k3u1fbpfcp-watermark.image?)

也就是说 ^~ 能够提高前缀匹配的优先级。

总结一下，一共 4 个 location 语法：

location = /aaa 是精确匹配 /aaa 的路由。

location /bbb 是前缀匹配 /bbb 的路由。

location ~ /ccc.\*.html 是正则匹配。可以再加个 \* 表示不区分大小写 location ~\* /ccc.\*.html 

location ^~ /ddd 是前缀匹配，但是优先级更高。

 这 4 种语法的优先级是这样的：

**精确匹配（=） > 高优先级前缀匹配（^~） > 正则匹配（～ ~\*） > 普通前缀匹配**

我们现在是直接用 return 返回的内容，其实应该返回 html 文件。

可以这样改：

```
location /222 {
    alias /usr/share/nginx/html;
}

location ~ ^/333/bbb.*\.html$ {
    alias /usr/share/nginx/html/bbb.html;
}
```
然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a432fa547246b4a26d41408d4c38f8~tplv-k3u1fbpfcp-watermark.image?)

都是能正确返回对应的 html 的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ee5f117ce05432f8e0a2e570bd6291c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e044e5743124fc88760e9ecdd0b817f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a171bc715a14627b5c9a804f05240be~tplv-k3u1fbpfcp-watermark.image?)

前面用过 root：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/318dc32f873146b5a758533ce62a611f~tplv-k3u1fbpfcp-watermark.image?)

root 和 alias 有什么区别呢？

比如这样的两个配置：

```
location /222 {
    alias /dddd;
}

location /222 {
    root /dddd;
}
```

同样是 /222/xxx/yyy.html，如果是用 root 的配置，会把整个 uri 作为路径拼接在后面。

也就是会查找 /dddd/222/xxx/yyy.html 文件。

如果是 alias 配置，它会把去掉 /222 之后的部分路径拼接在后面。

也就是会查找 /dddd/xxx/yyy.html 文件。

也就是 我们 **root 和 alias 的区别就是拼接路径时是否包含匹配条件的路径。**

这就是 nginx 的第一个功能：静态文件托管。

主配置文件在 /etc/nginx/nginx.conf，而子配置文件在 /etc/nginx/conf.d 目录下。

默认的 html 路径是 /usr/share/nginx/html。

然后来看下 nginx 的第二大功能：动态资源的反向代理。

什么是正向、什么是反向呢？

从用户的角度看，方向一致的就是正向，反过来就是反向。

比如这样两个代理：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8158459f8f694f38a2b1369c90f20207~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40ee2dabb15c45178b66228b1da66128~tplv-k3u1fbpfcp-watermark.image?)

第一个是正向代理，第二个是反向代理。

第一个代理是代理的用户请求，和用户请求方向一致，叫做正向代理。

第二个代理是代理服务器处理用户请求，和用户请求方向相反，叫做反向代理。

测试 nginx 做反向代理服务器之前，我们先创建个 nest 服务。

```
npx nest new nest-app -p npm
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a2d90944d44105a697885a4a9c5f60~tplv-k3u1fbpfcp-watermark.image?)

把服务跑起来：

```
npm run start:dev
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb7fd9e654ca43fe9586cc508bdd7df7~tplv-k3u1fbpfcp-watermark.image?)

浏览器就访问 http://localhost:3000 看到 hello world 就代表 nest 服务跑成功了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e857fe44156440684cf014f53f35ca9~tplv-k3u1fbpfcp-watermark.image?)

添加一个全局的前缀 /api

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1567dd0464bb43e88b077a63554df27b~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/479209c942c240efb58f07ab2ca03ef4~tplv-k3u1fbpfcp-watermark.image?)

改下 nginx 配置，添加个路由：

```
location ^~ /api {
    proxy_pass http://192.168.1.6:3000;
}
```

这个路由是根据前缀匹配 /api 开头的 url， ^~ 是提高优先级用的。

然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a432fa547246b4a26d41408d4c38f8~tplv-k3u1fbpfcp-watermark.image?)

然后你访问 http://localhost:81/api 就可以看到 nest 服务返回的响应了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2a61491809e446fa2de48cd9142abb4~tplv-k3u1fbpfcp-watermark.image?)

也就是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/027fbc84896647eeb5598ed32a8b2cd3~tplv-k3u1fbpfcp-watermark.image?)

为什么要多 nginx 这一层代理呢？

自然是可以在这一层做很多事情的。

比如修改 header：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/502d4d3bfa8b42cfa6b24db26ba700d0~tplv-k3u1fbpfcp-watermark.image?)

然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a432fa547246b4a26d41408d4c38f8~tplv-k3u1fbpfcp-watermark.image?)

在 nest 服务的 handler 里注入 headers，打印一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/367c102b0c4c42158f491ee9363afbd4~tplv-k3u1fbpfcp-watermark.image?)

然后浏览器访问下。

直接访问 nest 服务的话，是没有这个 header 的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11ef37cff0a142ad9c5ed8fdaa6adc33~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d363c53044c4a8ba144cc01fd204eb5~tplv-k3u1fbpfcp-watermark.image?)

访问 nginx 的反向代理服务器，做一次中转：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/220ff528185d418abf5f940a15b0b0e8~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/807b50f73cc144ebab6317c048f2c306~tplv-k3u1fbpfcp-watermark.image?)

这就是反向代理服务器的作用，可以透明的修改请求、响应。

而且，还可以用它实现负载均衡。

在 controlller 里打印下访问日志：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1321cb7502f4a9e80e55ca4b700ac1c~tplv-k3u1fbpfcp-watermark.image?)

把 nest 服务停掉，然后重新 npm run start

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b47a6600dff549d0b430a7b5e1ef3d4a~tplv-k3u1fbpfcp-watermark.image?)

3001 和 3002 端口各跑一个：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78b1e80e003f46b89ba2def1c6aea66f~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下，都是正常的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c68f71eb3dc4b6a915b9a169a7e852a~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87548445dfc749b693e64ad1190758b3~tplv-k3u1fbpfcp-watermark.image?)

控制台也打印了访问日志：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9444046f35374d9d8a6a6f909eeeb593~tplv-k3u1fbpfcp-watermark.image?)

问题来了，现在有一个 nginx 服务器，两个 nest 服务器了，nginx 该如何应对呢？

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b51f76b08bc74cadae95cb0d0c6f936a~tplv-k3u1fbpfcp-watermark.image?)

nginx 的解决方式就是负载均衡，把请求按照一定的规则分到不同的服务器。

改下 nginx 配置文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7e3ed96deaf4037a5aab7444ae98a3e~tplv-k3u1fbpfcp-watermark.image?)

在 upstream 里配置它代理的目标服务器的所有实例。

下面 proxy_pass 通过 upstream 的名字来指定。

然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a432fa547246b4a26d41408d4c38f8~tplv-k3u1fbpfcp-watermark.image?)

这时候我访问 http://localhost:81/api 刷新 5 次页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67d1a60b7fdf4f8b81fb9ccd6fed01ce~tplv-k3u1fbpfcp-watermark.image?)

可以看到两个 nest 服务，一个 3 次，一个 2 次。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92c02560584d4eb68e6ac303f5da67c7~tplv-k3u1fbpfcp-watermark.image?)

因为默认是轮询的方式。

一共有 4 种负载均衡策略：

- 轮询：默认方式。
- weight：在轮询基础上增加权重，也就是轮询到的几率不同。
- ip_hash：按照 ip 的 hash 分配，保证每个访客的请求固定访问一个服务器，解决 session 问题。
- fair：按照响应时间来分配，这个需要安装 nginx-upstream-fair 插件。

我们测试下 weight 和 ip_hash 的方式。

添加一个 weight=2，默认是 1，这样两个服务器轮询到的几率是 2 比 1。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c2453efe71a4c9c83f48362181a1197~tplv-k3u1fbpfcp-watermark.image?)

然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a432fa547246b4a26d41408d4c38f8~tplv-k3u1fbpfcp-watermark.image?)

按 command + k，把 nest 服务的控制台日志清空下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6899294da7274c7d89002d7e60b33090~tplv-k3u1fbpfcp-watermark.image?)

然后我访问了 8 次 http://localhost:81/api

看打印的日志来看，差不多就是 2:1 的轮询几率。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad411f5c61e5415988d201dafa33a187~tplv-k3u1fbpfcp-watermark.image?)

这就是带权重的轮询。

我们再试下 ip_hash 的方式；

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f399064d59154040ba96b2790781e491~tplv-k3u1fbpfcp-watermark.image?)

然后复制到容器里，并 reload：

```
docker cp ~/nginx-html/conf.d/default.conf nginx1:/etc/nginx/conf.d/default.conf
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89a432fa547246b4a26d41408d4c38f8~tplv-k3u1fbpfcp-watermark.image?)

按 command + k，把 nest 服务的控制台日志清空下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6899294da7274c7d89002d7e60b33090~tplv-k3u1fbpfcp-watermark.image?)

再次访问了 http://localhost:81/api

可以看到一直请求到了一台服务器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2202ecd0ee484ba58129b632b73f1777~tplv-k3u1fbpfcp-watermark.image?)

这就是 Nginx 的负载均衡的策略。

## 总结

我们通过 docker 跑了 nginx 服务器，并使用了它的静态资源托管功能，还有动态资源的反向代理功能。

nginx 的配置文件在 /etc/nginx/nginx.conf 里，它默认还引入了 /etc/nginx/conf.d 下的子配置文件。

默认 html 都放在 /usr/share/nginx/html 下。

我们可以通过 docker cp 来把容器内文件复制到宿主机来修改。

修改 nginx 配置，在 server 里配置路由，根据不同的 url 返回不同的静态文件。

有 4 种 location 语法：

- location /aaa 根据前缀匹配
- location ^~ /aaa 根据前缀匹配，优先级更高
- location = /aaa 精准匹配
- location ~ /aaa/.\*html 正则匹配
- location ~\* /aaa/.\*html 正则匹配，而且不区分大小写

优先级是 精确匹配（=） > 高优先级前缀匹配（^~） > 正则匹配（～ ~\*） > 普通前缀匹配

除了静态资源托管外，nginx 还可以对动态资源做反向代理。

也就是请求发给 nginx，由它转发给应用服务器，这一层也可以叫做网关。

nginx 反向代理可以修改请求、响应信息，比如设置 header。

当有多台应用服务器的时候，可以通过 upstream 配置负载均衡，有 4 种策略：轮询、带权重的轮询、ip_hash、fair。

掌握了静态资源托管、动态资源的反向代理+负载均衡，就算是掌握了 Nginx 的核心用法了。





## 71.基于 Nginx 实现灰度系统

软件开发一般不会上来就是最终版本，而是会一个版本一个版本的迭代。

新版本上线前都会经过测试，但就算这样，也不能保证上线了不出问题。

所以，在公司里上线新版本代码一般都是通过灰度系统。

灰度系统可以把流量划分成多份，一份走新版本代码，一份走老版本代码。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/154bff9a93964729acd72bae62f45815~tplv-k3u1fbpfcp-watermark.image?)

而且灰度系统支持设置流量的比例，比如可以把走新版本代码的流程设置为 5%，没啥问题再放到 10%，50%，最后放到 100% 全量。

这样可以把出现问题的影响降到最低。

不然一上来就全量，万一出了线上问题，那就是大事故。

而且灰度系统不止这一个用途，比如产品不确定某些改动是不是有效的，就要做 AB 实验，也就是要把流量分成两份，一份走 A 版本代码，一份走 B 版本代码。

那这样的灰度系统是怎么实现的呢？

其实很多都是用 nginx 实现的。

nginx 是一个反向代理的服务，用户请求发给它，由它转发给具体的应用服务器。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25711183998b4a2eb83c2dea3a4f7bc3~tplv-k3u1fbpfcp-watermark.image?)

这一层也叫做网关层。

由它负责转发请求给应用服务器，那自然就可以在这里控制流量的分配，哪些流量走版本 A，哪些流量走版本 B。

下面我们实现一下：

首先，我们准备两个版本的代码。

这里创建个 nest 项目：

```
npx nest new gray_test -p npm
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f933806c509342429029254e8c6f3306~tplv-k3u1fbpfcp-watermark.image?)

把 nest 服务跑起来：

```
npm run start
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba1716bdc4494df29fe98f96b18367e6~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7a43ccf04054d4b8e5e7cd05f0566bc~tplv-k3u1fbpfcp-watermark.image?)

看到 hello world 代表 nest 服务跑起来了。

然后改下 AppService：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bd346e44d1c4b989c41e2425bd4df0e~tplv-k3u1fbpfcp-watermark.image?)

修改下端口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9ac916173f42f387da9660558a6998~tplv-k3u1fbpfcp-watermark.image?)

然后再 npm run start：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5009cf2f6f1346b9821eb4a3a8a40bb5~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfda351df43e48808cbbfa4819ecd72a~tplv-k3u1fbpfcp-watermark.image?)

现在我们就有了两个版本的 nest 代码。

接下来的问题是，如何用 nginx 实现灰度，让一部分请求走一个版本的代码，一部分请求走另一个版本呢？

我们先跑一个 nginx 服务。

docker desktop 搜索 nginx 镜像（这步需要科学上网），点击 run：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04a6b34f238d42769ad08be17208d8b5~tplv-k3u1fbpfcp-watermark.image?)

设置容器名为 gray1，端口映射宿主机的 82 到容器内的 80

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf7d1989898d4ff5851dbb4acf95f004~tplv-k3u1fbpfcp-watermark.image?)

现在访问 http://localhost:82 就可以看到 nginx 页面了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faa73d7cac0241ad87d09f13c8f69b0b~tplv-k3u1fbpfcp-watermark.image?)

我们要修改下配置文件，把它复制出来：

```
docker cp gray1:/etc/nginx/conf.d ~/nginx-config
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2127066afc3847e69839c76dccef6cc3~tplv-k3u1fbpfcp-watermark.image?)

然后编辑下这个 default.conf

添加这么一行配置：
```nginx
location ^~ /api {
    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://192.168.1.6:3001;
}
```
这行就是加了一个路由，把 /api/ 开头的请求转发给 http://宿主机IP:3001 这个服务。

用 rewrite 把 url 重写了，比如 /api/xxx 变成了 /xxx。

然后我们重新跑个 nginx 容器：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf3385d954d4943b22118a0b6765408~tplv-k3u1fbpfcp-watermark.image?)

容器名为 gray2，端口映射 83 到容器内的 80。

指定数据卷，挂载本地的 ～/nginx-config 目录到容器内的 /etc/nginx/conf.d 目录。

点击 run。

然后看下 files 部分：

可以看到容器内的 /etc/nginx/conf.d 目录标识为了 mounted。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4e8a654512d4199b752b814cf08f207~tplv-k3u1fbpfcp-watermark.image?)

点开看看：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4ebe971f86e45adafe0b581dc42b49a~tplv-k3u1fbpfcp-watermark.image?)

这就是本地的那个文件。

我们在本地改一下试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a526cd70a12e4d5b98ae37e7bd572339~tplv-k3u1fbpfcp-watermark.image?)

容器内也同样修改了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/101c1100d4af4d30bdd89a17c22f4392~tplv-k3u1fbpfcp-watermark.image?)

在容器内修改这个文件，本地同样也会修改。

也就是说挂载数据卷之后，容器内的这个目录就是本地目录，是同一份。

然后我们访问下 http://localhost:83/api/ 看看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcb299ea5ec74bf4a456489d02173389~tplv-k3u1fbpfcp-watermark.image?)

nest 服务访问成功了。

现在我们不是直接访问 nest 服务了，而是经历了一层 nginx 反向代理或者说网关层。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/629d676511b249fb86b480515cc1c30e~tplv-k3u1fbpfcp-watermark.image?)

自然，我们可以在这一层实现流量控制的功能。

前面我们讲负载均衡的时候，是这么配的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f828c9da88a64fbb847d18f76a82857e~tplv-k3u1fbpfcp-watermark.image?)

默认会轮询把请求发给 upstream 下的 server。

现在需要有多组 upstream：

```nginx
upstream version1.0_server {
    server 192.168.1.6:3000;
}
 
upstream version2.0_server {
    server 192.168.1.6:3001;
}

upstream default {
    server 192.168.1.6:3000;
}
```
有版本 1.0 的、版本 2.0 的，默认的 server 列表。

然后需要根据某个条件来区分转发给哪个服务。

我们这里根据 cookie 来区分：

```nginx
set $group "default";
if ($http_cookie ~* "version=1.0"){
    set $group version1.0_server;
}

if ($http_cookie ~* "version=2.0"){
    set $group version2.0_server;
}

location ^~ /api {
    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://$group;
}
```
如果包含 version=1.0 的 cookie，那就走 version1.0_server 的服务，有 version=2.0 的 cookie 就走 version2.0_server 的服务，否则，走默认的。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a874705639364c33ad5c51098213ed76~tplv-k3u1fbpfcp-watermark.image?)

这样就实现了流量的划分，也就是灰度的功能。

然后我们重新跑下容器：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b36075bd46a74c8887b0c085dc9ec56e~tplv-k3u1fbpfcp-watermark.image?)

这时候，你访问 http://localhost:83/api/ 走到的就是默认的版本。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c342eceabaac41c58adfb504c26ae1dc~tplv-k3u1fbpfcp-watermark.image?)

然后带上 version=2.0 的 cookie，走到的就是另一个版本的代码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/212db4023f22441597742a814425832a~tplv-k3u1fbpfcp-watermark.image?)

这样，我们就实现了灰度的功能。

但现在还有一个问题：

什么时候设置的这个 cookie 呢？

比如我想实现 80% 的流量走版本 1.0，20% 的流量走版本 2.0

其实公司内部一般都有灰度配置系统，可以配置不同的版本的比例，然后流量经过这个系统之后，就会返回 Set-Cookie 的 header，里面按照比例来分别设置不同的 cookie。

比如随机数载 0 到 0.2 之间，就设置 version=2.0 的 cookie，否则，设置 version=1.0 的 cookie。

这也叫做流量染色。

完整的灰度流程是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60249ce21c284c928086815fec6801e9~tplv-k3u1fbpfcp-watermark.image?)

第一次请求的时候，会按照设定的比例随机对流量染色，也就是设置不同 cookie。

再次访问的时候会根据 cookie 来走到不同版本的代码。

其中，后端代码会根据 cookie 标识来请求不同的服务（或者同一个服务走不同的 if else），前端代码可以根据 cookie 判断走哪段逻辑。

这就实现了灰度功能，可以用来做 5% 10% 50% 100% 这样逐步上线的灰度上线机制。

也可以用来做产品的 AB 实验。

公司里都会用这样的灰度系统。

## 总结

新版本代码的上线基本都会用灰度系统，可以逐步放量的方式来保证上线过程不会出大问题，也可以用来做产品 AB 实验。

我们可以用 nginx 实现这样的功能。

nginx 有反向代理的功能，可以转发请求到应用服务器，也叫做网关层。

我们可以在这一层根据 cookie 里的 version 字段来决定转发请求到哪个服务。

在这之前，还需要按照比例来给流量染色，也就是返回不同的 cookie。

不管灰度系统做的有多复杂，底层也就是流量染色、根据标记转发流量这两部分，我们完全可以自己实现一个。


## 72.基于 Redis 实现分布式 session

前面我们学习了登录鉴权的两种方式 session 和 jwt。

session 是在服务端保存用户数据，然后通过 cookie 返回 sessionId。cookie 在每次请求的时候会自动带上，服务端就能根据 sessionId 找到对应的 session，拿到用户的数据

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5298508d5b74d4585c58b0034a96125~tplv-k3u1fbpfcp-watermark.image?)

而 jwt 是把所有的用户数据保存在加密后的 token 里返回，客户端只要在 authorization 的 header 里带上 token，服务端就能从中解析出用户数据。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95fd322ae4ec4b2bba3973405a659de4~tplv-k3u1fbpfcp-watermark.image?)

jwt 天然是支持分布式的，比如有两个服务器的时候，任何一个服务器都能从 token 出拿到用户数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2d4af048e3e4c1f965b23f6184f7a70~tplv-k3u1fbpfcp-watermark.image?)

但是 session 的方式不行，它的数据是存在单台服务器的内存的，如果再请求另一台服务器就找不到对应的 session 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76f00b76e0d944d584927aa6e913ba0d~tplv-k3u1fbpfcp-watermark.image?)

那如何让 session 支持分布式环境呢？

一种方式就是做 session 的同步，在多台服务器之间复制 session。

另一种方式就是自己基于 redis 实现一个分布式 session 了。

这节我们就来实现一下。

首先我们来分析下思路：

分布式 session 就是在多台服务器都可以访问到同一个 session。

我们可以在 redis 里存储它：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c92708cac3374e99a3e4a813bcfe7fe3~tplv-k3u1fbpfcp-watermark.image?)

用户第一次请求的时候，生成一个随机 id，以它作为 key，存储的对象作为 value 放到 redis 里。

之后携带 cookie 的时候，根据其中的 sid 来取 redis 中的值，注入 handler。

修改 session 之后再设置到 redis 里。

这样就完成了 session 的创建、保存、修改。

我们具体实现下：

```
nest new redis-session-test -p npm
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/875d542bb4a1407f90c43798f4fe6098~tplv-k3u1fbpfcp-watermark.image?)

创建 nest 项目。

安装 redis 的包：

```
npm install --save redis
```

然后创建个 redis 模块：

```
nest g module redis
nest g service redis
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf36dbe385544309bc35de23c2a45a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=196&e=webp&b=1f1f1f)

在 RedisModule 创建连接 redis 的 provider，导出 RedisService，并把这个模块标记为 @Global 模块

```javascript
import { Global, Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```

然后在 RedisService 里注入 REDIS_CLIENT，并封装一些方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async hashGet(key: string) {
        return await this.redisClient.hGetAll(key);
    }

    async hashSet(key: string, obj: Record<string, any>, ttl?: number) {
        for(let name in obj) {
            await this.redisClient.hSet(key, name, obj[name]);
        }

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```

因为我们要操作的是对象结构，比较适合使用 hash。

redis 的 hash 有这些方法：

- `HSET key field value`： 设置指定哈希表 key 中字段 field 的值为 value。
- `HGET key field`：获取指定哈希表 key 中字段 field 的值。
- `HMSET key field1 value1 field2 value2 ...`：同时设置多个字段的值到哈希表 key 中。
- `HMGET key field1 field2 ...`：同时获取多个字段的值从哈希表 key 中。
- `HGETALL key`：获取哈希表 key 中所有字段和值。
- `HDEL key field1 field2 ...`：删除哈希表 key 中一个或多个字段。
- `HEXISTS key field`：检查哈希表 key 中是否存在字段 field。
- `HKEYS key`：获取哈希表 key 中的所有字段。
- `HVALUES key`：获取哈希表 key 中所有的值。
-`HLEN key`：获取哈希表 key 中字段的数量。
- `HINCRBY key field increment`：将哈希表 key 中字段 field 的值增加 increment。
- `HSETNX key field value`：只在字段 field 不存在时，设置其值为 value。

这里我们就用到 hGetAll 和 hSet 方法，再就是用 expire 设置 key 的过期时间。

这里的 Record<string, any> 是对象类型的意思。

然后再封装个 SessionModule：

```
nest g module session
nest g service session --no-spec
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c8d0a8556f24180825e213dd36958b2~tplv-k3u1fbpfcp-watermark.image?)

导出 SessionService，并且设置 SessionModule 为 Global：
```javascript
import { Global, Module } from '@nestjs/common';
import { SessionService } from './session.service';

@Global()
@Module({
  providers: [SessionService],
  exports: [SessionService]
})
export class SessionModule {}

```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af5a3f5a84854fa9aa7f9af167eb7575~tplv-k3u1fbpfcp-watermark.image?)

然后实现 SessionService：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisService } from 'src/redis/redis.service';

@Injectable()
export class SessionService {

    @Inject(RedisService)
    private redisService: RedisService;

    async setSession(sid: string, value: Record<string, any>, ttl: number = 30 * 60) {
        if(!sid) {
            sid = this.generateSid();
        }
        await this.redisService.hashSet(`sid_${sid}`, value, ttl);
        return sid;
    }

    async getSession(sid: string) {
        return await this.redisService.hashGet(`sid_${sid}`);
    }

    generateSid() {
        return Math.random().toString().slice(2,12);
    }
}
```

setSession 就是用 sid_xx 的 key 在 redis 里创建 string 的数据结构。

getSession 是用 sid_xx 从 redis 取值。

generateSid 是生成随机的 session id

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29816011bc1741f49df6715d3513503a~tplv-k3u1fbpfcp-watermark.image?)

setSession 的时候如果没有传入 sid，则随机生成一个，并返回 sid。

我们在 AppController 添加个方法测试下：

```javascript
@Inject(SessionService)
private sessionService: SessionService;

@Get('count')
async count(@Req() req: Request, @Res() res: Response) {
    const sid = req.cookies?.sid;

    const session = await this.sessionService.getSession(sid);

}

```
这里用到 cookie，需要安装 cookie-parser 的包：

```
npm install --save cookie-parser
```
在 main.ts 里启用：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a881300cf443467e8540debaa894ec23~tplv-k3u1fbpfcp-watermark.image?)

现在 getSession 返回的是 Record<string, any> 也就是对象类型，但并不知道有啥具体的属性。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c14008ddf454a5ea7f0b823b1aed9ac~tplv-k3u1fbpfcp-watermark.image?)

所以我们改造下 getSession 的类型声明加个重载：

```typescript
async getSession<SessionType extends Record<string,any>>(sid: string): Promise<SessionType>;
async getSession(sid: string) {
    return await this.redisService.hashGet(`sid_${sid}`);
}
```
这样再用的时候，当不传类型参数，返回的是默认类型 Record<string, any>：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1be5e6fc8e0142cb8212d9089b2ecde4~tplv-k3u1fbpfcp-watermark.image?)

传入类型参数之后，返回的就是该类型了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13e8b607cf6244ffb9fcb78770892ec1~tplv-k3u1fbpfcp-watermark.image?)

为什么这里是 string 呢？

因为 redis 虽然可以存整数、浮点数，但是它会转为 string 来存，所以取到的是 string，需要自己转换一下。

我们实现下计数逻辑：

```javascript
@Inject(SessionService)
private sessionService: SessionService;

@Get('count')
async count(@Req() req: Request, @Res({ passthrough: true}) res: Response) {
    const sid = req.cookies?.sid;

    const session = await this.sessionService.getSession<{count: string}>(sid);

    const curCount = session.count ? parseInt(session.count) + 1 : 1;
    const curSid = await this.sessionService.setSession(sid, {
      count: curCount
    });

    res.cookie('sid', curSid, { maxAge: 1800000 });
    return curCount;
}
```
先根据 cookie 的 sid 调用 getSession 取 session。

拿到的如果有 count，就 + 1 之后放回去，没有就设置 1

然后 setSession 更新 session。

在 cookie 中返回 sid。

默认用了 @Res 传入 response 之后就需要手动返回响应了，比如 res.end('xxx')，如果还是想让 nest 把返回值作为响应，就加个 passthrough: true。

我们测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09b4d078662e4fc2908d1e284d4866d1~tplv-k3u1fbpfcp-watermark.image?)

我们自己实现的 session 就生效了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faaa9f20ae824c8294941553cd3f39e5~tplv-k3u1fbpfcp-watermark.image?)

在 Redis Insight 里可以看到 session 的值

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee658369fbd4a0cb212cf4f2aefd361~tplv-k3u1fbpfcp-watermark.image?)

而且这个 session 是支持分布式的。


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/991dd7dd3a6440d1bb63999a63bb2881~tplv-k3u1fbpfcp-watermark.image?)

我们用 nginx 做网关层，使用轮询的负载均衡策略，那请求可能到任何一台服务器上。

如果是之前的 session，当前机器没有对应的 session 对象，就拿不到登录状态。

而现在基于 redis 存储的 session，不管请求到了哪台服务器，都能从 redis 中取出对应的 session 从而拿到登录状态、用户数据。

这就是分布式 session。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/redis-session-test)。

## 总结

session 是在服务端内存存储会话数据，通过 cookie 中的 session id 关联。

但它不支持分布式，换台机器就不行了。

jwt 是在客户端存储会话数据，所以天然支持分布式。

我们通过 redis 自己实现了分布式的 session。

我们使用的是 hash 的数据结构，封装了 RedisModule 来操作 Redis。

又封装了 SessionModule 来读写 redis 中的 session，以 sid_xxx 为 key。

之后在 ctronller 里就可以读取和设置 session 了，用起来和内置的传统 session 差不多。但是它是支持分布式的。

如果你想在分布式场景下用 session，就自己基于 redis 实现一个吧。



## 73.手写序列化 Entity 的拦截器

上节我们学了用 class-transformer +  ClassSerializerInterceptor 来序列化 entity 对象，可以替代 vo。

这节我们自己来实现一下 ClassSerializerInterceptor，深入理解它的实现原理。

```
nest new serializer-interceptor-test
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39e6f51c2e4a49a190687b362dad3bbe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=700&s=172067&e=png&b=010101)

生成一个 user 的 CRUD 模块：

```
nest g resource user --no-spec
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e59b3383b94f83ad1e3c6dc93df1a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790&h=352&s=44190&e=webp&b=191919)

在 entity 里加一些内容：

```javascript
export class User {
    id: number;

    username: string;

    password: string;

    email: string;

    constructor(partial: Partial<User>) {
        Object.assign(this, partial);
    }
}
```

改下 UserService：

```javascript
import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { User } from './entities/user.entity';

const database = [
  new User({ id: 1, username: 'xxx', password: 'xxx', email: 'xxx@xx.com'}),
  new User({ id: 2, username: 'yyy', password: 'yyy', email: 'yyy@yy.com'})
];
let id = 0;

@Injectable()
export class UserService {
  create(createUserDto: CreateUserDto) {
    const user = new User(createUserDto);

    user.id = id++;

    database.push(user);

    return user;
  }

  findAll() {
    return database;
  }

  findOne(id: number) {
    return database.filter(item =>  item.id === id).at(0);
  }

  update(id: number, updateUserDto: UpdateUserDto) {
    return `This action updates a #${id} user`;
  }

  remove(id: number) {
    return `This action removes a #${id} user`;
  }
}
```
内置两条数据，这样就不用每次调用接口创建了。

然后安装 class-transformer 包：

```
npm install --save class-transformer
```
在 entity 上加一下 class-transformer 的装饰器：

```javascript
import { Exclude, Expose, Transform } from "class-transformer";

export class User {
    id: number;

    username: string;

    @Exclude()
    password: string;

    @Expose()
    get xxx(): string {
        return `${this.username} ${this.email}`;
    }

    @Transform(({value}) => '邮箱是：' + value)
    email: string;

    constructor(partial: Partial<User>) {
        Object.assign(this, partial);
    }
}
```

然后我们自己来实现 ClassSerializerInterceptor，还有一个自定义装饰器 SerializeOptions：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/956baf8a69794f3da2d5fca9c29e8690~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=564&s=147255&e=png&b=1f1f1f)

先来写这个自定义装饰器，它比较简单：
```
nest g decorator serialize-options --flat
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f36b85d40cdb40d1b3e0120d89447f5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=794&h=82&s=22319&e=png&b=191919)

```javascript
import { SetMetadata } from '@nestjs/common';
import { ClassTransformOptions } from 'class-transformer';

export const CLASS_SERIALIZER_OPTIONS = 'class_serializer:options';

export const SerializeOptions = (options: ClassTransformOptions) =>
    SetMetadata(CLASS_SERIALIZER_OPTIONS, options);
```
它做的事情就是往 class 或者 method 上加一个 metadata。

然后 interceptor 取出这个 metadata 的 options 给 class-transfromer 用。

所以这个 options 的类型就是 ClassTransformOptions。

是不是第一次见这样设置参数？

确实挺巧妙的。

然后来写 interceptor：

```
nest g interceptor class-serializer --flat --no-spec
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc2730355c7941f8a4e5d2ec57db04cf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&h=124&s=29430&e=png&b=191919)

```javascript
import { CallHandler, ExecutionContext, Inject, Injectable, NestInterceptor } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ClassTransformOptions } from 'class-transformer';
import { Observable } from 'rxjs';
import { CLASS_SERIALIZER_OPTIONS } from './serialize-options.decorator';

@Injectable()
export class ClassSerializerInterceptor implements NestInterceptor {

  @Inject(Reflector) 
  protected readonly reflector: Reflector;

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const contextOptions = this.getContextOptions(context);

    return next.handle();
  }

  protected getContextOptions(
    context: ExecutionContext,
  ): ClassTransformOptions | undefined {
    return this.reflector.getAllAndOverride(CLASS_SERIALIZER_OPTIONS, [
      context.getHandler(),
      context.getClass(),
    ]);
  }
}
```
注入 Reflector 包，用它的 getAllAndOverride 方法拿到 class 或者 handler 上的 metadata。

打印下看看。

我们把它加到 handler 上：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/207b3a403b68479182de119ef0a33a05~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1262&h=658&s=146839&e=png&b=1f1f1f)

加一个调试配置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44397a6f5cc3493fabd6fa0d0ed341cd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=522&h=416&s=45113&e=png&b=191919)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee9ef6d1e4c74a49a72a0dc31a73dfe3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1364&h=850&s=136490&e=png&b=1d1d1d)

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "debug nest",
            "runtimeExecutable": "npm",
            "args": [
                "run",
                "start:dev",
            ],
            "skipFiles": [
                "<node_internals>/**"
            ],
            "console": "integratedTerminal",
        }
    ]
}
```
打个断点，然后点击调试启动：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45921cf452b044b48da8575766cbd036~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=772&s=205956&e=png&b=1d1d1d)

现在是 undefined：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1300bbf55c324889b79f51373da9f90d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1550&h=722&s=244117&e=png&b=1d1d1d)

加一下 @SerializeOptions 装饰器，用我们刚才写的那个。然后点击 restart：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfcd6f3abd294f52a001b4b3ac6831a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078&h=512&s=113464&e=png&b=1f1f1f)

这时候就拿到 options 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88d729ddd5f94c07ad35281dff88da9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1582&h=632&s=228149&e=png&b=1e1e1e)

然后我们继续写：

```javascript
import { CallHandler, ExecutionContext, Inject, Injectable, NestInterceptor, StreamableFile } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ClassTransformOptions } from 'class-transformer';
import { Observable, map } from 'rxjs';
import { CLASS_SERIALIZER_OPTIONS } from './serialize-options.decorator';
import * as classTransformer from 'class-transformer';

function isObject(value) {
  return value !== null && typeof value === 'object'
}

@Injectable()
export class ClassSerializerInterceptor implements NestInterceptor {

  @Inject(Reflector) 
  protected readonly reflector: Reflector;

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const contextOptions = this.getContextOptions(context);

    return next
      .handle()
      .pipe(
        map((res) =>
          this.serialize(res, contextOptions),
        ),
      );
  }

  serialize(
    response: Record<string, any> | Array<Record<string, any>>,
    options: ClassTransformOptions
  ){

    if (!isObject (response) || response instanceof StreamableFile) {
      return response;
    }

    return Array.isArray(response)
      ? response.map(item => this.transformToNewPlain(item, options))
      : this.transformToNewPlain(response, options);
  }

  transformToNewPlain(
    palin: any,
    options: ClassTransformOptions,
  ) {
    if (!palin) {
      return palin;
    }

    return classTransformer.instanceToPlain(palin, options);
  }


  protected getContextOptions(
    context: ExecutionContext,
  ): ClassTransformOptions | undefined {
    return this.reflector.getAllAndOverride(CLASS_SERIALIZER_OPTIONS, [
      context.getHandler(),
      context.getClass(),
    ]);
  }
}

```

在 interceptor 里用 map operator 对返回的数据做修改。

在 serialize 方法里根据响应是数组还是对象分别做处理，调用 transformToNewPlain 做转换。

这里排除了 response 不是对象的情况和返回的是文件流的情况：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5fa2e02d9c84ec8b6fca845794c78ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1252&h=982&s=217106&e=png&b=1f1f1f)

transformToNewPlain 就是用 class-transformer 包的 instanceToPlain 根据对象的 class 上的装饰器来创建新对象：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ae99c9043874e8da8b4ce3d86c9a4de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1004&h=392&s=58207&e=png&b=1f1f1f)

有同学说不是 classToPlain 么？

那个 api 过时了，用 instanceToPlain 代替。

打个断点测试下：

最开始的响应数据是 user 对象：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/656ac75777b242d4b6bef4dd30bdac1b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=744&s=183652&e=png&b=212121)

转换完之后就是新的对象了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99e6ea4a61254a75b873a68d8bce25ef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1310&h=1032&s=216608&e=png&b=1d1d1d)


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3028d46d8104f00b5313714d43482b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750&h=890&s=85370&e=png&b=fdfdfd)

这样我们就实现了 ClassSerializerInterceptor 拦截器的功能。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/serializer-interceptor-test)
## 总结

上节学了用 entity 结合 class-transfomer 的装饰器和 ClassSerializerInterceptor 拦截器实现复用 entity 做 vo 的功能。

这节我们自己实现了下。

首先是 @SerializeOptions 装饰器，它就是在 class 或者 handler 上加一个 metadata，存放 class-transformer 的 options。

在 ClassSerializerInterceptor 里用 reflector 把它取出来。

然后拦截响应，用 map oprator对响应做变换，调用 classTransformer 包的 instanceToPlain 方法进行转换。

自己实现一遍之后，对它的理解就更深了。


## 74.Redis + 高德地图，实现附近的充电宝

想必大家都打过车，打车软件可以根据你的当前位置搜索附近的车辆：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc1b4c36782437a8dfdcd6495161e30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=924&s=462559&e=png&b=f7f2ee)

这两天国庆节，大家出去玩可能会借用共享充电宝。它也是基于你的位置来搜索附近充电宝：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/162332a323994cd0adc59478b4524747~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1414&s=485485&e=jpg&b=f7f5f2)

再就是大家搜索附近的酒店、餐厅等，也是基于位置的搜索。

那么问题来了：这种附近的人、附近的酒店、附近的充电宝的功能是怎么实现的呢？

答案是用 Redis 实现的。

很多人对 Redis 的认识停留在它能做缓存，也就是从数据库中查询出来的数据，放到 redis 里，下次直接拿 redis 的数据返回：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55f331ce98fe4a00a7cbcdfce9b1e1ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=532&s=25021&e=png&b=ffffff)

确实，缓存是 redis 的常见应用。

但它并不只是可以做缓存，很多临时的数据，比如验证码、token 等，都可以放到 redis 里。

redis 是 key-value 的数据库，value 有很多种类型：

- **string**： 可以存数字、字符串，比如存验证码就是这种类型
- **hash**：存一个 map 的结构，比如文章的点赞数、收藏数、阅读量，就可以用 hash 存
- **set**：存去重后的集合数据，支持交集、并集等计算，常用来实现关注关系，比如可以用交集取出互相关注的用户
- **zset**：排序的集合，可以指定一个分数，按照分数排序。我们每天看的文章热榜、微博热榜等各种排行榜，都是 zset 做的
- **list**：存列表数据
- **geo**：存地理位置，支持地理位置之间的距离计算、按照半径搜索附近的位置

其中，geo 的数据结构，就可以用来实现附近的人等功能。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e010dc001c742ee998f14e3b4f988f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1096&h=438&s=111789&e=png&b=fefefe)

比如大众点评、美团外卖这种，就是用 redis 实现的基于地理位置的功能。

今天我们就来实现一下：

在 RedisInsight 里输入命令，点击执行：

```redis
geoadd loc 13.361389 38.115556 "guangguang" 15.087269 37.502669 "dongdong" 
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682a25f128d44b2f8b34196a1d774499~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1882&h=536&s=111119&e=png&b=141414)

我们用 geoadd 命令添加了两个位置。

guangguang 的位置是经度 13.361389，纬度 38.11556

dongdong 的位置是经度 15.08729 ，纬度 37.502669

点击刷新，就可以看到 loc 的 key：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f653c454fac34e618576ea33c9e4a5b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1448&h=650&s=88500&e=png&b=181818)

然后可以用 geodist 计算两个位置之间的距离：

```
geodist loc guangguang dongdong
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e02e4b19c5e4a2fae164a35701b2912~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=488&h=162&s=15606&e=png&b=222535)

可以看到相距差不多 166 km

然后用 georadius 分别查找经度 15、纬度 37 位置的附近 100km 半径和 200km 半径的点：

```
georadius loc 15 37 100 km
georadius loc 15 37 200 km
```
结果如下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a259b3ff0314f5386c66eb5abc5b65d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=440&h=368&s=27172&e=png&b=020202)

因为两个点相距 166km，所以搜索 100km 以内的点，只能搜到一个。而 200km 的内的点，能搜到两个。

这样，我们就可以实现搜索附近 1km 的充电宝的功能。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff90584ad1994d4d8aa43c3a23ed94cd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1414&s=979580&e=png&b=f7f5f1)

服务端提供一个接口，让充电宝机器上传位置信息，然后把它存到 redis 里。

再提供个搜索的接口，基于传入的位置用 georadius 来搜索附近的充电宝机器，返回客户端。

客户端可以在地图上把这些点画出来。

这里用高德地图或者百度地图都行，他们都支持在地图上绘制 marker 标记的功能：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50accb5e2298400bb92f97bab49cb5ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1636&h=1226&s=3894495&e=gif&f=44&b=f5eee3)

比如上面我们分别在地图上绘制了 marker 和 circle：

这是添加 Marker 的代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7986d1420f40cd9da90d72a2c11614~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1000&h=678&s=115472&e=png&b=ffffff)

指定 marker 的经纬度和图片就行。

这是添加 Circle 的代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f877c980ae7343c3a04a5f69f5f4c047~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1064&h=780&s=156708&e=png&b=ffffff)

指定圆心经纬度和半径就行。

都挺简单的。

这样，后端和前端分别怎么实现，我们就都理清了。

接下来用代码实现下。

创建个 nest 项目：

```
npm install g @nestjs/cli

nest new nearby-search
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92de697f7c9479980b928e675a01f46~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&h=760&s=287965&e=png&b=010101)

进入项目目录，把它跑起来：

```
npm run start:dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eb33e14ce0644748607f503bd30dd29~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1560&h=350&s=112251&e=png&b=181818)

浏览器访问 http://localhost:3000 可以看到 hello world，就代表 nest 服务跑起来了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3a81755e0f646658bd5a08d2e97bd98~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=564&h=202&s=16433&e=png&b=ffffff)

然后我们安装连接 redis 的包：

```
npm install --save redis
```

创建个 redis 模块和 service：

```
nest g module redis
nest g service redis
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf36dbe385544309bc35de23c2a45a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=196&e=webp&b=1f1f1f)

在 RedisModule 创建连接 redis 的 provider，导出 RedisService：

```javascript
import { Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```

然后在 RedisService 里注入 REDIS_CLIENT，并封装一些操作 redis 的方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async geoAdd(key: string, posName: string, posLoc: [number, number]) {
        return await this.redisClient.geoAdd(key, {
            longitude: posLoc[0],
            latitude: posLoc[1],
            member: posName
        })
    }
}
```
我们先添加了一个 geoAdd 的方法，传入 key 和位置信息，底层调用 redis 的 geoadd 来添加数据。

在 AppController 里注入 RedisService，然后添加一个路由：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c748eec3bc424829ae279c62629dd86d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1396&h=1080&s=245118&e=png&b=1f1f1f)

添加 addPos 的 get 请求的路由，传入 name、longitude、latitude，调用 redisService添加位置信息。

```javascript
import { BadRequestException, Controller, Get, Inject, Query } from '@nestjs/common';
import { AppService } from './app.service';
import { RedisService } from './redis/redis.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject(RedisService)
  private redisService: RedisService;

  @Get('addPos')
  async addPos(
    @Query('name') posName: string,
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number
  ) {
    if(!posName || !longitude || !latitude) {
      throw new BadRequestException('位置信息不全');
    }
    try {
      await this.redisService.geoAdd('positions', posName, [longitude, latitude]);
    } catch(e) {
      throw new BadRequestException(e.message);
    }
    return {
      message: '添加成功',
      statusCode: 200
    }
  }

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```
测试下：

/addPos?name=guang

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6f12110e3294c50b2e68b50c20b55ef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=886&h=230&s=33422&e=png&b=fcfcfc)

/addPos?name=guang&longitude=15&latitude=35

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a93b4b67a4d340b1b5dbce4eb653150b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1214&h=234&s=37494&e=png&b=fcfcfc)

/addPos?name=dong&longitude=15&latitude=85

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2eb8b9b4f74d5b999135180d251627~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=190&s=35916&e=png&b=fbfbfb)

然后去 RedisInsight 里看下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e114cfd7b084284b9f4baee1009746a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2472&h=742&s=140318&e=png&b=1c1c1c)

点击刷新，可以看到确实有了 positions 的数据。

然后我们再添加个查询位置列表的接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da22b8a12a24f9b87473b8614366517~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1204&h=1124&s=219532&e=png&b=1f1f1f)

```javascript
async geoPos(key: string, posName: string) {
    const res = await this.redisClient.geoPos(key, posName);

    return {
        name: posName,
        longitude: res[0].longitude,
        latitude: res[0].latitude
    }
}

async geoList(key: string) {
    const positions = await this.redisClient.zRange(key, 0, -1);

    const list = [];
    for(let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        const res = await this.geoPos(key, pos);
        list.push(res);
    }
    return list;
}
```
因为 geo 信息底层使用 zset 存储的，所以查询所有的 key 使用 zrange。

zset 是有序列表，列表项会有一个分数，zrange 是返回某个分数段的 key，传入 0、-1 就是返回所有的。

然后再用 geoPos 拿到它对应的位置信息。

我们先在 RedisInsight 测试下这两个命令：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d204e7129f734932b9b87422691d74d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=534&h=390&s=34803&e=png&b=010101)

没啥问题。

在 AppController 添加两个路由：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce2f5fb88bc14082a01539fd9f4c0c74~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=822&s=151436&e=png&b=202020)

```javascript
@Get('allPos')
async allPos() {
    return this.redisService.geoList('positions');
}

@Get('pos')
async pos(@Query('name') name: string) {
    return this.redisService.geoPos('positions', name);
}
```

访问下试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d80c0bb3369475a88eebbb21df8b8f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=764&h=308&s=38044&e=png&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ca48e0678864b64b80f3192d15f2073~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=624&h=436&s=48980&e=png&b=fdfdfd)

最后，还要提供一个搜索附近的点的接口：

在 RedisService 添加 geoSearch 方法，传入 key，经纬度、搜索半径，返回附近的点：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a638bcdcc37d49bf9c717c86e0ec6b5e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1200&h=750&s=139520&e=png&b=1f1f1f)

这里单位用的 km。

```javascript
async geoSearch(key: string, pos: [number, number], radius: number) {
    const positions = await this.redisClient.geoRadius(key, {
        longitude: pos[0],
        latitude: pos[1]
    }, radius, 'km');

    const list = [];
    for(let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        const res = await this.geoPos(key, pos);
        list.push(res);
    }
    return list;
}
```
先用 geoRadius 搜索半径内的点，然后再用 geoPos 拿到点的经纬度返回。

在 AppController 添加 nearbySearch 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03a99a13b3594c589818f9dec3329eaa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1394&h=814&s=183689&e=png&b=1f1f1f)

```javascript
@Get('nearbySearch')
async nearbySearch(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('radius') radius: number
) {
    if(!longitude || !latitude) {
      throw new BadRequestException('缺少位置信息');
    }
    if(!radius) {
      throw new BadRequestException('缺少搜索半径');
    }

    return this.redisService.geoSearch('positions', [longitude, latitude], radius);
}
```

首先我们在 RedisInsight 里算下两点的距离：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3c061264dd14b9287f3b5b7cf1d8f2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=684&h=442&s=31930&e=png&b=0e0e0e)

大概 5561 km

在 guang 附近搜索半径 5000km 内的位置：

/nearbySearch?longitude=15&latitude=35&radius=5000

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6ac88afcb34c3586635f29a1f3187f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1250&h=344&s=49400&e=png&b=fdfdfd)

找到了一个点。

然后搜索半径 6000km 内的位置：

/nearbySearch?longitude=15&latitude=35&radius=6000

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a45cf75b41544bdfa537a6ee02e3364a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1252&h=446&s=67371&e=png&b=fcfcfc)

不过现在的经纬度我们是随便给的。

可以用高德地图的坐标拾取工具来取几个位置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd406c9760e24e12ab78450ac5a9630e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2316&h=1390&s=513513&e=png&b=f1ebd2)

天安门： 116.397444,39.909183

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfec6d97f254cb1a574b52610a5a3a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1530&h=796&s=240197&e=png&b=e4ebc0)

文化宫科技馆：116.3993,39.908578

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4155cd3d110f421a96227f7b98c8742d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=670&s=154219&e=png&b=e8ecc4)

售票处：116.397283,39.90943

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea18ac14e76a40efbd86d85800d69612~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1230&h=748&s=163260&e=png&b=e4ebc1)

故宫彩扩部：116.398002,39.909175

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dca4d64e6774277835632f2842f597d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1272&h=758&s=171813&e=png&b=e6ecc2)

把这样 4 个位置添加到系统中：

/addPos?name=天安门&longitude=116.397444&latitude=39.909183

/addPos?name=文化宫科技馆&longitude=116.3993&latitude=39.908578

/addPos?name=售票处&longitude=116.397283&latitude=39.90943

/addPos?name=故宫彩扩部&longitude=116.398002&latitude=39.909175

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/335950667b4b49a9b5cebbb5e910646e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1480&h=200&s=43493&e=png&b=fcfcfc)

先计算下天安门到故宫彩扩部的距离：

```
GEODIST positions 天安门 故宫彩扩部 km
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e9c32db99ae43a597e398e3b5c02ca8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=772&h=442&s=35420&e=png&b=0f0f0f)

是 0.0476km

那么我们在天安门的位置搜索 0.04km 内的点，应该搜不到它。

搜索 0.05 km 的点的时候，才能搜到。

试一下：

/nearbySearch?longitude=116.397444&latitude=39.909183&radius=0.04

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97a07d29baa54e68a92473888e921935~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1496&h=568&s=89712&e=png&b=fefefe)

/nearbySearch?longitude=116.397444&latitude=39.909183&radius=0.05

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c39141f291c45758c09ba655f8320fc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1516&h=674&s=116630&e=png&b=fefefe)

没啥问题，这样我们搜索附近的充电宝的后端功能就完成了。

然后写下前端页面。

在 main.ts 指定 public 目录为静态文件的目录：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f58898faa46436887d0ba68230c8a49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1212&h=502&s=113981&e=png&b=1f1f1f)

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.useStaticAssets('public');

  await app.listen(3000);
}
bootstrap();
```
然后创建 public/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    光光光
</body>
</html>
```
访问下看看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d94267c266948a9a60ef3126813091f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=164&s=15408&e=png&b=ffffff)

接下来要接入高德地图。

先按照[文档](https://lbs.amap.com/api/javascript-api-v2/getting-started)的步骤获取 key

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9309773ea1294e8caad93a28821e1b0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2322&h=790&s=251333&e=png&b=fefefe)

这个很简单，填一下信息就好。

点击[创建新应用](https://console.amap.com/dev/key/app)，选择 web 应用，就可以生成 key 了

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8facc24e999347cc9eb9357f3b88f9a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2326&h=468&s=99448&e=png&b=fcfcfc)

然后把文档的 [demo 代码](https://lbs.amap.com/demo/javascript-api-v2/example/map-componets/map-overlays)复制过来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d4a2c8d922e4a1c917db9ca543da97f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2814&h=1408&s=816652&e=png&b=f9eeec)

改成这样：

```html
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <title>附近的充电宝</title>
  <link rel="stylesheet" href="https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css" />
    <script src="https://cache.amap.com/lbs/static/es5.min.js"></script>
    <script type="text/javascript" src="https://cache.amap.com/lbs/static/addToolbar.js"></script>
    <style>
        html,
        body,
        #container {
          width: 100%;
          height: 100%;
        }
    </style>
</head>
<body>
<div id="container"></div>
<script src="https://webapi.amap.com/maps?v=2.0&key=f96fa52474cedb7477302d4163b3aa09"></script>
<script>
var map = new AMap.Map('container', {
    resizeEnable: true,
    zoom: 6,
    center: [116.397444, 39.909183]
});

var marker = new AMap.Marker({
    icon: "https://webapi.amap.com/theme/v1.3/markers/n/mark_b.png",
    position: [116.399327,39.908562],
    anchor:'bottom-center'
});

var circle = new AMap.Circle({
    center: new AMap.LngLat(116.397444, 39.909183), // 圆心位置
    radius: 50,
    strokeColor: "#F33",  //线颜色
    strokeOpacity: 1,  //线透明度
    strokeWeight: 3,  //线粗细度
    fillColor: "#ee2200",  //填充颜色
    fillOpacity: 0.35 //填充透明度
});

map.add(marker);
map.add(circle);

map.setFitView();

</script>
</body>
</html>
```
在天安门画了一个 circle，然后在文化宫科技馆画了一个 marker：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67157c4f02dd413fad750239e3a17dc2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1028&h=568&s=151672&e=png&b=e4eecb)

接下来引入 axios，来调用服务端接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc1d4f26b8454ece90d20733a7b64d53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1344&h=956&s=184709&e=png&b=1f1f1f)
```html
<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no, width=device-width">
    <title>附近的充电宝</title>
  <link rel="stylesheet" href="https://a.amap.com/jsapi_demos/static/demo-center/css/demo-center.css" />
    <script src="https://cache.amap.com/lbs/static/es5.min.js"></script>
    <script type="text/javascript" src="https://cache.amap.com/lbs/static/addToolbar.js"></script>
    <style>
        html,
        body,
        #container {
          width: 100%;
          height: 100%;
        }
        
        label {
            width: 55px;
            height: 26px;
            line-height: 26px;
            margin-bottom: 0;
        }
        button.btn {
            width: 80px;
        }
    </style>
</head>
<body>
<div id="container"></div>
<script src="https://webapi.amap.com/maps?v=2.0&key=f96fa52474cedb7477302d4163b3aa09"></script>
<script src="https://unpkg.com/axios@1.5.1/dist/axios.min.js"></script>
<script>

    const radius = 0.2;

    axios.get('/nearbySearch', {
        params: {
            longitude: 116.397444,
            latitude: 39.909183,
            radius
        }
    }).then(res => {
        const data = res.data;

        var map = new AMap.Map('container', {
            resizeEnable: true,
            zoom: 6,
            center: [116.397444, 39.909183]
        });

        data.forEach(item => {
            var marker = new AMap.Marker({
                icon: "https://webapi.amap.com/theme/v1.3/markers/n/mark_b.png",
                position: [item.longitude, item.latitude],
                anchor: 'bottom-center'
            });
            map.add(marker);
        });


        var circle = new AMap.Circle({
            center: new AMap.LngLat(116.397444, 39.909183), // 圆心位置
            radius: radius * 1000,
            strokeColor: "#F33",  //线颜色
            strokeOpacity: 1,  //线透明度
            strokeWeight: 3,  //线粗细度
            fillColor: "#ee2200",  //填充颜色
            fillOpacity: 0.35 //填充透明度
        });

        map.add(circle);
        map.setFitView();
    })
        
</script>
</body>
</html>
```
效果是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7857bdf3275f4f549619dae6cfb5d1f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=1148&s=518801&e=png&b=e9eecb)

然后把 radius 改成 0.05，是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498e4b77aee8419fb8d10b3d06a4861a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=576&s=156421&e=png&b=e6eecd)

这样就实现了查找附近的充电宝的功能。

代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/nearby-search)
## 总结

我们经常会使用基于位置的功能，比如附近的充电宝、酒店，打车，附近的人等功能。

这些都是基于 redis 实现的，因为 redis 有 geo 的数据结构，可以方便的计算两点的距离，计算某个半径内的点。

前端部分使用地图的 sdk 分别在搜出的点处绘制 marker 就好了。

geo 的底层数据结构是 zset，所以可以使用 zset 的命令。

我们在 Nest 里封装了 geoadd、geopos、zrange、georadius 等 redis 命令。实现了添加点，搜索附近的点的功能。

以后再用这类附近的 xxx 功能，你是否会想起 redis 呢？


## 75.用 Swagger 自动生成 api 文档

后端开发完接口后，需要给前端一份接口文档，描述有哪些接口，是 GET 还是 POST，有哪些参数，响应是什么。

但是写完代码后再去单独写一份这样的文档还是很麻烦的，并且改动接口之后也要同步去修改接口文档。

能不能自动生成 API 接口文档呢？

是可以的，就是这节要讲的 swagger。

我们新建个项目：
```
nest new swagger-test -p npm
```
安装 swagger 的包：

```
npm install --save @nestjs/swagger
```

然后在 main.ts 添加这样一段代码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c645be06c5b4a17b5559a461ab31592~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const config = new DocumentBuilder()
    .setTitle('Test example')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('test')
    .build();
const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('doc', app, document);
```
通过 DocumentBuilder 创建 config。

然后用 SwaggerModule.createDocument 根据 config 创建文档。

之后用 SwaggerModule.setup 指定在哪个路径可以访问文档。

跑起来试试：

```
npm run start:dev
```
访问 http://localhost:3000/doc 就可以看到 swagger 的 api 文档了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b17204d5704ab6ad958322794bb88d~tplv-k3u1fbpfcp-watermark.image?)

和 DocumentBuilder 填的配置的对应关系如下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/945dc014c5984efb9736936dc06507b8~tplv-k3u1fbpfcp-watermark.image?)

现在只有一个接口，调用会返回 hello world：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517ff7aef95d45eb808e1de8b20bcf73~tplv-k3u1fbpfcp-watermark.image?)

点击 try it out，再点击 execute，就可以看到返回的响应体和 header：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e13e86f9de74368b7453cabcb54fc95~tplv-k3u1fbpfcp-watermark.image?)

我们在 AppController 加几个接口试试：

```javascript
@Get('aaa')
aaa(@Query('a1') a1, @Query('a2') a2) {
    console.log(a1, a2);
    return 'aaa success';
}

@Get('bbb/:id')
bbb(@Param('id') id) {
    console.log(id);
    return 'bbb success';
}

@Post('ccc')
ccc(@Body('ccc') ccc) {
    console.log(ccc);
    return 'ccc success';
}
```

加了一个有 query 参数、一个有 param 参数、一个有 body 参数的接口。

刷新下可以看到，这几个接口都列出来了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfd5095e658f45e68550100fb4ac439d~tplv-k3u1fbpfcp-watermark.image?)

但是都没有 param 的描述和 response 的描述：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92a96da2278c45c5a9fb83dad8e8ad9c~tplv-k3u1fbpfcp-watermark.image?)

这时就需要我们手动标注了：

```javascript
@ApiOperation({ summary: '测试 aaa',description: 'aaa 描述' })
@ApiResponse({
    status: HttpStatus.OK,
    description: 'aaa 成功',
    type: String
})
@Get('aaa')
aaa(@Query('a1') a1, @Query('a2') a2) {
    console.log(a1, a2);
    return 'aaa success';
}
```
给 aaa 接口添加 @ApiOperation 和 @ApiResponse 的装饰器。

这俩分别是指定这个接口的描述，接口的响应的。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc02071eead047c9a037c29fa5d197a0~tplv-k3u1fbpfcp-watermark.image?)

再加上 @ApiQuery 来添加 query 参数的说明：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddab64ec2ad04c35a54f79245f26786d~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiQuery({
    name: 'a1',
    type: String,
    description: 'a1 param',
    required: false,
    example: '1111',
})
@ApiQuery({
    name: 'a2',
    type: Number,
    description: 'a2 param',
    required: true,
    example: 2222,
})  
```
刷新下，可以看到 swagger 文档里出现了这两个参数的说明：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0be733a2a8eb4701b4dcc4f7b4dcbf4e~tplv-k3u1fbpfcp-watermark.image?)

点击 try it out 和 execute，就可以看到发送了请求并返回了响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05da071c7fcb46b9a3da7a347735529c~tplv-k3u1fbpfcp-watermark.image?)

这样，一个接口就描述完了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5427ccb8ee86457ea1059b164eff0b30~tplv-k3u1fbpfcp-watermark.image?)

通过 @ApiOperation 描述接口的信息，@ApiResponse 描述返回值信息，@ApiQuery 描述 query 参数信息。

就能生成对应的 swagger 文档：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4360aa09d0a446d2bfa7039ea93a2f82~tplv-k3u1fbpfcp-watermark.image?)

我们接着来生成 bbb 接口的 swagger 文档：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea2eee5a5bc846a18f17590b9e88fbfe~tplv-k3u1fbpfcp-watermark.image?)

这里用到的是 @ApiParam 而不是 @ApiQuery，其余部分一样：
```javascript
@ApiOperation({ summary: '测试 bbb',description: 'bbb 描述' })
@ApiResponse({
    status: HttpStatus.OK,
    description: 'bbb 成功',
    type: String
})
@ApiParam({
    name: 'id',
    description: 'ID',
    required: true,
    example: 222,
})
```
刷新可以看到 bbb 接口的文档：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/928e4e0819c64c60a839dc77b203fba8~tplv-k3u1fbpfcp-watermark.image?)

那如果 id 不合法的时候，我返回了一个 401 的响应呢？

那就再加一个 @ApiResponse

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbebbca1221c4ff1bcb7f07bb0087faa~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@ApiOperation({ summary: '测试 bbb',description: 'bbb 描述' })
@ApiResponse({
    status: HttpStatus.OK,
    description: 'bbb 成功',
    type: String
})
@ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'id 不合法'
})
@ApiParam({
    name: 'id',
    description: 'ID',
    required: true,
    example: 222,
})
@Get('bbb/:id')
bbb(@Param('id') id: number) {
    console.log(id);
    if(id !== 111) {
      throw new UnauthorizedException();
    }
    return 'bbb success';
}
```
刷新下，可以看到 swagger 文档标识出了这两种响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1e6369dab694daeb2afbc546cfa201b~tplv-k3u1fbpfcp-watermark.image?)

然后再来写 ccc 接口的文档：

ccc 接收的是请求体的参数，我们创建个 CccDto。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/185022403c7a4b05bcb40432470b2e50~tplv-k3u1fbpfcp-watermark.image?)

```javascript
export class CccDto {
    aaa: string;
    bbb: number;
    ccc: Array<string>;
}
```
接收参数通过 dto 来接收，而返回值放在 vo 里：

```javascript
@Post('ccc')
ccc(@Body('ccc') ccc: CccDto) {
    console.log(ccc);
    return {
      aaa: 111,
      bbb: 222
    };
}
```
创建个 vo 的 class：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d057b89a9f934284bdc503a5ab75cb63~tplv-k3u1fbpfcp-watermark.image?)
```javascript
export class CccVo {
    aaa: number;
    bbb: number;
}
```
返回值就可以改成这样了：

```javascript
@Post('ccc')
ccc(@Body('ccc') ccc: CccDto) {
    console.log(ccc);

    const vo = new CccVo();
    vo.aaa = 111;
    vo.bbb = 222;
    return vo;
}
```

这里的 dto、vo 随便搜一下就能查到解释：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b8dc9e339e846f19a8129d2836abd43~tplv-k3u1fbpfcp-watermark.image?)

在 Nest 里要能清楚的区分 dto、vo、entity 的区别：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edaa8bcb7b60410381818bb437fc9e9e~tplv-k3u1fbpfcp-watermark.image?)

dto 是 data transfer object，用于参数的接收。

vo 是 view object，用于返回给视图的数据的封装。

而 entity 是和数据库表对应的实体类。

然后我们继续来写 ccc 接口的 swagger 文档。

很容易想到，body 的描述是通过 @ApiBody 的装饰器：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39542f0b140443f185e16d6284e94628~tplv-k3u1fbpfcp-watermark.image?)
```javascript
@ApiOperation({summary:'测试 ccc'})
@ApiResponse({
    status: HttpStatus.OK,
    description: 'ccc 成功',
    type: CccVo
})
@ApiBody({
    type: CccDto
})
@Post('ccc')
ccc(@Body('ccc') ccc: CccDto) {
    console.log(ccc);

    const vo = new CccVo();
    vo.aaa = 111;
    vo.bbb = 222;
    return vo;
}
```

刷新页面，你会看到除了接口外，还生成了俩 schema。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d78231587744afbacb85f8c3c7fc3e9~tplv-k3u1fbpfcp-watermark.image?)

也就是说对象的响应会对应 swagger 的 schema。

只不过现在 CccDto、CccVo 的 schema 没有内容，这是因为我们还没有标注。

在 CccDto 加一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb3e22b2a6447c8a5232f2a7e57c1cb~tplv-k3u1fbpfcp-watermark.image?)

aaa、bbb、ccc 通过 @ApiProperty 标识下，并且 bbb 是 @ApiPropertyOptional，也就是可选，这个和 @ApiProperty({ required: false }) 等价。

aaa 可以传 enum 的值，取值范围是 a1、a2、a3。

同样，CccVo 也加一下：

```javascript
import { ApiProperty } from "@nestjs/swagger";

export class CccVo {
    @ApiProperty({ name: 'aaa' })
    aaa: number;

    @ApiProperty({ name: 'bbb' })
    bbb: number;
}
```
刷新下，现在就可以看到 CccDto、CccVo 的 schema 有属性了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/433d58322cd84bbf964323d28a4e7b74~tplv-k3u1fbpfcp-watermark.image?)

其中 bbb 是没有 * 的，代表可不传。

上面的接口部分也有了请求和响应的示例：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cee6fce3f6d34449a210dbf71fe613f0~tplv-k3u1fbpfcp-watermark.image?)

点下 try it out，可以自己编辑请求体：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f08047115ad04ef9a5f8fabeec948dfa~tplv-k3u1fbpfcp-watermark.image?)

然后点击 execute 就可以看到响应的内容和 header：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d831fe310e9a41128c3c5f6e01bdbd24~tplv-k3u1fbpfcp-watermark.image?)

服务端也确实接收到了这个请求：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89aa180b109e45688f5db458e6188dc9~tplv-k3u1fbpfcp-watermark.image?)

可以用 swagger 来方便的测试接口。

此外，还可以通过 @ApiTags 来给接口分组：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d963555e47bc4ac7979999931a7bfeea~tplv-k3u1fbpfcp-watermark.image?)

比如 controller 是 xxx 开头的，那可以用 @ApiTags 来分组到 xxx。

显示的时候，就会把这个 controller 的接口分到一个组下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4d6cc0150aa4f8d962ea13af2eec87f~tplv-k3u1fbpfcp-watermark.image?)

也可以添加在 handler 上：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1c1e08988874b2d912f7cf5f48fb4b6~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c16f33a37034a33b31c882438507b38~tplv-k3u1fbpfcp-watermark.image?)

比如把 aaa、bbb 接口分到 xxx-get 的组。

那显示的时候就会把这俩接口分出来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/901666caeb6240dc88e1ab6cd0777bc4~tplv-k3u1fbpfcp-watermark.image?)

当接口多了之后，分组还是很有必要的。

回过头来，再讲下 @ApiProperty，其实它还有很多属性：

```javascript
import { ApiProperty, ApiPropertyOptional } from "@nestjs/swagger";

export class CccDto {
    @ApiProperty({ name: 'aaa', enum: ['a1', 'a2', 'a3'], maxLength: 30, minLength: 2, required: true})
    aaa: string;

    @ApiPropertyOptional({ name: 'bbb', maximum: 60, minimum: 40, default: 50, example: 55})
    bbb: number;

    @ApiProperty({ name: 'ccc' })
    ccc: Array<string>;
}
```

比如 required、minium、maximum、default、maxLength 等。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fb118bab6d4056acce8341bedcddb0~tplv-k3u1fbpfcp-watermark.image?)

此外，很多接口是需要登录才能访问的，那如何限制呢？

swagger 也提供了这方面的支持。

常用的认证方式就是 jwt、cookie。

分别在 aaa、bbb、ccc 接口添加 @ApiBearerAuth、@ApiCookieAuth、@ApiBasicAuth

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ea1c748586649e19a7a9c20b3c8980e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c475ca8e76c24cb68986e4197acd116e~tplv-k3u1fbpfcp-watermark.image?)


![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60c028ddc2514f12b15fa9832da658ac~tplv-k3u1fbpfcp-watermark.image?)

然后在 main.ts 里添 3 种认证方式的信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9db844dbb883482fbfb72c689db9e220~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const config = new DocumentBuilder()
    .setTitle('Test example')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('test')
    .addBasicAuth({
      type: 'http',
      name: 'basic',
      description: '用户名 + 密码'
    })
    .addCookieAuth('sid', {
      type: 'apiKey',
      name: 'cookie',
      description: '基于 cookie 的认证'
    })
    .addBearerAuth({
      type: 'http',
      description: '基于 jwt 的认证',
      name: 'bearer'
    })
    .build();
```
刷新页面就可以看到接口出现了锁的标记：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23266a80d42f4459b1255df4979a082f~tplv-k3u1fbpfcp-watermark.image?)

点击 aaa 的锁：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e0b0c78006746bbb39176d04e4eba17~tplv-k3u1fbpfcp-watermark.image?)

输入 jwt 的 token，然后点击 authorize。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55b2d227d3f4cb49383a04acae8641b~tplv-k3u1fbpfcp-watermark.image?)

锁会变成锁住状态，代表授权成功了。

这时候再发一个请求：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5caf31dfd8264d99ab167ee86cb7b41d~tplv-k3u1fbpfcp-watermark.image?)

会发现带上了 Authorization 的 header，这就是我们见过的 jwt 认证方式。

同理，下面的 cookie 会带上对应的 cookie来认证：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c021aa0737dc4b3f92329c9fb21feaaa~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da5b7aec500e4165804e0101c1c0e80e~tplv-k3u1fbpfcp-watermark.image?)

而 basic 的方式，会要求你输入用户名密码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09aa9509541f48208dd4a29dfc6c94f3~tplv-k3u1fbpfcp-watermark.image?)

请求时会带上 Authorization： Basic xxx 的 header 来访问。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d43a6425294432fa742256fd7fae12b~tplv-k3u1fbpfcp-watermark.image?)

这样，这些需要授权的接口就分别添加上了不同的认证方式的标识。

其实，swagger 是一种叫做 openapi 标准的实现。

在 /doc 后加上个 -json 就可以看到对应的 json

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a05e60ef45b440fbf084e33eff22f05~tplv-k3u1fbpfcp-watermark.image?)

装个格式化 chrome 插件格式化一下，大概是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0da0580723d04a35899855cc57e892d6~tplv-k3u1fbpfcp-watermark.image?)

如果你觉得 swagger 文档比较丑，可以这个 json 导入别的平台。

一般 api 接口的平台都是支持 openapi 的。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/swagger-test)

## 总结

这节我们学习了 swagger 自动生成文档。

需要先安装 @nestjs/swagger 的包。

然后在 main.ts 里用 DocumentBuilder + SwaggerModule.createDocuemnt 创建 swagger 文档配置，然后 setup 跑起来就好了。

还需要手动加一些装饰器来标注：

- ApiOperation：声明接口信息
- ApiResponse：声明响应信息，一个接口可以多种响应
- ApiQuery：声明 query 参数信息
- ApiParam：声明 param 参数信息
- ApiBody：声明 body 参数信息，可以省略
- ApiProperty：声明 dto、vo 的属性信息
- ApiPropertyOptional：声明 dto、vo 的属性信息，相当于 required: false 的 ApiProperty
- ApiTags：对接口进行分组
- ApiBearerAuth：通过 jwt 的方式认证，也就是 Authorization: Bearer xxx
- ApiCookieAuth：通过 cookie 的方式认证
- ApiBasicAuth：通过用户名、密码认证，在 header 添加 Authorization: Basic xxx

swagger 是 openapi 标准的实现，可以在 url 后加个 -json 拿到对应的 json，然后导入别的接口文档平台来用。

绝大多数公司的接口文档都是用 swagger 来自动生成的，不然手动维护太麻烦了。

而且 swagger 还可以方便的测试接口，自动添加身份认证等。

你们公司用的是 swagger 生成的接口文档么？


## 76.如何灵活创建 DTO

dto 是 data transfer object，用于封装请求参数，后端应用常见对象。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c5a32fca1704b23b62698a3028b73ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=334&s=18760&e=png&b=ffffff)

当开发 CRUD 接口的时候，你会发现 create 的 dto 对象和 update 的 dto 对象很类似。

那能不能不从头创建，而是基于已有的对象来创建呢？

可以的。

我们来试一下：

```
nest new dto-vo-test
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17a5386e3cca4f3f888f81cfc0dddbab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=822&h=688&s=254276&e=png&b=010101)

创建个 nest 项目。

进入项目，创建 aaa 的 crud 模块：

```
nest g resource aaa
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83077f87b50a4ba09806222eec3a3af9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=486&s=109582&e=png&b=191919)

可以看到，它自动创建了 CreateAaaDto、UpdateAaaDto 用来封装 create、update 的参数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eea77dedb76745f5b44d1eeb99745fc3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592&h=770&s=242151&e=png&b=1e1e1e)

改下 aaa.entity.ts

```javascript
export class Aaa {

    id: number;

    name: string;

    age: number;

    sex: boolean;
    
    email: string;

    hoobies: string[]
}
```

Entity 有 id、name、age、sex、email、hobbies 这些字段。

那 CreateAaaDto 里要有 name、age、sex、email、hobbies 这些字段

而 UpdateAaaDto 里也是 name、age、sex、email、hobbies 这些字段。

```javascript
export class CreateAaaDto {
    name: string;

    age: number;

    sex: boolean;

    email: string;

    hoobies: string[]
}
```

```javascript
export class UpdateAaaDto  {

    name: string;

    age: number;

    sex: boolean;

    email: string;

    hoobies: string[]
}
```

而且我们还要用 ValidationPipe 加上参数校验。

安装用到的包：

```
npm install --save class-validator class-transformer
```
然后在 CreateAaaDto 和 UpdateAaaDto 加一下验证：

```javascript
import { IsBoolean, IsEmail, IsNotEmpty, IsNumber, Length, MaxLength, MinLength } from "class-validator";

export class CreateAaaDto {
    @IsNotEmpty()
    @MinLength(4)
    @MaxLength(20)
    name: string;

    @IsNotEmpty()
    @IsNumber()
    age: number;

    @IsNotEmpty()
    @IsBoolean()
    sex: boolean;

    @IsNotEmpty()
    @IsEmail()
    email: string;

    hoobies: string[]
}
```

```javascript
import { IsBoolean, IsEmail, IsNotEmpty, IsNumber, Length, MaxLength, MinLength } from "class-validator";

export class UpdateAaaDto {
    @IsNotEmpty()
    @MinLength(4)
    @MaxLength(20)
    name: string;

    @IsNotEmpty()
    @IsNumber()
    age: number;

    @IsNotEmpty()
    @IsBoolean()
    sex: boolean;

    @IsNotEmpty()
    @IsEmail()
    email: string;

    hoobies: string[]
}
```
然后全局启用 ValidationPipe：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/326e0c5da7cc45758e84c00dbe83b7e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=886&h=564&s=106817&e=png&b=1f1f1f)

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalPipes(new ValidationPipe({
    transform: true
  }))

  await app.listen(3000);
}
bootstrap();
```
transform 指定为 true，这样会自动把参数的 js 对象转换为 dto 类型对象。

打印下 dto 对象：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/324fda2748f7496597f774d9e5e599ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1144&h=958&s=204936&e=png&b=1f1f1f)

测试下：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d5c752d1afd4bb4aac734a7ce084438~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1540&h=532&s=232104&e=png&b=181818)

create 接口，当参数没通过校验时：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/830b1f10b4a648e78fe94720723c12b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=942&s=110173&e=png&b=fcfcfc)

参数通过校验后：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9f9614725ce4aa9856a3fc645508b62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=706&s=81343&e=png&b=fcfcfc)

可以看到，打印的是 CreateAaaDto 的对象，说明 ValidationPipe 的 transform 生效了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/536f34c432fa41909b242b5684ffe8fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1052&h=976&s=264409&e=png&b=1a1a1a)

再试下 update 接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0072467cfa0f4c709a55bb0a456d3304~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=702&s=80229&e=png&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bc3accb2a184398b662ee56361569b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1216&h=1094&s=320800&e=png&b=1b1b1b)

也没问题。

虽然没问题，但是现在 CreateAaaDto 和 UpdateAaaDto 明显重复太多了。

很多字段重复写了两次。

有什么办法能避免这种重复呢？

很简单呀，继承不就行了？

```javascript
import { CreateAaaDto } from "./create-aaa.dto";

export class UpdateAaaDto extends CreateAaaDto {
}
```
试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bde4e21560e2483b890520b65c3a46c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=836&h=752&s=82758&e=png&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e286c01584a14eb0b402ab83fd3fbc07~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=964&h=920&s=239835&e=png&b=1a1a1a)

没啥问题。

当然，现在所有字段都是必填的，比如 name、age、email 等。

其实更新的时候可以只更新 name 或者 email。

这时候直接继承就不行了。

可以用 PartialType 处理下：

```javascript
import { PartialType } from '@nestjs/mapped-types';
import { CreateAaaDto } from "./create-aaa.dto";

export class UpdateAaaDto extends PartialType(CreateAaaDto) {

}
```
试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1c96401aad64bbb8190b8f91ac5bf74~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=682&s=70734&e=png&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7e084c0da2d42fa89562dcbf3d64052~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1112&h=936&s=259268&e=png&b=1b1b1b)

现在只填部分字段依然校验通过了。

好神奇，我们不是指定了 @IsNotEmpty 了么？

咋继承过来就没了呢？

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcb957a71fd4483dafa7e25de6641e19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=592&h=616&s=73723&e=png&b=1f1f1f)

这是因为 PartialType 内部做了处理。

简单看下源码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f0abde361f84fa88da76c293a8719b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1226&h=1076&s=234208&e=png&b=1f1f1f)

它创建了一个新的 class 返回，继承了传入的 class 的属性，和 validation metadata。

但是添加一个一个 @IsOptional 的装饰器。

这样可不就变为可选的了么？

类似的这样的方法还有几个：

比如 PickType：

```javascript
import { PartialType, PickType } from '@nestjs/mapped-types';
import { CreateAaaDto } from "./create-aaa.dto";

export class UpdateAaaDto extends PickType(CreateAaaDto, ['age', 'email']) {

}

```
现在可以只传 age、email 这两个字段：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da4a5390ecd14e14910c07d5bc7c0b22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=774&h=728&s=66524&e=png&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9c8b1d4b83f442fb30514f552d7ac45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1242&h=860&s=264169&e=png&b=1b1b1b)

但它和 PartialType 不同，Pick 出来的字段并不会变为可选：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a69e69f1ec1e44ec8a391bb4103b13a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=872&s=82949&e=png&b=fcfcfc)

或者也可以用 OmitType，从之前的 dto 删除几个字段：

```javascript
import { OmitType, PartialType, PickType } from '@nestjs/mapped-types';
import { CreateAaaDto } from "./create-aaa.dto";

export class UpdateAaaDto extends OmitType(CreateAaaDto, ['name', 'hoobies', 'sex']) {

}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b810bb318544c3babad313254e6838c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=808&h=782&s=84553&e=png&b=fcfcfc)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dd19780b0254786bac0e74c756e01eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=572&s=63956&e=png&b=fbfbfb)

效果一样。

PickType 是从中挑选几个，OmitType 是从中去掉几个取剩下的。

此外，如果你有两个 dto 想合并，可以用 IntersectionType。

创建个 xxx.dto.ts

```javascript
import { IsNotEmpty, IsNumber, MinLength } from "class-validator";

export class XxxDto {
    @IsNotEmpty()
    @MinLength(4)
    xxx: string;

    @IsNotEmpty()
    @IsNumber()
    yyy: number;
}

```
用 CreateAaaDto 和 XxxDto 来创建 UpdateAaaDto：

```javascript
import { IntersectionType } from '@nestjs/mapped-types';
import { CreateAaaDto } from "./create-aaa.dto";
import { XxxDto } from './xxx.dto';

export class UpdateAaaDto extends IntersectionType(CreateAaaDto, XxxDto) {

}
```

可以看到，现在会提示你这些字段都是必填的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/082077d6cc124119873e4b21f4fb0653~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1054&h=992&s=161446&e=png&b=fdfdfd)

这些字段都填上之后，校验就通过了：
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef17b8ed693148419177bf8ee0d62641~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750&h=726&s=77552&e=png&b=fcfcfc)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6535a42b7a514fd699047507845649c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1336&h=1082&s=328080&e=png&b=1a1a1a)

服务端接收到了 dto 的数据。

当然，PartialType、PickType、OmitType、IntersectionType 经常会组合用：

```javascript
import { IntersectionType, OmitType, PartialType, PickType } from '@nestjs/mapped-types';
import { CreateAaaDto } from "./create-aaa.dto";
import { XxxDto } from './xxx.dto';

export class UpdateAaaDto extends IntersectionType(
    PickType(CreateAaaDto, ['name', 'age']), 
    PartialType(OmitType(XxxDto, ['yyy']))
) {

}
```
从 CreateAaaDto 里拿出 name 和 age 属性，从 XxxDto 里去掉 yyy 属性变为可选，然后两者合并。

试一下效果：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83c19afb7c944969c24b1ec83206c44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=982&s=113374&e=png&b=fdfdfd)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a55eb90c89e14a20be70f5c1a1235f15~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=782&h=738&s=66423&e=png&b=fcfcfc)

name 必填、xxx 不是必填。

这样创建 dto 对象可太灵活了，随意组合已有的 dto 就行。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/dto-vo-test)

## 总结

开发 CRUD 接口的时候，经常会发现 update 的 dto 和 create 的 dto 很类似，而我们要重复的写两次。

这时候可以用 @nestjs/mapped-types 的 PartialType、PickType、OmitType、IntersectionType 来避免重复。

PickType 是从已有 dto 类型中取某个字段。

OmitType 是从已有 dto 类型中去掉某个字段。

PartialType 是把 dto 类型变为可选。

IntersectionType 是组合多个 dto 类型。

灵活运用这些方法，可以轻松的基于已有 dto 创建出新的 dto。


## 77.class- validator 的内置装饰器，如何自定义装饰器

我们会用 class-validator 的装饰器对 dto 对象做校验。

那 class-validator 都有哪些装饰器可用呢？

这节我们来过一遍。

```
nest new class-validator-decorators
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d7af944d38b4d50bf41fed5602c29c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1026&h=688&s=313314&e=png&b=010101)

创建个 CRUD 模块：

```
nest g resource aaa --no-spec
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/607e2e7bd0f84e2487119252fa87892f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=346&s=86022&e=png&b=191919)

全局启用 ValidationPipe，对 dto 做校验：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3d0bd2c1e09499990ab88db86e58899~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=978&h=426&s=100502&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bc21983dce14461b605477ebe7d107b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=900&h=482&s=98919&e=png&b=1f1f1f)

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
}
bootstrap();
```

安装用到的 class-validator 和 class-transformer 包：

```
npm install --save class-validator class-transformer
```
然后在 create-aaa.dto.ts 加一下校验：

```javascript
import { IsEmail, IsNotEmpty, IsString } from "class-validator";

export class CreateAaaDto {

    @IsNotEmpty({message: 'aaa 不能为空'})
    @IsString({message: 'aaa 必须是字符串'})
    @IsEmail({}, {message: 'aaa 必须是邮箱'})
    aaa: string;

}
```
把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5416023b3e8f4e64a42b9416bc7f8f8f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1532&h=510&s=244441&e=png&b=181818)

postman 里访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/609738a364a44bdaa23b259fd7851cef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=790&s=79083&e=png&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1c0389b2624006aca0d0e512c226b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=744&s=71630&e=png&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a30f1fddf7984de6a498ed5b440d65af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=662&h=536&s=46342&e=png&b=fbfbfb)

这就是 class-validator 的装饰器的用法。

类似这种装饰器有很多。

和 @IsNotEmpty 相反的是 @IsOptional：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5448bb691b364a85825ecef18d6569ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=834&h=384&s=87688&e=png&b=1f1f1f)

加上之后就是可选的了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1732de37c6ce40d48ba1c0af69e26bcb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=728&h=572&s=45140&e=png&b=fbfbfb)

上节学的 PartialType 就是用的 IsOptional 装饰器实现的。

@IsIn 可以限制属性只能是某些值：

```javascript
@IsNotEmpty({message: 'aaa 不能为空'})
@IsString({message: 'aaa 必须是字符串'})
@IsEmail({}, {message: 'aaa 必须是邮箱'})
@IsIn(['aaa@aa.com', 'bbb@bb.com'])
aaa: string;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75a1ff9e712e4bef89e486dcfc8004d7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1086&h=752&s=89576&e=png&b=fcfcfc)

还有 @IsNotIn，可以限制属性不能是某些值：

```javascript
@IsNotEmpty({message: 'aaa 不能为空'})
@IsString({message: 'aaa 必须是字符串'})
@IsEmail({}, {message: 'aaa 必须是邮箱'})
@IsNotIn(['aaa@aa.com', 'bbb@bb.com'])
aaa: string;
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e69acf3dc0934e72aeb069e601e04e93~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=682&s=94930&e=png&b=fcfcfc)

@IsBoolean、@IsInt、@IsNumber、@IsDate 这种就不说了。

@IsArray 可以限制属性是 array：

```javascript
@IsArray()
bbb:string;
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d0593ba68f54db9b3af50642aa1cb26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=670&h=570&s=50464&e=png&b=fbfbfb)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc4a4af2eb82415ab4a8737d2cd32bf6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=658&h=770&s=68187&e=png&b=fcfcfc)

@ArrayContains 指定数组里必须包含的值：

```javascript
@IsArray()
@ArrayContains(['aaa'])
bbb:string;
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3be40954cfd472f8d7f086149fc2ed3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=744&s=73050&e=png&b=fbfbfb)

类似的还有 @ArrayNotContains 就是必须不包含的值。

@ArrayMinSize 和 @ArrayMaxSize 限制数组的长度。

@ArrayUnique 限制数组元素必须唯一：

```javascript
@IsArray()
@ArrayNotContains(['aaa'])
@ArrayMinSize(2)
@ArrayMaxSize(5)
@ArrayUnique()
bbb:string;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/287585c939b447d08e223b8fa903c78c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=880&h=768&s=89883&e=png&b=fcfcfc)

前面讲过 @IsNotEmpty，和它类似的还有 @IsDefined。

@IsNotEmpty 检查值是不是 ''、undefined、null。

@IsDefined 检查值是不是 undefined、null。

当你允许传空字符串的时候就可以用 @IsDefined。

```javascript
@IsDefined()
ccc: string;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21e0ae4480b41c2a6abb4ba2ac19a5d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=682&h=646&s=54520&e=png&b=fbfbfb)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d650e234876a48d599fdaa56ee30f05c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=800&s=77837&e=png&b=fcfcfc)

如果是 @IsNotEmpty，那空字符串也是不行的：

```javascript
// @IsDefined()
@IsNotEmpty()
ccc: string;
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ca17d521374bcebd274a7d967f8621~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=694&h=786&s=74939&e=png&b=fcfcfc)

数字可以做更精准的校验：

```javascript
@IsPositive()
@Min(1)
@Max(10)
@IsDivisibleBy(2)
ddd:number;
```
@IsPositive 是必须是正数、@IsNegative 是必须是负数。

@Min、@Max 是限制范围。

@IsDivisibleBy 是必须被某个数整除。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/504219b2805e4ec1994db65e0f6a85e3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=798&h=848&s=95801&e=png&b=fcfcfc)

@IsDateString 是 ISO 标准的日期字符串：

```javascript
@IsDateString()
eee: string;
```
也就是这种：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b35e18bb026a47089a3d7e3f4275ba80~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=148&s=20010&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba93bb8349dd49958630659abecab434~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702&h=650&s=64697&e=png&b=fbfbfb)

还有几个字符串相关的：

@IsAlpha 检查是否只有字母

@IsAlphanumeric 检查是否只有字母和数字

@Contains 是否包含某个值

```javascript
@IsAlphanumeric()
@Contains('aaa')
fff: string;
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2da3a04f915844538acc9475883c636d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=836&s=99112&e=png&b=fdfdfd)

字符串可以通过 @MinLength、@MaxLength、@Length 来限制长度：

```javascript
@MinLength(2)
@MaxLength(6)
ggg: string;
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/983c5b4ec6d0484c816835525cf5778d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=892&h=746&s=87899&e=png&b=fcfcfc)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20a4d78a891a4e829c98817b24a019a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&h=824&s=98238&e=png&b=fdfdfd)

也可以用 @Length：

```javascript
@Length(2, 6)
ggg: string;
```
还可以校验颜色值的格式：@IsHexColor、@IsHSL、@IsRgbColor

校验 IP 的格式：@IsIP

校验端口： @IsPort

校验 JSON 格式 @IsJSON

常用的差不多就这些，更多的可以看 [class-validator 的文档](https://www.npmjs.com/package/class-validator#validation-decorators)。

此外，如果某个属性是否校验要根据别的属性的值呢？

这样：

```javascript
@IsBoolean()
hhh: boolean;

@ValidateIf(o => o.hhh === true)
@IsNotEmpty()
@IsHexColor()
iii: string;
```
如果 hhh 传了 true，那就需要对 iii 做校验，否则不需要。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b0e21cc11f347deabcf76d552754ada~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=764&s=84550&e=png&b=fcfcfc)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9686efe0623d4289965192ce3521fa97~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=582&s=58467&e=png&b=fcfcfc)

此外，如果这些内置的校验规则都不满足需求呢？

那就自己写！

创建 my-validator.ts

```javascript
import { ValidationArguments, ValidatorConstraint, ValidatorConstraintInterface } from "class-validator";

@ValidatorConstraint()
export class MyValidator implements ValidatorConstraintInterface {
    validate(text: string, validationArguments: ValidationArguments) {
        console.log(text, validationArguments)
        return true;
    }
}
```
用 @ValidatorConstraint 声明 class 为校验规则，然后实现 ValidatorConstraintInterface 接口。

用一下：
```javascript
@Validate(MyValidator, [11, 22], {
    message: 'jjj 校验失败',
})
jjj: string;
```

访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42044f93b98e4fa3aaad129cd07a64ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=832&h=668&s=70494&e=png&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0ec622e3aec4e75946a44e6601071b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=856&h=1016&s=181442&e=png&b=1a1a1a)

第一个参数传入的字段值，第二个参数包含更多信息，比如 @Validate 指定的参数在 constraints 数组里。

这样，我们只要用这些做下校验然后返回 true、false 就好了。

比如这样：

```javascript
import { ValidationArguments, ValidatorConstraint, ValidatorConstraintInterface } from "class-validator";

@ValidatorConstraint()
export class MyValidator implements ValidatorConstraintInterface {
    validate(text: string, validationArguments: ValidationArguments) {
        // console.log(text, validationArguments)
        return text.includes(validationArguments.constraints[0]);
    }
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d291e4fac9143b4b1e8141cc23f8076~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=798&s=83723&e=png&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80db0e02573a437b85f220471afac3ed~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=660&s=58450&e=png&b=fbfbfb)

内容包含 11 的时候才会校验通过。

那如果这个校验是异步的呢？

返回 promise 就行：

```javascript
import { ValidationArguments, ValidatorConstraint, ValidatorConstraintInterface } from "class-validator";

@ValidatorConstraint()
export class MyValidator implements ValidatorConstraintInterface {
    async validate(text: string, validationArguments: ValidationArguments) {
        // console.log(text, validationArguments)
        return new Promise<boolean>((resolve) => {
            setTimeout(() => {
                resolve(text.includes(validationArguments.constraints[0]));
            }, 3000);
        })
    }
}
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bff85edb9364b2ea117226a3f15bbf7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=804&s=73948&e=png&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bb15421b41a44ed992160382aceb3ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=684&s=57691&e=png&b=fbfbfb)

这样用起来还是不如内置装饰器简单：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/363e89978931443bbde6c756880c3c14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=262&s=33870&e=png&b=1f1f1f)

可以用我们前面学的创建自定义装饰器的方式来包装一下：

创建 my-contains.decorator.ts

```javascript
import { applyDecorators } from '@nestjs/common';
import { Validate, ValidationOptions } from 'class-validator';
import { MyValidator } from './my-validator';

export function MyContains(content: string, options?: ValidationOptions) {
  return applyDecorators(
     Validate(MyValidator, [content], options)
  )
}
```
用 applyDecorators 组合装饰器生成新的装饰器。

然后用起来就可以这样：

```javascript
@MyContains('111', {
    message: 'jjj 必须包含 111'
})
jjj: string;
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c457a9d48a9d4461b12bfbdafefd1c19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=648&h=776&s=72920&e=png&b=fcfcfc)

我们封装出了 @Contains，其实内置的那些装饰器我们都可以自己封装出来。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/class-validator-decorators)

## 总结

我们过了一遍 class-validator 的常用装饰器。

它们可以对各种类型的数据做精确的校验。

然后 @ValidateIf 可以根据别的字段来决定是否校验当前字段。

如果内置的装饰器不符合需求，完全可以自己实现，然后用 @Validate 来应用，用自定义装饰器 applyDecorators 包一层之后，和 class-validator 的内置装饰器就一模一样了。

所有的 class-validator 内置装饰器我们完全可以自己实现一遍。


## 78. 序列化 Entity，你不需要 VO 对象

后端系统常见的对象有三种：

Entity：数据实体，和数据库表对应。

DTO： Data Transfer Object，用于封装请求参数。

VO：Value Object，用于封装返回的响应数据。

三者的关系如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd019321aad2433db52a5a5fe537e457~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1626&h=396&s=15066&e=webp&b=fefcfc)

但文档中并没有提到 VO 对象，这是为什么呢？

因为有替代方案。

我们来看一下：

```
nest new vo-test
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19fd570e6f5d40e69b1b2678e49f3823~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=698&s=65154&e=webp&b=020202)

生成一个 user 的 CRUD 模块：

```
nest g resource user --no-spec
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e59b3383b94f83ad1e3c6dc93df1a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790&h=352&s=44190&e=webp&b=191919)

在 entity 里加一些内容：

```javascript
export class User {
    id: number;

    username: string;

    password: string;

    email: string;

    constructor(partial: Partial<User>) {
        Object.assign(this, partial);
    }
}
```

Partial 是把 User 的属性变为可选：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/724b739e321e4f1caff4f4c8fc05465b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=550&h=326&s=17204&e=webp&b=212121)

可以传入部分属性，然后 Object.assign 赋值到 this。

然后 CreateUserDto 里包含这些属性：

```javascript
export class CreateUserDto {
    username: string;

    password: string;

    email: string;
}
```

实现下 UserService 的 create 和 find 的逻辑：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f10bb959b5b410b9556a155bc7352d7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020&h=962&s=50112&e=webp&b=1f1f1f)

这里我们直接用数组模拟 database 来保存数据。

```javascript
import { BadRequestException, Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { User } from './entities/user.entity';

const database = [];
let id = 0;

@Injectable()
export class UserService {
  create(createUserDto: CreateUserDto) {
    const user = new User(createUserDto);

    user.id = id++;

    database.push(user);

    return user;
  }

  findAll() {
    return database;
  }

  findOne(id: number) {
    return database.filter(item =>  item.id === id).at(0);
  }

  update(id: number, updateUserDto: UpdateUserDto) {
    return `This action updates a #${id} user`;
  }

  remove(id: number) {
    return `This action removes a #${id} user`;
  }
}
```

把服务跑起来：

```
npm run start:dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75ff7aa1bb31434c9b69a2528cb9c9be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1562&h=538&s=106074&e=webp&b=191818)

创建两个 user：

![i](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28283119692c4058873b507b4537fe3f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=630&h=802&s=24440&e=webp&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d226a510cf22413a826a31154641367e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=794&s=24340&e=webp&b=fcfcfc)

查一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57056ac036364f1ab3bd45cd804145bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=626&h=884&s=25160&e=webp&b=fcfcfc)

可以看到，user 的 password 也被返回了。

而这个应该过滤掉。

一般这种情况，我们都会封装个 vo。

创建 vo/user.vo.ts：

```javascript
export class UserVo {
    id: number;

    username: string;

    email: string;

    constructor(partial: Partial<UserVo>) {
        Object.assign(this, partial);
    }
}
```

然后把数据封装成 vo 返回：

```javascript
findAll() {
    return database.map(item => {
      return new UserVo({
        id: item.id,
        username: item.username,
        email: item.email
      });
    });
}

findOne(id: number) {
    return database.filter(item =>  item.id === id).map(item => {
      return new UserVo({
        id: item.id,
        username: item.username,
        email: item.email
      });
    }).at(0);
}
```

试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe8e8514d4a643d3a38bc7b5853472e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=678&h=834&s=22600&e=webp&b=fcfcfc)

可以看到，这样就没有 password 了。

但你会发现 UserVo 和 User entity 很类似：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c80fab812a1b4aa98b7f9dc2c9820fa6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=756&h=446&s=18992&e=webp&b=202020)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83cd026b3d3243419952d4b63f89c488~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=500&s=18576&e=webp&b=1f1f1f)

对于 dto 我们可以通过 PartialType、PickType、OmitType、IntersectionType 来组合已有 dto，避免重复。

那 vo 是不是也可以呢？

是的，nest 里可以直接复用 entity 作为 vo。

这里要用到 class-transformer 这个包：

```
npm install --save class-transformer
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f219f7d5e7da427187b9df7f3e29213a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=838&h=646&s=27818&e=webp&b=1f1f1f)

然后在 UserController 的查询方法上加上 ClassSerializerInterceptor 就好了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29cd3977616046a1a498b7f82eb5a4fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=906&h=698&s=42714&e=webp&b=1f1f1f)

代码恢复原样：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7334aaa4bcfb49ab9c39744debb2f4a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=406&s=20614&e=webp&b=1f1f1f)

现在返回的数据就没有 password 字段了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3e65d1324504071b1a115dcd4a5e86a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=660&h=838&s=22328&e=webp&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63a58ef2ea2e42c6ade9f0410f216fd1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806&h=628&s=19222&e=webp&b=fbfbfb)

class-transformer 这个包我们用过，是用于根据 class 创建对应的对象的。

当时是 ValidationPipe 里用它来创建 dto class 对应的对象。

这里也是用它来创建 entity class 对应的对象。

简单看下 ClassSerializerInterceptor 的源码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f22a8ba17451430888d5fd89b0c25b5e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1142&h=1140&s=73802&e=webp&b=1f1f1f)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adfd7b28145a46ed806e0834f4bc3b93~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1160&h=614&s=139600&e=png&b=1f1f1f)

它是通过 map 对响应做转换，在 serialize 方法拿到响应的对象，如果是数组就拿到每个元素。

在 transformToPlain 方法里，调用 classToPlain 创建对象。

它会先拿到响应对象的 class、然后根据 class 上的装饰器来创建新的对象。

当然，装饰器不只有 @Exclude，还有几个有用的：

```javascript
import { Exclude, Expose, Transform } from "class-transformer";

export class User {
    id: number;

    username: string;

    @Exclude()
    password: string;

    @Expose()
    get xxx(): string {
        return `${this.username} ${this.email}`;
    }

    @Transform(({value}) => '邮箱是：' + value)
    email: string;

    constructor(partial: Partial<User>) {
        Object.assign(this, partial);
    }
}
```

@Expose 是添加一个导出的字段，这个字段是只读的。

@Transform 是对返回的字段值做一些转换。

测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad475a19f11446c2ac51099d13341538~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=694&h=760&s=24124&e=webp&b=fcfcfc)

可以看到，返回的数据多了 xxx 字段，email 字段也做了修改：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/507886adacc5487ba057b3608575a763~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=764&h=886&s=29500&e=webp&b=fcfcfc)

这样基于 entity 直接创建 vo 确实方便多了。

此外，你可以可以通过 @SerializeOptions 装饰器加一些序列化参数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39a63ab89e6d43be8a9f4b63b79dc29b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=462&s=28704&e=webp&b=1f1f1f)

strategy 默认值是 exposeAll，全部导出，除了有 @Exclude 装饰器的。

设置为 excludeAl 就是全部排除，除了有 @Expose 装饰器的。

当然，你可以 ClassSerializerInterceptor 和 SerializeOptions 加到 class 上：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ffd5daa800f4aafb4057adf7a3f6395~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=798&h=710&s=20312&e=webp&b=fcfcfc)

这样，controller 所有的接口返回的对象都会做处理：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/731eba777fc346d1a15d9155bc3ece46~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=678&s=21768&e=webp&b=fbfbfb)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f466d3dd59254b1fbc5c89a162d0a701~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=682&s=19764&e=webp&b=fcfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/043d798ccdca42ccb4eef9fe149bdd42~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=670&h=620&s=16000&e=webp&b=fbfbfb)

swagger 那节当返回对象的时候，我们都是创建了个 vo 的类，在 vo class 上加上 swagger 的装饰器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fd51d80deee40df9167688f5565d5ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=812&h=820&s=40860&e=webp&b=202020)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f0894f39cea4b2ba5c1855beb5726d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=810&h=422&s=25486&e=webp&b=202020)

其实没必要，完全可以直接用 entity。

安装 swagger 的包：

```
npm install --save @nestjs/swagger
```

然后在 main.ts 添加 swagger 的入口代码：

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const config = new DocumentBuilder()
    .setTitle('Test example')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('test')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('doc', app, document);

  await app.listen(3000);
}
bootstrap();
```

现在 @apiResponse 里就可以直接指定 User 的 entity 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b8c51901bc480cb552318d27dae5a3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=832&h=928&s=52744&e=webp&b=202020)

```javascript
import { Controller, Get, Post, Body, Patch, Param, Delete, UseInterceptors, ClassSerializerInterceptor, SerializeOptions, HttpStatus } from '@nestjs/common';
import { UserService } from './user.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { ApiBody, ApiOperation, ApiResponse } from '@nestjs/swagger';
import { User } from './entities/user.entity';

@Controller('user')
@SerializeOptions({
  // strategy: 'excludeAll'
})
@UseInterceptors(ClassSerializerInterceptor)
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.userService.create(createUserDto);
  }

  @ApiOperation({summary:'findAll'})
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'ok',
    type: User
  })
  @Get()
  findAll() {
    return this.userService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.userService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.userService.update(+id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.userService.remove(+id);
  }
}
```

在 User 里加一下 swagger 的装饰器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0df788a9c8e47538c5960bbaa7e086e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=948&h=890&s=43764&e=webp&b=1f1f1f)

```javascript
import { ApiHideProperty, ApiProperty } from "@nestjs/swagger";
import { Exclude, Expose, Transform } from "class-transformer";

export class User {
    @ApiProperty()
    id: number;

    @ApiProperty()
    username: string;

    @ApiHideProperty()
    @Exclude()
    password: string;

    @ApiProperty()
    @Expose()
    get xxx(): string {
        return `${this.username} ${this.email}`;
    }

    @ApiProperty()
    @Transform(({value}) => '邮箱是：' + value)
    email: string;

    constructor(partial: Partial<User>) {
        Object.assign(this, partial);
    }
}
```

注意，这里要用 @ApiHideProperty 把 password 字段隐藏掉。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84f030080d644548a4174b32f4ccc623~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1246&h=1166&s=32708&e=webp&b=eff5fa)

可以看到，现在的 swagger 文档是对的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d51865fe90248a0ac40b6663251f867~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1174&h=1156&s=30900&e=webp&b=eff5fa)

而且我们没有用 vo 对象。

这也是为什么 Nest 文档里没有提到 vo，因为完全可以用 entity 来替代。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/vo-test)

## 总结

后端系统中常见 entity、vo、dto 三种对象，vo 是用来封装返回的响应数据的。

但是 Nest 文档里并没有提到 vo 对象，因为完全可以用 entity 来代替。

entity 里加上 @Exclude 可以排除某些字段、@Expose 可以增加一些派生字段、@Transform 可以对已有字段的序列化结果做修改。

然后在 cotnroller 上加上 ClassSerializerInterceptor 的 interceptor，还可以用 @SerializeOptions 来添加 options。

它的底层是基于 class-transfomer 包来实现的，拿到响应对象，plainToClass 拿到 class，然后根据 class 的装饰器再 classToPlain 创建序列化的对象。

swagger 的 @ApiResponse 也完全可以用 entity 来代替 vo，在想排除的字段加一下 @ApiHideProperty 就好了。

Nest 文档里并没有提到 vo 对象，因为完全没有必要，可以直接用序列化的 entity。

## 79.使用 compodoc 生成文档

Nest 项目会有很多模块，模块之间相互依赖，模块内有 controller、service 等。

当项目复杂之后，模块之间的关系错综复杂。

这时候我们可以用 compodoc 生成一份文档，把依赖关系可视化。

compodoc 本来是给 angular 项目生成项目文档的，但是因为 angular 和 nest 项目结构类似，所以也支持了 nest。

我们创建个项目：

```
nest new compodoc-test
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/142fb1bcc11e492281c1d9a2a6b7e334~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1004&h=696&s=162264&e=png&b=010101)

安装 compodoc：

```
npm install --save-dev @compodoc/compodoc
```
然后生成一份文档：

```
npx @compodoc/compodoc -p tsconfig.json -s -o
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47df7a17e54349809f98ad9cae4eabdb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1246&h=670&s=56502&e=png&b=181818)

这个 README 就是项目下的 README.md:

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ff2612a4d6148ac9e34136364748ef6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2136&h=1438&s=299871&e=png&b=fdfdfd)

改一下 READMD.md，然后重新执行命令生成：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/883e1471264d4254b17272f7179adb6c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1328&h=944&s=158651&e=png&b=1c1c1c)

可以看到页面上的也变了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/050755c00629402aacd7b6f27cc09aeb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1490&h=1040&s=115146&e=png&b=fdfdfd)

overview 部分上面是依赖图，下面是项目有几个模块、controller，可注入的 provider

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd969ac7ee34156884f7c834475139c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2532&h=1336&s=207004&e=png&b=fdfdfd)

我们在项目下加几个模块：

```
nest g resource aaa

nest g resource bbb
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2eee91ece02a44b5a1f1311460ec052a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=776&h=412&s=100199&e=png&b=191919)


![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a39fed6d77454a6fbcb68012fe9739de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=780&h=360&s=88181&e=png&b=191919)

在 AaaModule 里把 AaaService 导出：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d965e009870c4d5b931c50f394a22b16~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=854&h=472&s=85655&e=png&b=1f1f1f)

然后 BbbModule 引入 AaaModule：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c843c5461a47ce9b4bb3ac6640dacc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=858&h=560&s=98790&e=png&b=1f1f1f)

在 BbbService 里注入 AaaService：
 
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45322f42acd743e4bb7bf3b4ce34b7c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1204&h=726&s=160144&e=png&b=1f1f1f)

先跑起来看一下：

```
npm run start:dev
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f42bca5192534333a1ba14beea6418b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=614&s=275578&e=png&b=181818)

没啥问题：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19bb581382514a4db7fcb7830c89794a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=812&h=248&s=24966&e=png&b=ffffff)

类似这种依赖关系，compodoc 可视化之后是什么样的呢？

重新跑一下 compodoc：
```
npx @compodoc/compodoc -p tsconfig.json -s -o
```
依赖可视化是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e2f65a59f4e4a9a86b34c8748fdfe92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=1284&s=140377&e=png&b=ffffff)

用不同的颜色表示 Module、Provider、Exports 等。

可以看到 AppModule 引入了 AaaModule、BbbModule。

AaaModule 导出了 AaaService。

以及每个模块的 provider。

都可以可视化的看到。

点击左侧的 Modules，可以看到每个模块的可视化分析：

AaaModule：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee7548ad946641d68d96ab273d9ec054~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2334&h=1004&s=171232&e=png&b=fdfdfd)

BbbModule：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5167be109f8245faa4d533cd6ac35a7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2160&h=1098&s=162601&e=png&b=fdfdfd)

AppModule：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4141dce1360f4286b660ec150a552529~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2378&h=1086&s=181131&e=png&b=fdfdfd)

当然，我们这个例子还是比较简单，当项目依赖复杂之后，这个可视化还是比较有用的。

此外，可以看到每个 Controller、Service 或者其他的 class 的属性、方法，点进去可以看到方法的参数、返回值等：


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b50a3f4efb44fed8f058b495c584d68~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2206&h=1260&s=173584&e=png&b=fdfdfd)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a58345f247864d2ab8af833aba937b64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1800&h=1322&s=195763&e=png&b=fdfdfd)

当新人接手这个项目的时候，可以通过这份文档快速了解项目的结构。

回过头来，我们看下 compodoc 的一些 cli 选项：

```
npx @compodoc/compodoc -p tsconfig.json -s -o
```

-p 是指定 tsconfig 文件

-s 是启动静态服务器

-o 是打开浏览器

更多选项在 [compodoc 文档](https://compodoc.app/guides/options.html)里可以看到:


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7300bd910d944b82a73338fd9089c1e1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2138&h=1432&s=344861&e=png&b=fdfdfd)

比如 --theme 可以指定主题，一共有 gitbook,aravel, original, material, postmark, readthedocs, stripe, vagrant 这 8 个主题：

跑一下：
```
npx @compodoc/compodoc -p tsconfig.json -s -o --theme postmark
```

可以看到文档主题换了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/799ce8ea459d449a80b007a1c72fa83f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2266&h=1250&s=211864&e=png&b=fdfdfd)

选项还是挺多的，如果都写在命令行也不现实，compodoc 同样支持配置文件。

我们在项目下添加一个 .compodoc.json 的文件：

```json
{
    "port": 8888,
    "theme": "postmark"
}
```

然后再跑下 compodoc：

```
npx @compodoc/compodoc -p tsconfig.json -s -o -c .compodoc.json
```

可以看到，配置生效了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaefa079eef24d669f77f20db59edb4e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1558&h=1170&s=120468&e=png&b=fcfcfc)

文档里写的这些 cli options，基本都可以写在配置文件里。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1fdd5f87d4c49fa857494017753eeec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1998&h=1426&s=347859&e=png&b=fcfcfc)

不过一般也不咋用配置。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/compodoc-test)。

## 总结

我们学习了用 compodoc 生成 nest 项目的文档，它会列出项目的模块，可视化展示模块之间的依赖关系，展示每个模块下的 provider、exports 等。

对于新人接手项目来说，还是比较有用的。

而且可视化分析依赖和模块结构，对于复杂项目来说，是比较有帮助的。

compodoc 算是一个不错的 nest 相关的工具。


## 8.全局模块和生命周期

模块导出 provider，另一个模块需要 imports 它才能用这些 provider。

但如果这个模块被很多模块依赖了，那每次都要 imports 就很麻烦。

能不能设置成全局的，它导出的 provider 直接可用呢？

Module、Controller、Provider 是由 Nest 创建的，能不能在创建、销毁的时候执行一些逻辑呢？

这节我们来学习下全局模块和生命周期。

创建一个 nest 项目：

    nest new global-and-lifecycle -p npm

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b4eed3a411645a78e2c03b86967a77b~tplv-k3u1fbpfcp-watermark.image?)

然后创建两个 CRUD 的模块：
```
nest g resource aaa --no-spec
nest g resource bbb --no-spec
```
--no-spec 是不生成测试文件

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19995287a0034e1b8c5955d2f6e87d25~tplv-k3u1fbpfcp-watermark.image?)

在 AaaModule 里指定 exports 的 provider：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ff932e0494441da85e47b51cc9fdcaf~tplv-k3u1fbpfcp-watermark.image?)

然后在 BbbModule 里 imports：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bcac36f1bc04497b4bcf37d493a82f5~tplv-k3u1fbpfcp-watermark.image?)

这样就可以在 BbbModule 内注入 AaaService 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54cf732cedfa4221a857494b26db92b1~tplv-k3u1fbpfcp-watermark.image?)

把 nest 服务跑起来：

```
npm run start:dev
```

可以看到 aaaService 生效了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/748baa4ef42f466fb6c9d8433dfe5793~tplv-k3u1fbpfcp-watermark.image?)

这是我们常用的引入 Module 的方式。

但如果这个 AaaModule 被很多地方引用呢？

每个模块都 imports 太麻烦了，这时候就可以把它声明为全局的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a24dd6994bfc47ffabe70bbc8f88ce39~tplv-k3u1fbpfcp-watermark.image?)

在 AaaModule 上加一个 @Global 的装饰器，然后在 BbbModule 里把 AaaModule 的 imports 去掉。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb83bcc03b6841ce93fd8dff8bb1a39e~tplv-k3u1fbpfcp-watermark.image?)

这样依然是可以注入的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30a1cd371ac54a398bf1d02d61edbbd3~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0201d602369746c286db52f426f7a261~tplv-k3u1fbpfcp-watermark.image?)

这就是全局模块。

不过全局模块还是尽量少用，不然注入的很多 provider 都不知道来源，会降低代码的可维护性。

然后是生命周期：

Nest 在启动的时候，会递归解析 Module 依赖，扫描其中的 provider、controller，注入它的依赖。

全部解析完后，会监听网络端口，开始处理请求。

这个过程中，Nest 暴露了一些生命周期方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd793a59d8a24b3e86312746c25eeb32~tplv-k3u1fbpfcp-watermark.image?)

首先，递归初始化模块，会依次调用模块内的 controller、provider 的 onModuleInit 方法，然后再调用 module 的 onModuleInit 方法。

全部初始化完之后，再依次调用模块内的 controller、provider 的 onApplicationBootstrap 方法，然后调用 module 的 onApplicationBootstrap 方法

然后监听网络端口。

之后 Nest 应用就正常运行了。

这个过程中，onModuleInit、onApplicationBootstrap 都是我们可以实现的生命周期方法。

我们来试一下：

再创建两个 Module：

    nest g resource ccc --no-spec
    nest g resource ddd --no-spec

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4759654a9b024d86898ba48f7d2471c8~tplv-k3u1fbpfcp-watermark.image?)

nest 提供了这样两个 interface：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7e6d116ff5942799d53fb90d688364e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d821abc66e4eaa81338f4c9cd3cf81~tplv-k3u1fbpfcp-watermark.image?)

在 controller、service、module 里分别实现它：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d36dd43bda646c892e6242489d6e43c~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96053772a6ae4258aa659a198e4b0dfc~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a1ccd1a8a7f472a9841a170182bd92f~tplv-k3u1fbpfcp-watermark.image?)

ddd 模块也是这样。

然后重新跑下服务，会看到这样的日志信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b84285b51b5441ef9759438bc302fbf3~tplv-k3u1fbpfcp-watermark.image?)

这就是 onModuleInit 和 onApplicationBootstrap 生命周期的调用顺序。

应用销毁的时候也同样有生命周期：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bb1ccd84fb14e638274df35198c3cff~tplv-k3u1fbpfcp-watermark.image?)

先调用每个模块的 controller、provider 的 onModuleDestroy 方法，然后调用 Module 的 onModuleDestroy 方法。

之后再调用每个模块的 controller、provider 的 beforeApplicationShutdown 方法，然后调用 Module 的 beforeApplicationShutdown 方法。

然后停止监听网络端口。

之后调用每个模块的 controller、provider 的 onApplicationShutdown 方法，然后调用 Module 的 onApplicationShutdown 方法。

之后停止进程。

是不是感觉 onModuleDestory 和 beforeApplicationShutdown 没区别呀？

其实是有区别的，可以看下对应的 interface：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ddd519aeef64bad8a0afcf6ec22baa5~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/560629f3f0574f50a639f70092184b00~tplv-k3u1fbpfcp-watermark.image?)

beforeApplicationShutdown 是可以拿到 signal 系统信号的，比如 SIGTERM。

这些终止信号是别的进程传过来的，让它做一些销毁的事情，比如用 k8s 管理容器的时候，可以通过这个信号来通知它。

我们分别给 CccController、CccProvider、CccModule 还有 ddd 模块的那些给加一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/238cfbb9006a4a8680c7714e2f6dba15~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/beba6215f36e43bbb53c8754abfd05ec~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a57ce56d0084e2e871eb30ad387d71e~tplv-k3u1fbpfcp-watermark.image?)

3s 后调用 app.close() 触发销毁（app.close() 只是触发销毁逻辑，但不会真正退出进程）

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ceaf10c25b1429aa3e7310d1cdd7cde~tplv-k3u1fbpfcp-watermark.image?)

生命周期方法是这样的执行顺序：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7882084092c4259943880eb14c9405d~tplv-k3u1fbpfcp-watermark.image?)

而且所有的生命周期函数都是支持 async 的。

我们来看看 @nestjs/typeorm、@nestjs/mongoose 里都是怎么用的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53af54ef4fcc4e5c8314979e3e87d3f4~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67a26e1870004d419fdbdd468caa47ec~tplv-k3u1fbpfcp-watermark.image?)

可以看到，一般都是通过 moduleRef 取出一些 provider 来销毁，比如关闭连接。

这里的 moduleRef 就是当前模块的引用。

我们来试试：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d8723c68f8344a6869cc25aa0ee0e1b~tplv-k3u1fbpfcp-watermark.image?)

onApplicationShutdown 的生命周期里，拿到当前模块的引用 moduleRef，调用 get 方法，传入 token，取出对应的 provider 实例，然后调用它的方法。

```javascript
import { Module, OnModuleInit, OnApplicationBootstrap, OnModuleDestroy, BeforeApplicationShutdown, OnApplicationShutdown  } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { CccService } from './ccc.service';
import { CccController } from './ccc.controller';

@Module({
  controllers: [CccController],
  providers: [CccService]
})
export class CccModule implements OnModuleInit, OnApplicationBootstrap, OnModuleDestroy, BeforeApplicationShutdown, OnApplicationShutdown  {


  onModuleDestroy() {
    console.log('CccModule onModuleDestroy');
  }

  beforeApplicationShutdown(signal: string) {
    console.log('CccModule beforeApplicationShutdown', signal);
  }

  onApplicationShutdown() {
    const cccService = this.moduleRef.get<CccService>(CccService);
    console.log('--------------------------', cccService.findAll());

    console.log('CccModule onApplicationShutdown');
  }

  onModuleInit() {
    console.log('CccModule OnModuleInit');
  }

  onApplicationBootstrap() {
    console.log('CccModule onApplicationBootstrap');
  }
}
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cb550b088b34ad3b0edf770a806f1ac~tplv-k3u1fbpfcp-watermark.image?)

这就是 onApplicationShutdown 生命周期的常见用法。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/global-and-lifecycle)。

## 总结

这节我们学习了全局模块和生命周期。

模块可以通过 @Global 声明为全局的，这样它 exports 的 provider 就可以在各处使用了，不需要 imports。

provider、controller、module 都支持启动和销毁的生命周期函数，这些生命周期函数都支持 async 的方式。

可以在其中做一些初始化、销毁的逻辑，比如 onApplicationShutwon 里通过 moduleRef.get 取出一些 provider，执行关闭连接等销毁逻辑。

全局模块、生命周期、moduleRef 都是 Nest 很常用的功能。


## 80.Node 如何发邮件？

除了微信外，邮件也是我们常用的通讯方式。

那你平时都是怎么收发邮件的呢？

大多数人会回答，就用邮箱客户端啊，比如 qq 邮箱的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b92c0eae252a47a8a22512126f4fe0e3~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf6ac87027e24e3b9a55f63346be519e~tplv-k3u1fbpfcp-watermark.image?)

但是这样体验并不好，比如写邮件的时候：

我有个漂亮的 html 页面，想直接把它作为邮件内容。

或者我想用 markdown 来写邮件。

但是它只支持富文本编辑器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01086b793a8b4063ac6a5930140f952a~tplv-k3u1fbpfcp-watermark.image?)

再比如收邮件的时候，我想把一些重要邮件的内容保存下来，附件啥的都下载到本地。

但是邮件多了的话，一个个手动搞太麻烦了。

有没有什么更好的方式呢？

当然是有的，作为一个专业的 Node 程序员，自然要用代码的方式来收发邮件了！

邮件有专门的协议：

**发邮件用 SMTP 协议。**

**收邮件用 POP3 协议、或者 IMAP 协议。**

并且在 node 里也有对应的包，发邮件用 nodemailer 包，收邮件用 imap 包。

我们来试试：

首先，要开启 smtp、imap 等服务，这里以 qq 邮箱举例（其他邮箱也类似）：

在邮箱帮助中心 https://service.mail.qq.com/ 可以搜到如何开启 smtp、imap 等服务：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0224a90307f8434dbbfa14bd294b39e9~tplv-k3u1fbpfcp-watermark.image?)

开启后可以在设置里看到：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9000e01314fc470b87a406fb254d003b~tplv-k3u1fbpfcp-watermark.image?)

然后在帮助中心页面搜索授权码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45036a9ade4f47339c0e4c3bf7a12840~tplv-k3u1fbpfcp-watermark.image?)

按照指引生成一个授权码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48886d0d39564171ac029998ef538cba~tplv-k3u1fbpfcp-watermark.image?)

这个是 qq 邮箱特有的一个第三方登录密码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22911ac0100b4f2a9f0e829b67a1e57e~tplv-k3u1fbpfcp-watermark.image?)

然后就可以开始写代码了：

```javascript
const nodemailer = require("nodemailer");

const transporter = nodemailer.createTransport({
    host: "smtp.qq.com",
    port: 587,
    secure: false,
    auth: {
        user: 'xxxxx@qq.com',
        pass: '你的授权码'
    },
});

async function main() {
  const info = await transporter.sendMail({
    from: '"guang" <xxxx@qq.com>',
    to: "xxxx@xx.com",
    subject: "Hello 111", 
    text: "xxxxx"
  });

  console.log("邮件发送成功：", info.messageId);
}

main().catch(console.error);
```
安装 nodemailer 包，然后执行上面的代码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1de52723b3e745b1aae9ccc95899d04b~tplv-k3u1fbpfcp-watermark.image?)

可以看到邮件发送成功了。

我们在邮箱里看看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2811274a2652417fbfff8148640c0e4c~tplv-k3u1fbpfcp-watermark.image?)

确实收到了这个邮件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f8c9963490a4a78b6a6c26530e3c7f6~tplv-k3u1fbpfcp-watermark.image?)

这样我们就用 node 发送了第一个邮件！

而且邮件是支持 html + css 的，比如把我之前写的一个 [3 只小鸟的 button 的 html](https://juejin.cn/post/7167355169934409758) 拿过来：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cfe464929c448648c2dae4a5d6eb788~tplv-k3u1fbpfcp-watermark.image?)

放到一个文件里，然后发邮件的时候读取这个文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98d204cc417b4ff9808fc7d15cf90002~tplv-k3u1fbpfcp-watermark.image?)

然后再跑下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16aa6adb898148649ea359e17a5b6fc9~tplv-k3u1fbpfcp-watermark.image?)

收到的邮件也渲染出了这个 html，并且 css 动画也是正常的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88eeaf82f5bc42f889e2fd7fcddd5984~tplv-k3u1fbpfcp-watermark.image?)

那是不是可以加一些 js 呢？

想多了，邮件里可以包含任何 html+ css，但是不支持 js。

不过基于 html + css，我们就已经可以实现各种炫酷的邮件了。

就像前面说的 markdown 格式来写邮件，这个加一个 markdown 转 html 的包，然后作为邮件的 html 内容发送就好了。

也就是说，通过代码的方式，我们可以做出更炫酷的邮件来。

发邮件我们会了，那如何通过 node 来收邮件呢？

收邮件是用 pop3 或者 imap 协议，需要换一个包。

```javascript
const Imap = require('imap');

const imap = new Imap({
    user: 'xxx@qq.com',
    password: '你的授权码',
    host: 'imap.qq.com',
    port: 993,
    tls: true
});

imap.once('ready', () => {
    imap.openBox('INBOX', true, (err) => {
        imap.search([['SEEN'], ['SINCE', new Date('2023-07-10 19:00:00').toLocaleString()]], (err, results) => {
            if (!err) {
                console.log(results);
            } else {
                throw err;
            }
        });
    });
});

imap.connect();
```
安装 imap 的包，然后填入 qq 邮箱的 imap 服务器的域名、端口，填入用户名和授权码，就可以连接了。

这里的 imap 服务器的信息也是在帮助中心里搜索：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea3ac2f7d42045fc89be427d743ba163~tplv-k3u1fbpfcp-watermark.image?)

search 的参数我们写了两个：

['SEEN'] 是查询已读的邮件。

['SINCE', '某个日期'] 是查询从这个日期以来的邮件。

当然，还有更多的搜索条件，可以看 [imap 包的文档](https://www.npmjs.com/package/imap)。

我们跑下试试：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19eb0a88b68f4d8c834e036f8ea57bac~tplv-k3u1fbpfcp-watermark.image?)

可以看到打印了搜索出的符合条件的邮件的 id，然后我们来处理下这些 id：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ae4bdbd1d3420e99090cad776606b6~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const { MailParser } =require('mailparser');
const fs = require('fs');
const path = require('path');

function handleResults(results) {
    imap.fetch(results, { 
        bodies: '',
    }).on('message', (msg) => {
        const mailparser = new MailParser();

        msg.on('body', (stream) => {

            

        });
    });
}

```
这里用 imap.fetch 来请求这些 id 的内容，bodies 为 '' 是查询 header + body 的意思：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e3f9dde7ec14b6daa10976e81c2ad00~tplv-k3u1fbpfcp-watermark.image?)

然后处理下 body 的内容，把结果保存到 info 对象里。

这里解析邮件内容要使用 mailparser 这个包：

```javascript
const { MailParser } =require('mailparser');
const fs = require('fs');
const path = require('path');
const Imap = require('imap');


function handleResults(results) {
    imap.fetch(results, { 
        bodies: '',
    }).on('message', (msg) => {
        const mailparser = new MailParser();

        msg.on('body', (stream) => {

            const info = {};
            stream.pipe(mailparser);

            mailparser.on("headers", (headers) => {
                info.theme = headers.get('subject');
                info.form = headers.get('from').value[0].address;
                info.mailName = headers.get('from').value[0].name;
                info.to = headers.get('to').value[0].address;
                info.datatime = headers.get('date').toLocaleString();
            });

            mailparser.on("data", (data) => {
                if (data.type === 'text') {
                    info.html = data.html;
                    info.text = data.text;
                    console.log(info);
                }
                if (data.type === 'attachment') {
                    const filePath = path.join(__dirname, 'files', data.filename);
                    const ws = fs.createWriteStream(filePath);
                    data.content.pipe(ws);
                }
            });
        });
    });
}
```

这部分还是容易看懂的，就是把 headers 的信息提取出来，把邮件 body 的信息提取出来，放到 info
对象里，打印。

如果有附件，就写到 files 目录下。

我们在本地创建个 files 目录，然后跑一下。

可以看到，我们前面发的那两个邮件都取到了。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0b1c3627ab64a0eab41dc9a336c0315~tplv-k3u1fbpfcp-watermark.image?)

日期也确实都是 7 月 10 日的。

我邮箱里有这样一个邮件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de8337f6903345bfa2aba85a5f1709bb~tplv-k3u1fbpfcp-watermark.image?)

可以看到，附件也下载到了 files 目录下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4882b3059d6b484da4390e4047420cd6~tplv-k3u1fbpfcp-watermark.image?)

我们把 html 的内容保存到本地文件里：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19d2c63615d94709823359ba7d6b6716~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const filePath = path.join(__dirname, 'mails', info.theme + '.html');
fs.writeFileSync(filePath, info.html || info.text)
```
以邮件主题为文件名。

当然，要现在本地创建 mails 这个目录，然后跑一下：

邮件内容和附件内容都保存了下来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f334573062dd4f499677968c60c265fd~tplv-k3u1fbpfcp-watermark.image?)

在邮箱里可以看到也是这些邮件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8351c9d67104b86b88944dbfab86b09~tplv-k3u1fbpfcp-watermark.image?)

我们打开这些 html 看看，起一个 http-server：

```
npx http-server .
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7e13671716e40fa871186fcb12db58e~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2e7aec109740918a71ac4d2d309f84~tplv-k3u1fbpfcp-watermark.image?)

和在邮箱里看一模一样。

这样，我们就把邮件内容和附件都保存了下来。

你想保存一些重要邮件的时候，还需要手动一个个复制和下载附件么？

不需要，用 node 写代码保存不更方便么？

收邮件部分的代码如下：

```javascript
const { MailParser } =require('mailparser');
const fs = require('fs');
const path = require('path');
const Imap = require('imap');

const imap = new Imap({
    user: 'xx@qq.com',
    password: '你的授权码',
    host: 'imap.qq.com',
    port: 993,
    tls: true
});

imap.once('ready', () => {
    imap.openBox('INBOX', true, (err) => {
        imap.search([['SEEN'], ['SINCE', new Date('2023-07-10 19:00:00').toLocaleString()]], (err, results) => {
            if (!err) {
                handleResults(results);
            } else {
                throw err;
            }
        });
    });
});


function handleResults(results) {
    imap.fetch(results, { 
        bodies: '',
    }).on('message', (msg) => {
        const mailparser = new MailParser();

        msg.on('body', (stream) => {

            const info = {};
            stream.pipe(mailparser);
            mailparser.on("headers", (headers) => {
                info.theme = headers.get('subject');
                info.form = headers.get('from').value[0].address;
                info.mailName = headers.get('from').value[0].name;
                info.to = headers.get('to').value[0].address;
                info.datatime = headers.get('date').toLocaleString();
            });

            mailparser.on("data", (data) => {
                if (data.type === 'text') {
                    info.html = data.html;
                    info.text = data.text;

                    const filePath = path.join(__dirname, 'mails', info.theme + '.html');
                    fs.writeFileSync(filePath, info.html || info.text)

                    console.log(info);
                }
                if (data.type === 'attachment') {
                    const filePath = path.join(__dirname, 'files', data.filename);
                    const ws = fs.createWriteStream(filePath);
                    data.content.pipe(ws);
                }
            });
        });
    });
}

imap.connect();
```

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/mail-test)。

## 总结

邮件是常用的通讯方式，我们一般是通过邮箱客户端来收发邮件。

但是这样不够方便：

比如写邮件不能直接贴 html + css，不能写 markdown，收邮件不能按照规则自动下载附件、自动保存邮件内容。

这些需求我们都能通过代码来自己实现。

发邮件是基于 SMTP 协议，收邮件是基于 POP3 或 IMAP 协议。

node 分别有 nodemailer 包和 imap 包用来支持收发邮件的协议。

我们通过 nodemailer 发送了 html 的邮件，可以发送任何 html+css 的内容。

通过 imap 实现了邮件的搜索，然后用 mailparser来做了内容解析，然后把邮件内容和附件做了下载。

能够写代码来收发邮件之后，就可以做很多自动化的事情了：

比如定时自动发一些邮件，内容是从数据库查出来的，比如自动拉取邮件，根据一定的规则来保存邮件和附件内容等。

这就是 Node 里收发邮件的方式。


## 81.实现基于邮箱验证码的登录

上节我们学习了用 Node 来收发邮件，其实 Node 发邮件最常见的场景还是邮箱验证码。

比如登录的时候除了可以通过用户名、密码来验证身份，还可以通过邮箱验证码来验证。

这节我们就实现下这个功能。

首先，我们写个简单的登录页面:

通过 create-react-app 创建个项目：

```
npx create-react-app email-login-frontend
```
然后进入项目把开发服务跑起来：

```
npm run start
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88aa773d3926406ca695f6dc618b54b3~tplv-k3u1fbpfcp-watermark.image?)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93940e5dc88140b49f78509ee42fd3bb~tplv-k3u1fbpfcp-watermark.image?)

安装 antd：

```
npm install antd --save
```

然后来写下登录 UI：

```javascript
import React from 'react';
import { Button, Form, Input } from 'antd';

const login = (values) => {
  console.log('Success:', values);
};

const sendEmailCode = () => {
  console.log('send email code')
}

const App = () => (
  <div style={{width: '500px', margin: '100px auto'}}>
    <Form onFinish={login}>

      <Form.Item
        label="邮箱"
        name="email"
        rules={[
          {
            required: true,
            message: '请输入邮箱地址',
          },
        ]}
      >
        <Input />
      </Form.Item>

      <Form.Item
        label="验证码"
        name="code"
        rules={[
          {
            required: true,
            message: '请输入验证码',
          },
        ]}
      >
        <Input/>
      </Form.Item>

      <Form.Item>
        <Button onClick={sendEmailCode}>发送验证码</Button>
      </Form.Item>

      <Form.Item>
        <Button type="primary" htmlType="submit">登录</Button>
      </Form.Item>

    </Form>
  </div>
);
export default App;
```
在 App.js 输入上面的代码，就可以看到登录页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91a6fe6fdd9e4726bec4a810c8bf1b0b~tplv-k3u1fbpfcp-watermark.image?)

比较丑，但功能是没问题的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae30f9ceac9f43ff825698da60e92ee1~tplv-k3u1fbpfcp-watermark.image?)

然后我们再来写下后端代码。

创建个 nest 项目：

```
nest new email-login-backend -p npm
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981c34fcbcbe4e82961db5ba42d29ec3~tplv-k3u1fbpfcp-watermark.image?)

在 main.ts 启用跨域，并且修改下端口号（因为前端项目开发服务也用这个端口号）：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/550ec1d9925f4eda89b37495209f18bf~tplv-k3u1fbpfcp-watermark.image?)

然后跑起来：

```
npm run start:dev
```
浏览器访问可以看到 hello world 代表 nest 服务跑成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a1e897d2b38464eabbd142c8a98fcf7~tplv-k3u1fbpfcp-watermark.image?)

然后在前端项目里访问下。

在前端项目安装 axios：

```
npm install --save axios
```

然后调用下接口：

```javascript
import axios from 'axios';

const login = (values) => {
  console.log('Success:', values);
};

const sendEmailCode = async () => {
  const res = await axios.get('http://localhost:3001');

  console.log(res);
  console.log('send email code')
}
```
试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83d7ee3fa99644e3beeaffba0dd6fbb0~tplv-k3u1fbpfcp-watermark.image?)

接口调通了。

然后回到后端项目，我们继续写后端接口：

创建 user 模块：

```
nest g resource user
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfe8c5a8e264f52a7a49c97b57bc0fb~tplv-k3u1fbpfcp-watermark.image?)

安装 typeorm 的依赖：
```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserModule } from './user/user.module';

@Module({
  imports: [
    UserModule,
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "email_login_test",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后我们在 mysql workbench 创建个新的 database：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28bd7114029240ae8657533e388395aa~tplv-k3u1fbpfcp-watermark.image?)

输入 database 或者叫 schema 的名字，指定字符集为 utf8mb4。

点击 apply 可以看到生成的 sql：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cd3c3564bfa438da1d4b0ce81161760~tplv-k3u1fbpfcp-watermark.image?)

改下 User 的 entity：

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class User {

    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 50,
        comment: '用户名'
    })
    username: string;

    @Column({
        length: 50,
        comment: '密码'
    })
    password: string;

    @Column({
        length: 50,
        comment: '邮箱地址'
    }) 
    email: string;
}
```
user 表有 id、username、password、email 这 4 个字段。

在 TypeOrm 的 entities 注册下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/393f8780ac7e4ac291dec5c3cd43627b~tplv-k3u1fbpfcp-watermark.image?)

保存，nest 服务会自动重新跑：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a880e338e7a541db8f3a41f4ea5b954a~tplv-k3u1fbpfcp-watermark.image?)

可以看到 user 表被创建了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804f5a86f16e49d18db738158bd57e56~tplv-k3u1fbpfcp-watermark.image?)

这次我们手动插入下数据：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dca8fd38a894ebcb7b18ca399557aa4~tplv-k3u1fbpfcp-watermark.image?)

输入内容后，点击 apply，可以看到生成的 sql：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da6028f5b2c34665baad01ecad4a1cff~tplv-k3u1fbpfcp-watermark.image?)

你直接执行这个 sql 来插入数据也行：

```sql
INSERT INTO `email_login_test`.`user` 
  (`id`, `username`, `password`, `email`) 
  VALUES ('1', 'aaaa', 'bbbb', 'xxx@xx.com');
```

这里邮箱要改成你自己的，因为待会要发邮件用。

之后来添加下发邮件的接口。

添加个 email 模块，这次不用生成 crud 代码了：

```
nest g resource email
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2af9a89494b42a082a52fb3d7440861~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09ecb98c8ceb454badbebf13f32d0342~tplv-k3u1fbpfcp-watermark.image?)

然后我们安装 nodemailer 包来发邮件：

```
npm install --save nodemailer

npm install --save-dev @types/nodemailer
```

在 MailService 里来发邮件：

```javascript
import { Injectable } from '@nestjs/common';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor() {
        this.transporter = createTransport({
            host: "smtp.qq.com",
            port: 587,
            secure: false,
            auth: {
                user: 'xx@xx.com',
                pass: '你的授权码'
            },
        });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '系统邮件',
          address: 'xx@xx.com'
        },
        to,
        subject,
        html
      });
    }
}
```

把邮箱和授权码改成你自己的。

然后添加一个 controller 方法：

```javascript
import { Controller, Get, Query } from '@nestjs/common';
import { EmailService } from './email.service';

@Controller('email')
export class EmailController {
  constructor(private readonly emailService: EmailService) {}

  @Get('code')
  async sendEmailCode(@Query("address") address) {
    await this.emailService.sendMail({
      to: address,
      subject: '登录验证码',
      html: '<p>你的登录验证码是 123456</p>'
    });
    return '发送成功';
  }
}

```
我们调用下试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5174540adbae451088b8da895a44fcef~tplv-k3u1fbpfcp-watermark.image?)

发送成功，邮箱里确实也收到了这封邮件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18d36bc45599467e838eb8a14fbfb4df~tplv-k3u1fbpfcp-watermark.image?)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd651142d7684f9e9ed0b6170650f8d7~tplv-k3u1fbpfcp-watermark.image?)

回过头来看一下，我们现在是把邮箱相关信息直接写在代码里了。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b734d8eb5e9845498f3ff59afdc85f5f~tplv-k3u1fbpfcp-watermark.image?)

实际上这些应该从配置读取。

我们安装下配置模块：

```
npm install --save @nestjs/config
```
在 AppModule 里引入，并且把它声明为全局的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b327e1b0c78949b2b3122be5a5175beb~tplv-k3u1fbpfcp-watermark.image?)

```javascript
ConfigModule.forRoot({
    isGlobal: true,
    envFilePath: 'src/.env'
})
```
在 src 下添加这个 .env 文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a615f96bac4e4fd1beb3da98b40cad39~tplv-k3u1fbpfcp-watermark.image?)

然后在 EmailService 里注入 ConfigService，从中读取配置：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a515a1017e24f78ad568933da5d2769~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor(private configService: ConfigService) {
      this.transporter = createTransport({
          host: "smtp.qq.com",
          port: 587,
          secure: false,
          auth: {
              user: this.configService.get('email_user'),
              pass: this.configService.get('email_password')
          },
      });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '系统邮件',
          address: this.configService.get('email_user')
        },
        to,
        subject,
        html
      });
    }

}

```
再调用下接口，这时依然是正常的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bec76944d0ba4dbb8bf8809c4209f6a8~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9f91ba5de6c4f41bc9645d7e2302f2c~tplv-k3u1fbpfcp-watermark.image?)

说明配置正确读取出来了。

不过用了 .env 配置文件之后有个问题：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5faae4d10684ad4bd63faf3ad9d2c88~tplv-k3u1fbpfcp-watermark.image?)

dist 目录下没有这个文件。

.env 需要配置下 assets 才会复制过去。

改下 nest-cli.json

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/973dbe96fc8d4c4e9ffa7c0aca02a297~tplv-k3u1fbpfcp-watermark.image?)

添加 assets 为 \*.env 这样就会在编译的时候把 src 下的 .env 文件复制到 dist 下。

注意，**assets 只支持 src 下的文件复制**。如果你是放在根目录，那就要自己复制了。

改了编译配置需要重新跑服务：

```
npm run start:dev
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/651b83bc997c43158431cea2d46a99e4~tplv-k3u1fbpfcp-watermark.image?)

这时就可以在 dist 下看到这个文件了。

但现在你改了 src 下的 .env 之后，dist 下的 .env 不会跟着改，需要重新跑服务才可以。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8818c524278c439498cb70c9d27f2db2~tplv-k3u1fbpfcp-watermark.image?)

这时候可以加一个 watchAssets：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5520e0a32f7743558906f98b840d2a02~tplv-k3u1fbpfcp-watermark.image?)

然后再重新跑下服务。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ccb94ef5dc64a1886caed415b94fbb1~tplv-k3u1fbpfcp-watermark.image?)

这时候改了 src 下的 .env 就会立刻复制了。

也就是说，**如果你用到了 .env 文件或者 yaml 等文件来配置，需要在 nest-cli.json 里配置下 assets 和 watchAssets。**

回过头来继续搞验证码的事情。

首先，验证码要随机，我们通过 Math.random 来生成：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b3234306c764761afb10ea468099dd3~tplv-k3u1fbpfcp-watermark.image?)

```javascript
const code = Math.random().toString().slice(2,8);
````
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d986ff400e4478a00b866c267ac16c~tplv-k3u1fbpfcp-watermark.image?)

然后在前端项目里调用下看看：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01c2e6cfbc8a45e0a9bb15653a339404~tplv-k3u1fbpfcp-watermark.image?)

通过 useForm 创建 form 实例，然后就可以通过 form.getFieldsValue 拿到表单值了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c050d23f47b4728a7f1e44c01e27cac~tplv-k3u1fbpfcp-watermark.image?)

```javascript
import React from 'react';
import { Button, Form, Input } from 'antd';
import axios from 'axios';

const login = (values) => {
  console.log('Success:', values);
};

const App = () => {
  const [form] = Form.useForm();

  const sendEmailCode = async () => {
    const res = await axios.get('http://localhost:3001');
  
    console.log(form.getFieldsValue());

    console.log(res);
    console.log('send email code')
  }
  

  return <div style={{width: '500px', margin: '100px auto'}}>
    <Form form={form} onFinish={login}>

      <Form.Item
        label="邮箱"
        name="email"
        rules={[
          {
            required: true,
            message: '请输入邮箱地址',
          },
        ]}
      >
        <Input />
      </Form.Item>

      <Form.Item
        label="验证码"
        name="code"
        rules={[
          {
            required: true,
            message: '请输入验证码',
          },
        ]}
      >
        <Input/>
      </Form.Item>

      <Form.Item>
        <Button onClick={sendEmailCode}>发送验证码</Button>
      </Form.Item>

      <Form.Item>
        <Button type="primary" htmlType="submit">登录</Button>
      </Form.Item>

    </Form>
  </div>
};
export default App;
```

在点击发送验证码的时候，验证下邮箱是否为空，不为空就调用后端接口来发送验证码：

```javascript
import { message } from 'antd';

const App = () => {
  const [form] = Form.useForm();

  const sendEmailCode = async () => {
    const email = form.getFieldValue('email');
    
    console.log(email)
    if(!email) {
      message.error('邮箱不能为空');
      return;
    }

    const res = await axios.get('http://localhost:3001/email/code', {
      params: {
        address: email
      }
    });
  
    message.info(res.data);
  }
  
```

我们来试试看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66fd29142b524e6698f4298209694301~tplv-k3u1fbpfcp-watermark.image?)

点击发送验证码，这个邮箱收到了一封验证码的邮件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10bea665108a4d38b153ebc3d39356cc~tplv-k3u1fbpfcp-watermark.image?)

然后我们来实现下登录。

登录就是根据用户填的信息去数据库匹配，如果匹配到了就查询出该用户的信息，放入 session 或者 jwt 里。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8de0ff950b3944d1ac5cc320ef528c56~tplv-k3u1fbpfcp-watermark.image?)

验证用户身份的信息，可以是用户名 + 密码，也可以是邮箱 + 验证码。
    
用邮箱验证码验证用户身份的流程是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/856aacfe0a304d0eb849cf292b81a16f~tplv-k3u1fbpfcp-watermark.image?)

用户填入邮箱地址，点击发送验证码，后端会生成验证码，发送邮件。并且还要把这个验证码存入 redis，以用户邮箱地址为 key。

之后用户输入验证码，点击登录。

后端根据邮箱地址去 redis 中查询下验证码，和用户传过来的验证码比对下，如果一致，就从 mysql 数据库中查询该用户的信息，放入 jwt 中返回。

思路理清了，我们来实现下：

创建个 redis 模块：

```
nest g resource redis  --no-spec
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92716a577dff4a308481a2297fdb1bd6~tplv-k3u1fbpfcp-watermark.image?)

安装 redis 的包：
```
npm install redis --save
```

把 RedisModule 声明为全局模块，并导出 RedisService。

然后添加一个 provider：

```javascript
import { Global, Module } from '@nestjs/common';
import { RedisService } from './redis.service';
import { RedisController } from './redis.controller';
import { createClient } from 'redis';

@Global()
@Module({
  controllers: [RedisController],
  providers: [RedisService, {
    provide: 'REDIS_CLIENT',
    async useFactory() {
      const client = createClient({
          socket: {
              host: 'localhost',
              port: 6379
          }
      });
      await client.connect();
      return client;
    }
  }],
  exports: [RedisService]
})
export class RedisModule {}

```

在 RedisService 里封装 redis 的 get、set 方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async get(key: string) {
        return await this.redisClient.get(key);
    }

    async set(key: string, value: string | number, ttl?: number) {
        await this.redisClient.set(key, value);

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```

然后修改下发送邮箱验证码的逻辑：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11942bb0152b4abbb16953c6d6579a8d~tplv-k3u1fbpfcp-watermark.image?)

注入 RedisService，并且发送验证码之前把它存入 redis，key 为 captcha_邮箱地址。

这里的 captcha 就是验证码的意思。

过期时间为 5 分钟。

```javascript
import { Controller, Get, Inject, Query } from '@nestjs/common';
import { RedisService } from 'src/redis/redis.service';
import { EmailService } from './email.service';

@Controller('email')
export class EmailController {
  constructor(private readonly emailService: EmailService) {}

  @Inject()
  private redisService: RedisService;

  @Get('code')
  async sendEmailCode(@Query("address") address) {
    const code = Math.random().toString().slice(2,8);

    await this.redisService.set(`captcha_${address}`, code, 5 * 60);

    await this.emailService.sendMail({
      to: address,
      subject: '登录验证码',
      html: `<p>你的登录验证码是 ${code}</p>`
    });
    return '发送成功';
  }
}
```

我们试试看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/701c92673e374b3287a407e37d5eef51~tplv-k3u1fbpfcp-watermark.image?)

输入邮箱地址，点击发送验证码。

邮箱收到了这个验证码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a1b3061a9ed4488a3915caafd644be5~tplv-k3u1fbpfcp-watermark.image?)

redis 里也保存了一份：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc3a3877c6e4eb1b3b442442d98caf5~tplv-k3u1fbpfcp-watermark.image?)

接下来只要填入这个验证码，点击登录就可以了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c1a52cc8be748629322adb54b291ce7~tplv-k3u1fbpfcp-watermark.image?)

我们再来实现下登录接口：

在 UserController 里添加一个路由：

```javascript
@Post('login')
login(@Body() loginUserDto: LoginUserDto) {
    console.log(loginUserDto);
    return 'success';
}
```
定义这个 LoginUserDto：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faad6cdc9c67494a8b2584b81399e55e~tplv-k3u1fbpfcp-watermark.image?)

然后需要对它做校验，我们引入 class-validator 和 class-transformer：

```
npm install --save class-validator class-transformer
```
在 main.ts 里全局启用 ValidationPipe：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b797d034382649fc8505a2504c9ac166~tplv-k3u1fbpfcp-watermark.image?)

然后给 LoginUserDto 添加一些约束：

```javascript
import { IsEmail, IsNotEmpty, Length } from "class-validator";

export class LoginUserDto {
    @IsNotEmpty()
    @IsEmail()
    email: string;

    @IsNotEmpty()
    @Length(6)
    code: string;
}
```
在 postman 里测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cef8edd17dd42f3946c597740fc7e1f~tplv-k3u1fbpfcp-watermark.image?)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b666dcfd95ec4522beff55a92a3aeecf~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

我们来实现下具体的验证逻辑:

```javascript
@Inject(RedisService)
private redisService: RedisService;

@Post('login')
async login(@Body() loginUserDto: LoginUserDto) {

    const { email, code } = loginUserDto;

    const codeInRedis = await this.redisService.get(`captcha_${email}`);

    if(!codeInRedis) {
      throw new UnauthorizedException('验证码已失效');
    }
    if(code !== codeInRedis) {
      throw new UnauthorizedException('验证码不正确');
    }

    const user = await this.userService.findUserByEmail(email);

    console.log(user);

    return 'success';
}
```
从 redis 中查找这个邮箱对应的验证码。

如果没查找，就返回验证码已失效。

查到的话和用户传过来的验证码对比，如果不一致，就返回验证码不正确。

验证码通过之后，从数据库中查询这个用户的信息。

我们在 UserService 里实现下这个方法：

```javascript
@InjectEntityManager()
private entityManager: EntityManager;

async findUserByEmail(email: string) {
    return await this.entityManager.findOneBy(User, {
      email
    });
}
```
然后在前端代码里调用下：

```javascript
const login = async (values) => {
  const res = await axios.post('http://localhost:3001/user/login', {
    email: values.email,
    code: values.code
  });
  if(res.data === 'success') {
    message.success('登录成功');
  } else {
    message.error(res.data.message);
  }
};
```
我们整体试一下：


![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db70633a78a4559ba569b403ab964c6~tplv-k3u1fbpfcp-watermark.image?)

输入邮箱，点击发送验证码。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50ba4ca2f10040ac9c5edde348eacb72~tplv-k3u1fbpfcp-watermark.image?)

收到了验证码邮件，并且 redis 里也存了这个 key：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7dac6c02c59a4f05b51255999eff0f00~tplv-k3u1fbpfcp-watermark.image?)

带上这个验证码请求：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c28e7a52c94147cdb820da49828ebf8a~tplv-k3u1fbpfcp-watermark.image?)

可以看到服务端通过了校验，并且从数据库中查询出了用户信息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c6b8b3734c442f39c6ca1061e0bc587~tplv-k3u1fbpfcp-watermark.image?)

接下来只要返回对应的 jwt token 就好了。

这部分可以参考前面 jwt 登录章节的内容，就不展开了。

案例代码上传了小册仓库：

[前端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/email-login-frontend)

[后端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/email-login-backend)

## 总结

这节我们实现了基于邮箱验证码的登录。

流程可以看这张图：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce964be279c24780b6f5e1b90ddbbbfd~tplv-k3u1fbpfcp-watermark.image?)

综合用到了 mysql、redis、typeorm、nodemailer 等技术。

并且使用 @nestjs/config 包的 ConfigModule 来封装配置。

要注意的是，如果用了 .env 文件，需要保证它在 src 下，并且要在 nest-cli.json 里配置 assets 和 watchAssets，不然 build 的时候不会复制到 dist 下。

这节实现的功能，前后端代码都有，算是一个不错的综合练习。


## 82.定时任务 + Redis 实现阅读量计数

文章都会有个阅读量，那这个阅读量是怎么计数的呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b7aa9c69b14847ad90c389f236593b~tplv-k3u1fbpfcp-watermark.image?)

有同学说，很简单啊，这不就是文章表里加个 views 的字段，然后每次刷新页面都加一么？

这样是可以，但有两个问题：

- 每次刷新阅读量都加一，其实还是同一个人看的这篇文章，这样统计出来的阅读量是不准的，我们想要的阅读量是有多少人看过这篇文章

- 阅读是个很高频的操作，直接存到数据库，数据库压力会太大

这两个问题分别都怎么解决呢？

其实我们学完 Redis 就应该能想到解决方案了：

- 在 redis 中存储 user 和 article 的关系，比如 user_111_article_222 为 key，10 分钟后删除，如果存在这个 key，就说明该用户看过这篇文章，就不更新阅读量，否则才更新

    10 分钟后，这个人再看这篇文章，就可以算是新的一次阅读量了。

- 访问文章时把阅读量加载到 redis，之后的阅读量计数只更新 redis，不更新数据库，等业务低峰期再把最新的阅读量写入数据库

    这里在业务低峰期，比如凌晨 4 点的时候写入数据库，可以用定时任务来做。


思路理清了，我们来实现一下：

```
nest new article-views -p npm
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfd1c5e7f004bb798b8a7ba9697e0de~tplv-k3u1fbpfcp-watermark.image?)

创建个 nest 项目。

安装 typeorm 相关的包：

```
npm install --save @nestjs/typeorm typeorm mysql2
```

在 AppModule 引入 TypeOrmModule：

```javascript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [ 
    TypeOrmModule.forRoot({
      type: "mysql",
      host: "localhost",
      port: 3306,
      username: "root",
      password: "guang",
      database: "article_views",
      synchronize: true,
      logging: true,
      entities: [],
      poolSize: 10,
      connectorPackage: 'mysql2',
      extra: {
          authPlugin: 'sha256_password',
      }
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```
在 mysql workbench 里创建这个 database

```
CREATE DATABASE article-views DEFAULT CHARACTER SET utf8mb4;
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/525cdf775e4347468986e5f7e214078a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1204&h=162&e=png&b=f5f4f4)

刷新可以看到这个 database

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/191672a15d064ac180dc2699a3650a94~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=500&h=456&e=png&b=e9e6e3)

然后建个文章和用户的模块：

```javascript
nest g resource user --no-spec
nest g resource article --no-spec
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2067e9ddbd804c0b8f31b13f691eff20~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=884&h=602&e=png&b=191919)

添加 user 和 article 的 entity

```javascript
import { Column, PrimaryGeneratedColumn, Entity } from "typeorm";

@Entity()
export class User {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        comment: '用户名'
    })
    username: string;

    @Column({
        comment: '密码'
    })
    password: string;
}
```
```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class Article {
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        comment: '文章名字',
        length: 50
    })
    title: string;

    @Column({
        comment: '内容',
        type: 'text'
    })
    content: string;

    @Column({
        comment: '阅读量',
        default: 0
    })
    viewCount: number;

    @Column({
        comment: '点赞量',
        default: 0
    })
    likeCount: number;

    @Column({
        comment: '收藏量',
        default: 0
    })
    collectCount: number;
}

```
在 entities 引入：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa3df96660be4d22b6366d7d2d2a29b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894&h=1050&e=png&b=1f1f1f)

可以看到 typeorm 自动创建了这两个表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64dde61b048940b3b75bd83739afee0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1634&h=670&e=png&b=191919)

然后插入一些数据：

在 AppController 创建 init-data 的路由，然后注入 EntityManager：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0446c10bb0f94671bdd1a4b99b8ee92f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1108&h=862&e=png&b=1f1f1f)

```javascript
@InjectEntityManager()
  private entityManager: EntityManager;

  @Get('init-data')
  async initData() {
    await this.entityManager.save(User, {
      username: 'dong',
      password: '111111'
    });
    await this.entityManager.save(User, {
      username: 'guang',
      password: '222222'
    });

    await this.entityManager.save(Article, {
      title: '基于 Axios 封装一个完美的双 token 无感刷新',
      content: `用户登录之后，会返回一个用户的标识，之后带上这个标识请求别的接口，就能识别出该用户。

      标识登录状态的方案有两种： session 和 jwt。
      `
    });

    await this.entityManager.save(Article, {
      title: 'Three.js 手写跳一跳小游戏',
      content: `前几年，跳一跳小游戏火过一段时间。

      玩家从一个方块跳到下一个方块，如果没跳过去就算失败，跳过去了就会再出现下一个方块。`
    });
    return 'done';
  }
```
两个 entity 分别插入 2 条数据。

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b41c9f560eb44c87bd7f2ef913f59c86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=216&e=png&b=ffffff)


可以看到 4 条 insert 语句：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d1726aa77334d79b5430b2df16e7e19~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672&h=672&e=png&b=191919)

在 mysql workbench 里也可以看到两个表都插入了数据：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ea593b965a4509941e46f57d2251c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1758&h=394&e=png&b=f0eeed)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c0d4d171eb14fdebfe891e53e1ce7b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038&h=420&e=png&b=edeae8)

然后先实现登录：

这次用 session 的方案：

安装相关的包：
```
npm install express-session @types/express-session
```
在 main.ts 里启用：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/689b475a6a8f4c6b9f3e8790dbc8a600~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=928&h=648&e=png&b=1f1f1f)

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import * as session from 'express-session';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  app.use(session({
    secret: 'guang',
    resave: false,
    saveUninitialized: false
  }));

  await app.listen(3000);
}
bootstrap();
```

然后实现下登录：

在 UserController 添加 login 的路由：

```javascript
@Post('login')
async login(@Body() loginUserDto: LoginUserDto) {
    console.log(loginUserDto);
    return 'success';
}
```
新建 src/user/dto/login-user.dto.ts

```javascript
export class LoginUserDto {
    username: string;

    password: string;
}
```
测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c02152dcbd440fe86ee86120ae7fd3f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=716&h=628&e=png&b=fbfbfb)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13514ad5de634e18876e9dfe0512625d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=772&h=396&e=png&b=191919)

然后在 UserService 实现登录逻辑：

```javascript
@InjectEntityManager()
private entityManager: EntityManager;

async login(loginUser: LoginUserDto) {
    const user = await this.entityManager.findOne(User, {
      where: {
        username: loginUser.username
      }
    });

    if(!user) {
      throw new BadRequestException('用户不存在');
    }

    if(user.password !== loginUser.password) {
      throw new BadRequestException('密码错误');
    }

    return user;
}
```
在 UserController 调用下：

```javascript
@Post('login')
async login(@Body() loginUserDto: LoginUserDto, @Session() session) {
    const user = await this.userService.login(loginUserDto);

    session.user = {
        id: user.id,
        username: user.username
    }

    return 'success';
}
```
调用 userService 的 login 方法，实现登录验证，然后把用户信息存入 session。

当用户不存在时：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3afa73c85f8545339664bc4708c2f494~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=764&e=png&b=fbfbfb)

当密码错误时：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d86d6b88e5a942049fe74e07cdf705f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=818&h=748&e=png&b=fcfcfc)

登录成功时：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66a65a32faca464fb889cfbd7b3da07d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=754&h=670&e=png&b=fcfcfc)

然后在 ArticleController 添加一个查询文章的接口：

```javascript
@Get(':id')
async findOne(@Param('id') id: string) {
    return await this.articleService.findOne(+id);
}
```
实现 articleService.findOne 方法：

```javascript
@InjectEntityManager()
private entityManager: EntityManager;

async findOne(id: number) {
    return await this.entityManager.findOneBy(Article, {
      id
    });
}
```
测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1537ebd9b484709aa8933ccb5e02095~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=896&e=png&b=fdfdfd)

然后我们在 ArticleController 加一个阅读的接口：

```javascript
@Get(':id/view')
async view(@Param('id') id: string) {
    return await this.articleService.view(+id);
}
```
然后在 ArticleService 里实现具体的逻辑：

```javascript
async view(id: number) {
    const article = await this.findOne(id);

    article.viewCount ++;

    await this.entityManager.save(article);

    return article.viewCount;
}
```
测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31879fdb321a4f5994a1fe2ba3dc09be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1262&h=768&e=gif&f=24&b=fcfcfc)

数据库里阅读量确实更新了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0909a6305c95493997cd6f34f2fbccba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1214&h=304&e=png&b=f6f6f6)

再次查询出来的就是新的阅读量：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bb624bd733840e98795ceb1ceb09446~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=966&h=806&e=png&b=fdfdfd)

这样是能实现功能，但有前面我们讲到的两个问题：

- 每次刷新阅读量都加一，其实还是同一个人看的这篇文章，这样统计出来的阅读量是不准的，我们想要的阅读量是有多少人看过这篇文章

- 阅读是个很高频的操作，直接存到数据库，数据库压力会太大

所以，我们要引入 redis。

安装 redis 的包：

```
npm install --save redis
```

然后创建个 redis 模块：

```
nest g module redis
nest g service redis
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf36dbe385544309bc35de23c2a45a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=722&h=196&e=webp&b=1f1f1f)

在 RedisModule 创建连接 redis 的 provider，导出 RedisService，并把这个模块标记为 @Global 模块

```javascript
import { Global, Module } from '@nestjs/common';
import { createClient } from 'redis';
import { RedisService } from './redis.service';

@Global()
@Module({
  providers: [
    RedisService,
    {
      provide: 'REDIS_CLIENT',
      async useFactory() {
        const client = createClient({
            socket: {
                host: 'localhost',
                port: 6379
            }
        });
        await client.connect();
        return client;
      }
    }
  ],
  exports: [RedisService]
})
export class RedisModule {}
```

然后在 RedisService 里注入 REDIS_CLIENT，并封装一些方法：

```javascript
import { Inject, Injectable } from '@nestjs/common';
import { RedisClientType } from 'redis';

@Injectable()
export class RedisService {

    @Inject('REDIS_CLIENT') 
    private redisClient: RedisClientType;

    async get(key: string) {
        return await this.redisClient.get(key);
    }

    async set(key: string, value: string | number, ttl?: number) {
        await this.redisClient.set(key, value);

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }

    async hashGet(key: string) {
        return await this.redisClient.hGetAll(key);
    }

    async hashSet(key: string, obj: Record<string, any>, ttl?: number) {
        for(let name in obj) {
            await this.redisClient.hSet(key, name, obj[name]);
        }

        if(ttl) {
            await this.redisClient.expire(key, ttl);
        }
    }
}
```
我们封装了 get、set、hashGet、hashSet 方法，分别是对 redis 的 string、hash 数据结构的读取。

然后在 view 方法里引入 redis：

```javascript
@Inject(RedisService)
private redisService: RedisService;

async view(id: number) {
    const res = await this.redisService.hashGet(`article_${id}`);

    if(res.viewCount === undefined) {
      const article = await this.findOne(id);

      article.viewCount ++;

      await this.entityManager.save(article);

      await this.redisService.hashSet(`article_${id}`, {
        viewCount: article.viewCount,
        likeCount: article.likeCount,
        collectCount: article.collectCount
      });

      return article.viewCount;

    } else {
      await this.redisService.hashSet(`article_${id}`, {
        ...res,
        viewCount: +res.viewCount + 1
      });
      return +res.viewCount + 1;
    }
}
```
先查询 redis，如果没查到就从数据库里查出来返回，并存到 redis 里。

查到了就更新 redis 的 viewCount，直接返回 viewCount + 1

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9546b6f44a01456eb5c7a1dfd755d2d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=772&h=640&e=png&b=fcfcfc)

服务端打印了 3 条 sql：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3626eedca554a6587282af70d1c8ac8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1596&h=314&e=png&b=191919)

redis 里也有了这个 hash 的结构：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e530ee6adad439ab08a6808947b4377~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2246&h=838&e=png&b=1a1a1a)

为什么是 3 条呢？

因为 findOne 发一条 select，save 会先发一条 select，再发一条 update。

我们可以优化一下，把 save 换成 update：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/948b542076df453ebf7c84532609b353~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=652&e=png&b=1f1f1f)

```javascript
await this.entityManager.update(Article, {  id }, {
    viewCount: article.viewCount
});
```
然后把 redis 那条数据删掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9788237156734af0a24fa841d5c4b68c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1412&h=824&e=png&b=1d1d1d)

重新跑一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3737234048e341439251f70d71fa5c2c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1618&h=216&e=png&b=191919)

现在就只有一条 select、一条 update 了。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faf52919e478446bbfd90c65ca20931a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1944&h=706&e=png&b=1c1c1c)

然后多刷新几次：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/026c9f9fe0ab42b696cf2717c38a9a5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1270&h=670&e=gif&f=19&b=fbfbfb)

没发送 sql，还是之前那两条：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed1d914a14f34ec193c2624d045e6ba8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078&h=228&e=png&b=191919)

因为这时候查的是 redis。

redis 里数据更新了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb2f7c7a439424b81a837c26e163db9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1924&h=738&e=png&b=1c1c1c)

但是数据库里的 viewCount 还是 8

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0e47c613c6f475881a4f8a93aa3afe2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=240&e=png&b=fafafa)

这样一重启 redis 数据就没了。

所以还要同步到数据库。

同步倒是不用很频繁，可以放在凌晨 4 点，访问量少的时候通过定时任务同步数据库。

我们需要引入定时任务包 @nestjs/schedule

```
npm install --save @nestjs/schedule
```

在 AppModule 引入下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da9dd554de1b4601ad796006221742af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=988&h=602&e=png&b=1f1f1f)

然后创建一个 service：
```
nest g module task
nest g service task
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54cfef67d208453eab9317728cdcfec3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=732&h=248&e=png&b=191919)

定义个方法，通过 @Cron 声明每 10s 执行一次：

```javascript
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class TasksService {

  @Cron(CronExpression.EVERY_10_SECONDS)
  handleCron() {
    console.log('task execute')
  }
}
```
然后就可以看到控制台会每 10s 打印一次

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebee4294bf994a3e8f057dfe909b3d14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1084&h=738&e=png&b=181818)

我们在 TaskModule 引入 ArticleModule：

```javascript
import { Module } from '@nestjs/common';
import { TaskService } from './task.service';
import { ArticleModule } from 'src/article/article.module';

@Module({
  imports: [
    ArticleModule
  ],
  providers: [TaskService]
})
export class TaskModule {}
```
并且在 ArticleModule 导出 ArticleService

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdb0e59201a84700b742a3673502a5f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&h=488&e=png&b=1f1f1f)

然后在 TaskService 里注入 articleService 
```javascript
import { Inject, Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { ArticleService } from 'src/article/article.service';

@Injectable()
export class TaskService {

  @Inject(ArticleService)
  private articleService: ArticleService;

  @Cron(CronExpression.EVERY_MINUTE)
  async handleCron() {
    await this.articleService.flushRedisToDB();
  }
}
```

每分钟执行一次，调用 articleService 的 flushRedisToDB 方法。

然后我们实现这个方法：

先在 RedisService 添加一个 keys 方法，用来查询 key：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0783f06b09b845ebbb813e6caf2e1cfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920&h=512&e=png&b=1f1f1f)

```javascript
async keys(pattern: string) {
    return await this.redisClient.keys(pattern);
}
```
然后在 ArticleService 里实现同步数据库的逻辑：

```javascript
async flushRedisToDB() {
    const keys = await this.redisService.keys(`article_*`);
    console.log(keys);
}
```

我们先打印下 keys。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cadcfe5c40ad490dbf0d2a0243eff546~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=358&h=214&e=png&b=181818)

现在只有一个 key，我们再访问下另一篇文章


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b861eb19d5c4488a4cd691ff25941ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=742&h=576&e=png&b=fbfbfb)

现在就有 2 个 key 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a2623fea2564d47a42118e61bea4e99~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=496&h=174&e=png&b=191919)

我们把所有的 key 对应的值存入数据库：

```javascript
async flushRedisToDB() {
    const keys = await this.redisService.keys(`article_*`);

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];

      const res = await this.redisService.hashGet(key);

      const [, id] = key.split('_');

      await this.entityManager.update(Article, {
        id: +id
      }, {
        viewCount: +res.viewCount,        
      });
    }
}
```

查询出 key 对应的值，更新到数据库。

测试下：
  
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6ef2153ce824061a42daaa7f96303a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1320&h=864&e=gif&f=29&b=fcfcfc)

刷新几次 view 接口，redis 里阅读量增加了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30c2b390069a404f922d08146b51dcb6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1916&h=678&e=png&b=1d1d1d)

但是数据库里没变：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5e3bc2f86f24a409e6e16f1dca68490~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1108&h=238&e=png&b=fafafa)

过了一会，控制台打印了 2 条 update 语句：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b2ded51d38646a0b1a6fc54b16a0fb9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1176&h=180&e=png&b=191919)

数据库里的数据就更新了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64857cb5a78745028c80ea6d1da94b74~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1048&h=236&e=png&b=f9f9f9)

接下来只要把定时任务的执行时间改为 4 点就好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bbbbb54c49e444fa3bcb3c7eeaba66d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=936&h=598&e=png&b=1f1f1f)

```javascript
@Cron(CronExpression.EVERY_DAY_AT_4AM)
```
这样，基于 redis 的阅读量缓存，以及定时任务更新数据库就完成了。

还有剩下的一个问题：

- 每次刷新阅读量都加一，其实还是同一个人看的这篇文章，这样统计出来的阅读量是不准的，我们想要的阅读量是有多少人看过这篇文章

我们可以在用户访问文章的时候在 redis 存一个 10 分钟过期的标记，有这个标记的时候阅读量不增加。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5efa6c2989b8452090c4d747cfdd8c64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=1238&e=png&b=1f1f1f)

```javascript
await this.redisService.set(`user_${userId}_article_${id}`, 1, 3);
```
为了测试方便，我们先设置 3s 过期。

```javascript
const flag = this.redisService.get(`user_${userId}_article_${id}`);

if(flag) {
    return res.viewCount;
}
```
这里需要传入 userId。

我们在 ArticleController 的 view 方法里传入下：

```javascript
@Get(':id/view')
async view(@Param('id') id: string, @Session() session, @Req() req) {
    return await this.articleService.view(+id, session?.user?.id || req.ip);
}
```

试试看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44075eeee18742dd8071c58547e67370~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1266&h=684&e=gif&f=38&b=fcfcfc)

可以看到，现在就不是每次刷新都增加阅读量了，而是 3s 之后再刷新才增加。

在 redis 里可以看到这个 key：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee2fa1fe43b41a186ae89520ad89ab3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1246&h=600&e=png&b=1c1c1c)

只不过现在没登录，用的是 ip，而本地访问的时候获取的 ip 就是 ::1 这样的，线上就能拿到具体的 ip 了。

然后我们登录下再访问：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63184b6d205448918f25939aeefb1459~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=586&e=png&b=fbfbfb)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fba69d15f5465c8a72e66e074222c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750&h=584&e=png&b=fbfbfb)

这时用的就是用户 id 了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca4a9e9f38343d9a38f3eece0a87d49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1214&h=626&e=png&b=1b1b1b)

这样就实现了真实的阅读量计数。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/article-views)。

## 总结

我们通过 redis + 定时任务实现了阅读量计数的功能。

因为阅读是个高频操作，所以我们查出数据后存在 redis里，之后一直访问 redis 的数据，然后通过定时任务在凌晨 4 点把最新数据写入数据库。

并且为了统计真实的用户阅读量，我们在 redis 存储了用户看了哪篇文章的标识，10 分钟后过期。

这就是我们常见的阅读量功能的实现原理。


## 83.Nest 的 3 种定时任务

定时任务，顾名思义就是你可以设定个时间，任务会在设定的时间自动执行。

比如上节我们在 redis 里存取数据，然后通过定时任务在凌晨 4 点刷入数据库。

这节我们就更全面的学下定时任务吧。

新建个 nest 项目：

```
nest new schedule-task
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/213eba42ce5744308a280f266f802b6c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=890&h=680&e=png&b=010101)

然后安装定时任务的包：

```
npm install --save @nestjs/schedule
```
在 AppModule 里引入：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/193df5b55a5645ce816d7cb05424411c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=916&h=544&e=png&b=1f1f1f)

然后就可以创建定时任务了。

我们创建个 service：
```
nest g service task --flat --no-spec
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e53c8b6762f4e90b632021c60483b55~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=94&e=png&b=191919)

通过 @Cron 声明任务执行时间：

```javascript
import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class TaskService {

  @Cron(CronExpression.EVERY_5_SECONDS)
  handleCron() {
    console.log('task execute');
  }
}
```
把服务跑起来试下：

```
npm run start:dev
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e9b86802d874c619cafb25350b6fdf2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1426&h=776&e=gif&f=59&b=181818)

可以看到，任务每 5s 都会执行。

当然，也可以注入其他模块的 service。

我们创建个 aaa 模块：

```
nest g resource aaa
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b1de143ef95469fb334dcfee2acc15c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=764&h=340&e=png&b=191919)

把 AaaService 导出：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb14a55b1054d51a10da476748e51c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=432&e=png&b=1f1f1f)

然后在 TaskService 注入：

```javascript
import { Inject, Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import { AaaService } from './aaa/aaa.service';

@Injectable()
export class TaskService {

  @Inject(AaaService)
  private aaaService: AaaService;

  @Cron(CronExpression.EVERY_5_SECONDS)
  handleCron() {
    console.log('task execute：', this.aaaService.findAll());
  }
}
```
这样就可以定时执行 AaaService 的方法：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8593a48b386e4f1e814b542a62566801~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=424&e=png&b=191919)

上节我们定时把 redis 数据刷入数据库就是这样做的。

我们设置的每 5s 执行一次，其实是一个 cron 表达式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a3625307fea4b7b8da80b2872ed4a65~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=232&e=png&b=202020)

cron 表达式有这 7 个字段：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f92a440ff82e4d34971c5216ae91afd7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1390&h=726&e=png&b=fdfdfd)

其中年是可选的，所以一般都是 6 个。

每个字段都可以写 * ，比如秒写 * 就代表每秒都会触发，日期写 * 就代表每天都会触发。

但当你指定了具体的日期的时候，星期得写 ？

比如表达式是 

```
7 12 13 10 * ?
```

就是每月 10 号的 13:12:07 执行这个定时任务。

但这时候你不知道是星期几，如果写 * 代表不管哪天都会执行，这时候就要写 ?，代表忽略星期。

同样，你指定了星期的时候，日期也可能和它冲突，这时候也要指定 ?

但只有日期和星期可以指定 ？，因为只有这俩字段是相互影响的。

除了指定一个值外，还可以指定范围，比如分钟指定 20-30，

```
0 20-30 * * * *
```

这个表达式就是从 20 到 30 的每分钟每个第 0 秒都会执行。


当然也可以指定枚举值，通过 , 分隔

比如每小时的第 5 和 第 10 分钟的第 0 秒执行定时任务：

```
0 5,10 * * * *
```
而且还可以通过 / 指定每隔多少时间触发一次。

比如从第 5 分钟开始，每隔 10 分钟触发一次：
```
0 5/10 * * * *
```

此外，日期和星期还支持几个特殊字符：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73a4c83260754c39b9b2e0112a21600b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=568&e=png&b=fdfcfc)

L 是 last，L 用在星期的位置就是星期六：
```
* * * ? * L
```
L 用在日期的位置就是每月最后一天：

```
* * * L * ?
```
W 代表工作日 workday，只能用在日期位置，代表从周一到周五
```
* * * W * ?
```
当你指定 2W 的时候，代表每月的第而个工作日：

```
* * * 2W * ?
```
LW 可以在指定日期时连用，代表每月最后一个工作日：

```
* * * LW * ?
```
星期的位置还可以用 4#3 表示每个月第 3 周的星期三：

```
* * * ? * 4#3
```
同理，每个月的第二周的星期天就是这样：
```
* * * ? * 1#2
```

此外，星期几除了可以用从 1（星期天） 到 7（星期六） 的数字外，还可以用单词的前三个字母：SUN, MON, TUE, WED, THU, FRI, SAT

我们来看几个例子：

每隔 5 秒执行一次:
```
*/5 * * * * ?
```
每天 5-15 点整点触发：
```
0 0 5-15 * * ?  
```
每天 10 点、14 点、16 点触发：
```
0 0 10,14,16 * * ?   
```
每个星期三中午12点：
```
0 0 12 ? * WED
```
每周二、四、六下午五点：
```
0 0 17 ? * TUES,THUR,SAT
```
每月最后一天 22 点执行一次：
```
0 0 22 L * ?
```
2023 年至 2025 年的每月的最后一个星期五上午 9:30 触发
```
0 30 9 ? * 6L 2023-2025 
```
每月的第三个星期五上午 10:15 触发：
```
0 15 10 ? * 6#3 
```
基本就这些语法。

但自己写这样的 cron 表达式还是挺麻烦的，所以 Nest 提供了一些常量可以直接用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94a21b7f57694d058867501eb22dc1fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1586&h=506&e=png&b=202020)

这个 @Cron 装饰器还有第二个参数，可以指定定时任务的名字，还有时区：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac50ed680eed4f54bfce87c0d67a900a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1000&h=700&e=png&b=1f1f1f)

时区的名字可以在[这里](https://momentjs.com/timezone/)查：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2861497a64d946d2be2b8091e51508d7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2336&h=1234&e=gif&f=31&b=f9f9f9)

除了 @Cron 之外，你还可以用 @Interval 指定任务的执行间隔，参数是毫秒值：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6aee23d36204dea97179744fd27a5bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=660&h=524&e=png&b=1f1f1f)

```javascript
@Interval('task2', 500)
task2() {
    console.log('task2');
}
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b62d02b93bb54f518e8904e39c1a7f5b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&h=640&e=gif&f=23&b=191919)

还可以用 @Timeout 指定多长时间后执行一次：

```javascript
@Timeout('task3', 3000)
task3() {
    console.log('task3');
}
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2f1d8e0d07344ee80b4bcc55022dbc6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=610&h=478&e=png&b=191919)

综上，我们可以通过 @Cron、@Interval、@Timeout 创建 3 种定时任务。

我们知道了怎么声明定时任务，那能不能管理定时任务，也就是对它做增删改呢？

当然是可以的。

我们在 AppModule 里注入 SchedulerRegistry，然后在 onApplicationBootstrap 的声明周期里拿到所有的 cronJobs 打印下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be8ad8d01ba4d5899ff71f0da5b40d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1024&h=862&e=png&b=1f1f1f)

```javascript
@Inject(SchedulerRegistry)
private schedulerRegistry: SchedulerRegistry;

onApplicationBootstrap() {
    const jobs = this.schedulerRegistry.getCronJobs();
    console.log(jobs);
}
```
可以看到，拿到了我们声明的 task1 的定时任务：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a703882479694a5e9c21a257fdf9fd07~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=810&h=978&e=png&b=181818)

这样看不方便，我们加一下调试配置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/342296921655462b8377fb6e35c7f8ee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=616&h=336&e=png&b=181818)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/176cec8c06504df8a7ad8aec07ba6791~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=924&h=850&e=png&b=1f1f1f)
```json
{
    "type": "node",
    "request": "launch",
    "name": "debug nest",
    "runtimeExecutable": "npm",
    "args": [
        "run",
        "start:dev",
    ],
    "skipFiles": [
        "<node_internals>/**"
    ],
    "console": "integratedTerminal",
}
```
打个断点：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15a4cbc631cc4e34a0645e8ca9ade3b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=990&h=416&e=png&b=1f1f1f)

把之前的服务停掉，点击 debug 启动：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/543c815416c94c13a6ec5e6308d4805a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=680&h=496&e=png&b=1a1a1a)

代码会在断点处断住：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da8d00e8fa2e41559299ef3379368464~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=728&e=png&b=202020)

这样就方便多了。

切换到 debug console 就可以动态执行表达式：

比如拿到所有的 interval 定时任务的名字：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c31a49c4d9cd436e89f62b369a95bf86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=836&e=png&b=191919)

再根据名字拿到具体的 interval 定时任务：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e53d6d31ef4448e9a2584a96dfb4c5ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=624&e=png&b=191919)

```javascript
this.schedulerRegistry.getIntervals()

this.schedulerRegistry.getInterval('task2')
```
timeout 和 cron 类型的定时任务也是同理：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec5dbed4e0a7403e9d0df1098af8e771~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=830&h=564&e=png&b=191919)
```javascript
this.schedulerRegistry.getTimeouts();

this.schedulerRegistry.getTimeout('task3')
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bf1a5180e7e46af9d1d63d8693e1d4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=890&h=578&e=png&b=191919)

```javascript
this.schedulerRegistry.getCronJobs()

this.schedulerRegistry.getCronJob('task1')
```
当然，它还有增加和删除定时任务的 api：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afe882e46e954b5caea2392dfbec44b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=860&e=png&b=191919)

我们来写个具体的案例：

把声明的 3 个 task 删掉，再动态添加 3 个：

自己创建定时任务，需要安装 cron 的包：

```
npm install --save cron
```
然后实现下删除定时任务的逻辑：

```javascript
onApplicationBootstrap() {
    const crons = this.schedulerRegistry.getCronJobs();
    
    crons.forEach((item, key) => {
      item.stop();
      this.schedulerRegistry.deleteCronJob(key);
    });

    const intervals = this.schedulerRegistry.getIntervals();
    intervals.forEach(item => {
      const interval = this.schedulerRegistry.getInterval(item);
      clearInterval(interval);

      this.schedulerRegistry.deleteInterval(item);
    });

    const timeouts = this.schedulerRegistry.getTimeouts();
    timeouts.forEach(item => {
      const timeout = this.schedulerRegistry.getTimeout(item);
      clearTimeout(timeout);

      this.schedulerRegistry.deleteTimeout(item);
    });

    console.log(this.schedulerRegistry.getCronJobs());
    console.log(this.schedulerRegistry.getIntervals());
    console.log(this.schedulerRegistry.getTimeouts());
  }
```
为什么停掉 CronJob 用 job.stop 而停掉 timeout 和 interval 用 clearTimeout 和 clearInterval 呢？

因为 timeout 和 interval 本来就是基于 setTimeout、setInterval 的原生 api 封装出来的啊！

而 CronJob 则是基于 cron 包。

跑起来试下：

```
npm run start:dev
```
确实没有定时任务执行了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fac8c496de14fc59259245efeaf7172~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=808&h=656&e=png&b=181818)

当然，还可以动态添加定时任务：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f01b9dd3a4849779e6746381e4c2ebf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1022&h=852&e=png&b=1f1f1f)

```javascript
const job = new CronJob(`0/5 * * * * *`, () => {
  console.log('cron job');
});

this.schedulerRegistry.addCronJob('job1', job);
job.start();

const interval = setInterval(() => {
  console.log('interval job')
}, 3000);
this.schedulerRegistry.addInterval('job2', interval);

const timeout = setTimeout(() => {
  console.log('timeout job');
}, 5000);
this.schedulerRegistry.addTimeout('job3', timeout);
```
这里也可以看出来 CronJob 是基于 cron 包封装的，而 interval 和 timeout 就是用的原生 api。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5f40e90890b4c059628fbacff91d0c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=514&h=602&e=png&b=181818)

跑起来可以看到，定时任务确实都添加成功了。

也就是说，我们可以注入 SchedulerRegistry 来动态增删定时任务。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/schedule-task)。

## 总结

这节我们学习了定时任务，用到 @nestjs/scheduler 这个包。

主要有 cron、timeout、interval 这  3 种任务。

其中 cron 是依赖 cron 包实现的，而后两种则是对原生 api 的封装。

我们学习了 cron 表达式，还是挺复杂的，当然，你也可以直接用 CronExpression 的一些常量。

此外，你还可以注入 SchedulerRegistery 来对定时任务做增删改查。

定时任务里可以注入 service，来定时执行一些逻辑，在特定业务场景下是很有用的。



## 84.Nest 里如何实现事件通信？

后端应用中会有很多业务模块，这些业务模块之间会有互相调用的关系。

但是把一个业务模块作为依赖注入的别的业务模块也不大好。

比如下单送优惠券的活动，订单模块在订单完成后调用优惠券模块下发优惠券。

这种如果直接把优惠券模块注入到订单模块里就不大好，因为是两个独立的业务模块。

有没有别的通信方式呢？

有，比如通过 event emitter 通信。

我们试一下：

```
nest new event-emitter-test
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327c737cf5284482ad74abd9c988ed0e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=698&s=161489&e=png&b=010101)

安装用到的包：

```
npm i --save @nestjs/event-emitter
```
在 AppModule 引入下 EventEmitterModule：

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { EventEmitterModule } from '@nestjs/event-emitter';

@Module({
  imports: [
    EventEmitterModule.forRoot(),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

然后创建两个 module：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f42eed297e3448cb9514d0d59baa274d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=780&h=298&s=75317&e=png&b=191919)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/967b36c24c8141fb8af361eb50feb0ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=772&h=306&s=74252&e=png&b=191919)

把服务跑起来：

```
npm run start:dev
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/519eed6dab934d4abaad97e44219b88e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1638&h=654&s=364853&e=png&b=181818)

访问下 aaa 和 bbb 的接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/946c6e7a3d0d46b6aeb667fbddaa4346~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=748&h=222&s=23147&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78553f423f904cff88030a3c072b5517~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=848&h=276&s=25167&e=png&b=ffffff)

没啥问题。

然后我们想在 aaa 模块的查询触发的时候，调用 bbb 模块记录一条日志呢？

这时候就可以用 Event Emitter 来做。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efb13c737f78487ca131426bd74aebc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982&h=828&s=168979&e=png&b=1f1f1f)

```javascript
@Inject(EventEmitter2)
private eventEmitter: EventEmitter2;

findAll() {
    this.eventEmitter.emit('aaa.find',{
      data: 'xxxx'
    })
    return `This action returns all aaa`;
}
```
在 AaaService 里注入 EventEmitter2，然后调用它的 emit 方法发送一个事件。

然后在 BbbService 里监听下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd79955ec0674a4a922f9b38ac9530a6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=938&h=726&s=151929&e=png&b=202020)

```javascript
@OnEvent('aaa.find')
handleAaaFind(data) {
    console.log('aaa find 调用', data)
    this.create(new CreateBbbDto());
}
```
试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9d5219675ec4ad593e1e645b6adfc42~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=798&h=238&s=23703&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99dfdaba77024ecfa3f8b3fb8cac8c00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=822&h=1088&s=293056&e=png&b=1a1a1a)

可以看到 AaaService 的 findAll 调用的时候，自动触发了 BbbService 里的方法调用。

是不是很方便？

如果你没感觉出来，那想一下不通过事件怎么做呢？

是不是需要在 BbbModule 里把 BbbService 放到 exports 里声明，然后在 AaaModule 里引入之后 BbbModule 之后，注入它的 BbbService 来用呢？

或者通过全局模块，把 BbbModule 通过 @Global 声明为全局模块，然后在 AaaService 里注入 BbbService 来调用呢？

不管哪种都很麻烦。

而通过事件的方式就简单太多了。

此外，EventEmitterModule 还支持一些配置：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faace15ae4414193967ad2a4698f5fc9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=558&h=328&s=34971&e=png&b=1f1f1f)

wildcard 是允许通配符 *。

delimiter 是 namespace 和事件名的分隔符。

配置之后就可以这样用了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/071ea45608614d3f946fa5e9e4b85d13~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=672&h=768&s=99877&e=png&b=1f1f1f)

```javascript
findAll() {
    this.eventEmitter.emit('aaa.find',{
      data: 'xxxx'
    })

    this.eventEmitter.emit('aaa.find2',{
      data: 'xxxx2'
    })
    return `This action returns all aaa`;
}
```

BbbService 里可以用 aaa.* 通配符匹配：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c41b777e9a4c499286c784f438cd97f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=746&h=560&s=123828&e=png&b=1f1f1f)

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f7bcec802874e568839310b2b64da4a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=712&h=218&s=22733&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f9b8da3d6744c4c919a17069124fee1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=678&h=470&s=114493&e=png&b=191919)

event emitter 用起来很简单，但却很有用，比直接引入模块注入依赖的方式方便太多了。

我们来做个具体案例，用户注册成功之后，通知模块里发送欢迎邮件：

```
nest g resource user --no-spec
nest g resource notification --no-spec
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/600ff7e571214ec1b1e3b073c43f1b7c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=770&h=296&s=73799&e=png&b=191919)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ac1846d1627468d9b7943455baa06e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=972&h=296&s=83395&e=png&b=191919)

```
nest g module email
nest g service email --no-spec
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c50955f211e42a39a22f4299c04bb7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=210&s=53119&e=png&b=191919)

创建 user 用户模块、notification 通知模块，email 邮件模块。

先来写下邮件模块：

安装 nodemailer 包：

```
npm install --save nodemailer
```
写下 EmailService：

```javascript
import { Injectable } from '@nestjs/common';
import { createTransport, Transporter} from 'nodemailer';

@Injectable()
export class EmailService {

    transporter: Transporter
    
    constructor() {
      this.transporter = createTransport({
          host: "smtp.qq.com",
          port: 587,
          secure: false,
          auth: {
              user: "你的用户名",
              pass: "你的授权码"
          },
      });
    }

    async sendMail({ to, subject, html }) {
      await this.transporter.sendMail({
        from: {
          name: '系统邮件',
          address: "你的邮箱地址"
        },
        to,
        subject,
        html
      });
    }

}
```
如何获取授权码看 [node 发邮件](https://juejin.cn/book/7226988578700525605/section/7247327089496424505)那节。

然后把 EmailModule 声明为全局模块：

```javascript
import { Global, Module } from '@nestjs/common';
import { EmailService } from './email.service';

@Global()
@Module({
  providers: [EmailService],
  exports: [EmailService]
})
export class EmailModule {}

```

这样 NotificationService 里就可以直接注入 EmailService 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7677723e30848838a34f7dae8ad2e2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1000&h=862&s=184919&e=png&b=1f1f1f)

```javascript
@Inject(EmailService)
private emailService: EmailService

@OnEvent("user.register")
async hanldeUserRegister(data) {
    console.log('user.register');

    await this.emailService.sendMail({
      to: data.email,
      subject: '欢迎' + data.username,
      html: '欢迎新人'
    })
}
```

然后在 CreateUserDto 添加两个属性：

```javascript
export class CreateUserDto {
    username: string;
    email: string;
}
```
在 create 的时候调用下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2037448ce8614f1189f099e97dc5fe60~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=912&h=786&s=156904&e=png&b=1f1f1f)

```javascript
@Inject(EventEmitter2)
private eventEmitter: EventEmitter2;

create(createUserDto: CreateUserDto) {
    this.eventEmitter.emit('user.register', {
      username: createUserDto.username,
      email: createUserDto.email
    })

    return 'This action adds a new user';
}
```
在 postman 里调用下 create 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08b0d7a936e84b31946897ecaf11b9a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=778&h=594&s=65248&e=png&b=fbfbfb)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a86fc83bc284137a72e7233cf58935a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=478&s=148792&e=png&b=191919)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca091039e2744b6bb57b21d203338f40~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=506&h=252&s=28589&e=png&b=f5f5f5)

通知成功了！

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/event-emitter-test)。
## 总结

多个业务模块之间可能会有互相调用的关系，但是也不方便直接注入别的业务模块的 Service 进来。

这种就可以通过 EventEmitter 来实现。

在一个 service 里 emit 事件和 data，另一个 service 里 @OnEvent 监听这个事件就可以了。

用起来很简单，但比起注入别的模块的 service 方便太多了。


## 85.HttpModule + pinyin 实现天气预报查询服务

今天我们来实现一个查询城市天气预报的服务。

使用的是和风天气的免费 api。

免费的接口一天可以请求 1000 次，自己的项目足够用了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd080c15ff9b49579616c43883947447~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1818&h=888&s=183028&e=png&b=ffffff)

最多可以查询未来 7 天的天气预报。

首先，登录[和风天气](https://id.qweather.com/#/login)，

然后在用户中心绑定邮箱和手机号：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4908b91761a407eb62089cf9121d330~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2268&h=1246&s=651917&e=png&b=ffffff)

之后进入[控制台](https://console.qweather.com/#/console)，点击创建项目：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab22d18cf7864dbb93f2b10aa39ec78e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2654&h=892&s=179435&e=png&b=fcfcfc)

这里大家选择免费订阅（我别的项目用了，就没免费名额了），指定 key 的名字：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a135fc697bcf490a9eb83cf995d68782~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1640&h=1438&s=213709&e=png&b=fcfcfc)

然后就可以看到你的 key 了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32199a8ca61a4732a47fb0bc937b6eee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1792&h=974&s=427945&e=gif&f=19&b=fbfbfb)

如果我们要查询青岛未来 7 天的天气。

需要先查询青岛的 id：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2125713b249e46f48dd6c55157543060~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1778&h=1414&s=238721&e=png&b=ffffff)

location 是城市名字的拼音，然后带上刚刚的 key：

```
https://devapi.qweather.com/v7/weather/7d?location=101120606&key=aff40f07926348b9b06f3229d2b52e6a
```
返回了青岛市和各个区的信息。

有了城市 id 之后就可以查询天气了：

```
https://api.qweather.com/v7/weather/7d?location=101120201&key=187d6c3dd15f4d2d99e2a7e0ee08ba04
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5087b11b581944299bc04b42b5b01ddd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1720&h=1324&s=246256&e=png&b=fefefe)

这里返回了从 2024-5-1 到 2024-5-7 的天气。

具体字段的解释可以看[文档](https://dev.qweather.com/docs/api/weather/weather-daily-forecast/#%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE)：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f4093ff415646fe9c2a3eac82275eec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1758&h=1230&s=265571&e=png&b=ffffff)

这样我们就实现了查询某个城市为了 7 天的天气的功能。

还有个问题，现在是先用城市的拼音查的 id，再用 id 查的天气。

那直接让用户输入城市拼音么？

这样也不好，我们可以用 pinyin 这个包：

它可以拿到中文的拼音：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4175dcffcd46470cacdbbb4adbaca2b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234&h=656&s=121783&e=png&b=f7f7f7)

这样，整个流程就串起来了。

当然，如果你想让用户直接选择城市，然后查询城市的天气，这种就要拿到所有城市的信息了。

网上有挺多这种 [JSON 数据](https://blog.csdn.net/qq_32353771/article/details/82221604)的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b84fcc5eb6914e4bbf4d0749c16a7cf1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1588&h=1272&s=240917&e=png&b=fbfbfb)

有所有城市名和它的 id。

思路理清了，我们来写下代码：

```
npm install -g @nestjs/cli

nest new city-weather
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/544f4edefd1b44c6ba22d76f94220727~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=848&h=692&s=163005&e=png&b=010101)

安装 pinyin 包和它的类型：

```
npm install --save pinyin@alpha
npm install --save-dev @types/pinyin
```
然后我们加个接口测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bfe31ea79eb40d1bc22cc485484de98~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=988&h=662&s=128808&e=png&b=1f1f1f)

```javascript
@Get('pinyin')
pinyin(@Query('text') text: string) {
    return pinyin(text).join('')
}
```

把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd5279865b544614b67613a257cfacc9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1546&h=416&s=132568&e=png&b=181818)

访问下试试：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a96031961c24249b417a3f5ff0265e0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&h=196&s=30543&e=png&b=ffffff)

可以看到，确实返回了拼音。

但是我们不需要知道是几声。

改下参数：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20c4cc49e3e34e61ac47bf8cf0ade96c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=844&h=584&s=99234&e=png&b=1f1f1f)

这样就好了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f2e0089a1524de78c824c73302e70d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942&h=194&s=29927&e=png&b=ffffff)

然后 nest 服务里怎么访问三方接口呢？

直接用 axios 么？

可以，但是我们希望统一配置 axios，然后各个模块都用同一个 axios 实例。

所以用 @nestjs/axios 这个包：

```
npm install --save @nestjs/axios axios
```
在 AppModule 引入下 HttpModule：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4666a3c3e36b498d98810ef4954b94c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=852&h=542&s=106442&e=png&b=1f1f1f)

这里可以填入各种请求配置，比如 baseURL 等，其实就是 new 了一个 Axios 实例：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aa369fd2ce74f198e0e645833c81e9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918&h=554&s=118186&e=png&b=1f1f1f)

然后在用到的地方注入 httpService：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2cc81ede47a4555a7cb63c26820d1a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1854&h=688&s=158219&e=png&b=1f1f1f)

```javascript
@Inject(HttpService)
private httpService: HttpService;

@Get('weather/:city')
async weather(@Param('city') city: string) {
  const cityPinyin = pinyin(city, { style: 'normal'}).join('');

  const { data } = await firstValueFrom(
    this.httpService.get(`https://geoapi.qweather.com/v2/city/lookup?location=${cityPinyin}&key=187d6c3dd15f4d2d99e2a7e0ee08ba04`)
  )

  return data;
}
```

用 @Param 取路径中的参数。

然后用 pinyin 拿到 city 的拼音，然后调用和风天气的接口。

这里为啥用 firstValueFrom 的 rxjs 操作符呢？

因为 HttpModule 把 axios 的方法返回值封装成了 rxjs 的 Observerable。

好处是你可以用 rxjs 的操作符了。

坏处是转成 promise 还得加一层 firstValueFrom。

它就是用来把 rxjs Observable 转成 promise 的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9412be39906406188b900d98593dab2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2072&h=630&s=154121&e=png&b=f8f8f8)

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8590d3492ab4464b94ece31ce7fad104~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1174&h=808&s=115668&e=png&b=ffffff)

没啥问题。

然后继续调用天气预报接口：

```javascript
@Get('weather/:city')
async weather(@Param('city') city: string) {
    const cityPinyin = pinyin(city, { style: 'normal'}).join('');

    const { data } = await firstValueFrom(
      this.httpService.get(`https://geoapi.qweather.com/v2/city/lookup?location=${cityPinyin}&key=187d6c3dd15f4d2d99e2a7e0ee08ba04`)
    )

    const location = data?.['location']?.[0];

    if(!location) {
      throw new BadRequestException('没有对应的城市信息');
    }

    const { data: weatherData } = await firstValueFrom(
      this.httpService.get(`https://api.qweather.com/v7/weather/7d?location=${location.id}&key=187d6c3dd15f4d2d99e2a7e0ee08ba04`)
    )

    return weatherData;
}
```

如果没查到 location，返回 400 错误。

否则用 location.id 查询该城市天气预报。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb9f2cc2764843c6ba3e3f7c74f35814~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=818&h=330&s=42177&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1974d65642442289d5d449ee9df54b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1156&h=1278&s=198301&e=png&b=ffffff)

这样，我们的城市天气预报服务就完成了。

当然，这里最好用 redis 做一层缓存，同一个城市的一天内只查一次，避免接口反复调用。这个大家可以自己去优化。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/city-weather)

## 总结

我们基于和风天气的 api 实现了天气预报查询服务。

主要用到了 pinyin 这个包来完成中文转拼音，然后用 pinyin 去请求和风天气的 api 查询城市 id。

接下来用城市 id 请求天气数据。

和风天气的 api 免费版一天可以调用 1000 次，足够用了。

Nest 里发送 http 请求，我们用的是 @nestjs/axios 包的 HttpModule 来做的。

它可以统一配置，然后注入 HttpService 到用到的地方，并且 httpService 方法的返回值封装成了 rxjs 的 Observerable，可以直接用 rxjs 的操作符。

比如用 fistValueFrom 来把 rxjs 的 Observable 转为 Promise。

这样，你就可以在你的应用中集成天气预报功能了。


## 86.如何记录请求日志

Nest 服务会不断处理用户用户的请求，如果我们想记录下每次请求的日志呢？

可以通过 interceptor 来做。

我们写一下：

```
nest new request-log
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc5b226b098b40399f00f369e95a89b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=836&h=696&s=156435&e=png&b=010101)

进入项目，创建个 interceptor：

```
nest g interceptor request-log --no-spec --flat
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4488f05084c4a02ad7e850d42c5c3d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=810&h=62&s=19827&e=png&b=191919)

打印下日志：

```javascript
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { Response } from 'express';
import { Request } from 'express';
import { Observable, tap } from 'rxjs';

@Injectable()
export class RequestLogInterceptor implements NestInterceptor {
  private readonly logger = new Logger(RequestLogInterceptor.name);

  intercept(
    context: ExecutionContext,
    next: CallHandler<any>,
  ) {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();

    const userAgent = request.headers['user-agent'];

    const { ip, method, path } = request;

    this.logger.debug(
      `${method} ${path} ${ip} ${userAgent}: ${
        context.getClass().name
      } ${
        context.getHandler().name
      } invoked...`,
    );

    const now = Date.now();

    return next.handle().pipe(
      tap((res) => {
        this.logger.debug(
          `${method} ${path} ${ip} ${userAgent}: ${response.statusCode}: ${Date.now() - now}ms`,
        );
        this.logger.debug(`Response: ${JSON.stringify(res)}`);
      }),
    );
  }
}
```
这里用 nest 的 Logger 来打印日志，可以打印一样的格式。

打印下 method、path、ip、user agent，调用的目标 class、handler 等信息。

然后记录下响应的状态码和请求时间还有响应内容。

全局启用这个 interceptor：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993e301485814f80bf286317ba3176b9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1100&h=690&s=138192&e=png&b=1f1f1f)

```javascript
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { RequestLogInterceptor } from './request-log.interceptor';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLogInterceptor
    }
  ],
})
export class AppModule {}
```
把服务跑起来：

```
npm run start:dev
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc05427113c54555bde236a16b9bae63~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606&h=356&s=117752&e=png&b=181818)

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ad2fc8d22a439eb4af197fa9d9566d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=658&h=192&s=19921&e=png&b=fefefe)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c91f2ef3b2e34afbb08037dc9487f590~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2086&h=518&s=218602&e=png&b=181818)

可以看到，打印了请求的信息，目标 class、handler，响应的内容。

但其实这个 ip 是有问题的：

如果客户端直接请求 Nest 服务，那这个 ip 是准的，但如果中间经过了 nginx 等服务器的转发，那拿到的 ip 就是 nginx 服务器的 ip 了。

这时候要取 X-Forwarded-For 这个 header，它记录着转发的客户端 ip。

当然，这种事情不用自己做，有专门的库 request-ip：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d185d5f4a8434bd9807ff00c4c9ab6f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2196&h=888&s=165747&e=png&b=fefefe)

安装下：

```
npm install --save request-ip
```

然后把打印的 ip 换一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8c19bab4cc04c5b853dbc8e3298b985~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1254&h=912&s=207022&e=png&b=1f1f1f)

换成 X-Forwarded-For 的客户端 ip 或者是 request.ip。

```javascript
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { Response } from 'express';
import { Request } from 'express';
import { Observable, tap } from 'rxjs';
import * as requestIp from 'request-ip';

@Injectable()
export class RequestLogInterceptor implements NestInterceptor {
  private readonly logger = new Logger(RequestLogInterceptor.name);

  intercept(
    context: ExecutionContext,
    next: CallHandler<any>,
  ) {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();

    const userAgent = request.headers['user-agent'];

    const { ip, method, path } = request;

    const clientIp = requestIp.getClientIp(ip) || ip;

    this.logger.debug(
      `${method} ${path} ${clientIp} ${userAgent}: ${
        context.getClass().name
      } ${
        context.getHandler().name
      } invoked...`,
    );

    const now = Date.now();

    return next.handle().pipe(
      tap((res) => {
        this.logger.debug(
          `${method} ${path} ${clientIp} ${userAgent}: ${response.statusCode}: ${Date.now() - now}ms`,
        );
        this.logger.debug(`Response: ${JSON.stringify(res)}`);
      }),
    );
  }
}
```
访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ad2fc8d22a439eb4af197fa9d9566d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=658&h=192&s=19921&e=png&b=fefefe)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adc0f934451143a288f12d84d42fa754~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1780&h=486&s=204844&e=png&b=181818)

因为我们本地访问用 localhost 是拿不到真实 ip 的。

你可以查一下本地 ip，用 ip 访问：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a56c88c01e64c8caca56d634e310a5b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=824&h=202&s=24905&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62a40d49ecc742d0ba9de4c2cc21e8de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1750&h=516&s=213532&e=png&b=181818)

这里的 ::ffff 是 ipv6 地址的意思：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d740b9700c2242108175eb301a000b1a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1336&h=472&s=90642&e=png&b=ffffff)

这样部署到线上之后就能拿到真实地址了。

那如果想拿到 ip 地址对应的城市呢？

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b41849f8d89476182956347521a788f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1468&h=512&s=93946&e=png&b=ffffff)

很多系统会做登录日志，每次登录的时候记录登录时的 ip 和对应的城市信息到数据库里。

如何根据 ip 拿到城市信息呢？

其实可以通过一些在线的免费接口：

https://whois.pconline.com.cn/ipJson.jsp?ip=221.237.121.165&json=true

这个就是用于查询 IP 对应的城市的。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6506d0caf004facb57998c7fce77ebc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2248&h=246&s=89901&e=png&b=fefefe)

请求三方服务用 axios 的包，

安装下：

```
npm install --save @nestjs/axios axios
```
在 AppModule 里引入下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa49346ee39405d99d554fbf56dd8e1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=878&s=165504&e=png&b=1f1f1f)

然后在 interceptor 里注入 HttpService 来发请求：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18d1f0dfa5654005935252e3b77e6fac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1696&h=756&s=202009&e=png&b=1f1f1f)

注入 HttpService，封装个 ipToCity 方法来查询，在 intercept 方法里调用下：

```javascript
import { CallHandler, ExecutionContext, Inject, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import { Response } from 'express';
import { Request } from 'express';
import { Observable, tap } from 'rxjs';
import * as requestIp from 'request-ip';
import { HttpService } from '@nestjs/axios';

@Injectable()
export class RequestLogInterceptor implements NestInterceptor {
  private readonly logger = new Logger(RequestLogInterceptor.name);

  @Inject(HttpService)
  private httpService: HttpService;

  async ipToCity(ip: string) {
    const response = await this.httpService.axiosRef(`https://whois.pconline.com.cn/ipJson.jsp?ip=${ip}&json=true`);
    return response.data.addr;
  }

  async intercept(
    context: ExecutionContext,
    next: CallHandler<any>,
  ) {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();

    console.log(await this.ipToCity('221.237.121.165'))

    const userAgent = request.headers['user-agent'];

    const { ip, method, path } = request;

    const clientIp = requestIp.getClientIp(ip) || ip;

    this.logger.debug(
      `${method} ${path} ${clientIp} ${userAgent}: ${
        context.getClass().name
      } ${
        context.getHandler().name
      } invoked...`,
    );

    const now = Date.now();

    return next.handle().pipe(
      tap((res) => {
        this.logger.debug(
          `${method} ${path} ${clientIp} ${userAgent}: ${response.statusCode}: ${Date.now() - now}ms`,
        );
        this.logger.debug(`Response: ${JSON.stringify(res)}`);
      }),
    );
  }
}
```

直接用 httpService 的方法是被包装过后的，返回值是 rxjs 的 Observable，需要用 firstValueFrom 的操作符转为 promise：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1318b2218ed1490bb70eba60cdb5c4b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=684&h=340&s=68534&e=png&b=1f1f1f)

如果想用原生 axios 对象，可以直接调用 this.httpService.axiosRef.xxx，这样返回的就是 promise。

可以看到，返回的数据是没问题的，但是字符集不对：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/452e3160cf424122acb376a6ec8632ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1336&h=542&s=206185&e=png&b=181818)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a250d8b5dced478caf5793901c2b4f28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1682&h=238&s=81039&e=png&b=fefefe)

接口返回的字符集是 gbk，而我们用的是 utf-8，所以需要转换一下。

用 iconv-lite 这个包：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b78b63df13a4bc4b9b2072c3b0495f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1908&h=738&s=204367&e=png&b=fefefe)

它就是用来转换字符集的。

```
npm install --save iconv
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c20abf9572984107bcec15fa1d155ef6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1230&h=894&s=211648&e=png&b=1f1f1f)

指定 responseType 为 arraybuffer，也就是二进制的数组，然后用 gbk 的字符集来解码。

```javascript
async ipToCity(ip: string) {
    const response = await this.httpService.axiosRef(`https://whois.pconline.com.cn/ipJson.jsp?ip=${ip}&json=true`, {
      responseType: 'arraybuffer',
      transformResponse: [
        function (data) {
          const str = iconv.decode(data, 'gbk');
          return JSON.parse(str);
        }
      ]
    });
    return response.data.addr;
}
```
现在，就能拿到 utf-8 编码的城市信息了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dc8cbf610d94894af4f72d68dfe0301~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=992&h=546&s=165628&e=png&b=181818)

当然，这个不建议放到请求日志里，不然每次请求都调用一次接口太浪费性能了。

登录日志里可以加这个。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4391f262b3c415290213c78d3b8180a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954&h=488&s=56088&e=png&b=ffffff)

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/request-log)

## 总结

我们通过 interceptor 实现了记录请求日志的功能。

其中 ip 地址如果被 nginx 转发过，需要取 X-Forwarded-For 的 header 的值，我们直接用 request-ip 这个包来做。

如果想拿到 ip 对应的城市信息，可以用一些免费接口来查询，用 @nestjs/axios 来发送请求。当然，这个不建议放到请求日志里。

这样，就可以记录下每次请求响应的信息了。



## 87.短链服务？自己写一个

生活中我们经常遇到需要短链的场景。

比如一段很长的 url：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b211ab9d9194da4b27229d748887f37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1860\&h=728\&s=121533\&e=png\&b=fefefd)

分享出去很不方便。

这时候就可以通过短链服务把它缩短：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c8ee9fe6b45486abfc51ec56cc316f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=472\&h=206\&s=24455\&e=png\&b=ffffff)

点击短链会跳转到原链接：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a54d225d10244a7ba595587615c332c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1434\&h=1186\&s=348521\&e=gif\&f=32\&b=fdfcfc)

这种在短信里很常见：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ebede01abb6454c9d8dd8e86d0a3f4c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=614\&h=518\&s=93209\&e=png\&b=fbfbfb)

因为短信是按照字数收费的，太长不但阅读体验不好，费用也高。

所以都会生成短链之后再加到短信里。

那短链是怎么实现的呢？

很容易想到的思路是这样的：

用 0、1、2、3、4、5 的递增 id 标识每个 url，把映射关系存到数据库里。

这样访问短链的时候从数据库中查出对应的长链接，返回 302 重定向即可。

比如刚才的短链服务就是通过 302 把短链重定向到长链：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f4c1a9fe2264f188cd15a7e2446a284~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1250\&h=684\&s=166016\&e=png\&b=ffffff)

这里也可以用 301。

301 是永久重定向，就是重定向一次之后，下次浏览器就不会再访问短链，会直接访问长链接。

302 是临时重定向，下次访问短链依然会先访问短链服务，返回 302 后再重定向到长链。

这两种都可以，301 的话，短链服务压力小，不过 302 每次都会先访问短链服务，这样可以记录链接的访问次数等数据。

比如刚才我们用的短链服务，就会记录这个链接的访问记录：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc20b10406b4b8d80dea639ae26f41a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1614\&h=996\&s=250165\&e=png\&b=ffffff)

还可以做一些分析：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b130d898281c433ea842c998ac33d6d4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1612\&h=1260\&s=145072\&e=png\&b=ffffff)

所以访问记录也挺有价值的。

一般短链服务都是用 302 来重定向。

每个 url 的 id 我们会用 Base64 或者 Base62 编码：

```javascript
const data = '123456';
const buff = Buffer.from(data);
const base64data = buff.toString('base64');

console.log(base64data);
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad074557e15149ad83efe154589dd3fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=772\&h=410\&s=67101\&e=png\&b=1d1d1d)

base64 就是 26 个大写字母、26 个小写字母、10 个数字、2 个特殊字符，一共 64 个字符。

而 base62 则是去掉了两个特殊字符，一共 62 个字符。

做短链的话，我们用 base62 比较多。

安装用到的包：

    npm install base62

测试下：

```javascript
const base62 = require("base62/lib/ascii");
 
const res = base62.encode(123456);

console.log(res);
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65197cdf1fe24f0f9874888b1ae37743~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750\&h=404\&s=58088\&e=png\&b=1d1d1d)

按照这个思路，我们就能实现一个短链服务。

在 mysql 里创建压缩码和长链接的对应关系的表，用 mysql 的自增 id 然后进行 base62 之后作为压缩码。

访问短链的时候，根据压缩码查询这个表，找到长链接，通过 302 重定向到这个链接，并且记录短链访问记录。

这样是可以的，但有个问题：

用自增 id 作为压缩码，那别人很容易拿到上一个、下一个压缩码，从而拿到别的短链，万一这个短链是用来兑奖之类的呢？

这样就会有安全问题。

所以自增 id 的方案不太好。

那如果我们对 url 做 hash 呢？

也就是这样：

```javascript
const crypto = require('crypto');

function md5(str) {
  const hash = crypto.createHash('md5');
  hash.update(str);
  return hash.digest('hex');
}

console.log(md5('111222'))
```

这样太长了，有 32 位呢：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8d55e7164974d728ad423980824c54d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=782\&h=594\&s=83106\&e=png\&b=1d1d1d)

倒是可以每 4 位取一个数字，然后组成一个 8 位的压缩码。

但是，这样是有碰撞的可能的。

也就是两个不同的 url 生成的压缩码一样。

所以，hash 的方案也不行。

还有一种方案，就是通过随机数的方式生成压缩码。

比如这样：

```javascript
const base62 = require("base62/lib/ascii");

function generateRandomStr(len) {
    let str = '';
    for(let i = 0; i < len; i++) {
        const num = Math.floor(Math.random() * 62);
        str += base62.encode(num);
    }
    return str;
}

console.log(generateRandomStr(6));
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e97d5a2f11e4f85b77423947f902612~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1014\&h=764\&s=108967\&e=png\&b=1e1e1e)

随机生成 0-61 的数字，然后转成字符。

62 的 6 次方，范围有 580 亿，足够用了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7d111efa99543fd8ee622b60b7d9fc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=282\&h=76\&s=11475\&e=png\&b=010101)

当然，随机数也是有碰撞的可能的，这个可以在生成之后查下表，看下是否有重复的，有的话就再重新生成。

不过每次生成都查表的话性能会不好，那有啥优化的方案呢？

我们可以提前生成一批压缩码，用的时候直接取！

可以用个定时任务来跑，每天凌晨 4 点生成一批。

这样，生成压缩码的方案就完美了。

小结下：

**用递增 id + base62 作为压缩码，可以保证唯一，但是容易被人拿到其它短码，不安全。**

**用 url 做 hash 之后取一部分然后 base62 做为压缩码，有碰撞的可能，不唯一。**

**随机生成字符串再查表检测是否重复，可以保证唯一且不连续，但是性能不好。用提前批量生成的方式可以解决。**

有的同学可能提到 uuid、雪花 id 之类的，那些都太长了，不适合用来做压缩码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4841cfd7b0f445f2a84a91168b981736~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1114\&h=484\&s=58331\&e=png\&b=fbfbfb)

思路理清了，我们来写下代码。

创建个 nest 项目：

    npm install -g @nestjs/cli

    nest new short-url

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7318eaabf8d24b2fac6e3ab73604e9b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=816\&h=676\&s=151088\&e=png\&b=010101)

先进入项目，把它跑起来：

    npm run start:dev

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0596b21b198d409391310a3556b316bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1560\&h=384\&s=120650\&e=png\&b=181818)

浏览器看到 hello world，代表 nest 服务跑成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7516bcdad3b4c92aa4a869023d406ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=542\&h=192\&s=16437\&e=png\&b=ffffff)

然后我们用 docker 把 mysql 跑起来：

从 docker 官网下载 docker desktop，这个是 docker 的桌面端：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d7da48155df448698ae5fc57072fe0b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2380\&h=1336\&s=459767\&e=png\&b=ffffff)

跑起来后，搜索 mysql 镜像（这步需要科学上网），点击 run：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/659eaef5c4b8445a8c7224981515c1fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2368\&h=1460\&s=326395\&e=png\&b=7a7a7b)

输入容器名、端口映射、以及挂载的数据卷，还要指定一个环境变量：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33961dc3a8cd4d9c805c2ff096a1caf9~tplv-k3u1fbpfcp-watermark.image#?w=1332\&h=1428\&s=187941\&e=png\&b=ffffff)

端口映射就是把宿主机的 3306 端口映射到容器里的 3306 端口，这样就可以在宿主机访问了。

数据卷挂载就是把宿主机的某个目录映射到容器里的 /var/lib/mysql 目录，这样数据是保存在本地的，不会丢失。

而 MYSQL\_ROOT\_PASSWORD 的密码则是 mysql 连接时候的密码。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7db618f4e4b4ca3b0b44752450d4322~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2232\&h=1326\&s=496885\&e=png\&b=ffffff)

跑起来后，我们用 GUI 客户端连上，这里我们用的是 mysql workbench，这是 mysql 官方提供的免费客户端：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1311f9991e248de8a9cdd92c9b72a15~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=270\&h=270\&s=40789\&e=png\&b=9b5801)

连接上之后，点击创建 database：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cfd92779aee4f71b99725a18b93a535~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518\&h=1160\&s=348762\&e=png\&b=e7e5e5)

指定名字、字符集为 utf8mb4，然后点击右下角的 apply。

创建成功之后在左侧就可以看到这个 database 了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a200f9e98604ddc9658937629ac1e11~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=436\&h=260\&s=35737\&e=png\&b=e8e4e1)

当然，现在还没有表。

我们在 Nest 里用 TypeORM 连接 mysql。

安装用到的包：

    npm install --save @nestjs/typeorm typeorm mysql2

mysql2 是数据库驱动，typeorm 是我们用的 orm 框架，而 @nestjs/tyeporm 是 nest 集成 typeorm 用的。

在 AppModule 里引入 TypeORM，指定数据库连接配置：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee1a89260b3442a3a68ed58c8130d1ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=946\&h=1040\&s=190094\&e=png\&b=1f1f1f)

```javascript
TypeOrmModule.forRoot({
  type: "mysql",
  host: "localhost",
  port: 3306,
  username: "root",
  password: "guang",
  database: "short-url",
  synchronize: true,
  logging: true,
  entities: [],
  poolSize: 10,
  connectorPackage: 'mysql2',
  extra: {
      authPlugin: 'sha256_password',
  }
}),
```

然后创建个 entity：

src/entities/UniqueCode.ts

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class UniqueCode {
    
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 10,
        comment: '压缩码'
    })
    code: string;

    @Column({
        comment: '状态, 0 未使用、1 已使用'
    })
    status: number;
}
```

在 AppModule 引入：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0183c2033b7c4d4397f3307b78bb3c08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920\&h=878\&s=146919\&e=png\&b=1f1f1f)

保存之后，TypeORM会自动建表:

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9817210634084bfb80e846ea41f918df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1612\&h=544\&s=211591\&e=png\&b=181818)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5eaef96c96e46eb9be7923d33d0acc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1442\&h=880\&s=267100\&e=png\&b=f2f0ef)

表创建好了，接下来插入一些数据：

    nest g service unique-code --flat --no-spec

生成 service 类，--flat 是不生成目录 --no-spec 是不生成测试代码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35ab3bc3701e4e5b97a94e0d50e734d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=748\&h=108\&s=28990\&e=png\&b=191919)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb3e81ed1fe54146850a53fa5e18ef6e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1306\&h=548\&s=104348\&e=png\&b=1d1d1d)

然后创建 src/utils.ts 来放生成随机压缩码的代码：

```javascript
import * as  base62 from "base62/lib/ascii";

export function generateRandomStr(len: number) {
    let str = '';
    for(let i = 0; i < len; i++) {
        const num = Math.floor(Math.random() * 62);
        str += base62.encode(num);
    }
    return str;
}
```

安装用到的包：

    npm install base62

然后在 UniqueCodeService 添加下插入压缩码的方法：

```javascript
import { Injectable } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { EntityManager } from 'typeorm';
import { generateRandomStr } from './utils';
import { UniqueCode } from './entities/UniqueCode';

@Injectable()
export class UniqueCodeService {

    @InjectEntityManager()
    private entityManager: EntityManager;
 
    async generateCode() {
        let str = generateRandomStr(6);

        const uniqueCode = await this.entityManager.findOneBy(UniqueCode, {
            code: str
        });

        if(!uniqueCode) {
            const code = new UniqueCode();
            code.code = str;
            code.status = 0;

            return await this.entityManager.insert(UniqueCode, code);
        } else {
            return this.generateCode();
        }
    }
}
```

就是生成随机的长度为 6 的字符串，查下数据库，如果没查到，就插入数据，否则重新生成。

我们用定时任务的方式来跑：

安装用到的包：

```javascript
npm install --save @nestjs/schedule
```

在 AppModule 注册下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cfc7780489a435aae708fe76b93e641~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=940\&h=414\&s=90143\&e=png\&b=1f1f1f)

然后在 service 方法上声明，每 5s 执行一次：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71e1bb13a4fc455a90d30b09a39d1cb1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158\&h=938\&s=180151\&e=png\&b=1f1f1f)

```javascript
@Cron(CronExpression.EVERY_5_SECONDS)
```

然后就可以看到一直在打印 insert 语句：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da207a4a676a4005af78881ff76c3732~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1618\&h=914\&s=301288\&e=png\&b=191919)

数据库中也可以看到插入的未使用的压缩码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b6a242a31f940c1bde4533b045a59c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1392\&h=1096\&s=445337\&e=png\&b=efedec)

当然，一个个这么插入可太费劲了。

我们一般是在凌晨 4 点左右批量插入一堆，比如一次性插入 10000 个。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/875589c996c64ab48385ee5d68bb1806~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1084\&h=546\&s=94044\&e=png\&b=1f1f1f)

```javascript
@Cron(CronExpression.EVERY_DAY_AT_4AM)
async batchGenerateCode() {
    for(let i = 0; i< 10000; i++) {
        this.generateCode();
    }
}
```

这里我们是每次 insert 一个，你也可以每次 insert 10 个 20 个这种。

批量插入性能会好，因为执行的 sql 语句少。这里我们就先不优化了。

压缩码有了，接下来生成 url 和压缩码的对应关系就好了。

同样需要创建 entity：

src/entities/ShortLongMap.ts

```javascript
import { Column, CreateDateColumn, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class ShortLongMap {
    
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 10,
        comment: '压缩码'
    })
    shortUrl: string;

    @Column({
        length: 200,
        comment: '原始 url'
    })
    longUrl: string;

    @CreateDateColumn()
    createTime: Date;
}
```

在 entities 引入：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a920928075b4de5aded211e597d48a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1038\&h=978\&s=196034\&e=png\&b=1f1f1f)

同样会自动建表：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4198170d0a3e42f199f728d57eb5da43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1668\&h=580\&s=191393\&e=png\&b=181818)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/671860b8ec504dccbb4493ddb596623a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1126\&h=748\&s=248818\&e=png\&b=eae7e6)

生成短链就是往这个表里添加记录。

我们加一个生成短链的 service：

    nest g service short-long-map --flat --no-spec

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ae4fab0939440dfafeb794a91a32ced~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=812\&h=102\&s=27748\&e=png\&b=191919)

实现生成短链的方法：

```javascript
import { UniqueCodeService } from './unique-code.service';
import { Inject, Injectable } from '@nestjs/common';
import { InjectEntityManager } from '@nestjs/typeorm';
import { EntityManager } from 'typeorm';
import { ShortLongMap } from './entities/ShortLongMap';
import { UniqueCode } from './entities/UniqueCode';

@Injectable()
export class ShortLongMapService {

    @InjectEntityManager()
    private entityManager: EntityManager;

    @Inject(UniqueCodeService)
    private uniqueCodeService: UniqueCodeService;

    async generate(longUrl: string) {
        let uniqueCode = await this.entityManager.findOneBy(UniqueCode, {
            status: 0
        })

        if(!uniqueCode) {
            uniqueCode = await this.uniqueCodeService.generateCode();
        }
        const map = new ShortLongMap();
        map.shortUrl = uniqueCode.code;
        map.longUrl = longUrl;
  
        await this.entityManager.insert(ShortLongMap, map);
        await this.entityManager.update(UniqueCode, {
            id: uniqueCode.id
        }, {
            status: 1
        });
        return uniqueCode.code;
    }

}
```

这里就是先从 unique-code 表里取一个压缩码来用，如果没有可用压缩码，那就生成一个。

然后在 short-long-map 表里插入这条新的短链映射，并且把用到的压缩码状态改为 1。

我们在 AppController 里添加一个接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88737ff560954cfe8c4801404b0b160f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1118\&h=826\&s=182772\&e=png\&b=1f1f1f)

```javascript
import { ShortLongMapService } from './short-long-map.service';
import { Controller, Get, Inject, Query } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject(ShortLongMapService)
  private shortLongMapService: ShortLongMapService;

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('short-url')
  async generateShortUrl(@Query('url') longUrl) {
    return this.shortLongMapService.generate(longUrl);
  }
}
```

在浏览器里测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a795016948b4ce5ac2fdaec9b0bed09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1040\&h=174\&s=25149\&e=png\&b=ffffff)

可以看到，打印了 4 条 sql：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2907562f1b34d5eac682666c9fc961d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1426\&h=326\&s=135238\&e=png\&b=191919)

首先 select 查出一个压缩码来，然后 insert 插入压缩码和 url 的映射，之后再把它 select 出来返回。

最后 update 更新压缩码状态。

看 sql 来说，是符合我们的预期的。

然后看下数据：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ccf2ff4102a46de9c8c85206bba2d4d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082\&h=536\&s=138164\&e=png\&b=f9f9f9)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6bb96e45d64327852089d80aef6e7e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=902\&h=500\&s=130541\&e=png\&b=f7f6f6)

也是对的。

那剩下的事情就很简单了，只要加一个重定向就好：

首先在 service 里添加根据压缩码查询 longUrl 的方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae97470f965e429b9f63b3edec11add5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1210\&h=820\&s=168798\&e=png\&b=1f1f1f)

```javascript
async getLongUrl(code: string) {
    const map = await this.entityManager.findOneBy(ShortLongMap, {
        shortUrl: code
    });
    if(!map) {
        return null;
    }
    return map.longUrl;
}
```

然后在 AppController 里添加一个重定向的接口：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/151d37cb5113428b8263395cd58505bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158\&h=834\&s=164197\&e=png\&b=202020)

```javascript
@Get(':code')
@Redirect()
async jump(@Param('code') code) {
    const longUrl = await this.shortLongMapService.getLongUrl(code);
    if(!longUrl) {
      throw new BadRequestException('短链不存在');
    }
    return {
      url: longUrl,
      statusCode: 302
    }  
}
```

测试下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4b745c87af14532b2e22f4104ad60b5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=604\&h=312\&s=32840\&e=png\&b=ffffff)

![2023-12-01 14.32.03.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c7ea3fb7f214727bc86cd095e57252e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1678\&h=978\&s=142119\&e=gif\&f=27\&b=fefefe)

这样，我们的短链服务就完成了。

其他的非核心功能，比如记录每次访问记录，做一些分析：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39233680e07d4b9faf8e782a6cb2dc41~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1614\&h=996\&s=232597\&e=png\&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67fbebff65a94dd89612e8b89bafeb7a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1612\&h=1260\&s=135792\&e=png\&b=ffffff)

这些比较简单，就不实现了。

案例代码上传了 github： <https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/short-url>

## 总结

我们经常用短链服务把长的 url 缩短，在短信里的链接一般都是这种。

我们用 Nest 自己实现了一个。

核心是压缩码的生成，我们分析了自增 id + base62，这样容易被人拿到其它短链，不安全。hash + base62 会有冲突的可能，所以最终用的是自己生成随机数 + base62 的方案。

当然，这个随机字符串最好是提前生成，比如用定时任务在低峰期批量生成一堆，之后直接用就好了。

短链的重定向使用 302 临时重定向，这样可以记录短链访问记录，做一些分析。

市面上的短链服务，基本都是这样实现的。


## 88.Nest 实现 Server Sent Event 数据推送

提到推送数据，大家可能会首先想到 WebSocket。

确实，WebSocket 能双向通信，自然也能做服务器到浏览器的消息推送。

但如果只是单向推送消息的话，HTTP 就有这种功能，它就是 Server Sent Event。

WebSocket 的通信过程是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d77dfe73e74d4fac89f8747266c01cd1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1260&h=810&e=png&b=ffffff)

首先通过 http 切换协议，服务端返回 101 的状态码后，就代表协议切换成功。

之后就是 WebSocket 格式数据的通信了，一方可以随时向另一方推送消息。

而 HTTP 的 Server Sent Event 是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d99ee4d7ad0471db06cb16280001d77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1294&h=832&e=png&b=ffffff)

服务端返回的 Content-Type 是 text/event-stream，这是一个流，可以多次返回内容。

Sever Sent Event 就是通过这种消息来随时推送数据。

可能你是第一次听说 SSE，但你肯定用过基于它的应用。

比如你用的 CICD 平台，它的日志是实时打印的。

那它是如何实时传输构建日志的呢？

明显需要一段一段的传输，这种一般就是用 SSE 来推送数据。

再比如说 ChatGPT，它回答一个问题不是一次性给你全部的，而是一部分一部分的加载回答。

这也是基于 SSE。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/008f737072b3484ea1362a14139c49f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2156&h=1232&e=gif&f=45&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dea4c6489fa45e0905ddc5d16551daa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894&h=598&e=png&b=ffffff)

知道了什么是 SSE 以及它的应用，我们来自己实现一下吧：

创建 nest 项目：

```
nest new sse-test
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adde2c230c76422495a89e8d98d11ab6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=804&h=686&e=png&b=010101)

把它跑起来：

```
npm run start:dev
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca328c8232d04975bc43366c6fae6d14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1900&h=452&e=png&b=181818)

访问 http://localhost:3000 可以看到 hello world，代表服务器跑成功了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53b674db7798413193a4c69560368a95~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=604&h=186&e=png&b=ffffff)

然后在 AppController 添加一个 stream 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34eabde3dd8f48aaa2448dd0d5ebef6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=1122&e=png&b=1f1f1f)

这里不是通过  @Get、@Post 等装饰器标识，而是通过 @Sse 标识这是一个 event stream 类型的接口。

```javascript
@Sse('stream')
stream() {
    return new Observable((observer) => {
      observer.next({ data: { msg: 'aaa'} });

      setTimeout(() => {
        observer.next({ data: { msg: 'bbb'} });
      }, 2000);

      setTimeout(() => {
        observer.next({ data: { msg: 'ccc'} });
      }, 5000);
    });
}
```
返回的是一个 Observable 对象，然后内部用 observer.next 返回消息。

可以返回任意的 json 数据。

我们先返回了一个 aaa、过了 2s 返回了 bbb，过了 5s 返回了 ccc。

然后写个前端页面：

创建一个 react 项目：

```
npx create-react-app --template=typescript sse-test-frontend
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e01a275e8994ecc9da577af5aa80db7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1092&h=244&e=png&b=010101)

在 App.tsx 里写如下代码：

```javascript
import { useEffect } from 'react';

function App() {

  useEffect(() => {
    const eventSource = new EventSource('http://localhost:3000/stream');
    eventSource.onmessage = ({ data }) => {
      console.log('New message', JSON.parse(data));
    };
  }, []);

  return (
    <div>hello</div>
  );
}

export default App;
```

这个 EventSource 是浏览器原生 api，就是用来获取 sse 接口的响应的，它会把每次消息传入 onmessage 的回调函数。

我们在 nest 服务开启跨域支持：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66d522b6a18944f09ebb9a6755588199~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&h=504&e=png&b=1f1f1f)

然后把 react 项目 index.tsx 里这几行代码删掉，它会导致额外的渲染：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b495ad20d295425888b3759d2238d929~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=846&h=456&e=png&b=1f1f1f)

执行 npm run start

因为 3000 端口被占用了，它会跑在 3001：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c25c8cf6f05241bf8a02f695e022f442~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=966&h=434&e=png&b=181818)

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce8133bed60e490dba2fba6c99943358~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=986&h=842&e=gif&f=37&b=fefefe)

看到一段段的响应了没？

这就是 Server Sent Event。

在 devtools 里可以看到，响应的 Content-Type 是 text/event-stream：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caacaaed946a4ca9b744ccfb7564d629~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1442&h=622&e=png&b=ffffff)

然后在 EventStream 里可以看到每一次收到的消息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42356050a93842ce81ea68d16d9b79f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=336&e=png&b=ffffff)

这样，服务端就可以随时向网页推送消息了。

那它兼容性怎么样呢？

可以在 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/EventSource#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7) 看到：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738fa0f21305432bbec7f5e9d51d5064~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=538&e=png&b=fcfcfc)

除了 ie、edge 外，其他浏览器都没任何兼容问题。

基本是可以放心用的。

那用在哪呢？

一些只需要服务端推送的场景就特别适合 Server Sent Event。

比如这个站内信：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc91875b11784430af4e49df01b4e990~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1390&h=1088&e=png&b=ffffff)

这种推送用 WebSocket 就没必要了，可以用 SSE 来做。

那连接断了怎么办呢？

不用担心，浏览器会自动重连。

这点和 WebSocket 不同，WebSocket 如果断开之后是需要手动重连的，而 SSE 不用。

再比如说日志的实时推送。

我们来测试下：

tail -f 命令可以实时看到文件的最新内容：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981b74e7c9474732867d32ad8b9f5992~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1284&h=1180&e=gif&f=46&b=1b1b1b)

我们通过 child_process 模块的 exec 来执行这个命令，然后监听它的 stdout 输出：

```javascript
const { exec } = require("child_process");

const childProcess = exec('tail -f ./log');

childProcess.stdout.on('data', (msg) => {
    console.log(msg);
});
```
用 node 执行它：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89d57f5c4c8a43b6a0020c07cc8df196~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1040&h=1018&e=gif&f=31&b=1d1d1d)

然后添加一个 sse 的接口：

```javascript
@Sse('stream2')
stream2() {
const childProcess = exec('tail -f ./log');

return new Observable((observer) => {
  childProcess.stdout.on('data', (msg) => {
    observer.next({ data: { msg: msg.toString() }});
  })
});
```
监听到新的数据之后，把它返回给浏览器。

浏览器连接这个新接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23ba4a4421ce4324956053feb043be08~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1470&h=720&e=png&b=1f1f1f)

测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c46cf62c6194fc28f614337bcbe6b81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1752&h=934&e=gif&f=38&b=1d1d1d)

可以看到，浏览器收到了实时的日志。

很多构建日志都是通过 SSE 的方式实时推送的。

日志之类的只是文本，那如果是二进制数据呢？

二进制数据在 node 里是通过 Buffer 存储的。

```javascript
const { readFileSync } = require("fs");

const buffer = readFileSync('./package.json');

console.log(buffer);
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e01065105a604bc38582258f51db45b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1208&h=176&e=png&b=181818)

而 Buffer 有个 toJSON 方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e87134d7364b4b2f9a84f850bf0eae84~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1120&h=1048&e=png&b=1b1b1b)

这样不就可以通过 sse 的接口返回了么？

试一下：

```javascript
@Sse('stream3')
stream3() {
    return new Observable((observer) => {
        const json = readFileSync('./package.json').toJSON();
        observer.next({ data: { msg: json }});
    });
}
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ace2ca2874ec4161ac09ca557a5f6d96~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1454&h=758&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dd21acf5d4a42a4b16b1e9142f72add~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1058&h=1404&e=png&b=ffffff)

确实可以。

也就是说，基于 sse，除了可以推送文本外，还可以推送任意二进制数据。

案例代码上传了小册仓库：

[后端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/sse-test)

[前端代码](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/sse-test-frontend)

## 总结

服务端实时推送数据，除了用 WebSocket 外，还可以用 HTTP 的 Server Sent Event。

只要 http 返回 Content-Type 为 text/event-stream 的 header，就可以通过 stream 的方式多次返回消息了。

它传输的是 json 格式的内容，可以用来传输文本或者二进制内容。

我们通过 Nest 实现了 sse 的接口，用 @Sse 装饰器标识方法，然后返回 Observe 对象就可以了。内部可以通过 observer.next 随时返回数据。

前端使用 EventSource 的 onmessage 来接收消息。

这个 api 的兼容性很好，除了 ie 外可以放心的用。

它的应用场景有很多，比如站内信、构建日志实时展示、chatgpt 的消息返回等。

再遇到需要消息推送的场景，不要直接 WebSocket 了，也许 Server Sent Event 更合适呢？


## 89.用 minio 自己搭一个 OSS 服务

文件上传是常见需求，一般我们不会直接把文件保存在服务器的某个目录下，因为服务器的存储容量是有限的，这样不好扩展。

我们会用 OSS （Object Storage Service）对象存储服务来存文件，它是支持分布式扩展的，不用担心存储容量问题，而且也好管理。

比如阿里云的 OSS 服务。

但是有一些业务场景下，数据需要保密，要求私有部署，也就是要在自己的机房里部署一套 OSS 服务。

这时候怎么办呢？

这种需求一般我们会用 minio 来做。

它可以实现和阿里云 OSS 一样的功能。

首先，我们用一下阿里云的 OSS 服务。

OSS 里的文件是放在一个个 Bucekt（桶）里的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e160417af6d64029bf13473977bfbf36~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1060&h=508&s=102325&e=png&b=fffefe)

我们创建个 Bucket：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f1fa488ca024ca18f1a23e0e52702a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1708&h=1236&s=278242&e=png&b=fefcfc)

然后进入文件列表，就可以上传文件了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70d09ee8647e4988b73880df71eea219~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1848&h=698&s=149099&e=png&b=fefefe)

因为创建的 Bucket 设置了公共读，所以可以直接访问：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3996562ab54441ab8f40a790e3e8b8c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2310&h=1254&s=758784&e=png&b=8c8c8c)

此外，阿里云 OSS 还可以通过 SDK 来上传文件。

创建个项目：

```
mkdir minio-test
cd minio-test
npm init -y
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d96eb2559ac46fbb02e017835018567~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=822&h=614&s=116276&e=png&b=010101)

进入项目，安装 ali-oss：

```
npm install ali-oss
```

创建 index.js

```javascript
const OSS = require('ali-oss')

const client = new OSS({
    region: 'oss-cn-beijing',
    bucket: 'guang-666',
    accessKeyId: '',
    accessKeySecret: '',
});

async function put () {
  try {
    const result = await client.put('smile.png', './smile.png');
    console.log(result);
  } catch (e) {
    console.log(e);
  }
}

put();
```
填入 region、bucket 和 accessKeyId、accessKeySecret

这里的 region 可以从概览里看到：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd75de8c0c574468b00a9ea7877944b5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1686&h=928&s=225918&e=png&b=fefefe)

acessKey 是在这里看：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41cd70bb22d7421a95cc00ccc7bfcac2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=708&h=686&s=67637&e=png&b=fefefe)

具体创建 accessKey 的流程看[之前 OSS 那节](https://juejin.cn/book/7226988578700525605/section/7324620995183968293)

然后跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c05b7e4930049d2b0fca2201acba67a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1048&h=962&s=176487&e=png&b=1b1b1b)

上传成功之后就可以通过 OSS 服务访问这个图片了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc4f029f4e8d4d9db4c4dd3650f28065~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2344&h=1270&s=797467&e=png&b=8c8c8c)

也可以通过 sdk 下载图片：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03d670392ddb403abd3534360658520c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=818&h=424&s=44036&e=png&b=1f1f1f)

执行后可以看到，图片被下载下来了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a3a7cd455974839b431c4793c58cd41~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1124&h=612&s=95408&e=png&b=1c1c1c)

这就是阿里云 OSS 的用法。

那我们用 minio 自己搭呢？

首先，我们需要安装 [docker 桌面端](https://www.docker.com/)：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/260fc42611fd4f6aa84a0356286d79f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2040&h=1270&s=210506&e=png&b=ffffff)

打开后可以看到本地的所有镜像和容器：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4edf8c78c292448db124d132ca79d76f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2096&h=968&s=266517&e=png&b=f7f7f8)

搜索下 minio（这步需要科学上网）：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1451e7ef59b7432892ccefa417b67500~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1998&h=1274&s=258702&e=png&b=f2f3f7)

填入一些信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87eb9a405bae4470834b2bb29899053d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=1470&s=230560&e=png&b=ffffff)

name 是容器名。

port 是映射本地 9000 和 9001 端口到容器内的端口。

volume 是挂载本地目录到容器内的目录

这里挂载了一个本地一个目录到容器内的数据目录 /bitnami/minio/data，这样容器里的各种数据都保存在本地了。

还要指定两个环境变量，MINIO_ROOT_USER 和 MINIO_ROOT_PASSWORD，是用来登录的。

点击 run，跑起来之后可以看到数据目录被标记为 mounted，端口也映射成功了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c94439277d9149869b9d343214538fe0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1342&h=1022&s=107797&e=png&b=f8f8f9)

访问下 http://localhost:9001

输入刚才环境变量填的用户名密码：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baef7edbd8174f53a508dec6ec4a1c2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2578&h=1022&s=779261&e=png&b=ffffff)

进入管理界面：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/590cd0c074844e329ca296ed890e3252~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1930&h=1332&s=653275&e=png&b=fefefe)

这个 bucket 就是管理桶的地方，而 object browser 就是管理文件列表的地方。

和阿里云 OSS 用法一样。

我们创建个 bucket：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d485eaf6eaa14d3aa225ea84d3463be7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1520&h=1016&s=94712&e=png&b=ffffff)

然后在这个 bucket 下上传一个文件：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7a8f077b04d4b8b98bc85067b50b737~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2338&h=1116&s=596635&e=png&b=fdfdfd)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6363048236144ab691f4ff2d9c3e3203~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1988&h=900&s=145669&e=png&b=fdfdfd)

点击 share 就可以看到这个文件的 url：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/427ac302512a4d7aa94aeba2188c70fc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1854&h=808&s=119246&e=png&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9573aaa5a6914711b600ff66c0447fdd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1766&h=1032&s=242268&e=png&b=ececec)

现在倒是能在浏览器访问，只不过需要带后面的一长串东西：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42a7bc7b89e47308fb5b21725943b70~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2158&h=1206&s=669084&e=png&b=0202f3)

不带的话会提示拒绝访问：


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4378e11261914c19afe147791c2f9b66~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1472&h=288&s=47877&e=png&b=ffffff)

因为现在文件访问权限不是公开的。

我们设置下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc0f1990162d401dafa60444b84f38a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2258&h=966&s=483874&e=png&b=fdfdfd)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76ffdce9aa904d4fac72b01abdf36392~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1750&h=766&s=172612&e=png&b=e9e9e9)

添加一个 / 的匿名的访问规则。

然后就可以直接访问了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b76d7716ddb45ffa10a94d4fbb4ef53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1950&h=980&s=468443&e=png&b=0202f3)

是不是感觉用起来和阿里云的 OSS 差不多？

我们再来试试 sdk 的方式：

```
npm install minio
```
安装 minio 包。

然后创建 index2.js

```javascript
var Minio = require('minio')

var minioClient = new Minio.Client({
  endPoint: 'localhost',
  port: 9000,
  useSSL: false,
  accessKey: '',
  secretKey: '',
})

function put() {
    minioClient.fPutObject('aaa', 'hello.png', './smile.png', function (err, etag) {
        if (err) return console.log(err)
        console.log('上传成功');
    });
}

put();
```

创建用到的 accessKey：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7912ac2bae84a7c8e185b0c2876195f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2178&h=998&s=528632&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa7c4a1e52f5470da5d7978595f954b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1734&h=890&s=338812&e=png&b=f4f4f4)

跑一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfb07408e94b4f7fb61515f7a103928a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702&h=110&s=18112&e=png&b=191919)

可以看到，文件上传成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9695e5104db45248e2c4f72cafcdf88~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1482&h=708&s=347394&e=png&b=fefefe)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98299e5024b64886a9790926e98e8d39~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1568&h=948&s=364737&e=png&b=0202f3)

同样，也可以下载文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d42133eba37248b18f79b4977600f0bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094&h=486&s=86475&e=png&b=1f1f1f)

```javascript
const fs = require('fs');

function get() {
    minioClient.getObject('aaa', 'hello.png', (err, stream) => {
        if (err) return console.log(err)
        stream.pipe(fs.createWriteStream('./xxx.png'));
    });
}

get();
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d12088c76edd4e6fafcf5bf26e658e85~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1408&h=720&s=126200&e=png&b=1d1d1d)

用起来和阿里云 OSS 几乎一毛一样。

更多的 api 用法可以看 [minio 文档](https://min.io/docs/minio/linux/developers/javascript/minio-javascript.html)。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fb69960a0a4e9c96777068737c08b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1652&h=1194&s=331748&e=png&b=e7eaec)

最后，还记得我们跑 docker 容器的时候指定了挂载目录么：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ad955a69ff846fb8e351c5b2a90ffe0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1342&h=1022&s=100335&e=png&b=f8f8f9)

这样，数据就会保存在本地的那个目录下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3477dab0c0194f57b7eeedf7f2700030~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1386&h=252&s=60541&e=png&b=fbf9f9)

那为什么 OSS 服务都这么相似呢？

因为它们都是遵循 AWS 的 Simple Storage Service（S3）规范的，简称 S3 规范。

所以不管哪家的 OSS，用起来都是差不多的。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/minio-test)。

## 总结

文件上传一般我们都是用 OSS 服务来存储，比如阿里云的 OSS。

但是 OSS 是收费的，而且有些敏感数据不能传到云上，需要私有部署，这种就可以自己搭一个 OSS 服务。

我们用 docker 跑了一个 minio 的容器，然后分别在管理界面和用 npm 包的方式做了文件上传和下载。

用法和阿里云 OSS 差不多，因为他们都是亚马逊 S3 规范的实现。

你公司内部有没有自己用 minio 搭 OSS 服务呢？


## 9.AOP 架构有什么好处？

后端框架基本都是 MVC 的架构。

MVC 是 Model View Controller 的简写。MVC 架构下，请求会先发送给 Controller，由它调度 Model 层的 Service 来完成业务逻辑，然后返回对应的 View。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/580375b654ac445cb2cd07784824104c~tplv-k3u1fbpfcp-watermark.image?)

在这个流程中，Nest 还提供了 AOP （Aspect Oriented Programming）的能力，也就是面向切面编程的能力。

AOP 是什么意思呢？什么是面向切面编程呢？

一个请求过来，可能会经过 Controller（控制器）、Service（服务）、Repository（数据库访问） 的逻辑：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/109025024af543febb44ca2a70ca9f92~tplv-k3u1fbpfcp-watermark.image?)

如果想在这个调用链路里加入一些通用逻辑该怎么加呢？比如日志记录、权限控制、异常处理等。

容易想到的是直接改造 Controller 层代码，加入这段逻辑。

这样可以，但是不优雅，因为这些通用的逻辑侵入到了业务逻辑里面。能不能透明的给这些业务逻辑加上日志、权限等处理呢？

那是不是可以在调用 Controller 之前和之后加入一个执行通用逻辑的阶段呢？

比如这样：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f99087120e847eab901738bf8504d21~tplv-k3u1fbpfcp-watermark.image?)

是不是就和切了一刀一样？

这样的横向扩展点就叫做切面，这种透明的加入一些切面逻辑的编程方式就叫做 AOP （面向切面编程）。

**AOP 的好处是可以把一些通用逻辑分离到切面中，保持业务逻辑的纯粹性，这样切面逻辑可以复用，还可以动态的增删。**

其实 Express 的中间件的洋葱模型也是一种 AOP 的实现，因为你可以透明的在外面包一层，加入一些逻辑，内层感知不到。

而 Nest 实现 AOP 的方式更多，一共有五种，包括 Middleware、Guard、Pipe、Interceptor、ExceptionFilter。

新建个 nest 项目，我们挨个试一下：

```
nest new aop-test
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b73ed377eb44e3f85ff0c818fa37e1a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=908&h=736&s=165169&e=png&b=020202)

### 中间件 Middleware

中间件是 Express 里的概念，Nest 的底层是 Express，所以自然也可以使用中间件，但是做了进一步的细分，分为了全局中间件和路由中间件。

全局中间件就是这样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a40c5a0eb6f842c2b0d340f8b5429e72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=622&s=132458&e=png&b=1f1f1f)

在 main.ts 里通过 app.use 使用：

```javascript
app.use(function(req: Request, res: Response, next: NextFunction) {
    console.log('before', req.url);
    next();
    console.log('after');
})
```

在 AppController 里也加个打印：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e759bd9cbd0940cd89e1edbca857a0d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=812&h=570&s=103057&e=png&b=1f1f1f)

把服务跑起来：

```
npm run start:dev
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b589d298f1474daea4d38925314dd74c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1294&h=396&s=113266&e=png&b=181818)

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c935c5c674ce4705b73c3346d11a7885~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=610&h=224&s=18771&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46864de7f8774585b6aab4f69e80f2bd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=826&h=454&s=89639&e=png&b=181818)

可以看到，在调用 handler 前后，执行了中间件的逻辑。

我们再添加几个路由：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e00869e6c6cf4874bff3e0f909f60131~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=738&h=756&s=101595&e=png&b=1f1f1f)

```javascript
@Get('aaa')
aaa(): string {
    console.log('aaa...');
    return 'aaa';
}

@Get('bbb')
bbb(): string {
    console.log('bbb...');
    return 'bbb';
}
```
然后浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03cc9d2ca4904b1080cc075c2bb46378~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=672&h=214&s=17700&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8becc3e2244141ffaa105500987444af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=650&h=214&s=18422&e=png&b=ffffff)

可以看到，中间件逻辑都执行了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96fa8ab016fc4ea4a26aa864db53ccf3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=682&h=598&s=89854&e=png&b=181818)


也就是说，可以在多个 handler 之间复用中间件的逻辑：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c77913aa1f9f41d6b91c8b17d7a57b9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=766&h=652&s=31772&e=png&b=ffffff)

这种可以给在 handler 前后动态增加一些可复用的逻辑，就是 AOP 的切面编程的思想。

除了全局中间件，Nest 还支持路由中间件。

用 nest cli 创建一个路由中间件：

```
nest g middleware log --no-spec --flat
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bbdcdc042b145439e636a287d861ffe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=88&s=21460&e=png&b=191919)

--no-spec 是不生成测试文件，--flat 是平铺，不生成目录。

生成的代码是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eae334091f4f47088100f3d95628c7ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1044&h=374&s=68220&e=png&b=1f1f1f)

在前后打印下日志：

```javascript
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response } from 'express';

@Injectable()
export class LogMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: () => void) {
    console.log('before2', req.url);

    next();

    console.log('after2');
  }
}

```
然后在 AppModule 里启用：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/453edfc9fefa4d22b68c779dc7124c98~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=926&h=672&s=137172&e=png&b=1f1f1f)

```javascript
import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { LogMiddleware } from './log.middleware';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule implements NestModule{

  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LogMiddleware).forRoutes('aaa*');
  }

}

```

在 configure 方法里配置 LogMiddleware 在哪些路由生效。

然后测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c7525796b084291af2d270951e72101~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=590&h=184&s=16599&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bcd7ba91623481b899249a18ae9c467~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640&h=218&s=18419&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96405113ca3d43289b66d0527ab72dd2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=660&h=628&s=95335&e=png&b=181818)

可以看到，只有 aaa 的路由，中间件生效了。

这就是全局中间件和路由中间件的区别。

### Guard

Guard 是路由守卫的意思，可以用于在调用某个 Controller 之前判断权限，返回 true 或者 false 来决定是否放行：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e9a9eee8aa74881b6789dd753916202~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1008&h=270&s=23833&e=png&b=ffffff)

我们创建个 Guard：

```
nest g guard login --no-spec --flat
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/808e3f3b9907429a9b698079d93ef5d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=660&h=94&s=22514&e=png&b=191919)

生成的 Guard 代码是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12dd5753fcfa428a94e558c85ae7eb82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1106&h=460&s=88330&e=png&b=1f1f1f)

Guard 要实现 CanActivate 接口，实现 canActivate 方法，可以从 context 拿到请求的信息，然后做一些权限验证等处理之后返回 true 或者 false。

我们加个打印语句，然后返回 false：

```javascript
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class LoginGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    console.log('login check')
    return false;
  }
}

```

之后在 AppController 里启用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eed15d31e2f414db9e46e152955f06b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=784&h=674&s=103222&e=png&b=1f1f1f)

然后再访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3716f6a8d834deca1440d10bebe025c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640&h=172&s=17667&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b41674805f44a4582d48493cad54f38~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=644&h=330&s=36399&e=png&b=ffffff)

aaa 没有权限，返回了 403。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da3f4e4198e4cae95355c09d45b8243~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=294&h=320&s=31000&e=png&b=181818)

Controller 本身不需要做啥修改，却透明的加上了权限判断的逻辑，这就是 AOP 架构的好处。

而且，就像 Middleware 支持全局级别和路由级别一样，Guard 也可以全局启用：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36bef5bfec3e4fba9808ba10a9994b2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=678&s=134490zhe&e=png&b=1f1f1f)

这样每个路由都会应用这个 Guard：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/942d0807b56d48dbb6db0bf36230bcac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=324&s=36379&e=png&b=ffffff)

还有一种全局启用的方式，是在 AppModule 里这样声明：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fef40f8b899541838abd76616d545342~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=694&s=127717&e=png&b=202020)

```javascript
{
  provide: APP_GUARD,
  useClass: LoginGuard
}
```
把 main.ts 里的 useGlobalGuards 注释掉：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85fedf11dc22461f8eb7760ccfc081a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=884&h=670&s=132203&e=png&b=1f1f1f)

再试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91145c2d73d343a9aca3acb385002e56~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=700&h=356&s=38399&e=png&b=fefefe)

可以看到，Guard 依然是生效的。

那为什么都是声明全局 Guard，需要有两种方式呢？

因为之前这种方式是手动 new 的 Guard 实例，不在 IoC 容器里：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cc1c76db00d43f4acd0838bbff1d131~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=164&s=23541&e=png&b=1f1f1f)

而用 provider 的方式声明的 Guard 是在 IoC 容器里的，可以注入别的 provider：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97d3ed989e59453d95e6bb2bdf6b55bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=528&h=408&s=41843&e=png&b=1f1f1f)

我们注入下 AppService 试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2404dd9d894813addb09ffc22067fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=994&h=628&s=132018&e=png&b=1f1f1f)

```javascript
@Inject(AppService)
private appService: AppService;
```
浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dae1a24e2dca4f80ac2e312ad89dfc13~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=504&s=85424&e=png&b=191919)

可以看到，注入的 AppService 生效了。

所以，当需要注入别的 provider 的时候，就要用第二种全局 Guard 的声明方式。

### Interceptor

Interceptor 是拦截器的意思，可以在目标 Controller 方法前后加入一些逻辑：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a981ca0f64c4e37be0475d95366a0ef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=246&s=27755&e=png&b=ffffff)

创建个 interceptor：

```
nest g interceptor time --no-spec --flat
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed5ed0360afd47678bc0eae19d1239a1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=86&s=19684&e=png&b=191919)

生成的 interceptor 是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f138dffc595045d594f8b2b0f9ca499d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1256&h=432&s=90354&e=png&b=1f1f1f)

Interceptor 要实现 NestInterceptor 接口，实现 intercept 方法，调用 next.handle() 就会调用目标 Controller，可以在之前和之后加入一些处理逻辑。

Controller 之前之后的处理逻辑可能是异步的。Nest 里通过 rxjs 来组织它们，所以可以使用 rxjs 的各种 operator。

```javascript
import { CallHandler, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Observable, tap } from 'rxjs';

@Injectable()
export class TimeInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {

    const startTime = Date.now();

    return next.handle().pipe(
      tap(() => {
        console.log('time: ', Date.now() - startTime)
      })
    );
  }
}
```

把之前那个 LoginGuard 注掉：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6e85a03911b4bbc84c82285e6b54a72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=914&h=692&s=133600&e=png&b=1f1f1f)

然后启用这个 interceptor：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/749c757354c84c78a35ccd4f08fe3d6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=774&h=450&s=62740&e=png&b=1f1f1f)

跑一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bddd97309b42499cb0195f6bdd80c551~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=802&h=530&s=111292&e=png&b=181818)

可以看到，interceptor 生效了。

有的同学可能会觉得 Interceptor 和 Middleware 差不多，其实是有区别的，主要在于参数的不同。

interceptor 可以拿到调用的 controller 和 handler：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b5b5aff62d9414f980cc287ff3e4520~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1130&h=706&s=134358&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68bb13a8c04e4a1f8d7366fd84da5639~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710&h=558&s=98424&e=png&b=181818)

后面我们会在 controller 和 handler 上加一些 metadata，这种就只有 interceptor或者 guard 里可以取出来，middleware 不行。

Interceptor 支持每个路由单独启用，只作用于某个 handler：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78c08a9c7acd436ab99de78cc2dfbcd8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=536&h=246&s=32411&e=png&b=202020)

也可以在 controller 级别启动，作用于下面的全部 handler：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1d0256ca6244896a450b0e664df18ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=748&h=398&s=92507&e=png&b=202020)

也同样支持全局启用，作用于全部 controller：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/002252e580c347dbb7d67cc36bb4e469~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=886&h=526&s=108431&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/602ab05e55754cd792fefe20c6c0c2f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=756&h=738&s=113524&e=png&b=1f1f1f)

两种全局启用方式的区别和 guard 的一样，就不测试了。

除了路由的权限控制、目标 Controller 之前之后的处理这些都是通用逻辑外，对参数的处理也是一个通用的逻辑，所以 Nest 也抽出了对应的切面，也就是 Pipe：

### Pipe

Pipe 是管道的意思，用来对参数做一些检验和转换：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f8625ebb4f3d457b9d6517a5ce053769~tplv-k3u1fbpfcp-watermark.image?)

用 nest cli 创建个 pipe：
```
nest g pipe validate --no-spec --flat
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a9e8f85ea14ea58da8a71313de7c5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=658&h=82&s=21109&e=png&b=191919)

生成的代码是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a505030f9284555a49e0cd2c17a3f86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=968&h=336&s=64677&e=png&b=1f1f1f)

Pipe 要实现 PipeTransform 接口，实现 transform 方法，里面可以对传入的参数值 value 做参数验证，比如格式、类型是否正确，不正确就抛出异常。也可以做转换，返回转换后的值。

我们实现下：

```javascript
import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from '@nestjs/common';

@Injectable()
export class ValidatePipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {

    if(Number.isNaN(parseInt(value))) {
      throw new BadRequestException(`参数${metadata.data}错误`)
    }

    return typeof value === 'number' ? value * 10 : parseInt(value) * 10;
  }
}
```
这里的 value 就是传入的参数，如果不能转成数字，就返回参数错误，否则乘 10 再传入 handler：

在 AppController 添加一个 handler，然后应用这个 pipe：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9b8cf48d7a64eb68edb020ef5edd8a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=870&h=344&s=49272&e=png&b=1f1f1f)

```javascript
@Get('ccc')
ccc(@Query('num', ValidatePipe) num: number) {
    return num + 1;
}
```
访问下：


![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993cc99ff218499f82cf63d4beee1ac2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=738&h=206&s=18991&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0a9d78e7df54877a6a74de53f21ecc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=726&h=340&s=44591&e=png&b=fefefe)

可以看到，参数错误的时候返回了 400 响应，参数正确的时候也乘 10 传入了 handler。

这就是 Pipe 的作用。

Nest 内置了一些 Pipe，从名字就能看出它们的意思：

*   ValidationPipe
*   ParseIntPipe
*   ParseBoolPipe
*   ParseArrayPipe
*   ParseUUIDPipe
*   DefaultValuePipe
*   ParseEnumPipe
*   ParseFloatPipe
*   ParseFilePipe

同样，Pipe 可以只对某个参数生效，或者整个 Controller 都生效：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6ea5b5ea0b34ef98e8e58d571991adf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=738&h=168&s=25290&e=png&b=1f1f1f)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b59ad26c89547ac9ac762c34f51f08a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=700&h=346&s=76324&e=png&b=1f1f1f)


或者全局生效：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d414573c1c1497e8c4e74ae59a3d5b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=824&h=492&s=99581&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/547c0fd51bef474c91f79c6c52e17939~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=692&h=690&s=93776&e=png&b=1f1f1f)

不管是 Pipe、Guard、Interceptor 还是最终调用的 Controller，过程中都可以抛出一些异常，如何对某种异常做出某种响应呢？

这种异常到响应的映射也是一种通用逻辑，Nest 提供了 ExceptionFilter 来支持：

### ExceptionFilter

ExceptionFilter 可以对抛出的异常做处理，返回对应的响应：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/703ea24742a04ff08d0c244852e6212b~tplv-k3u1fbpfcp-watermark.image?)

其实我们刚刚在 pipe 里抛的这个错误，能够返回 400 的响应，就是 Exception Filter 做的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7eaf5e16a744fdf83f30c4d059d63a1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228&h=488&s=121930&e=png&b=1f1f1f)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0a9d78e7df54877a6a74de53f21ecc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=726&h=340&s=44591&e=png&b=fefefe)

创建一个 filter：

```
nest g filter test --no-spec --flat
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0877c763dbf469085c742b7ffec129c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=684&h=88&s=19771&e=png&b=191919)

生成的代码是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75179a0606c4c6789c6965ed4a11ef9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=974&h=276&s=56511&e=png&b=1f1f1f)

改一下：

```javascript
import { ArgumentsHost, BadRequestException, Catch, ExceptionFilter } from '@nestjs/common';
import { Response } from 'express';

@Catch(BadRequestException)
export class TestFilter implements ExceptionFilter {
  catch(exception: BadRequestException, host: ArgumentsHost) {

    const response: Response = host.switchToHttp().getResponse();

    response.status(400).json({
      statusCode: 400,
      message: 'test: ' + exception.message
    })
  }
}
```

实现 ExceptionFilter 接口，实现 catch 方法，就可以拦截异常了。

拦截什么异常用 @Catch 装饰器来声明，然后在 catch 方法返回对应的响应，给用户更友好的提示。

用一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd94c4f4313c410b8e568b1458a7b9c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=718&h=220&s=32376&e=png&b=1f1f1f)

再次访问，异常返回的响应就变了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4ddf9465a5f40e6817f4fbcf03e9aa7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=796&h=308&s=39321&e=png&b=ffffff)
Nest 内置了很多 http 相关的异常，都是 HttpException 的子类：

*   BadRequestException
*   UnauthorizedException
*   NotFoundException
*   ForbiddenException
*   NotAcceptableException
*   RequestTimeoutException
*   ConflictException
*   GoneException
*   PayloadTooLargeException
*   UnsupportedMediaTypeException
*   UnprocessableException
*   InternalServerErrorException
*   NotImplementedException
*   BadGatewayException
*   ServiceUnavailableException
*   GatewayTimeoutException

当然，也可以自己扩展：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf0edb48c82c4e6fa744f8e32e19fcc3~tplv-k3u1fbpfcp-watermark.image?)

**Nest 通过这样的方式实现了异常到响应的对应关系，代码里只要抛出不同的异常，就会返回对应的响应，很方便。**

同样，ExceptionFilter 也可以选择全局生效或者某个路由生效：

某个 handler：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd94c4f4313c410b8e568b1458a7b9c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=718&h=220&s=32376&e=png&b=1f1f1f)

某个 controller：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49772f6eaa7f4475a996cc2c5bc573a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786&h=462&s=101279&e=png&b=202020)

全局：
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/412348dd82e241089a0891a7bf82a60d~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c15f9cfbc704752852f29d97eda0521~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=350&s=71895&e=png&b=202020)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca3e0a1af7c44fada7f5f5f774e6c38f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=688&h=794&s=108264&e=png&b=1f1f1f)
我们了解了 Nest 提供的 AOP 的机制，但它们的顺序关系是怎样的呢？

### 几种 AOP 机制的顺序

Middleware、Guard、Pipe、Interceptor、ExceptionFilter 都可以透明的添加某种处理逻辑到某个路由或者全部路由，这就是 AOP 的好处。

但是它们之间的顺序关系是什么呢？

调用关系这个得看源码了。

对应的源码是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a6c3d7eebcc4d248bd8df8c1f71f7ed~tplv-k3u1fbpfcp-watermark.image?)

很明显，进入这个路由的时候，会先调用 Guard，判断是否有权限等，如果没有权限，这里就抛异常了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f066097b408148f7aa96b301e4613ca9~tplv-k3u1fbpfcp-watermark.image?)

抛出的 ForbiddenException 会被 ExceptionFilter 处理，返回 403 状态码。

如果有权限，就会调用到拦截器，拦截器组织了一个链条，一个个的调用，最后会调用的 controller 的方法：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20d438fd167e438cb63307c10643308a~tplv-k3u1fbpfcp-watermark.image?)

调用 controller 方法之前，会使用 pipe 对参数做处理：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc6133a5919044d29decd780253b7f6f~tplv-k3u1fbpfcp-watermark.image?)

会对每个参数做转换：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2017b403a0fb4bc6a41b261fd7cb2da0~tplv-k3u1fbpfcp-watermark.image?)

ExceptionFilter 的调用时机很容易想到，就是在响应之前对异常做一次处理。

而 Middleware 是 express 中的概念，Nest 只是继承了下，那个是在最外层被调用。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4d0291cafa9449ca4702617464c5979~tplv-k3u1fbpfcp-watermark.image?)

这就是这几种 AOP 机制的调用顺序。把这些理清楚，就知道什么逻辑放在什么切面里了。

案例代码在[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/aop-test)。

## 总结

Nest 基于 express 这种 http 平台做了一层封装，应用了 MVC、IOC、AOP 等架构思想。

MVC 就是 Model、View Controller 的划分，请求先经过 Controller，然后调用 Model 层的 Service、Repository 完成业务逻辑，最后返回对应的 View。

IOC 是指 Nest 会自动扫描带有 @Controller、@Injectable 装饰器的类，创建它们的对象，并根据依赖关系自动注入它依赖的对象，免去了手动创建和组装对象的麻烦。

AOP 则是把通用逻辑抽离出来，通过切面的方式添加到某个地方，可以复用和动态增删切面逻辑。

Nest 的 Middleware、Guard、Interceptor、Pipe、ExceptionFilter 都是 AOP 思想的实现，只不过是不同位置的切面，它们都可以灵活的作用在某个路由或者全部路由，这就是 AOP 的优势。

我们通过源码来看了它们的调用顺序，Middleware 是 Express 的概念，在最外层，到了某个路由之后，会先调用 Guard，Guard 用于判断路由有没有权限访问，然后会调用 Interceptor，对 Contoller 前后扩展一些逻辑，在到达目标 Controller 之前，还会调用 Pipe 来对参数做检验和转换。所有的 HttpException 的异常都会被 ExceptionFilter 处理，返回不同的响应。

Nest 就是通过这种 AOP 的架构方式，实现了松耦合、易于维护和扩展的架构。

AOP 架构的好处，你感受到了么？


## 90.前端如何直传文件到 Minio

前面我们学了 Nest 如何上传文件到服务器，但实际上基本不会直接在应用服务器存文件。

因为很容易到达存储上限，而且不好管理。

一般都会用 OSS 服务，比如阿里云的 OSS。

或者自己搭的 OSS 服务，比如用 minio。

用了 OSS 服务之后，可以通过服务器中转的方式上传文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b363bfe995714131b0f25dea6ad18822~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1302&h=302&s=29501&e=png&b=ffffff)

也就是前端把文件上传应用服务器，服务器上传阿里云或者 minio。

但这样没必要，传两次文件，浪费流量。

一般都是前端直传 OSS 服务，然后把文件 url 给应用服务器：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4a4d64a83884b6c8670c4ed09ccd716~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=842&h=514&s=38047&e=png&b=ffffff)

但这样直接把 accessKey 暴露给前端也不安全。

学阿里云 OSS 的时候我们讲过通过临时凭证的方式直穿 OSS。

也就是应用服务器返回一个临时的凭证，前端用这个临时凭证传 OSS，不需要把 accessKey 暴露给前端。

用 minio 自然也可以。

这节我们就来讲下前端如何直传 minio 的 OSS 服务。

搜索下 minio：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1451e7ef59b7432892ccefa417b67500~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1998&h=1274&s=258702&e=png&b=f2f3f7)

填入一些信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87eb9a405bae4470834b2bb29899053d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=1470&s=230560&e=png&b=ffffff)

name 是容器名。

port 是映射本地 9000 和 9001 端口到容器内的端口。

volume 是挂载本地目录到容器内的目录

这里挂载了一个本地一个目录到容器内的数据目录 /bitnami/minio/data，这样容器里的各种数据都保存在本地了。

还要指定两个环境变量，MINIO_ROOT_USER 和 MINIO_ROOT_PASSWORD，是用来登录的。

点击 run，跑起来之后可以看到数据目录被标记为 mounted，端口也映射成功了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c94439277d9149869b9d343214538fe0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1342&h=1022&s=107797&e=png&b=f8f8f9)

访问下 http://localhost:9001

我们创建个 bucket：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d485eaf6eaa14d3aa225ea84d3463be7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1520&h=1016&s=94712&e=png&b=ffffff)

设置下可以公开访问：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc0f1990162d401dafa60444b84f38a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2258&h=966&s=483874&e=png&b=fdfdfd)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76ffdce9aa904d4fac72b01abdf36392~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1750&h=766&s=172612&e=png&b=e9e9e9)

然后上传个文件：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a691b9dbe8648cfb2851e12e7560a53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2144&h=810&s=435665&e=png&b=fefefe)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/069e73d1a9f34c2e82ebfcade9e0a40b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1762&h=906&s=124414&e=png&b=fefefe)

浏览器直接访问文件路径的 URL：

http://localhost:9000/aaa/ground.png

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea17b8dea44647049c43a7dc50be42d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2158&h=1260&s=358720&e=png&b=171717)

可以看到，现在 OSS 服务的上传和查看图片就都成功了。

上节我们也写过在 node 里上传文件到 minio：

```javascript
var Minio = require('minio')

var minioClient = new Minio.Client({
  endPoint: 'localhost',
  port: 9000,
  useSSL: false,
  accessKey: '',
  secretKey: '',
})

function put() {
    minioClient.fPutObject('aaa', 'hello.png', './smile.png', function (err, etag) {
        if (err) return console.log(err)
        console.log('上传成功');
    });
}

put()
```
这节来做前端直传 minio。

因为需要服务端生成临时凭证，我们创建个 nest 服务：

```
nest new minio-fe-upload
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4819d203d6d4e148243dfb99cfbb205~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=882&h=714&s=275469&e=png&b=010101)

安装 minio 包：
```
npm install --save minio
```
然后创建个模块：

```
nest g module minio
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5c25cdd12e045f7b81c28cff6bf1e34~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=654&h=108&s=24294&e=png&b=191919)
```javascript
import { Global, Module } from '@nestjs/common';
import * as Minio from 'minio';

export const MINIO_CLIENT = 'MINIO_CLIENT';

@Global()
@Module({
    providers: [
        {
            provide: MINIO_CLIENT,
            async useFactory() {
                const client = new Minio.Client({
                        endPoint: 'localhost',
                        port: 9000,
                        useSSL: false,
                        accessKey: '',
                        secretKey: ''
                    })
                return client;
            }
          }
    ],
    exports: [MINIO_CLIENT]
})
export class MinioModule {}
```
把 minio client 封装成 provider，放到 exports 里，并设置模块为 @Global。

用到 accessKey 和 secretKey 在这里创建：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e91672fc9d7d46919e25c034a17eb4b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2186&h=928&s=452155&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c36ea8451ad74c4cb1f545afa75c8f63~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2146&h=1144&s=639753&e=png&b=d5d5d5)

在 AppController 里注入下测试下：

```javascript
import { Controller, Get, Inject } from '@nestjs/common';
import { AppService } from './app.service';
import { MINIO_CLIENT } from './minio/minio.module';
import * as Minio from 'minio';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject(MINIO_CLIENT)
  private minioClient: Minio.Client;

  @Get('test')
  async test() {
    try {
      await this.minioClient.fPutObject('aaa', 'hello.json', './package.json');
      return 'http://localhost:9000/aaa/hello.json';
    } catch(e) {
      console.log(e);
      return '上传失败';
    }
  }

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}
```
注入 Minio Client，在 test 接口里上传文件。

把服务跑起来；

```
npm run start:dev
```

试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13d8a236a54946648b86612f74bb5901~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922&h=246&s=28027&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57494c37c3964019bfc9837894a4e545~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1140&h=686&s=119826&e=png&b=ffffff)

上传成功。

然后我们要在前端做直传，

指定 public 为静态文件目录：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63b842ad980c47b78a3d8591f2599e7b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1230&h=492&s=109522&e=png&b=1f1f1f)

```javascript
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);
  
  app.useStaticAssets('public');

  await app.listen(3000);
}
bootstrap();
```
写下前端代码 public/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <input type="file" id="selector" multiple>
    <button onclick="upload()">Upload</button>
    <div id="status">No uploads</div>

    <script type="text/javascript">
        function upload() {
            var files = document.querySelector("#selector").files;
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                retrieveNewURL(file, (file, url) => {
                    uploadFile(file, url);
                });
            }
        }

        function retrieveNewURL(file, cb) {
            fetch(`/presignedUrl?name=${file.name}`).then((response) => {
                response.text().then((url) => {
                    cb(file, url);
                });
            }).catch((e) => {
                console.error(e);
            });
        }

        function uploadFile(file, url) {
            if (document.querySelector('#status').innerText === 'No uploads') {
                document.querySelector('#status').innerHTML = '';
            }
            fetch(url, {
                method: 'PUT',
                body: file
            }).then(() => {
                document.querySelector('#status').innerHTML += `<br>Uploaded ${file.name}.`;
            }).catch((e) => {
                console.error(e);
            });
        }
    </script>
</body>
</html>
```
这部分是[文档](https://min.io/docs/minio/linux/integrations/presigned-put-upload-via-browser.html)里的。

就是一个 type 为 file 的 input，可以多选。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f4e40e39cc54f0e8de754579b884be3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=892&h=430&s=82740&e=png&b=1f1f1f)

点击上传的时候遍历文件，对每个文件路径调用服务端的 presignedUrl 接口进行 url 签名：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4adc11218f84aa29b42cada44bbb76f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1110&h=738&s=124606&e=png&b=1f1f1f)

之后用返回的 url 就可以直传服务端了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/437eace9975d4b088f43d80b4b1aa9c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1250&h=486&s=95757&e=png&b=1f1f1f)

用 fetch 传的，换成 axios 也一样。

然后我们在服务端增加这个签名接口：

```javascript  
@Get('presignedUrl')
async presignedUrl(@Query('name') name: string) {
    return this.minioClient.presignedPutObject('aaa', name);
}
```
测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a056359830e4c9c8d0b2d491b834634~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1792&h=974&s=1134229&e=gif&f=46&b=fdfdfd)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2870ef96c34c4477acf4185e707fb18f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1438&h=872&s=416186&e=png&b=fefefe)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae4c5b9eed284a7fabeefffd41239830~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1478&h=714&s=113153&e=png&b=fefefe)

上传成功！

看下 url 签名之后的样子：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1667cac96385490b9fa4699bc816c70c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2572&h=550&s=222788&e=png&b=fefefe)

其实就是在 url 里带上了鉴权信息。

这样，前端不需要 accessKey 也可以直传文件到 minio 了。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/minio-fe-upload)。

## 总结

前面我们实现过阿里云 OSS 的前端直传文件，只要在服务端做预签名，前端就可以不用 accessKey 实现文件上传。

这节我们实现了 minio 的前端文件直传，也是通过服务端做预签名，然后前端直接传 minio 就行。

一般我们不会直接上传文件到应用服务器，或者传阿里云 OSS 或者传 minio。


## 91.基于 sharp 实现 gif 压缩工具

不知道大家有没有场景会需要 GIF 压缩，我是经常会用到。

因为公众号的图片最大支持 10M，但是我录制出来的 GIF 经常超过 10M。

比如这样一个图片：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/534f62e9f98a4d89ab5074b33e355b03~tplv-k3u1fbpfcp-watermark.image?)

在编辑器上传会提示超过 10 M 了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6488ca24bfc548f2a9d12be840328983~tplv-k3u1fbpfcp-watermark.image?)

这时候就需要 GIF 压缩，不然文章发不了。

于是我在百度搜素 GIF 压缩，就找到了一个工具：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a77546139604ab99b174650a17d3c89~tplv-k3u1fbpfcp-watermark.image?)

它确实能解决我的问题：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f0958bf3004e5f929067bc8930bbf9~tplv-k3u1fbpfcp-watermark.image?)

但是要花钱：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abfb01d8086a400f923bdf9b5ca94ce5~tplv-k3u1fbpfcp-watermark.image?)

一年 148 呢，对一个小工具来说还是挺贵的。

但没办法，这对我是刚需，总不能不发文章了吧。

于是去年年底我就开了一年的会员：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb82df4b2464e58ac0003323c68bd4d~tplv-k3u1fbpfcp-watermark.image?)

但最近发现有 npm 包可以做这个，没必要买这种网站的会员。。。

当时我的心情是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56098a7eaefc43488e4917f3e5d6fd5a~tplv-k3u1fbpfcp-watermark.image?)

这个 npm 包就是 sharp，它是用来处理各种图片的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbb3d4cb491247b9a341561383cdded4~tplv-k3u1fbpfcp-watermark.image?)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/006b0a681c464318849f695afefd71be~tplv-k3u1fbpfcp-watermark.image?)

它可以用来调整图片的大小，对图片做旋转、颜色调整、合成图片等。

这些功能我用不到，我就关心它的 gif 压缩功能。

看了下文档，大概这样用：

```javascript
const sharp = require('sharp');

sharp('1.image.gif', {
    animated: true,
    limitInputPixels: false
}).gif({
    colours: 10
}).toFile('2.image.gif')
```
我们先试试看：

node 执行这个文件，可以看到产生了 2.image.gif，只有 2.7 M

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/969d2190fe7b4b1282d6d2ed4d77e9d8~tplv-k3u1fbpfcp-watermark.image?)

要知道之前的 1.image.gif 可是有 21M 啊：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba702430da5a414bba766f271a3ddf82~tplv-k3u1fbpfcp-watermark.image?)

然后打开它看看：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/558424b82d2d4f1b8211f6ce34139e6a~tplv-k3u1fbpfcp-watermark.image?)

没啥问题。

回过头来，我们再来看看这段代码：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26b6de2e70e2465c95e205c55773edfd~tplv-k3u1fbpfcp-watermark.image?)

animated 设为 true 是读取所有的帧，不然默认只会读取 gif 的第一帧。

limitInputPixels 设为 false 是不限制大小，默认太大的图片是会报错的。

然后是输出参数：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe371950ef354b7eb302e86e00540b51~tplv-k3u1fbpfcp-watermark.image?)

colours 是颜色的数量，默认是 256。

一般色彩不丰富的图片，可以把 colours 设置的小一点。

当把 colours 设置为 2，图片就变成这样了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/035a108ea6e941728632fc5f42002ab1~tplv-k3u1fbpfcp-watermark.image?)

图片也更小了一些：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf5e6418996f435c8c237e97de3cb87f~tplv-k3u1fbpfcp-watermark.image?)

具体怎么设置压缩级别和颜色数量，还是看需求。

总之，我们完全可以用 sharp 来自己做 gif 压缩，没必要买这种工具网站的会员。。。

不过体验上还是网页更好一点，我们也来写个这种网页：

用 create-react-app 创建个项目：

```
npx create-react-app gif-compression-frontend
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab409f4fc3724b30ad962140239eab2d~tplv-k3u1fbpfcp-watermark.image?)

进入项目目录，安装 antd：

```
npm install --save antd
```
修改下 App.js

```javascript
import { DatePicker } from 'antd';

function App() {
  return (
    <div>
      <DatePicker/>
    </div>
  );
}

export default App;
```
然后把开发服务跑起来：

```
npm run start
```
浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3a83edc815544e28ec8795f8352b9b2~tplv-k3u1fbpfcp-watermark.image?)

antd 引入成功了。

然后我们来写下上传文件的 UI：

```javascript
import React from 'react';
import { InboxOutlined } from '@ant-design/icons';
import { message, Upload } from 'antd';

const { Dragger } = Upload;

const props = {
  name: 'file',
  action: 'http://localhost:3005',
  onChange(info) {
    const { status } = info.file;
    if (status === 'done') {
      message.success(`${info.file.name} 文件上传成功`);
    } else if (status === 'error') {
      message.error(`${info.file.name} 文件上传失败`);
    }
  }
};

const App = () => (
  <Dragger {...props}>
    <p className="ant-upload-drag-icon">
      <InboxOutlined />
    </p>
    <p className="ant-upload-text">点击或拖拽文件到这个区域来上传</p>
  </Dragger>
);

export default App;
```
大概是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd025c87d4eb44db962c184e6a7d2da0~tplv-k3u1fbpfcp-watermark.image?)

antd 会 post 方式请求 action 对应的接口，带上上传的文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e619fef32305427f988e5c2f95a90d43~tplv-k3u1fbpfcp-watermark.image?)

我们再用 nest 写个后端服务接收下：

```
nest new gif-compression-backend
```
创建个 nest 项目：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd29629beee140a7832279cf86d9d409~tplv-k3u1fbpfcp-watermark.image?)

修改 main.ts，启用跨域支持，并修改启动端口为 3005

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0938ccf5e241659acbfda47b9b9e7b~tplv-k3u1fbpfcp-watermark.image?)

把它跑起来：

```
npm run start:dev
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fafdf617a144d24abc95c2aca3fbf94~tplv-k3u1fbpfcp-watermark.image?)

浏览器访问 http://localhost:3005 可以看到 hello world，说明 nest 服务跑成功了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57f1de80ce843d19453c223eb3bd111~tplv-k3u1fbpfcp-watermark.image?)

然后我们来添加下文章上传的接口：

安装需要的 ts 类型的包：

```
npm install -D @types/multer
```

在 AppController 里添加这样一个路由：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d728bcdb0f0486bb6453b89a2c8b914~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Post('upload')
@UseInterceptors(FileInterceptor('file', {
  dest: 'uploads'
}))
uploadFile(@UploadedFile() file: Express.Multer.File) {
  console.log('file', file);
}
```
这段代码是提取 file 参数的内容，保存到 dest 目录下，然后把文件对象传入该方法。

然后我们改下前端代码的上传接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1956716d40b84b81b8fc46d74717b753~tplv-k3u1fbpfcp-watermark.image?)

测试下上传：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85560f4437134a878f38d6c5870d4896~tplv-k3u1fbpfcp-watermark.image?)

提示文件上传成功了，然后在服务端控制台也打印了文件信息，并且在 uploads 目录下可以看到这个文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd39a9a51a554bbea2148e7fe52468cc~tplv-k3u1fbpfcp-watermark.image?)

这些文件在浏览器打开，可以看到就是上传的 gif：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/530b9987a7d9417792668927fc61fd4e~tplv-k3u1fbpfcp-watermark.image?)

然后我们把文件路径返回就好了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0eea12b4a6584b7bb887b7aa5496daa1~tplv-k3u1fbpfcp-watermark.image?)

现在上传文件成功之后就可以拿到这个文件在服务端的路径了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7179b1164b514fcd8c5f192d410ba3c0~tplv-k3u1fbpfcp-watermark.image?)

然后我们再实现下压缩，在 AppController 增加一个接口：

```javascript
@Get('compression')
compression(@Query('path') filePath: string, @Query('color', ParseIntPipe) color:number) {
    console.log(filePath, color);

    if(!existsSync(filePath)) {
      throw new BadRequestException('文件不存在');
    }
    return 'success';
}
```

接收 path、color 的 query 参数，分别是文件路径、颜色数量的意思。

其中 color  要使用 ParseIntPipe 转成 int 类型。

测试下：

访问 http://localhost:3005/compression?path=uploads/xxx&color=10

提示文件不存在：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/260fce890e1749a19d65ccdf676dc953~tplv-k3u1fbpfcp-watermark.image?)

服务端接收到了传过来的参数：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ee09d44a1f4d148cbaeb529788e28b~tplv-k3u1fbpfcp-watermark.image?)

然后换一个真实存在的路径，返回 success：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8d438617d364fd1857dced1be249a26~tplv-k3u1fbpfcp-watermark.image?)

说明服务端找到了这个路径的文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87e16f47a1ed4d7b92a0afbd6c2bf26b~tplv-k3u1fbpfcp-watermark.image?)

接下来安装 sharp 来实现压缩：

```
npm install --save sharp
```

修改下 compression 方法：

调用 sharp 来压缩 gif 图片，并注入 response 对象来返回文件下载响应：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb256bd73dc479c8978477a4dbe607f~tplv-k3u1fbpfcp-watermark.image?)

```javascript
@Get('compression')
async compression(
    @Query('path') filePath: string,
    @Query('color', ParseIntPipe) color:number,
    @Res() res: Response
) {

    if(!existsSync(filePath)) {
      throw new BadRequestException('文件不存在');
    }

    const data = await sharp(filePath, {
        animated: true,
        limitInputPixels: false
    }).gif({
        compressionLevel: level,
        colours: color
    }).toBuffer();

    res.set('Content-Disposition', `attachment; filename="dest.gif"`);

    res.send(data);
}
```
测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a3d7046afee4724b453590ed269928e~tplv-k3u1fbpfcp-watermark.image?)

访问这个接口，带上文件路径和压缩的参数，会返回压缩后的文件：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96ede0c962514ba086287a3cfde2d17b~tplv-k3u1fbpfcp-watermark.image?)

然后我们在前端页面上加一个表单来填参数，然后访问这个接口压缩文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d394163b762486cbdebc2ae5dc4f4fa~tplv-k3u1fbpfcp-watermark.image?)

代码如下：
```javascript
import React, { useState } from 'react';
import { InboxOutlined } from '@ant-design/icons';
import { message, Upload, Form, Input, Button } from 'antd';

const { Dragger } = Upload;

const App = () => {
  const [form] = Form.useForm();
  const [filePath, setFilePath] = useState('');
  const [fileName, setFileName] = useState('');

  const compress = async (values) => {
    console.log(values);
    console.log(filePath);
  };

  const props = {
    name: 'file',
    action: 'http://localhost:3005/upload',
    onChange(info) {
      const { status } = info.file;
      if (status === 'done') {
        setFilePath(info.file.response);
        setFileName(info.file.name);
        message.success(`${info.file.name} 文件上传成功`);
      } else if (status === 'error') {
        message.error(`${info.file.name} 文件上传失败`);
      }
    }
  };

  return <div>
    <Form style={{width: 500, margin: '50px auto'}}form={form} onFinish={compress}>
      <Form.Item
        label="颜色数量"
        name="color"
      >
        <Input />
      </Form.Item>

      <Form.Item>
        <Dragger {...props}>
          <p className="ant-upload-drag-icon">
            <InboxOutlined />
          </p>
          <p className="ant-upload-text">点击或拖拽文件到这个区域来上传</p>
        </Dragger>
      </Form.Item>

      <Form.Item>
        <Button type="primary" htmlType="submit">压缩</Button>
      </Form.Item>
    </Form>
  </div>
}

export default App;
```

用 filePath 的 state 来保存上传后的文件路径，用 fileName 保存文件名。

在点击登录的时候打印下表单的值和 filePath。

我们试试看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1faf57685f884ac0a38e4ccf9db97bce~tplv-k3u1fbpfcp-watermark.image?)

3 个参数都拿到了，然后调用下压缩接口。

安装 axios：

```
npm install --save axios
```

修改下 compress 方法：

```javascript
const compress = async (values) => {
    const res = await axios.get('http://localhost:3005/compression', {
      params: {
        color: values.color || 256,
        level: values.level || 9,
        path: filePath
      },
      responseType: 'arraybuffer'
    });

    const blob = new Blob([res.data], { type: 'image/jpeg' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a'); 
    link.href = url; 
    link.download = fileName;
    link.click(); 

    message.success('压缩成功');
};
```
访问 comporession 接口，传入参数，指定返回数据的类型为 arraybuffer。

然后用 URL.createObjectURL 创建 blob 的 url，设置为 a 标签的 src，指定 download 属性的值也就是文件名，然后触发点击。

这样，就能把返回的 arraybuffer 作为文件下载了。

我们试试看：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ddffc405b3d48808f43b0e7512a5c1d~tplv-k3u1fbpfcp-watermark.image?)

整个流程都跑通了！

我们试下刚开始那个 21M 的文件，压缩之后下载的是 2.7M。

和用这个网站压缩的差不多：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b2acf5de1f34d89bfade7eb3da7516a~tplv-k3u1fbpfcp-watermark.image?)

更重要的是不用每年 138 的会员费。

案例代码在小册仓库：

前端代码：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/gif-compression-frontend

后端代码：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/gif-compression-backend

## 总结

压缩 gif 图片是我的刚需，之前都是买某网站的 138 的年度会员，直到我发现了 sharp 这个包。

它是用来处理各种图片的，调整大小、旋转等等，我们只用它的 gif 压缩的功能。

然后我们也做了一个网站，前端 react + antd，后端 nest + sharp。

后端提供一个 /upload 接口用于上传文件，返回文件路径。

又提供了一个 /compression 接口用来压缩 gif，返回压缩后的文件。

整个流程如下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03dc4ab868a04400a8f7e0aa1a8cccf5~tplv-k3u1fbpfcp-watermark.image?)

其实最好再做一步: 把这个应用通过 dockerfile 来 build 成 docker 镜像，随时用，随时跑。

再需要压缩图片的时候，不用花钱买会员了，直接用自己的压缩工具就好了。


## 92.大文件如何实现流式下载？

文件上传、文件下载都是常见的需求。

大文件上传我们会通过分片上传来优化。

比如[阿里云 OSS 的大文件分片上传](https://help.aliyun.com/zh/oss/user-guide/multipart-upload)：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/896de2622dbf4b5a8f110388f91fee51~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2028&h=1046&s=285258&e=png&b=fefefe)

那大文件下载如何优化呢？

答案也是分片下载，或者叫流式传输。

我们试一下：

```
nest new download-test
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd350a368f95466282163b0d59537196~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=848&h=686&s=160615&e=png&b=010101)

创建个 Nest 项目。

在 AppController 里添加个 download 的路由：

```javascript
import { Controller, Get, Res } from '@nestjs/common';
import { AppService } from './app.service';
import { Response } from 'express';
import * as fs from 'fs';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('download')
  download(@Res() res: Response) {
    const content = fs.readFileSync('package.json');

    res.set('Content-Disposition', `attachment; filename="guang.json"`);

    res.end(content);
  }
}
```
把服务跑起来：

```
npm run start:dev
```
浏览器访问下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6ce5db01d2343458c0452d03eb5eed2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1754&h=790&s=204649&e=gif&f=23&b=fefefe)

可以看到，触发了下载。

在 devtools 里可以看到正确设置了 header：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0164a3f47d74484ebb80a0e5ebe570c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1912&h=552&s=107753&e=png&b=ffffff)

header 通过 @Header 装饰器加也可以：

```javascript
@Get('download')
@Header('Content-Disposition', `attachment; filename="guang.json"`)
download(@Res() res: Response) {
    const content = fs.readFileSync('package.json');

    res.end(content);
}
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6ca7548308b43d3902b0277d094d8ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1716&h=732&s=201634&e=gif&f=20&b=fdfdfd)

效果一样。

但是，这样文件是全部读取出来返回，如果文件大了，比如好几个 G，会占用很大的内存。

当大文件下载的时候，能不能读出一部分返回一部分，也就是流式的下载呢？

可以的，http 有这个功能。

就是 transfer-encoding:chunked

这个是面试常考题。

从服务器下载一个文件的时候，如何知道文件下载完了呢？

有两种方式：

一种是 header 里带上 Content-Length，浏览器下载到这个长度就结束。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6876968033b44759a5a97f4eeedce012~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1088&h=316&s=63926&e=png&b=fefefe)

另一种是设置 transfer-encoding:chunked，它是不固定长度的，服务器不断返回内容，直到返回一个空的内容代表结束。

比如这样：
```
5
Hello
1
,
5
World
1
!
0
```
这里分了 “Hello”  “,” “World”“!” 这 4 个块，长度分别为 5、1、5、1

最后以一个长度为 0 的块代表传输结束。

这样，不管内容多少都可以分块返回，就不用指定 Content-Length 了。

这就是大文件的流式传输的原理，就是 transfer-encoding:chunked。

然后我们在代码里实现下：

```javascript
@Get('download2')
@Header('Content-Disposition', `attachment; filename="guang.json"`)
download2(@Res() res: Response) {
    const stream = fs.createReadStream('package.json');

    stream.pipe(res);
}
```
node 的 stream 本来就是分块读取内容的，这里配合流式返回数据很合适。

现在就不再返回 Content-Length 了，而是返回了 Transfer-Encoding:chunked：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c840647e73394dd99865a821a717d37e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1716&h=732&s=395017&e=gif&f=34&b=fefefe)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08d00a6f9c854b23a1eb930972ca30f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1916&h=508&s=109188&e=png&b=ffffff)

这就是流式传输。

不过在 nest 里最好不要直接用 node 的 stream api。

因为它有很多事件，比如 data、error、end 等，自己处理还是挺麻烦的。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cf7c87433d840b5bd2e4f90db39080f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1046&h=434&s=74033&e=png&b=202020)

可以直接用 Nest 封装的一个类 StreamableFile：

```javascript
@Get('download3')
download3() {
    const stream = fs.createReadStream('package.json');

    return new StreamableFile(stream, {
      disposition: `attachment; filename="guang.json"`
    });
}
```

试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d36625c8e74638839a562bf23af984~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=574&s=325813&e=gif&f=31&b=fefefe)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0f06d1eb15d41fb80032ebdfff3019e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1924&h=550&s=120317&e=png&b=fefefe)

效果一样。

只是这里的 Content-Type 默认是 application/octet-stream 二进制流：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7803b8ec2c3642efaeb2721bbb2ef773~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1916&h=516&s=116600&e=png&b=fefefe)

你也可以改一下：

```javascript
@Get('download3')
download3() {
    const stream = fs.createReadStream('package.json');

    return new StreamableFile(stream, {
      type: 'text/plain',
      disposition: `attachment; filename="guang.json"`
    });
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/decd175f0cd7443599ba8da676a63a72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1316&h=462&s=74880&e=png&b=fefefe)

这样就实现了流式传输了。

相比大文件上传需要自己实现分片，大文件下载这个，浏览器和 http 内置了支持，直接指定对应 header 就行，自己不用做很多事情。

然后具体的 http 响应体是什么样的呢？

我们用 wireshark 抓包看一下：

在 [wireshark 官网](https://www.wireshark.org/)下载安装包：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc7ab892b6114efe832d5f78b8275cbd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1796&h=1138&e=png&b=081121)

安装后把它跑起来：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3345ccfb87f644bf9be1b3b3c1da5869~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=292&h=290&e=png&b=971900)

选择 loopback 这个网卡，本地回环地址，可以抓到 localhost 的包：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7a614404c334bd2a714efa53fb16947~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1344&h=848&s=111555&e=png&b=fafafa)

输入过滤器 port 3000，也就是过滤 3000 端口的数据包。

然后回车就会进入抓包界面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a012fc36cbe14b5faa434c295ed8df6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1436&h=508&e=png&b=f2f2f2)

这时候再访问下 http://localhost:3000/download3

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d36625c8e74638839a562bf23af984~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=574&s=325813&e=gif&f=31&b=fefefe)

可以看到抓到了几个 tcp 的包：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac9aaa51b434bbeaa18a143646a85fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1864&h=466&e=png&b=e6e5fe)

这两个分别是请求和响应：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad9595c45eef4fe8ada1c7f7ca84e420~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1990&h=1128&s=300985&e=png&b=fafafa)

如果多了找不到，点一下 protocal 会排序：
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3480efd1fcfb4f0db8355cbab123a911~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1842&h=422&s=153670&e=png&b=f0e8de)


可以看到，确实是分块传输的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eff8facd2f034e8fb1ec39921a034487~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=960&h=620&s=107262&e=png&b=fefefe)

这里有一个数据块，然后一个空块结尾。

再访问下 http://localhost:3000/download 接口对比下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb5607ab0ab046c3b86cc82d6bb7578b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1848&h=1106&s=287818&e=png&b=fcfcfc)

和上面的对比下，这就是没有分块的响应。

当然，现在的文件比较小，可以找一个大一点的文件试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99743aae8c434d318b3fe3b5f9c8e05d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=346&h=214&s=12664&e=png&b=ffffff)

可以看到，现在分片就多了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a17f70d2588a4e59aff0f6212760e459~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1942&h=1040&s=277544&e=png&b=f9f9f9)

大概是 65536 一个分块，也就是 64k。

每个分块都有 chunk size 和 chunk data：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/951a6246405c4b58b5b54ceaab2dd928~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1006&h=456&s=95703&e=png&b=fefefe)

确实是分块了。

案例代码上传了 [Nest 小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/download-test)。

## 总结

大文件上传的优化是分片上传，大文件下载的优化是分片下载。

只不过这个分片下载 http 帮你做了，你只要指定 transfer-encoding:chunked 就行，也叫流式传输。

在 Nest 里可以用 fs.createReadStream 获取文件流，然后返回 StreamableFile 的对象就可以了。

返回的响应就是流式的，我们通过 wireshark 抓包证实了这点。

每个分块都有 chunk size、chunk data 的信息。

以后面试官再问你大文件下载优化或者问 transfer-encoding:chunked，你就可以大胆的说你用 wireshark 抓包验证过了。

## 93.Puppeteer 实现爬虫，爬取 BOSS 直聘全部前端岗位

我们在找工作的时候，都会用 boss 直聘、拉钩之类的 APP 投简历。

根据职位描述筛选出适合自己的来投。

此外，职位描述也是我们简历优化的方向，甚至是平时学习的方向。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64f41bb318ea4ac0ad747e5d79575265~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1578&h=1028&s=271262&e=png&b=fefefe)

所以我觉得招聘网站的职位描述还是挺有价值的，就想把它们都爬取下来存到数据库里。

今天我们一起来实现下。

爬取数据我们使用 Puppeteer 来做，然后用 TypeORM 把爬到的数据存到 mysql 表里。

创建个项目：

```
mkdir jd-spider
cd jd-spider
npm init -y
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91c31c077058466c9a56e27bdafb0450~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=860&h=666&s=125266&e=png&b=000000)

进入项目，安装 puppeteer：

```
npm install --save puppeteer
```

我们要爬取的是 boss 直聘的网站数据。

首先，进入[搜索页面](https://www.zhipin.com/web/geek/job?query=%E5%89%8D%E7%AB%AF&city=100010000)，选择全国范围，搜索前端：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3608e2ed5b014e768043743f7b6f7f00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1942&h=1268&s=1338255&e=gif&f=40&b=fcfcfc)

然后职位列表的每个点进去查看描述，把这个岗位的信息和描述抓取下来：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25f97e689fb3435d884efbdcd298bf9d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1942&h=1268&s=2453118&e=gif&f=37&b=fdfdfd)

创建 test.js

```javascript
import puppeteer from 'puppeteer';

const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: {
        width: 0,
        height: 0
    }
});

const page = await browser.newPage();

await page.goto('https://www.zhipin.com/web/geek/job');

await page.waitForSelector('.job-list-box');

await page.click('.city-label', {
    delay: 500
});

await page.click('.city-list-hot li:first-child', {
    delay: 500
});

await page.focus('.search-input-box input');

await page.keyboard.type('前端', {
    delay: 200
});

await page.click('.search-btn', {
    delay: 1000
});
```
调用 launch 跑一个浏览器实例，指定 headless 为 false 也就是有界面。

defaultView 设置 width、height 为 0 是网页内容充满整个窗口。

然后就是自动化的流程了：

首先进入职位搜索页面，等 job-list-box 这个元素出现之后，也就是列表加载完成了。

就点击城市选择按钮，选择全国。

然后在输入框输入前端，点击搜索。

然后跑一下。

跑之前在 package.json 设置 type 为 module，也就是支持 es module 的 import：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d84b572a639e4c54b2ab475caa175dfd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=526&h=346&s=47857&e=png&b=202020)

```
node ./test.js
```
它会自动打开一个浏览器窗口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b49f9a105fe4b80b6974a4506253d34~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2224&h=1328&s=963516&e=gif&f=41&b=1a1a1a)

然后执行自动化脚本：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b5eb0ec636c4aae9bab904cae3dca43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2224&h=1328&s=3039422&e=gif&f=55&b=fefefe)

这样，下面的列表数据就是可以抓取的了。

不过这里其实没必要这么麻烦，因为只要你 url 里带了 city 和 query 的参数，会自动设置为搜索参数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb3816d3f7e34a10910630998a969310~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1904&h=1294&s=421979&e=png&b=fefefe)

所以直接打开这个 url 就可以：

```javascript
import puppeteer from 'puppeteer';

const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: {
        width: 0,
        height: 0
    }
});

const page = await browser.newPage();

await page.goto('https://www.zhipin.com/web/geek/job?query=前端&city=100010000');

await page.waitForSelector('.job-list-box');
```
然后我们要拿到页数，用来访问列表的每页数据。

怎么拿到页数呢？

其实就是拿 options-pages 的倒数第二个 a 标签的内容：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f65f7ab734a4cf5ae1c3ef69510d665~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1396&h=708&s=181545&e=png&b=ffffff)

```javascript
import puppeteer from 'puppeteer';

const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: {
        width: 0,
        height: 0
    }
});

const page = await browser.newPage();

await page.goto('https://www.zhipin.com/web/geek/job?query=前端&city=100010000');

await page.waitForSelector('.job-list-box');

const res = await page.$eval('.options-pages a:nth-last-child(2)', el => {
    return parseInt(el.textContent)
});

console.log(res);
```

$eval 第一个参数是选择器，第二个参数是对选择出的元素做一些处理后返回。

跑一下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4551f481f16941ec9d9030172d8edd10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=740&h=166&s=19530&e=png&b=191919)

页数没问题。

然后接下来就是访问每页的列表数据了。

就是在 url 后再带一个 page 的参数：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca2993be235b46f991bcfc4cc613d4e1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1360&h=876&s=203355&e=png&b=fefefe)

然后，我们遍历访问每页数据，拿到每个职位的信息：

```javascript
import puppeteer from 'puppeteer';

const browser = await puppeteer.launch({
    headless: false,
    defaultViewport: {
        width: 0,
        height: 0
    }
});

const page = await browser.newPage();

await page.goto('https://www.zhipin.com/web/geek/job?query=前端&city=100010000');

await page.waitForSelector('.job-list-box');

const totalPage = await page.$eval('.options-pages a:nth-last-child(2)', e => {
    return parseInt(e.textContent)
});

const allJobs = [];
for(let i = 1; i <= totalPage; i ++) {
    await page.goto('https://www.zhipin.com/web/geek/job?query=前端&city=100010000&page=' + i);

    await page.waitForSelector('.job-list-box');

    const jobs = await page.$eval('.job-list-box', el => {
        return [...el.querySelectorAll('.job-card-wrapper')].map(item => {
            return {
                job: {
                    name: item.querySelector('.job-name').textContent,
                    area: item.querySelector('.job-area').textContent,
                    salary: item.querySelector('.salary').textContent
                },
                link: item.querySelector('a').href,
                company: {
                    name: item.querySelector('.company-name').textContent,
                }
            }
        })
    });
    allJobs.push(...jobs);
}

console.log(allJobs);
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fc855414f844db4b4a1d312fd8e9e55~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1520&h=1144&s=267097&e=png&b=1f1f1f)

具体的信息都是从 dom 去拿的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59e84b44db2845ceba1383ae9bf99a48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1632&h=866&s=315365&e=png&b=fefefe)

跑一下试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff27d24e98bf48b5b3308f9983b59b72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2224&h=1124&s=2368796&e=gif&f=32&b=fcfcfc)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5234507b1ff644e0932b9b843ed2c1bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1464&h=1004&s=265647&e=png&b=181818)

可以看到，它会依次打开每一页，然后把职位数据爬取下来。

做到这一步还不够，我们要点进去这个链接，拿到 jd 的描述。

[](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c311e0bdcf4db6b8d15bf173ed058f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&h=756&s=122606&e=png&b=1f1f1f)
```javascript
for(let i = 0; i< allJobs.length; i ++) {
    await page.goto(allJobs[i].link);

    try{
        await page.waitForSelector('.job-sec-text');

        const jd= await page.$eval('.job-sec-text', el => {
            return el.textContent
        });
        allJobs[i].desc = jd;

        console.log(allJobs[i]);
    } catch(e) {}
}

```
try catch 是因为有的页面可能打开会超时导致中止，这种就直接跳过好了。

跑一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba3dcdb20d1742b8a40ecd6a0157b748~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2224&h=1124&s=779848&e=gif&f=36&b=2f495d)

它同样会自动打开每个岗位详情页，拿到职位描述的内容，并打印在控制台。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3644003abe114974a64c1e1db1d96f0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1686&h=910&s=10214544&e=gif&f=43&b=181818)

接下来只要把这些存入数据库就好了。

我们新建个 nest 项目：

```
npm install -g @nestjs/cli

nest new boss-jd-spider
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8bae052c7e149d0832a978a267c674b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=888&h=692&s=159575&e=png&b=020202)

用 docker 把 mysql 跑起来：

从 [docker 官网](https://docker.com/)下载 docker desktop，这个是 docker 的桌面端：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d7da48155df448698ae5fc57072fe0b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2380\&h=1336\&s=459767\&e=png\&b=ffffff)

跑起来后，搜索 mysql 镜像（这步需要科学上网），点击 run：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/659eaef5c4b8445a8c7224981515c1fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2368\&h=1460\&s=326395\&e=png\&b=7a7a7b)

输入容器名、端口映射、以及挂载的数据卷，还要指定一个环境变量：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33961dc3a8cd4d9c805c2ff096a1caf9~tplv-k3u1fbpfcp-watermark.image#?w=1332\&h=1428\&s=187941\&e=png\&b=ffffff)

端口映射就是把宿主机的 3306 端口映射到容器里的 3306 端口，这样就可以在宿主机访问了。

数据卷挂载就是把宿主机的某个目录映射到容器里的 /var/lib/mysql 目录，这样数据是保存在本地的，不会丢失。

而 MYSQL\_ROOT\_PASSWORD 的密码则是 mysql 连接时候的密码。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7db618f4e4b4ca3b0b44752450d4322~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2232\&h=1326\&s=496885\&e=png\&b=ffffff)

跑起来后，我们用 GUI 客户端连上，这里我们用的是 mysql workbench，这是 mysql 官方提供的免费客户端：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1311f9991e248de8a9cdd92c9b72a15~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=270\&h=270\&s=40789\&e=png\&b=9b5801)

连接上之后，点击创建 database：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76b5b5d5a2814853a3f87e23d92e4724~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1384&h=800&s=238779&e=png&b=e6e4e4)

指定名字、字符集为 utf8mb4，然后点击右下角的 apply。

创建成功之后在左侧就可以看到这个 database 了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3f6a454a1504779aedf6dc13f4fea4d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=540&h=244&s=39017&e=png&b=e5e0df)

当然，现在还没有表。

我们在 Nest 里用 TypeORM 连接 mysql。

安装用到的包：
```
npm install --save @nestjs/typeorm typeorm mysql2
```
mysql2 是数据库驱动，typeorm 是我们用的 orm 框架，而 @nestjs/tyeporm 是 nest 集成 typeorm 用的。

在 AppModule 里引入 TypeORM，指定数据库连接配置：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c69193db961c4c4d87d54e0157b511b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=994&h=1078&s=190450&e=png&b=1f1f1f)

```javascript
TypeOrmModule.forRoot({
  type: "mysql",
  host: "localhost",
  port: 3306,
  username: "root",
  password: "guang",
  database: "boss-spider",
  synchronize: true,
  logging: true,
  entities: [],
  poolSize: 10,
  connectorPackage: 'mysql2',
  extra: {
      authPlugin: 'sha256_password',
  }
}),
```

然后创建个 entity：

src/entities/Job.ts

```javascript
import { Column, Entity, PrimaryGeneratedColumn } from "typeorm";

@Entity()
export class Job {
    
    @PrimaryGeneratedColumn()
    id: number;

    @Column({
        length: 30,
        comment: '职位名称'
    })
    name: string;

    @Column({
        length: 20,
        comment: '区域'
    })
    area: string;

    @Column({
        length: 10,
        comment: '薪资范围'
    })
    salary: string;

    @Column({
        length: 600,
        comment: '详情页链接'
    })    
    link: string;

    @Column({
        length: 30,
        comment: '公司名'
    })   
    company: string;

    @Column({
        type: 'text',
        comment: '职位描述'
    })
    desc: string;
}
```
链接可能很长，所以设置为 600，而职位描述就更长了，直接设置 text 就行，它可以存储大段文本。

在 AppModule 引入：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bc3c5de72ff4723a73124fad378655d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=844&h=908&s=168374&e=png&b=1f1f1f)

把服务跑起来：

```
npm run start:dev
```
TypeORM会自动建表:

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80140981a5b749e4a6cb19025a340660~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1974&h=724&s=305999&e=png&b=191919)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb92d013305347c9b41c408dbfbf9e81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1134&h=566&s=208834&e=png&b=efecec)

然后我们加个启动爬虫的接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/844085e6df0f4deeadd7db63bd40e7df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=748&s=133242&e=png&b=1f1f1f)

```javascript
@Get('start-spider')
startSpider() {
    this.appService.startSpider();
    return '爬虫已启动';
}
```
安装 puppeteer：

```
npm install --save puppeteer
```
在 AppService 里实现 startSpider：

```javascript
import { Injectable } from '@nestjs/common';
import puppeteer from 'puppeteer';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }

  async startSpider() {
    const browser = await puppeteer.launch({
        headless: false
        ,
        defaultViewport: {
            width: 0,
            height: 0
        }
    });

    const page = await browser.newPage();

    await page.goto('https://www.zhipin.com/web/geek/job?query=前端&city=100010000');

    await page.waitForSelector('.job-list-box');

    const totalPage = await page.$eval('.options-pages a:nth-last-child(2)', e => {
        return parseInt(e.textContent)
    });

    const allJobs = [];
    for(let i = 1; i <= totalPage; i ++) {
        await page.goto('https://www.zhipin.com/web/geek/job?query=前端&city=100010000&page=' + i);

        await page.waitForSelector('.job-list-box');

        const jobs = await page.$eval('.job-list-box', el => {
            return [...el.querySelectorAll('.job-card-wrapper')].map(item => {
                return {
                    job: {
                        name: item.querySelector('.job-name').textContent,
                        area: item.querySelector('.job-area').textContent,
                        salary: item.querySelector('.salary').textContent
                    },
                    link: item.querySelector('a').href,
                    company: {
                        name: item.querySelector('.company-name').textContent
                    }
                }
            })
        });
        allJobs.push(...jobs);
    }

    // console.log(allJobs);

    for(let i = 0; i< allJobs.length; i ++) {
        await page.goto(allJobs[i].link);

        try{
            await page.waitForSelector('.job-sec-text');

            const jd= await page.$eval('.job-sec-text', el => {
                return el.textContent
            });
            allJobs[i].desc = jd;

            console.log(allJobs[i]);
        } catch(e) {}
    }
  }
  
}
```

这里原封不动的把之前的爬虫逻辑复制了过来，只是把 headless 设置为了 true，因为我们不需要界面。

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c3771b0555b4cd5aad11e492399018b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=908&h=252&s=24791&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/006ea5a260a24df28e00a679b60bbe99~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1806&h=1226&s=674664&e=png&b=181818)

爬虫跑的没啥问题。

不过这个过程中 boss 可能会检测到你访问频率过高，会让你做下是不是真人的验证：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e8590f9018b478eb63031c00a22d30f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1780&h=1102&s=155397&e=png&b=eef0f5)

这个就是验证码点点就好了。

然后我们把数据存到数据库里：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38e011871cd14870a8a1dfcdfc720566~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1092&h=990&s=204799&e=png&b=1f1f1f)

用 EntityManager 来 save 就好了：

```javascript
@Inject(EntityManager)
private entityManager: EntityManager;
```
```javascript
const job = new Job();

job.name = allJobs[i].job.name;
job.area = allJobs[i].job.area;
job.salary = allJobs[i].job.salary;
job.link = allJobs[i].link;
job.company = allJobs[i].company.name;
job.desc = allJobs[i].desc;

await this.entityManager.save(Job, job);
```
再跑下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/174db8ed016140e7b2252ebe22320461~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=832&h=210&s=23434&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/854c4ef9a33b48c6a9845d27007b5588~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1686&h=910&s=5167759&e=gif&f=35&b=1a1a1a)

去数据库里看下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbc3086343d94d75a3820a58ea0c1188~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1250&h=648&s=424247&e=png&b=f7f7f7)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cc9688ff68a44dd8b68de63dc11896c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1256&h=656&s=471799&e=png&b=f6f6f6)

这样，你就可以对这些职位描述做一些搜索，分析之类的了。
 
比如搜索职位描述中包含 react 的岗位：

```sql
SELECT * FROM `boss-spider`.job where `desc` like "%React%";
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84c759b449424ca19a591b127e5402d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234&h=766&s=412429&e=png&b=f7f7f7)

这样，爬虫就做完了。

如果想在前端实时看到爬取到的数据，可以通过 SSE 来实时返回：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e357dd1fdcda4a5a8dda77c91834beea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=792&h=184&s=22514&e=png&b=ffffff)

这样用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b36d04da9b4038ba500018334d6a32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702&h=526&s=76304&e=png&b=202020)

这里我们就不改了。

案例代码上传了 nest 小册仓库：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/boss-jd-spider

## 总结

我们通过 puppeteer 实现了对 BOSS 直聘网站的前端职位的爬取，并用 Nest + TypeORM 把数据保存到了数据库里。

这样就可以在本地对这些职位数据做一些处理或分析了。


## 94.实现扫二维码登录

扫码登录是常见的功能，基本各种网站都支持。

比如掘金的登录就支持 APP 扫码的方式：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fb47046ab8146eab82fb32fd9dc0fe4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1438&h=898&s=191078&e=png&b=f5f5f5)

如果你 APP 没登录，扫码后会跳到登录页面：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0182a6e1fb546d0bd1150c74eaf9050~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=476&h=1002&s=1435289&e=gif&f=29&b=fcfbfb)

登录之后，会进入确认界面，你可以选择授权登录或者取消：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b78b9d78cd9b4ec4b43365a7ce5f0a26~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=478&h=976&s=1081691&e=gif&f=45&b=fdfdfd)

这边确认之后，pc 网站就登录了。

知乎，b 站等也是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/383503009f304552b9d6fd592614e857~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1590&h=850&s=233151&e=png&b=ffffff)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28e706b5e1a44d21b73cf981cb44a414~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1554&h=670&s=130973&e=png&b=fefefe)

有没有感觉很神奇，为什么一扫二维码，然后确认下，那边就自动登录了呢？

其实原理也很简单。

我们先用解析工具解码下二维码的内容：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d8894d940ad4bcc8be2770b3be5fd45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=628&h=948&s=195555&e=png&b=fafafa)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dccfa3ca78964b58a8d95aae3c884dd7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=886&s=309358&e=png&b=f9f9f9)

可以看到，二维码的内容是一个 url，如果在手机浏览器打开，是这样的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f07126cc2fd48428a8d23862fd92be7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=636&h=1168&s=192864&e=png&b=fefdfd)

会让你下载 APP。

而在 APP 里打开，就是登录确认界面了：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92145ba5fb4e4d6f8cb87ce21c796067~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080&h=1505&s=111235&e=jpg&b=ffffff)

那确认的是哪个二维码呢？

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dccfa3ca78964b58a8d95aae3c884dd7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=646&h=886&s=309358&e=png&b=f9f9f9)

二维码这里是有个唯一 id 的，通过这个 id 就知道是哪个二维码。

这个二维码有 5 个状态：

- 未扫描
- 已扫描，等待用户确认
- 已扫描，用户同意授权
- 已扫描，用户取消授权
- 已过期

最开始是未扫描状态：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682727acbc2a45b785ae8e08f74794a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=482&h=534&s=45446&e=png&b=ffffff)

扫码后会进入等待用户确认状态：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b59ef0f07f542098b2141c857b0e073~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=418&h=530&s=49587&e=png&b=fbfbfb)

确认后会进入同意授权状态：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45bfdfbcb0c6482680c08e0cfff18d00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=482&h=534&s=46480&e=png&b=fcfcfc)

取消的话会进入取消授权状态：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/682727acbc2a45b785ae8e08f74794a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=482&h=534&s=45446&e=png&b=ffffff)

长时间不操作会进入过期状态：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74ccab5aa7a741c3b63c41a7eee00932~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=490&h=514&s=51254&e=png&b=fefefe)

也就是说，扫码后进行不同的操作就是修改这个 id 对应的二维码的状态。

另一边修改了状态，这边是怎么知道二维码状态变了呢？

websocket 么？

不用，一般都是轮询来做。

比如掘金：

二维码出现后，会有一个每秒一次的轮询请求来查询二维码状态：

最开始是 new：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/007fb6aebf714c8686f4a4e9ac1b75f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1986&h=1186&s=309276&e=png&b=f4f4f4)

扫码后会变成 scanned：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/652f04b6310f43fab83a71c23d999d1f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1880&h=1134&s=315938&e=png&b=f3f3f3)

知乎也是一样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cbcb7dd403041438ae83ee779b90914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1302&h=896&s=345535&e=png&b=fdf8f8)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67444d7606f348619610d7dc217a2c8c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1324&h=1184&s=457052&e=png&b=fdf7f7)

这时候，手机会进入登录确认页面：

bilibili 的登录确认页面：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e24874e2e9e455db4b281e981b5b1cc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=636&h=822&s=66456&e=png&b=ffffff)

知乎的登录确认页面：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc1a92ffa5e44f50a5ad1a44c56848da~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=468&h=1046&s=48147&e=png&b=ffffff)

这边点击确认登录或者取消之后，会发请求修改 id 对应的二维码的状态。

那边一直在轮询，自然就知道了二维码状态的变更。

也就是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e253865ec4a24d868d21774cb41d709d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1620&h=1110&s=151466&e=png&b=fefcfc)

服务端有个 qrcode/generate 接口，会生成一个随机的二维码 id，存到 redis 里，并返回二维码。

还有个 qrcode/check 接口，会返回 redis 里的二维码状态，浏览器里可以轮询这个接口拿到二维码状态。

然后手机 APP 扫码之后，如果没登录，会先跳转到登录页面，登录之后会进入登录确认页面。

这个时候就从二维码中拿到了 id，然后调用 qrcode/scan、qrcode/cancel、qrcode/confirm 就是修改二维码为不同的状态。

这时候用户是登录了的，jwt 的登录认证方式会携带 token，服务端只要从 token 中取出用户信息，存入 redis 即可。

然后另一边的轮询接口发现是确认状态，会根据用户信息生成 jwt 返回。

这样，手机 APP 里确认之后，pc 的浏览器就自动登录了该用户账号。

这里的 jwt 是保存登录状态的一种方案，会把用户信息放在 token 里返回，然后每次访问接口带上 authorization 的 header，携带 token。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d8ba39866154acbbf3c3f8006d265ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168&h=472&s=64050&e=png&b=ffffff)

思路理清了，我们来实现一下吧！

创建个 nest 项目：
```
npm install -g @nestjs/cli

nest new qrcode-login
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b752fa1160d46caaa326978a74f705e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=934&h=686&s=267305&e=png&b=010101)

把它跑起来：

```
npm run start:dev
```

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fafac79754a649d5a5778c1f8a6a1f27~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1864&h=506&s=149211&e=png&b=181818)

浏览器访问 http://localhost:3000 就可以可以看到 hello world，就代表服务跑起来了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6bd684dbb4f441c390b7f76268ee7cfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=552&h=186&s=16445&e=png&b=ffffff)

然后我们实现下生成二维码的接口：

安装下用到的包：

```
npm install qrcode @types/qrcode
```

添加一个路由：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68aab932c8504b2ca502e971483d598b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1190&h=1124&s=209155&e=png&b=1f1f1f)

```javascript
import { randomUUID } from 'crypto';
import * as qrcode from 'qrcode';
```
```javascript
@Get('qrcode/generate')
async generate() {
    const uuid = randomUUID();
    const dataUrl = await qrcode.toDataURL(uuid);
    return {
      qrcode_id: uuid,
      img: dataUrl
    }
}
```
这里用 node 的 crypto 模块生成一个随机的 uuid。

然后用 qrcode 生成二维码，只不过转成 base64 返回。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0eff253a775d4bf19c69dd98cc07062d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1120&h=432&s=156529&e=png&b=fdfdfd)

我们在 html 里把它渲染出来看一下：

新建 static/index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>扫码登录</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <img src="data:image/png;base64,这里填入你生成的 url" alt=""/>
</body>
</html>

```
然后在 main.ts 里支持这个目录下静态资源的访问，用 pages 作为前缀：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0af7e7200cc741d4bf8ec8346fb3c3c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1510&h=586&s=145389&e=png&b=1f1f1f)

```javascript
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.useStaticAssets('static', { prefix: '/pages'});

  await app.listen(3000);
}
bootstrap();
```

这样你访问 http://localhost:3000/pages/index.html 就可以看到二维码了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19ffbb16fffb4999a43d6ad3a1a95159~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=810&h=384&s=35573&e=png&b=fefefe)

我们用在线解码工具解码下看看：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8157992f29e14a85a1ade9b273b01155~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=612&h=668&s=76718&e=png&b=fbfbfb)

确实，内容就是生成的 uuid。

然后，其实这个二维码扫出的应该是个网址。

比如掘金的二维码解析出的内容：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15a7e655674e46a19ee70cabaaa37bd8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=696&h=796&s=159392&e=png&b=fbfbfb)

如果用手机浏览器扫这个码的话，打开的就是下载 APP 的页面：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b1ee0ad37594270931685e54cf80d4e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=500&h=1018&s=144169&e=png&b=fefdfd)

而如果用掘金 APP 扫码，扫出的就是登录确认页面了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cb5edeee7fb44d5a3f5ad6c4a0b6286~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=528&h=1062&s=68585&e=png&b=ffffff)

这个很正常，因为如果随便一个浏览器都能扫码打开登录确认页面，那谁还下载掘金 APP 呢？

所以掘金的二维码只能掘金 APP 扫，微信的二维码只能用微信 APP 扫。

这个页面做了检查，判断是 APP 打开的还是其他方式打开的，分别会显示不同的内容。

这里我们也改成一个 url：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3719fa4057487a894679444e9cd932~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1722&h=424&s=83805&e=png&b=1f1f1f)

扫码就会打开这个页面，而这个页面就是登录确认页面。

我们写一下这个页面：

新建 static/confirm.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扫码登录确认</title>
</head>
<body>
    <button>确认登录</button>
    <button>取消</button>
</body>
</html>
```
但这里有个问题，开发服务是在电脑上的，手机怎么访问呢？

这里需要用 charles 来做代理：

[下载 charles](https://www.charlesproxy.com/download/)，打开

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ae04affd87e455fa823a51a122a42b2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=266&h=280&s=59590&e=png&b=9c5301)

让电脑和手机连接同一个 wifi，然后在手机的 wifi 设置那里设置代理：

代理的 ip 是电脑 ip，端口号就是 charles 代理服务的默认端口 8888

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c359f2d13a5a4732aba7d3cd97795ff3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=422&h=836&s=74404&e=png&b=fcfcfc)

这时候电脑上会收到连接提醒，同意下就好了：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7ad193b9814f808951345886b1ca22~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548&h=374&s=103014&e=png&b=edecec)

然后手机就可以访问电脑上的 nest 服务：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91613f501696463fbde4527b56043577~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=526&h=254&s=28438&e=png&b=fcfcfc)

看到这个 hello world 了没？

这就是电脑上的这个 nest 服务返回的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b914063711e84a39b64d20295af04f30~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=556&h=170&s=17190&e=png&b=ffffff)

那个登录确认页面在电脑访问是这样的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5355ebdbd8794068a8d5c11de7ffd4c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1000&h=256&s=31240&e=png&b=fefefe)

然后我把二维码的内容改为这个：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d8f6199974948999d2f7fa38a17e538~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1778&h=400&s=84824&e=png&b=1f1f1f)

修改下展示二维码的页面：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>扫码登录</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
</head>
<body>
    <img id="img" src="" alt=""/>

    <script>
        axios.get('http://localhost:3000/qrcode/generate').then(res => {
            document.getElementById('img').src = res.data.img;
        })
    </script>
</body>
</html>
```
用 axios 请求生成二维码的接口，然后修改图片 src。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/506a59ae214e4e30ac46f3a1d7433535~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=766&h=426&s=37165&e=png&b=fefefe)

用手机扫码下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cf518d1fc74407a893c4db5006d77a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=484&h=858&s=2198287&e=gif&f=40&b=eeeded)

用微信扫码，可以看到，打开了登录确认页面。

按钮有点小，我们设置下样式。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扫码登录确认</title>
    <style>
        #info {
            height: 400px;
            line-height: 400px;
            font-size: 20px;
            padding: 20px;
        }
        #confirm, #cancel{
            display: block;
            width: 80%;
            line-height: 40px;
            font-size: 20px;
            margin-bottom: 20px;
        }
        #confirm {
            background: skyblue;
        }
    </style>
</head>
<body>
    <div id="info">
        是否确认登录 xxx 网站？
    </div>
    <button id="confirm">确认登录</button>
    <button id="cancel">取消</button>
</body>
</html>
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e19a73abaa9b48e5af24369a1166cb53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=454&h=826&s=2135402&e=gif&f=36&b=edecec)

好看多了。

二维码的内容解码后是这样的：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34dfd9cf20bc40309f15035451d36719~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=670&h=656&s=107357&e=png&b=fafafa)

然后我们来实现剩下的接口：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14b352ece74f47e48a1f4d366fd08b73~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1620&h=1110&s=138991&e=png&b=fefcfc)

生成二维码之后，要在 redis 里保存一份，这里我们简化一下，直接用个 map 保存吧。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a865258dd20c4e97b5adc47dfd3ec81a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1358&h=1400&s=288652&e=png&b=1f1f1f)

```javascript
const map = new Map<string, QrCodeInfo>();

interface QrCodeInfo{
  status: 'noscan' | 'scan-wait-confirm' | 'scan-confirm' | 'scan-cancel' | 'expired',
  userInfo?: {
    userId: number;
  }
}
// noscan 未扫描
// scan-wait-confirm -已扫描，等待用户确认
// scan-confirm 已扫描，用户同意授权
// scan-cancel 已扫描，用户取消授权
// expired 已过期
```
```javascript
map.set(`qrcode_${uuid}`, {
  status: 'noscan'
});
```
然后加一个 qrcode/check 接口，用来查询二维码状态：

```javascript
@Get('qrcode/check')
async check(@Query('id') id: string) {
    return map.get(`qrcode_${id}`);
}
```
测试下：

访问 /qrcode/generate 生成二维码和 id

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32a0669d416d45588dd18e90c9392a04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=506&s=206489&e=png&b=fcfcfc)

然后访问 /qrcode/check 拿到这个 id 的状态：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c5997fff544697ada987914cb311b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1140&h=162&s=29297&e=png&b=ffffff)

然后再实现 /qrcode/confirm、/qrcode/cancel、/qrcode/scan 这三个接口：

```javascript
@Get('qrcode/scan')
async scan(@Query('id') id: string) {
    const info = map.get(`qrcode_${id}`);
    if(!info) {
      throw new BadRequestException('二维码已过期');
    }
    info.status = 'scan-wait-confirm';
    return 'success';
}

@Get('qrcode/confirm')
async confirm(@Query('id') id: string) {
    const info = map.get(`qrcode_${id}`);
    if(!info) {
      throw new BadRequestException('二维码已过期');
    }
    info.status = 'scan-confirm';
    return 'success';
}

@Get('qrcode/cancel')
async cancel(@Query('id') id: string) {
    const info = map.get(`qrcode_${id}`);
    if(!info) {
      throw new BadRequestException('二维码已过期');
    }
    info.status = 'scan-cancel';
    return 'success';
}
```
测试下：

先 qrcode/generate 生成二维码，拿到 id：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bde202b2c084200aa97f3cdccaa48ef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1260&h=560&s=249395&e=png&b=fdfdfd)

然后调用 qrcode/scan 修改状态，之后调用 qrcode/check 查询下状态：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8dd2fc138074fb585b663444ab44a9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=962&h=168&s=25143&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8d4ceb466724d64a9e949a7571f18f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=890&h=212&s=26986&e=png&b=ffffff)

同样的方式测试 qrcode/cancel 和 qrcode/confirm 接口：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65556923d4994c7cbeb65a89f75a0cc6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=902&h=212&s=24523&e=png&b=ffffff)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd5ee75b095a4ef7858a6649f774fe79~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=892&h=200&s=26773&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34d293f791ae4f57b87b213581be92f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=854&h=196&s=23978&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/431da08bfbfa42b7b42113b434e6db9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=976&h=178&s=26816&e=png&b=ffffff)

如果 id 不存在，会返回 400 的状态码：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8673fb355f2e46d9a4d25747244b6717~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1152&h=298&s=61640&e=png&b=ffffff)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93911a7b52f342118a5859763578f210~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1474&h=200&s=36243&e=png&b=ffffff)

然后就可以在 static/index.html 里加上 qrcode/check 接口来轮询二维码状态了。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>扫码登录</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
</head>
<body>
    <img id="img" src="" alt=""/>
    <div id="info"></div>
    <script>
        axios.get('http://localhost:3000/qrcode/generate').then(res => {
            document.getElementById('img').src = res.data.img;

            queryStatus(res.data.qrcode_id);
        })

        function queryStatus(id) {
            axios.get('http://localhost:3000/qrcode/check?id=' + id).then(res => {
                const status = res.data.status;

                let content = '';
                switch(status) {
                    case 'noscan': content = '未扫码'; break;
                    case 'scan-wait-confirm': content = '已扫码，等待确认'; break;
                    case 'scan-confirm': content = '已确认'; break;
                    case 'scan-cancel': content = '已取消'; break;
                }
                document.getElementById('info').textContent = content;

                if(status === 'noscan' || status === 'scan-wait-confirm') {
                    setTimeout(() => queryStatus(id), 1000);
                }
            })
        }
    </script>
</body>
</html>
```
生成二维码之后，就开始轮询状态了。

根据状态分别显示不同的文字，如果不是已确认或者已取消就在一秒后继续下次轮询。

然后，在登录确认页面也加上接口调用：

改下 static/confirm.html

使用 URLSearchParams 的 api 拿到 url 中的 id：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/498039aceff849ed9a5fd3f1c09fbaef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1144&h=684&s=83334&e=png&b=ffffff)

然后修改这个 id 对应的二维码的状态。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扫码登录确认</title>
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
    <style>
        #info {
            height: 400px;
            line-height: 400px;
            font-size: 20px;
            padding: 20px;
        }
        #confirm, #cancel{
            display: block;
            width: 80%;
            line-height: 40px;
            font-size: 20px;
            margin-bottom: 20px;
        }
        #confirm {
            background: skyblue;
        }
    </style>
</head>
<body>
    <div id="info">
        是否确认登录 xxx 网站？
    </div>
    <button id="confirm">确认登录</button>
    <button id="cancel">取消</button>

    <script>
        const params = new URLSearchParams(window.location.search.slice(1));

        const id = params.get('id');

        axios.get('http://192.168.31.56:3000/qrcode/scan?id=' + id).catch(e => {
            alert('二维码已过期');
        });
        
        document.getElementById('confirm').addEventListener('click', () => {
            axios.get('http://192.168.31.56:3000/qrcode/confirm?id=' + id).catch(e => {
                alert('二维码已过期');
            });
        });

        document.getElementById('cancel').addEventListener('click', () => {
            axios.get('http://192.168.31.56:3000/qrcode/cancel?id=' + id).catch(e => {
                alert('二维码已过期');
            });
        });
    </script>
</body>
</html>
```
进入这个页面，就访问 qrcode/scan 接口，来把 id 对应的二维码改为已扫描状态。

点击确认或者取消按钮也分别修改状态为确认和取消。

注意，这个页面是在手机打开的，需要通过 ip 的方式访问接口。

测试下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df25ae7a819e44c89085f7423fdaea1a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1294&h=1128&s=175212&e=png&b=fefefe)

打开页面后，生成二维码，这时候就开始轮询二维码状态。

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba4aa28a974b424192a8f2187a91e561~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=564&h=1080&s=2449704&e=gif&f=31&b=edecec)

手机扫码，进入登录确认页面。

这时候二维码页面的状态变为了等待确认：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a746d614b3f64efdb96abf782c279541~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1246&h=1100&s=167076&e=png&b=fefefe)

然后确认登录，这时候 pc 页面变为了已确认状态：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2968738cbb14eeca61adf33079a027e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=506&h=590&s=33749&e=png&b=fdfdfd)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0069dbfa26684ad78e3c67e5675472ee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1172&h=1054&s=145738&e=png&b=fefefe)

如果点击取消，那就会变为已取消状态：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d41bb6e935a040ca82a2d58c14cd626c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=1066&s=149096&e=png&b=fefefe)

这就是扫码之后，pc 上的二维码同步改变状态的原理。

当然，最终我们是要做登录的。

确认之后，就要拿到这边的登录状态，从中取出用户信息。

当然，现在我们还没做登录。

我们通过 jwt 搞一下：

引入 jwt 的 包：

```
npm install @nestjs/jwt
```

在 AppModule 里引入它：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d73cce32ac3c4310aadd059b5bfc57d4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=808&h=714&s=125928&e=png&b=1f1f1f)

然后实现登录接口：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd64743493af46568c9c6a6d367e2dc2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1692&h=1256&s=259718&e=png&b=1f1f1f)

这里我们没有用数据库，只有 2 个用户，如果信息匹配，就返回 jwt 的 token：
```javascript
@Inject(JwtService)
private jwtService: JwtService;

private users = [
    {id: 1, username: 'dong', password: '111'},
    {id: 2, username: 'guang', password: '222'},
];

@Get('login')
async login(@Query('username') username: string, @Query('password') password: string) {

    const user = this.users.find(item => item.username === username);

    if(!user) {
      throw new UnauthorizedException('用户不存在');
    }
    if(user.password !== password) {
      throw new UnauthorizedException('密码错误');
    }

    return {
      token: await this.jwtService.sign({
      userId: user.id
    })
}
```
postman 里测试下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4f87496e12c47528e24322e1ef050aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1002&h=706&s=78880&e=png&b=fcfcfc)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98ddf9d9bba84df5b4834c925db67392~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1056&h=776&s=89706&e=png&b=fcfcfc)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/781ec9ffe9b34d7888039312311605b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1186&h=708&s=88776&e=png&b=fcfcfc)

登录成功后，会返回 token。

这个 token 一般都是在访问接口的时候放在 authorization 的 header 里，通过 Bearer xxx 的方式。

我们添加一个 userInfo 的接口来拿到用户信息：

```javascript
@Get('userInfo')
async userInfo(@Headers('Authorization') auth: string) {
    try{
      const [, token] = auth.split(' ');
      const info = await this.jwtService.verify(token);

      const user = this.users.find(item => item.id == info.userId);
      return user;
    } catch(e) {
      throw new UnauthorizedException('token 过期，请重新登录');
    }
}
```
它会从 header 中取出 token，解析出其中的信息，从而拿到 userId，然后查询 id 对应的用户信息返回。

我们加上 authorization 的 header，访问下 userInfo 接口：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca79ec37b0e94bf79ab213afc12fa781~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1162&h=710&s=88816&e=png&b=fbfbfb)

可以看到，拿到了用户的信息。

然后我们在登录确认页面加上登录：

添加两个按钮：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a17c0ea10dd145008880099dd68b066f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=866&h=146&s=35108&e=png&b=202020)

这俩按钮分别是登录不同的账号，拿到 token：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1902e94ca9d4b289a1bb8381834353e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1258&h=1052&s=168297&e=png&b=1f1f1f)

访问 confirm 接口时带上这个 token：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3558d46dbe824dec90b4b6ae9789dacd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1332&h=826&s=173309&e=png&b=1f1f1f)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扫码登录确认</title>
    <script src="https://unpkg.com/axios@1.5.0/dist/axios.min.js"></script>
    <style>
        #info {
            height: 400px;
            line-height: 400px;
            font-size: 20px;
            padding: 20px;
        }
        #confirm, #cancel{
            display: block;
            width: 80%;
            line-height: 40px;
            font-size: 20px;
            margin-bottom: 20px;
        }
        #confirm {
            background: skyblue;
        }
    </style>
</head>
<body>
    <button id="guang">登录光光账号</button>
    <button id="dong">登录东东账号</button>

    <div id="info">
        是否确认登录 xxx 网站？
    </div>
    <button id="confirm">确认登录</button>
    <button id="cancel">取消</button>

    <script>
        const params = new URLSearchParams(window.location.search.slice(1));

        const id = params.get('id');

        let token = '';
        document.getElementById('dong').addEventListener('click', () => {
            axios.get('http://192.168.31.56:3000/login', {
                params: {
                    username: 'dong',
                    password: '111'
                }
            }).then(res => {
                token = res.data.token;
            });
        });

        document.getElementById('guang').addEventListener('click', () => {
            axios.get('http://192.168.31.56:3000/login', {
                params: {
                    username: 'guang',
                    password: '222'
                }
            }).then(res => {
                token = res.data.token;
            });
        });

        axios.get('http://192.168.31.56:3000/qrcode/scan?id=' + id).catch(e => {
            alert('二维码已过期');
        });
        
        document.getElementById('confirm').addEventListener('click', () => {
            axios.get('http://192.168.31.56:3000/qrcode/confirm?id=' + id, {
                headers: {
                    authorization: 'Bearer ' + token
                }
            }).catch(e => {
                alert('二维码已过期');
            });
        });

        document.getElementById('cancel').addEventListener('click', () => {
            axios.get('http://192.168.31.56:3000/qrcode/cancel?id=' + id).catch(e => {
                alert('二维码已过期');
            });
        });
    </script>
</body>
</html>
```
然后我们在 qrcode/confirm 接口里把 token 取出来，拿到其中的用户信息，保存到 map 里：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39604c336b8547279f6e7dcaa05bba55~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462&h=888&s=182870&e=png&b=1f1f1f)

```javascript
@Get('qrcode/confirm')
async confirm(@Query('id') id: string, @Headers('Authorization') auth: string) {
    let user;
    try{
      const [, token] = auth.split(' ');
      const info = await this.jwtService.verify(token);

      user = this.users.find(item => item.id == info.userId);
    } catch(e) {
      throw new UnauthorizedException('token 过期，请重新登录');
    }

    const info = map.get(`qrcode_${id}`);
    if(!info) {
      throw new BadRequestException('二维码已过期');
    }
    info.status = 'scan-confirm';
    info.userInfo = user;
    return 'success';
}
```
这样，当扫码确认后，那边就能拿到用户信息：

我们改下 static/index.html

确认的时候展示下登录用户的信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d80ee62f9e6e4526966e9b04cb9e7ba3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1562&h=716&s=179685&e=png&b=1f1f1f)

加上登录之后，我们再测试下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7fa9d20c9f04917bf6c8a631d2cb5a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=840&h=508&s=42114&e=png&b=ffffff)

手机扫码，点击登录光的账号，然后确认登录：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef637d571a484fa79fb7445f5bf4e0c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=664&h=1160&s=2104022&e=gif&f=23&b=8b8a8a)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0fe0804c441487f92d1d5647ff35d74~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=762&h=504&s=45558&e=png&b=fefefe)

刷新页面，重新扫码，然后登录东东账号。

这时候 pc 网站就显示了当前登录用户是 dong

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9505acdb3fb34872b69f605261ac5827~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=776&h=518&s=45876&e=png&b=fefefe)

当然，登录状态需要一个 jwt，我们返回下就好了。

```javascript
@Get('qrcode/check')
async check(@Query('id') id: string) {
    const info = map.get(`qrcode_${id}`);
    if(info.status === 'scan-confirm') {
        return {
          token: await this.jwtService.sign({
            userId: info.userInfo.userId
          }),
          ...info
        }
    }
    return info;
}
```
这样，当那边确认登录之后，这边就拿到了 jwt 的 token，也就是完成了登录了：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115f1d484a2d4faf86c64d12cb056f79~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1648&h=1162&s=229328&e=png&b=fefefe)

对比下掘金的扫码登录流程：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d4e3c15bb5547728d2fb5e846d67fa0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1438&h=898&s=176458&e=png&b=f5f5f5)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf5208c73d254b27ac5e223b5a61e45f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=476&h=1002&s=169977&e=png&b=fdfcfc)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ced7c4b4d7464a82b59497e259444b41~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=478&h=976&s=99098&e=png&b=fdfdfd)

是不是一摸一样？

扫码登录就是这样实现的。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/qrcode-login)

## 总结
扫码登录是常用的功能，掘金、知乎、b 站等各大网站都有。

流程是在 pc 选择扫码登录的方式，用 APP 扫码，在 app 上登录之后进入登录确认页面。

可以点击确认登录或者取消，如果确认登录，那 pc 网站就会自动登录该账号。

它的实现原理是这样的：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a7469b3869b47b386b9b894d5b947c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1620&h=1110&s=139485&e=png&b=fefcfc)

pc 端生成二维码，然后不断轮询二维码状态。

APP 里扫码拿到 qrcode_id，然后分别调用 scan、confirm、cancel 来修改二维码状态。

并且登录之后会把 token 带过去。

在 redis 里保存着二维码的状态和用户信息，然后这边确认之后，另一边就可以用 userInfo 生成 jwt 的 token，从而实现登录。

这就是扫码登录的实现原理。



## 95.Nest 的 REPL 模式

我们写过很多 Module、Service、Controller，但这些都要服务跑起来之后在浏览器里访问对应的 url，通过 get 或者 post 的方式传参来测试。

这个还是挺麻烦的，能不能像 node 的 repl 那样，直接在控制台测试呢？

repl 是 read-eval-paint-loop，也就是这个：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/777cf2c0ab8b4f648dc795a37f320162~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=566&h=482&s=51437&e=png&b=000000)

Nest 能不能这样来测试呢？

可以的，Nest 支持 repl 模式。

我们创建个 Nest 项目：

```
nest new repl-test
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/137a3efc322e4e26ba648fb4a617f2f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=840&h=642&s=141942&e=png&b=010101)

然后创建两个模块：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6754d51a50bb4e16866d1c4483ba3c2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=926&h=1016&s=239764&e=png&b=191919)

把服务跑起来：

```
npm run start:dev
```
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/086be719b6654c86a246a2858423b588~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1704&h=994&s=451390&e=png&b=181818)

浏览器访问下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c09659fd4f4649f59ad5f9ba34369c4c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=600&h=182&s=19289&e=png&b=ffffff)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0d3997c6ede4de5a952612758bd4505~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=604&h=204&s=19983&e=png&b=ffffff)

我们前面都是这么测试接口的。

其实还可以用 repl 模式。

在 src 下创建个 repl.ts，写入如下内容：

```javascript
import { repl } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  await repl(AppModule);
}
bootstrap();
```
然后把服务停掉，通过这种方式跑：

```
npm run start:dev -- --entryFile repl
```

这里的 --entryFile 是指定入口文件是 repl.ts

前面带了个 -- 是指后面的参数不是传给 npm run start:dev 的，要原封不动保留。

也就是会传给 nest start

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b21e78e1a14452c80196ae20c545812~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=114&s=25838&e=png&b=202020)

当然，你直接执行 nest start 也可以：

```
nest start --watch --entryFile repl
```

跑起来后，执行 debug()，会打印所有的 module 和 module 下的 controllers 和 providers。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b15e5eb0e5b474db29720e3211d9a9d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=588&h=794&s=87297&e=png&b=181818)

而且，你可以 get() 来取对应的 providers 或者 controllers 调用：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebfcd94265ab490a8d31e3ebf6b542f5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1062&h=698&s=116051&e=png&b=1c1c1c)

get、post 方法都可以调用。

有的同学说，你这个 post 方法没有参数啊。

那我们加一些：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdf7f5845e854489b829e8186aac5695~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690&h=286&s=36309&e=png&b=1f1f1f)

然后添加 ValidationPipe：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01be04999b794519b5e3fdf793c37b82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1046&h=612&s=127403&e=png&b=1f1f1f)

安装校验相关的包：

```
npm install class-validator class-transformer
```

在 dto 添加约束：

```javascript
import { IsEmail, IsNotEmpty } from "class-validator";

export class CreateAaaDto {
    @IsNotEmpty()
    aaa: string;

    @IsEmail()
    bbb: string;
}
```

我们先正常跑下服务：

```
npm run start:dev
```
然后 postman 里测试下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c14f46a195014e37b9c954d504fbfb5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=788&h=838&s=83951&e=png&b=fcfcfc)

可以看到，ValidationPipe 生效了。

那 repl 里是不是一样呢？

我们再跑下 repl 模式：

```
npm run start:dev -- --entryFile repl
```

可以看到，并没有触发 pipe：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfd8ec0cd0ff4570b7a77d1794988bcd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098&h=804&s=167939&e=png&b=1b1b1b)

也就是说，它只是单纯的传参调用这个函数，不会解析装饰器。

所以测试 controller 的话，repl 的方式是有一些限制的。

但是测试 service 很不错：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/637e0aaca9bd4ffca0ea475da193c2bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=644&h=214&s=26237&e=png&b=181818)

比如测试某个项目的 UserService 的 login 方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c56f9d0f87ac40a5978c5f47ecd902fa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534&h=1422&s=336812&e=png&b=191919)

就很方便。

大概知道 repl 模式是做啥的之后，我们过一下常用的 api：

debug() 可以查看全部的 module 或者某个 module 下的 cotrollers、providers：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47567c24da6341bb93687460679247a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=466&h=644&s=62438&e=png&b=181818)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8bf9ec2ffbd40a8a1b9b97fc276aa44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=426&h=296&s=28159&e=png&b=181818)

methods() 可以查看某个 controller 或者 provider 的方法：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/843e3284b7444bff885c5a825cf853a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=530&h=338&s=27089&e=png&b=181818)

get() 或者 $() 可以拿到某个 controller 或者 provider 调用它的方法：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e4482f8468f4657aa76e08100e363d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&h=288&s=40856&e=png&b=181818)

常用的 api 就这些。

此外，按住上下键可以在历史命令中导航：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981e59361f9e45b0b425cdedcf8e0bd3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234&h=718&s=96689&e=gif&f=26&b=191919)

但有个问题。

当你重新跑之后，这些命令历史就消失了，再按上下键也没有历史。

可以改一下 repl.ts：

```javascript
import { repl } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
    const replServer = await repl(AppModule);
    replServer.setupHistory(".nestjs_repl_history", (err) => {
        if (err) {
            console.error(err);
        }
    });
}
bootstrap();

```
再跑的时候也是有历史的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d9ffa40680b4004a7f84bba633b0524~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1572&h=764&s=319655&e=gif&f=42&b=191919)

其实就是 nest 会把历史命令写入文件里，下一次跑就可以用它恢复历史了：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7adf2d8d4d024957b788c25fd46cf2af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=482&h=272&s=27250&e=png&b=1f1f1f)

你还可以把这个命令配到 npm scripts 里：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8da4ff55b144c98b61c6a4ab7af0873~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=924&h=114&s=25935&e=png&b=202020)

然后直接 npm run repl:dev 来跑。

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/repl-login)。

## 总结

这节我们学了 nest 的 repl 模式。

repl 模式下可以直接调用 controller 或者 provider 的方法，但是它们并不会触发 pipe、interceptor 等，只是传参测试函数。

可以使用 debug() 拿到 module、controller、provider 的信息，methods() 拿到方法，然后 get() 或者 $() 拿到 controller、provider 然后调用。

repl 模式对于测试 service 或者 contoller 的功能还是很有用的。


## 96.实现 Excel 导入导出

Excel 是常用的办公软件，我们会用它来做数据的整理。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d93156a170f4c23a75cbce3f40014ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020&h=536&s=63426&e=png&b=fdfdfd)

后台管理系统一般都会支持从 Excel 导入数据，或者导出数据到 Excel 文件：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c36b870e0ce24a9e86fae6f06bb63876~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1378&h=640&s=119707&e=png&b=d6d6d6)

那这种功能是如何实现的呢？

在 Node 和浏览器里，如何解析、生成 Excel 文件呢？

一般我们会用 [exceljs](https://www.npmjs.com/package/exceljs) 这个包来做。

在 npm 官网可以看到，这个包每周有 30w+ 的下载量，用的还是很多的：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e4a95a769c4423bb83ae6102e9efe23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=694&h=514&s=43873&e=png&b=fefefe)

我们具体写代码试试：

```
mkdir exceljs-test
cd exceljs-test
npm init -y
```
![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c18b7a56c1b4208a686bcedc5da71ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=820&h=666&s=86286&e=png&b=010101)

安装 exceljs：

```
npm install --save exceljs
```
把刚才这个 excel 文件复制过来：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d93156a170f4c23a75cbce3f40014ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020&h=536&s=63426&e=png&b=fdfdfd)

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b591b0ae6914488aa20cb9ef8135ab83~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=410&h=244&s=24754&e=png&b=191919)

我们在代码里读取出来看看：

```javascript
const { Workbook } = require('exceljs');

async function main(){
    const workbook = new Workbook();

    const workbook2 = await workbook.xlsx.readFile('./data.xlsx');

    workbook2.eachSheet((sheet, index1) => {
        console.log('工作表' + index1);

        sheet.eachRow((row, index2) => {
            const rowData = [];
    
            row.eachCell((cell, index3) => {
                rowData.push(cell.value);
            });

            console.log('行' + index2, rowData);
        })
    })
}

main();
```
工作表就是这个东西：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb7c74166adc4b50ba7af7a6db9b2fa2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1160&h=894&s=285150&e=gif&f=42&b=fdfdfd)

每个工作表下都是独立的表格。

也就是 workbook（工作簿） > worksheet（工作表） > row（行） > cell（列）这样的层级关系。

每一层都可以遍历：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a8e52d5819d4f6ca1cefaab0b32e173~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020&h=818&s=127582&e=png&b=1f1f1f)

所以我们遍历 sheet、row、cell 这几层，就能拿到所有的数据。

跑下看看：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28013f43c3ce4ae89200190d697944f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=822&h=204&s=44099&e=png&b=181818)

确实都拿到了。

这样就是数据导入，我们从 excel 文件里解析出数据，然后存入数据库。

exceljs 还提供了简便的方法，可以直接调用 worksheet 的 getSheetValues 来拿到表格数据，不用自己遍历：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bb978d8799d4752ab3832eb744818ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1030&h=970&s=183332&e=png&b=1d1d1d)

解析 excel 文件还是很简单的。

导入数据的时候，按照格式从中解析数据然后存入数据库就行。

有同学可能会说，那如果 excel 的格式不符合要求呢？

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cb4f54f3eaf4ad78b3604395a42759a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=970&h=578&s=94262&e=png&b=eeeeee)

一般我们都会提供一个 excel 模版，用这个模版来填数据，然后再导入。

excel 解析我们会了，再来看下 excel 的生成：

```javascript
const { Workbook } = require('exceljs');

async function main(){
    const workbook = new Workbook();

    const worksheet = workbook.addWorksheet('guang111');

    worksheet.columns = [
        { header: 'ID', key: 'id', width: 20 },
        { header: '姓名', key: 'name', width: 30 },
        { header: '出生日期', key: 'birthday', width: 30},
        { header: '手机号', key: 'phone', width: 50 }
    ];

    const data = [
        { id: 1, name: '光光', birthday: new Date('1994-07-07'), phone: '13255555555' },
        { id: 2, name: '东东', birthday: new Date('1994-04-14'), phone: '13222222222' },
        { id: 3, name: '小刚', birthday: new Date('1995-08-08'), phone: '13211111111' }
    ]
    worksheet.addRows(data);

    workbook.xlsx.writeFile('./data2.xlsx');    
}

main();
```
相当简单，也是按照层次结构，先 addWorkSheet、然后 addRows，之后写入文件。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2e9d654fbf476a9bcbf843929e9385~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1704&h=976&s=107669&e=png&b=fefefe)

可以看到 worksheet 的名字，还有每行的数据都是对的。

右边手机号那一列最宽，因为我们设置了 width 是 50。

excel 是可以设置格式的，比如字体、背景色等，在代码里同样可以。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95ef121dde384041b6283b594c581d58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1012&h=1038&s=175284&e=png&b=1f1f1f)

就是遍历 row、cell，根据行数设置 style 就好了：
```javascript
worksheet.eachRow((row, rowIndex) => {
    row.eachCell(cell => {
        if(rowIndex === 1) {
            cell.style = {
                font: {
                    size: 10,
                    bold: true,
                    color: { argb: 'ffffff' }
                },
                alignment: { vertical: 'middle', horizontal: 'center' },
                fill: {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: '000000' }
                },
                border: {
                    top: { style: 'dashed', color: { argb: '0000ff' } },
                    left: { style: 'dashed', color: { argb: '0000ff' } },
                    bottom: { style: 'dashed', color: { argb: '0000ff' } },
                    right: { style: 'dashed', color: { argb: '0000ff' } }
                }
            }
        } else {
            cell.style = {
                font: {
                    size: 10,
                    bold: true,
                },
                alignment: { vertical: 'middle', horizontal: 'left' },
                border: {
                    top: { style: 'dashed', color: { argb: '0000ff' } },
                    left: { style: 'dashed', color: { argb: '0000ff' } },
                    bottom: { style: 'dashed', color: { argb: '0000ff' } },
                    right: { style: 'dashed', color: { argb: '0000ff' } }
                }
            }
        }
    })
})
```
style 可以设置 font、fill、border、alignment 这些。

跑下看看：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3233def7c38d4047b0ea9eb90c555aa9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1732&h=506&s=78554&e=png&b=fefefe)

这样，就完成了数据的导出。

而且，exceljs 这个库可以直接在浏览器里用。

我们试试：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d20a3d223934f0296f629780100f8a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1292&h=1148&s=235094&e=png&b=1f1f1f)

创建 index.html，引入 exceljs 包。

添加一个 file 类型的 input，onchange 的时候解析其中的内容，解析逻辑和之前一样，只是从 readFile 换成 load。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/exceljs@4.4.0/dist/exceljs.min.js"></script>
</head>
<body>
    <input id="fileInput" type="file"/>
    <script>
        const fileInput = document.getElementById('fileInput');
        fileInput.onchange = async () => {
            const file = fileInput.files[0];

            const { Workbook } = ExcelJS;

            const workbook = new Workbook();

            const workbook2 = await workbook.xlsx.load(file);

            workbook2.eachSheet((sheet, index1) => {
                console.log('工作表' + index1);

                const value = sheet.getSheetValues();

                console.log(value);
            })
        }
    </script>
</body>
</html>
```
起个静态服务：

```
npx http-server .
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e316343d7ec743b4b661840d79f62f80~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=594&h=546&s=83162&e=png&b=181818)

浏览器访问下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffb5b97548c14580b1e626946525853c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1146&h=834&s=115567&e=png&b=fefefe)

可以看到，同样解析出了 excel 的内容。

然后再试试生成 excel：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e726e420d33844ee9b87f0e273d0f03f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1224&h=1002&s=211065&e=png&b=202020)

前面的逻辑一样，只是把 writeFile 换成了 writeBuffer。

这里我创建了一个 10M 的 ArrayBuffer 来写入数据，之后再读取。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/exceljs@4.4.0/dist/exceljs.min.js"></script>
</head>
<body>
    <script>
        const { Workbook } = ExcelJS;

        async function main(){
            const workbook = new Workbook();

            const worksheet = workbook.addWorksheet('guang111');

            worksheet.columns = [
                { header: 'ID', key: 'id', width: 20 },
                { header: '姓名', key: 'name', width: 30 },
                { header: '出生日期', key: 'birthday', width: 30},
                { header: '手机号', key: 'phone', width: 50 }
            ];

            const data = [
                { id: 1, name: '光光', birthday: new Date('1994-07-07'), phone: '13255555555' },
                { id: 2, name: '东东', birthday: new Date('1994-04-14'), phone: '13222222222' },
                { id: 3, name: '小刚', birthday: new Date('1995-08-08'), phone: '13211111111' }
            ]
            worksheet.addRows(data);

            worksheet.eachRow((row, rowIndex) => {
                row.eachCell(cell => {
                    if(rowIndex === 1) {
                        cell.style = {
                            font: {
                                size: 10,
                                bold: true,
                                color: { argb: 'ffffff' }
                            },
                            alignment: { vertical: 'middle', horizontal: 'center' },
                            fill: {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: { argb: '000000' }
                            },
                            border: {
                                top: { style: 'dashed', color: { argb: '0000ff' } },
                                left: { style: 'dashed', color: { argb: '0000ff' } },
                                bottom: { style: 'dashed', color: { argb: '0000ff' } },
                                right: { style: 'dashed', color: { argb: '0000ff' } }
                            }
                        }
                    } else {
                        cell.style = {
                            font: {
                                size: 10,
                                bold: true,
                            },
                            alignment: { vertical: 'middle', horizontal: 'left' },
                            border: {
                                top: { style: 'dashed', color: { argb: '0000ff' } },
                                left: { style: 'dashed', color: { argb: '0000ff' } },
                                bottom: { style: 'dashed', color: { argb: '0000ff' } },
                                right: { style: 'dashed', color: { argb: '0000ff' } }
                            }
                        }
                    }
                })
            })

            const arraybuffer = new ArrayBuffer(10 * 1024 * 1024);
            const res = await workbook.xlsx.writeBuffer(arraybuffer);

            console.log(res.buffer);
        }

        main();
    </script>
</body>
</html>
```
跑下试试：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/348ad82e55ee4618b12c071c7d7300ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=924&h=1080&s=104568&e=png&b=ffffff)

可以看到，确实有数据了。

那有了 arraybuffer 的数据，如何触发下载呢？

创建一个 a 标签，设置 download 属性，然后触发点击就可以了。

也就是这样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/435f792813204ef992932295b04a40b5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=984&h=848&s=155108&e=png&b=1f1f1f)

```javascript
function download(arrayBuffer) {
    const link = document.createElement('a');

    const blob = new Blob([arrayBuffer]);
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.download = 'guang.xlsx';

    document.body.appendChild(link);

    link.click();
    link.addEventListener('click', () => {
        link.remove();
    });
}
```
跑一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10353e0521545a2820abd644bb73f45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=930&h=292&s=57738&e=png&b=fefefe)

可以看到，生成了 excel 并且触发了下载。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9090e02d4ca847d5a4a80928b6f516a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1722&h=364&s=52811&e=png&b=fdfdfd)

打开文件，可以看到和 node 里生成的一样。

案例代码上传了 github：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/exceljs-test

## 总结

Excel 的导入导出是后台管理系统的常见功能，我们一般用 exceljs 来实现。

excel 文件分为 workbook、worksheet、row、cell 这 4 层，解析和生成都是按照这个层次结构来。

解析就是 readFile 之后，遍历 worksheet、row，拿到 cell 中的数据 。

生成就是 addWorkSheet、addRow 添加数据，然后 writeFile 来写入文件。

如果是在浏览器里，就把 readFile 换成 load，把 writeFile 换成 writeBuffer 就好了。

浏览器里生成 excel 之后，可以通过 a 标签触发下载，设置 download 属性之后，触发点击就好了。

这样，我们就分别在 node 和浏览器里完成了 excel 的解析和生成。

## 97.如何用代码动态生成 PPT

假设有一天，你需要整理一份中国所有大学信息的 ppt。

大学的信息是能搜到的，但是一份份整理到 ppt 里也太麻烦了。

能不能用代码自动生成 PPT呢？

自然是可以的。

这里大学的信息可以从[中国大学 MOOC](https://www.icourse163.org/university/view/all.htm#/)这里抓取：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7685b256da540b1a6d3cb27f3cd517c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2540&h=1308&s=626463&e=png&b=f4f4f4)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41ede95f567f4a94a1ca714818cdc2fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2262&h=732&s=1498671&e=png&b=f4f3f3)

我们用 puppeteer 来爬取大学的校徽、名字、介绍，然后用这些信息来生成 pdf 等。

创建个 Nest 项目：

```
nest new ppt-generate
```
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/030f1726ea0847c48a0d8ac2337117e0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=902&h=682&s=158386&e=png&b=010101)
安装 puppeteer：

```
npm install --save puppeteer
```

然后在 AppService 里引入下：

```javascript
import { Injectable } from '@nestjs/common';
import puppeteer from 'puppeteer';

let cache = null;

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }

  async getUniversityData() {
    if(cache) {
      return cache;
    }
  
    const browser = await puppeteer.launch({
        headless: true,
        defaultViewport: {
            width: 0,
            height: 0
        }
    });
    
    const page = await browser.newPage();
    
    await page.goto('https://www.icourse163.org/university/view/all.htm');
    
    await page.waitForSelector('.u-usitys');
    
    const universityList = await page.$eval('.u-usitys', el => {
        return [...el.querySelectorAll('.u-usity')].map(item => {
          return {
            name: item.querySelector('img').alt,
            img: item.querySelector('img').src,
            link: item.getAttribute('href')
          }
      })
    });

    await browser.close();

    cache = universityList;

    return universityList;
  }
}
```
这里用 puppeteer 抓取中国大学 mooc 的学校列表的信息。

headless 指定 true，不用看界面了。

然后简单在内存做了下 cache，没用 redis。
 
在 AppController 里加个路由：

```javascript
@Get('list')
async universityList() {
    return this.appService.getUniversityData();
}
```
把服务跑起来：

```
npm run start:dev
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28491837b2814e89bfc15edc30d80d43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1530&h=388&s=135507&e=png&b=181818)

试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/530b401efb444124904910ab1fed1190~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1866&h=1172&s=271513&e=png&b=ffffff)

然后继续点进详情页，拿到学校的描述：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41ede95f567f4a94a1ca714818cdc2fe~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2262&h=732&s=1498671&e=png&b=f4f3f3)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c759433c2be041fbb80ab0a4a3b12f92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1322&h=708&s=152949&e=png&b=1f1f1f)

抓取每个学校数据的时间太长，我们用 SSE（server sent event） 的方式返回数据。

Sever Sent Event 就是服务端返回的 Content-Type 是 text/event-stream，这是一个流，可以多次返回内容，通过这种方式来随时推送数据。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d99ee4d7ad0471db06cb16280001d77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1294&h=832&e=png&b=ffffff)

SSE 类似这样用：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b36d04da9b4038ba500018334d6a32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702&h=526&s=76304&e=png&b=202020)

改下 AppController

```javascript
@Sse('list')
async universityList() {
    return this.appService.getUniversityData();
}
```

还有 AppService

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec62843bd95a40c094c3985911192f27~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1274&h=992&s=203102&e=png&b=1f1f1f)

```javascript
import { Injectable } from '@nestjs/common';
import puppeteer from 'puppeteer';
import { Observable, Subscriber } from 'rxjs';

let cache = null;

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }

  async getUniversityData() {
    if(cache) {
      return cache;
    }

    async function getData(observer: Subscriber<Record<string, any>>) {
      
      const browser = await puppeteer.launch({
          headless: true,
          defaultViewport: {
              width: 0,
              height: 0
          }
      });
      
      const page = await browser.newPage();
      
      await page.goto('https://www.icourse163.org/university/view/all.htm');
      
      await page.waitForSelector('.u-usitys');

      const universityList: Array<Record<string, any>> = await page.$eval('.u-usitys', el => {
          return [...el.querySelectorAll('.u-usity')].map(item => {
            return {
              name: item.querySelector('img').alt,
              img: item.querySelector('img').src,
              link: item.getAttribute('href')
            }
        })
      });

      for(let i = 0; i < universityList.length; i ++) {
        const item = universityList[i];
        await page.goto('https://www.icourse163.org' + item.link);

        await page.waitForSelector('.m-cnt');

        const content = await page.$eval('.m-cnt p', el => el.textContent);
        item.desc = content;

        observer.next({data: item});

      }

      await browser.close();

      cache = universityList;
    }

    return  new Observable((observer) => {
      getData(observer);
    });

  }
}
```

主要是返回一个 rxjs 的 Observable 然后不断用 observer.next 返回数据。

试一下：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6b115e9a3e44e3db881934be842c497~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1746&h=818&s=887003&e=gif&f=24&b=fbfbfb)

**SSE 和爬虫简直是绝配！**

接下来生成 ppt，用 [pptxgenjs](https://www.npmjs.com/package/pptxgenjs) 这个包。

用法很简单：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6966b1961d96426c8ac059e3a119283d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1208&h=912&s=152741&e=png&b=f6f8fa)

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4faa895370a748c789116de57ccf4923~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1536&h=380&s=105740&e=png&b=f6f8fa)

new 一个实例，添加一个 Slide，然后添加 text image 等内容，最后写入文件。

我们先测试下：

```
npm install --save pptxgenjs
```
新建 test.js

```javascript
const pptxgen = require('pptxgenjs');

const ppt = new pptxgen();

const slide  = ppt.addSlide();

slide.addText('北京大学', { x: '10%', y: '10%', color: '#ff0000', fontSize: 30,  align: ppt.AlignH.center,});

slide.addImage({ 
    path: "https://nos.netease.com/edu-image/F78C41FA9703708FB193137A688F7195.png?imageView&thumbnail=150y150&quality=100", 
    x: '42%',
    y: '25%',
});

slide.addText(`北京大学创办于1898年，初名京师大学堂，是中国第一所国立综合性大学，也是当时中国最高教育行政机关。辛亥革命后，于1912年改为现名。 学校为教育部直属全国重点大学，国家“211工程”、“985工程”建设大学、C9联盟，以及东亚研究型大学协会、国际研究型大学联盟、环太平洋大学联盟、东亚四大学论坛的重要成员。`, 
    { x: '10%', y: '60%', color: '#000000', fontSize: 14,}
);

ppt.writeFile({
    fileName: '中国所有大学.pptx'
})
```
分别指定文字和图片的 x、y，对齐方式 align。

跑一下：

```
node ./test.js
```

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d3ae4466df44cfebb60f310ea2478af~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1190&h=508&s=100282&e=png&b=1b1b1b)

打开看一下：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fcade45cdec4a529c275070e3c92fb5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2550&h=1056&s=251018&e=png&b=fdfcfc)

没问题。

然后我们在 list 接口里加一下这个：

顺便替换下校徽图片，之前取的这个：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab6418a383ed4acd9a7cfe8c5f996b7b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=888&h=374&s=78049&e=png&b=f7f7f7)

换成这里的：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/349f5724193a40a5825b31b9a4b2a8fb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1214&h=514&s=472665&e=png&b=f4f3f3)

```javascript
import { Injectable } from '@nestjs/common';
import puppeteer from 'puppeteer';
import { Observable, Subscriber } from 'rxjs';
const pptxgen = require('pptxgenjs');

let cache = null;

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello World!';
  }

  async getUniversityData() {
    if(cache) {
      return cache;
    }

    async function getData(observer: Subscriber<Record<string, any>>) {
      
      const browser = await puppeteer.launch({
          headless: true,
          defaultViewport: {
              width: 0,
              height: 0
          }
      });
      
      const page = await browser.newPage();
      
      await page.goto('https://www.icourse163.org/university/view/all.htm');
      
      await page.waitForSelector('.u-usitys');

      const universityList: Array<Record<string, any>> = await page.$eval('.u-usitys', el => {
          return [...el.querySelectorAll('.u-usity')].map(item => {
            return {
              name: item.querySelector('img').alt,
              link: item.getAttribute('href')
            }
        })
      });

      const ppt = new pptxgen();

      for(let i = 0; i < universityList.length; i ++) {
        const item = universityList[i];
        await page.goto('https://www.icourse163.org' + item.link);

        await page.waitForSelector('.m-cnt');

        const content = await page.$eval('.m-cnt p', el => el.textContent);
        item.desc = content;

        item.img = await page.$eval('.g-doc img', el => el.getAttribute('src'));

        observer.next({data: item});

        const slide = ppt.addSlide();

        slide.addText(item.name, { x: '10%', y: '10%', color: '#ff0000', fontSize: 30,  align: ppt.AlignH.center,});

        slide.addImage({ 
            path: item.img, 
            x: '42%',
            y: '25%',
        });

        slide.addText(item.desc, 
            { x: '10%', y: '60%', color: '#000000', fontSize: 14,}
        );
      }

      await browser.close();

      await ppt.writeFile({
        fileName: '中国所有大学.pptx'
      })

      cache = universityList;
    }

    return  new Observable((observer) => {
      getData(observer);
    });
  }
}
```
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f54c2e41ca4b4b6ba62b578ccadc1fce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1322&h=1308&s=242893&e=png&b=1f1f1f)

跑一下：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5086d500d394dbcbb8f1b416bbd9bc2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1878&h=546&s=215761&e=png&b=fefefe)

跑完之后可以看到，动态生成了 400 多张 ppt：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8be1fd2d7d3482a8482a54e039c9eb5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2386&h=1250&s=3066927&e=gif&f=40&b=fcfbfb)

案例代码上传了 github：https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/ppt-generate

## 总结

我们使用 puppeteer 抓取了大学的信息，用 SSE 的方式创建了接口，不断返回爬取到的数据。

然后用 pptxgenjs 来生成了 ppt。

这样，400 多张 PPT 瞬间就生成了，不用自己手动搞。


## 99.如何拿到服务器 CPU、内存、磁盘状态

在很多系统中，会有展示服务器信息的页面。

比如 CPU、内存、磁盘等：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559b3f430278402cb932f3ef737c85b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2210&h=1198&s=190259&e=png&b=ffffff)

这是怎么实现的呢？

其实通过 node 的原生 api 就可以做到。

我们还是用 Nest 写个接口来返回这些信息：

```
nest new server-status
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c56a1617eca4eb0a819064d89aa79c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=936&h=686&s=159449&e=png&b=010101)

在 AppController 加个接口，用 os.cpus 拿到 cpu 的信息：

```javascript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
import * as os from 'os';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('status')
  status() {
    return os.cpus();
  }
}
```
把服务跑起来：

```
npm run start:dev
```

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ed12e3e86c6446ba41d5c7166f042a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1546&h=370&s=135833&e=png&b=181818)

浏览器访问下：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8176b06d7dc446b5ac6fad92a26eb6f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=990&h=1302&s=135722&e=png&b=ffffff)

返回的数组元素个数就是 cpu 数。

那具体的属性是什么意思呢？

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77e63f2dc6d344dda3cfcaa8ae1bdb2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1184&h=866&s=927954&e=gif&f=32&b=1c1c1c)

可以看到，times.user、times.sys、times.idle 分别代表用户代码占用的 cpu 时间、系统代码占用的 cpu 时间，空闲的 cpu 时间：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115ecfa501ab442f9f244c3d43c68966~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1180&h=608&s=110146&e=png&b=202020)

基于这些就能算出 cpu 的使用率、空置率来。

```javascript
@Get('status')
status() {
    const cpus = os.cpus();
    const cpuInfo = cpus.reduce(
      (info, cpu) => {
        info.cpuNum += 1;
        info.user += cpu.times.user;
        info.sys += cpu.times.sys;
        info.idle += cpu.times.idle;
        info.total += cpu.times.user + cpu.times.sys + cpu.times.idle;
        return info;
      },
      { user: 0, sys: 0, idle: 0, total: 0, cpuNum: 0 },
    );
    const cpu = {
      cpuNum: cpuInfo.cpuNum,
      sys: ((cpuInfo.sys / cpuInfo.total) * 100).toFixed(2),
      used: ((cpuInfo.user / cpuInfo.total) * 100).toFixed(2),
      free: ((cpuInfo.idle / cpuInfo.total) * 100).toFixed(2),
    };
    return cpu;
}
```
用 reduce 方法累加 cpu 的数量、user、sys、idle 以及总的 cpu 时间。

然后 cpu 的系统使用率就是 sys/total，用户使用率是 user/total 而空置率就是 idle/total。


![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c3a07d6060c464b93fe1298a3c6c90d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=686&h=344&s=34454&e=png&b=ffffff)

对应的就是这部分信息：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b2c333918e14c5181cf52bf2fd1b664~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1174&h=538&s=45380&e=png&b=fefefe)

然后继续拿内存信息：

```javascript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
import * as os from 'os';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('status')
  status() {
    return {
      cpu: this.getCpuInfo(),
      mem: this.getMemInfo()
    }
  }

  getMemInfo() {
    const totalMemory = os.totalmem();
    const freeMemory = os.freemem();
    const usedMemory = totalMemory - freeMemory;
    const memoryUsagePercentage = (((totalMemory - freeMemory) / totalMemory) * 100).toFixed(2);
    const mem = {
      total: totalMemory,
      used: usedMemory,
      free: freeMemory,
      usage: memoryUsagePercentage,
    };
    return mem;
  }

  getCpuInfo() {
    const cpus = os.cpus();
    const cpuInfo = cpus.reduce(
      (info, cpu) => {
        info.cpuNum += 1;
        info.user += cpu.times.user;
        info.sys += cpu.times.sys;
        info.idle += cpu.times.idle;
        info.total += cpu.times.user + cpu.times.sys + cpu.times.idle;
        return info;
      },
      { user: 0, sys: 0, idle: 0, total: 0, cpuNum: 0 },
    );
    const cpu = {
      cpuNum: cpuInfo.cpuNum,
      sys: ((cpuInfo.sys / cpuInfo.total) * 100).toFixed(2),
      used: ((cpuInfo.user / cpuInfo.total) * 100).toFixed(2),
      free: ((cpuInfo.idle / cpuInfo.total) * 100).toFixed(2),
    };
    return cpu;
  }
}
```

os.totalmem 是总内存，os.freemem 是空闲内存，那差值就是已使用的内存。

这样也可以求出内存使用率。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc7f468ede654ce381d6db9a4425a6d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=760&h=650&s=67180&e=png&b=ffffff)

我们把它转成 GB 单位的数值返回：

```javascript
bytesToGB(bytes) {
    const gb = bytes / (1024 * 1024 * 1024);
    return gb.toFixed(2);
}

getMemInfo() {
    const totalMemory = os.totalmem();
    const freeMemory = os.freemem();
    const usedMemory = totalMemory - freeMemory;
    const memoryUsagePercentage = (((totalMemory - freeMemory) / totalMemory) * 100).toFixed(2);
    const mem = {
      total: this.bytesToGB(totalMemory),
      used: this.bytesToGB(usedMemory),
      free: this.bytesToGB(freeMemory),
      usage: memoryUsagePercentage,
    };
    return mem;
}
```

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1ba1ed95d4c62a84e94ac6278ed48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=754&h=612&s=62155&e=png&b=ffffff)

对应的是这部分信息：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099a22854ab24f95b9616e374df31cd6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=492&s=34059&e=png&b=ffffff)

然后是磁盘信息：

这里用到 [node-disk-info](https://www.npmjs.com/package/node-disk-info) 这个包：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a64e44266394fb488e0dcf68dfc894b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1520&h=628&s=104407&e=png&b=fefefe)

安装下：

```
npm install --save node-disk-info
```

调用下：

```javascript
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';
import * as os from 'os';
import * as nodeDiskInfo from 'node-disk-info';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }

  @Get('status')
  async status() {
    return {
      cpu: this.getCpuInfo(),
      mem: this.getMemInfo(),
      dist: await this.getDiskStatus()
    }
  }

  async getDiskStatus() {
    const disks = await nodeDiskInfo.getDiskInfoSync();

    const sysFiles = disks.map((disk: any) => {
      return {
        dirName: disk._mounted,
        typeName: disk._filesystem,
        total: this.bytesToGB(disk._blocks) + 'GB',
        used: this.bytesToGB(disk._used) + 'GB',
        free: this.bytesToGB(disk._available) + 'GB',
        usage: ((disk._used / disk._blocks || 0) * 100).toFixed(2),
      };
    });
    return sysFiles;
  }

  bytesToGB(bytes) {
    const gb = bytes / (1024 * 1024 * 1024);
    return gb.toFixed(2);
  }

  getMemInfo() {
    const totalMemory = os.totalmem();
    const freeMemory = os.freemem();
    const usedMemory = totalMemory - freeMemory;
    const memoryUsagePercentage = (((totalMemory - freeMemory) / totalMemory) * 100).toFixed(2);
    const mem = {
      total: this.bytesToGB(totalMemory),
      used: this.bytesToGB(usedMemory),
      free: this.bytesToGB(freeMemory),
      usage: memoryUsagePercentage
    };
    return mem;
  }

  getCpuInfo() {
    const cpus = os.cpus();
    const cpuInfo = cpus.reduce(
      (info, cpu) => {
        info.cpuNum += 1;
        info.user += cpu.times.user;
        info.sys += cpu.times.sys;
        info.idle += cpu.times.idle;
        info.total += cpu.times.user + cpu.times.sys + cpu.times.idle;
        return info;
      },
      { user: 0, sys: 0, idle: 0, total: 0, cpuNum: 0 },
    );
    const cpu = {
      cpuNum: cpuInfo.cpuNum,
      sys: ((cpuInfo.sys / cpuInfo.total) * 100).toFixed(2),
      used: ((cpuInfo.user / cpuInfo.total) * 100).toFixed(2),
      free: ((cpuInfo.idle / cpuInfo.total) * 100).toFixed(2),
    };
    return cpu;
  }
}
```
这里拿到的就是本地所有的磁盘信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b46e743377eb40f6b0f034dc8458c424~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=896&h=1270&s=167821&e=png&b=fefefe)

分别是路径、文件系统、总大小、已用大小、可用大小、已用百分比：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f37a661d02e4a1aab8bdf8d762c4474~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2100&h=280&s=55708&e=png&b=ffffff)

最后，我们还要返回其他的服务器信息：

```javascript
@Get('status')
async status() {
    return {
      cpu: this.getCpuInfo(),
      mem: this.getMemInfo(),
      dist: await this.getDiskStatus(),
      sys: this.getSysInfo()
    }
}

getSysInfo() {
    return {
      computerName: os.hostname(),
      computerIp: this.getServerIP(),
      osName: os.platform(),
      osArch: os.arch(),
    };
}

getServerIP() {
    const nets = os.networkInterfaces();
    for (const name of Object.keys(nets)) {
      for (const net of nets[name]) {
        if (net.family === 'IPv4' && !net.internal) {
          return net.address;
        }
      }
    }
}
```
这里的 os.networkInterfaces 是拿到所有网卡信息：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4122d908e2bf4d288fd9ad009a65cc85~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=872&h=638&s=127329&e=png&b=202020)

从中过滤出非 IPv4 的外部网卡的 ip 来返回。

此外，我们还通过 os.homename、os.platform、os.arch 分别拿到了主机名、操作系统、操作系统架构等信息。

试一下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2386a8e611a4e7f82c10170b97fbfa3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=634&h=312&s=37614&e=png&b=fefefe)

和我系统设置里的 ip 一样：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a02adc972efe4ea0b2638333c02233cb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1342&h=446&s=88591&e=png&b=eeecec)

对应这部分信息：

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9231ba0033264253a0e0d44b10627b2e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1822&h=278&s=47229&e=png&b=ffffff)

这样，服务器的状态数据就都拿到了。

可以实现这样的服务监控页面：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0f236a9efd64d6cb82e75eaa5335dea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2656&h=1220&s=255530&e=png&b=fefefe)

案例代码上传了[小册仓库](https://github.com/QuarkGluonPlasma/nestjs-course-code/tree/main/server-status)
## 总结

这节我们拿到了服务器的 cpu、内存、磁盘、ip 等信息。

通过 node 的 os 模块的 api 以及 node-disk-info 这个包。

可以在后台管理系统加一个页面来展示这些信息。


