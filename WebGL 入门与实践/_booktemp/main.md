---
title: WebGL 入门与实践
author: WebGL 入门与实践
date: 2025-02-14
lang: zh-CN
---

## 1.初级入门 --- 认识 WebGL

如果你在看这本小册，说明你或多或少地了解一些 WebGL 的相关内容，并且对它有浓厚的兴趣，我想我们在这点上一定是志同道合的。接下来的一段时间，我将借助本小册，带领大家一起学习 WebGL 开发过程中所用到的知识。

```!
因为 WebGL 涉及很多专业术语以及 API，而我或许不能一一向大家阐述清楚，希望大家见谅。我会尽可能的对一些关键概念或 API 进行通俗化的解释，如果大家在阅读时发现某个概念理解不了，建议到权威网站比如 MDN， 浏览一下官方解释~
```

* [MDN 传送门](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API)

## WebGL 产生的背景
在学习 `WebGL` 之前，我们先简单了解一下 `WebGL` 产生的背景。WebGL 规范产生以前，浏览器如果想实现 3D 动画效果，只能借助一些浏览器插件，比如 Adobe 的 `Flash`、微软的 `SilverLight` 等来实现，那么，为了打破这一局限，各大知名公司联手制定了一种跨平台的 3D 开发标准，也就是 `WebGL 规范`。

## WebGL 是什么？
那么，WebGL 是什么？一言以蔽之，WebGL 是一组基于 JavaScript 语言的图形规范，浏览器厂商按照这组规范进行实现，为 Web 开发者提供一套`3D图形`相关的 API。那么，这些 API 能够帮助 Web 开发者做些什么呢？

这些 API 能够让 Web 开发者使用 JavaScript 语言直接和显卡（GPU）进行通信。当然 WebGL 的 GPU 部分也有对应的编程语言，简称 `GLSL`。我们用它来编写运行在 GPU 上的着色器程序。着色器程序需要接收 CPU（WebGL 使用 JavaScript） 传递过来的数据，然后对这些数据进行流水线处理，最终显示在屏幕上，进而实现丰富多彩的 3D 应用，比如 3D 图表，网页游戏，3D 地图，WebVR 等。

## WebGL 工作原理

3D 模型数据从诞生到最终显示在屏幕上，这期间经历了什么样的过程呢？大家可以想象一下`流水线`的生产过程，流水线按照既定的步骤对原料进行加工，当前步骤只对前一步骤的结果进行处理，然后将处理后的结果传递给下一步骤，最终将原材料生产成完整的产品。WebGL 的工作方式和流水线类似，也是按照流水线的方式将 3D 模型数据渲染到 2D 屏幕上的，业界把这种渲染方式称为`图形管线`或者`渲染管线`，大家以后碰到这两个名词，应该能明白什么意思了。

>之后的章节，我们也会遵循业界用语，用`渲染管线`表示 WebGL 的渲染过程。

我们知道，WebGL 只能够绘制`点`、`线段`、`三角形`这三种基本图元，但是我们经常看到 WebGL 程序中含有立方体、球体、圆柱体等规则形体，甚至很多更复杂更逼真的不规则模型，那么 WebGL 是如何绘制它们的呢？其实这些模型本质上是由一个一个的`点`组成，GPU 将这些点用`三角形图元`绘制成一个个的微小平面，这些平面之间互相连接，从而组成各种各样的立体模型。

因此，我们的首要任务是创建组成这些模型的顶点数据。

一般情况下，最初的顶点坐标是相对于`模型中心`的，不能直接传递到着色器中，我们需要对`顶点坐标`按照一系列步骤执行`模型转换`，`视图转换`，`投影转换`，转换之后的坐标才是 WebGL 可接受的坐标，即`裁剪空间坐标`。我们把最终的`变换矩阵`和`原始顶点坐标`传递给 `GPU`，GPU 的渲染管线对它们执行流水线作业。

GPU 渲染管线的主要处理过程如下：

* 首先进入顶点着色器阶段，利用 GPU 的并行计算优势对顶点逐个进行坐标变换。
* 然后进入图元装配阶段，将顶点按照图元类型组装成图形。
* 接下来来到光栅化阶段，光栅化阶段将图形用不包含颜色信息的像素填充。
* 在之后进入片元着色器阶段，该阶段为像素着色，并最终显示在屏幕上。


>事实上，这其中每个环节还有一些细微的处理没有列举出来，比如`深度测试`、`模板测试`等。



## 开发者需要掌握的技能
那么，WebGL 这么有吸引力，我相信很多开发者已经迫不及待的想上手了。但在此之前，我想我们还是先了解一下需要掌握哪些技能，之后再学习也不迟。

对于开发者来说，需要掌握哪些技能呢？

首先，我们分析一下一般的 Web 网页和 WebGL 应用在开发过程中有哪些不同？

###  普通的 Web 网页

* HTML
* CSS
* JavaScript
* ...

一般情况，我们只需掌握 HTML、CSS、JavaScript，就可以进行 Web 开发了，入门比较容易。

### WebGL 程序

* HTML  
因为 WebGL 应用是网页程序，所以我们仍然需要掌握HTML，至少要知道怎么使用 `canvas`。

* JavaScript  
我们需要使用 JavaScript 声明 WebGL 运行的载体 `canvas`，设置 `canvas` 的初始大小，获取 WebGL 的`上下文`，对模型顶点的`坐标`、`颜色`、`法向量`等信息进行处理，并将这些处理好的数据传递给 GPU 。对于复杂的 WebGL 应用，顶点、纹理、光照等数据甚至需要从外部`模型文件`中获取，所以我们还需要用 JavaScript `解析加载`模型数据。

* GLSL(着色器语言)。  
不同于普通网页的开发，除了 JavaScript 语言需要熟练掌握之外，开发者还需要熟练使用 `GLSL` 语言。因为一个完整的 3D 应用离不开 JavaScript 程序和 GLSL 程序，二者缺一不可。我们需要用 GLSL 编写着色器程序，并配合 JavaScript 共同实现 3D 效果。
* 3D数学知识  
除了掌握必要的编程语言，还需要掌握一定的 3D 数学知识，特别是`向量`和`矩阵`之间的表示和运算。在 WebGL 中顶点位置的`坐标系变换`、`光照效果`等都需要有 3D 数学的功底才能真正灵活运用。

## 什么是 GLSL？

`GLSL` 的中文意思是 OpenGL 着色语言，英文全称是 OpenGL Shading Language，它是用来在 OpenGL 编写`着色器程序`的语言。

>为了书写方便，在之后的章节我们用 `GLSL` 指代`OpenGL 着色语言`。

* 着色器程序  
我们知道了 GLSL 是用来编写着色器程序的语言，那么新的问题来了，着色器程序是用来做什么的呢？
简单地说，着色器程序是在显卡（GPU）上运行的简短程序，代替了 GPU `固定渲染管线`的一部分，使 GPU 渲染过程中的某些部分允许开发者通过`编程`进行控制。

上面这段解释有些长，用一句话来说：着色器程序允许我们通过编程来控制 GPU 的渲染。

那么 GPU 渲染过程中的哪些部分允许开发者控制呢？下图是对 WebGL 渲染管线的简单演示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc3be028ca3~tplv-t2oaga2asx-image.image)

上图简单演示了 WebGL 对一个红色三角形的渲染过程，绿色部分为开发者可以通过编程控制的部分：

* JavaScript 程序  
  处理着色器需要的`顶点坐标`、`法向量`、`颜色`、`纹理`等信息，并负责为`着色器`提供这些数据，上图为了演示方便，只是提供了三角形顶点的位置数据。
* 顶点着色器  
  接收 JavaScript 传递过来的`顶点信息`，将顶点绘制到对应坐标。
* 图元装配阶段  
  将三个顶点装配成指定`图元类型`，上图采用的是三角形图元。
* 光栅化阶段
  将三角形内部区域用空像素进行填充。
* 片元着色器
  为三角形内部的像素填充颜色信息，上图为暗红色。
  
实际上，对顶点信息的变换操作既可以在 `JavaScript` 中进行，也可以在`着色器程序`中进行。通常我们都是在 `JavaScript` 中生成一个包含了所有变换的最终变换矩阵，然后将该矩阵传递给着色器，利用 GPU 并行计算优势对所有顶点执行变换。

>WebGL 开发中具体都有哪些变换，我们会在后面章节中详细介绍，请大家拭目以待。

>虽然我们还需要学习一门新的语言 GLSL，但是它的学习成本比 JavaScript 要低一些，而且常用的知识点也比较少，多加练习即可掌握，这点大家不用担心。GLSL 本质上是在 C 语言的基础上，增加了一些数据类型和数学函数。而我们需要编写的着色器程序，往往是最简单的 main 函数。


从上面可以看出，WebGL 程序比起一般的网页开发需要多掌握一门 GLSL 语言，但由于我们用到的着色器程序都比较简单，学习 GLSL 所占用的时间比重不是很大，所以大家不用过于担心。

> WebGL 的入门难度不在语言层面，而在于理解各种矩阵变换的原理。



## 总结

本文是学习 WebGL 开发前的一个铺垫，读完本小节，相信大家会对 WebGL 有了一个整体认识：

* WebGL 是一组图形 API，允许我们使用 JavaScript 控制 GPU 渲染过程，进行 3D 绘图。
* WebGL 应用由 JavaScript 程序和着色器程序构成。 
* WebGL 如何将 3D 模型数据显示在 2D 屏幕上。
* WebGL 编程要素：开发者需要针对 CPU 和 GPU 进行编程，CPU 部分是 JavaScript 程序，GPU 部分是着色器程序。


接下来的章节，我们进入初级入门阶段，这个阶段带大家进行基础练习，让大家学会如何正确地使用 WebGL，并穿插着介绍 WebGL 的细枝末节。

那么，打开您的爱机，让我们开始 WebGL 的学习之旅吧~

## 10.中级进阶 --- 神说要有光，于是就有了光：给物体添加环境光。

之前的章节我们学习了一个自由转动的立方体，本节我们讲解如何给物体增加光照效果，有了光照，物体之间才会有层次感，才会显得更真实。

## 什么是颜色

现实生活中，当我们看一个物体的时候，很容易地能分辨出它的颜色。但大家有没有想过，颜色到底是什么？

其实颜色并不是客观存在的东西，只是一个视觉效果，决定这个视觉效果的关键因素是有三个：光、物体、视觉系统。

大家都知道，在有光线存在的时候，我们能够看到物体，准确分辨它们的颜色。但是到了晚上伸手不见五指的时候，这时候已经没了光线，我们是看不到任何东西的。

光是什么呢？光是一种电磁波，电磁波中的一部分能够被人眼所感知，这部分被称为可见光。

当光线照射到物体上时，物体能够吸收可见光的一部分，并反射不能吸收的那部分，反射出来的这部分可见光会刺激人眼，经过视神经传到大脑，形成对物体的色彩信息，这就是我们所说的`颜色`。

所以颜色的形成离不开这三个因素。

比如，当白色的太阳光照射在一个红色的物体上时，该物体吸收红色以外的光线，反射剩余的光线（红色光），所以我们看到了红色的物体。

假如我们有一盏蓝色的灯（r:0, g:0, b:1），照射在一个红色的物体（r:1, g:0, b:0）上，该物体吸收红色以外的光线，反射剩余的光线（r:0, g:0, b:0），黑色，所以我们看到的是一个黑色的物体。

简单一句话就是，人眼看到的物体是什么颜色，就代表这个物体反射该颜色。

## 颜色在计算机中的表示

那么，在计算机中，我们表示物体的颜色时，其实就是设置该物体能够反射的可见光。比如我们为一个物体指定蓝色，本质就是让该物体吸收除了蓝色以外的光线，只反射蓝色光线，这样我们看到的物体就是蓝色的。

我们前面的例子，都是只设置了物体的颜色，并没有加入光照因素。如果我们加入光照因素的话，该如何计算光照效果呢？

加入光照因素后，会影响进入人眼的颜色，所以，我们仍然是通过设置物体的颜色来表达加入光照后的效果。

当我们在计算机中创建一个光源时，需要给光源设置一个颜色（光源也是有颜色的哦），我们给光源设置为白色：

> 以下的代码部分为 GLSL 语法。

```glsl
vec3 light = vec3(1, 1, 1);
```

假设我们有一个物体是红色的：

```glsl
vec3 color = vec3(1, 0, 0);
```

在计算机领域中，将`光源颜色的各个分量`与`物体颜色的各个分量`相乘，得到的就是物体所反射的颜色，即该物体在该光源照射下进入人眼的颜色：

```glsl
vec3 resultColor = light * color
```

>在 GLSL 语言中，vec3 与 vec3 相乘的实质是将两个 vec3 的分量分别相乘，得到一个新的 vec3。

得到的结果是 `vec3(1 * 1, 1 * 0, 1 * 0) = vec3(1, 0, 0)`，很明显，是红色，这也和现实生活中的表现一致。

前面讲了，如果蓝色的光线照射到红色的物体上，进入人眼的颜色是黑色，我们验证一下：

```glsl
vec3 light = vec3(0, 0, 1);
vec3 color = vec3(1, 0, 0);
vec3 resultColor = light * color;
```

将光线的 rgb分量 和 物体颜色的 rgb 分量相乘：

`resultColor = (0 * 1, 0 * 0, 1 * 0) = (0, 0, 0)`

最终结果是黑色，很明显，和现实生活中的表现一致。

这就是在计算机中光照作用下物体颜色的计算原理。

## 环境光

在现实世界中，物体由于有本身材质的不同，对光线的反射效果也不同。材质粗糙的物体会将光线向各个方向进行反射，即漫反射，这也是现实生活中最为常见的反射类型，当漫反射的光线碰到另一个物体时，还会再次进行漫反射，所以，即使在没有光线照射到某个物体的情况下，其他物体的漫反射光也能照射到该物体，所以我们能够看到它。

那么在计算机中，如果想真实地模拟现实生活中没有光源直接照射物体时，通过其他物体的漫反射我们仍然能够看到该物体的情况，耗费的算力特别大，所以定义一种`环境光`的概念，来近似模拟这种效果。

>请注意，虽然在环境光中多次提到了漫反射的概念，但是环境光要模拟的并不是有光线照射下的漫反射，而是多个物体的漫反射互相作用的光线效果。

那么环境光，如何设置呢？

通常，我们使用一个较小的常量乘以光的颜色来模拟环境光。

## 环境光的计算
假设有一个光源，发出的光线是白色光：

```glsl
vec3 lightColor = vec3(1, 1, 1);
```

我们定义环境光的常量因子为 0.1

```glsl
float ambientFactor = 0.1;
```

那么环境光的计算如下：

```glsl
vec3 ambientColor = ambientFactor * lightColor;
```

> GLSL中浮点数和 vec 向量相乘的实质是将该浮点数分别与vec向量的各个分量相乘，并返回新的 vec向量

计算出的环境光是：
`ambientColor = (1 * 0.1, 0.1 * 1, 0.1 * 1) = (0.1, 0.1, 0.1)`


## 给物体增加环境光
之前的章节例子中，我们并没有提到光的概念，事实上我们默认有一个白色的环境光在里面的，所以我们能够看到它们。

看看我们之前的片元着色器

```glsl
gl_FragColor = v_Color;
```

其实可以理解为一个强度因子为 1 的白色光源：

```glsl
vec3 ambientFactor = 1.0;
vec3 lightColor = vec3(1, 1, 1);
vec3 ambientColor = ambientFactor * lightColor;
gl_FragColor = vec4(ambientColor, 1) * v_Color;
```

那这次，我们要改变强度因子，同时改变光线颜色，所以我们要定义两个常量，强度因子`u_AmbientFactor`和光源颜色`u_LightColor`。

增加了环境光的片元着色器如下：

```glsl
    precision mediump float;
    varying vec4 v_Color;
    //光源颜色
    uniform vec3 u_LightColor;
    //环境光强度因子
    uniform float u_AmbientFactor;
    void main(){
      vec3 ambientColor = u_AmbientFactor * u_LightColor;
      gl_FragColor = vec4(ambientColor, 1) * v_Color;
    }
```

接下来我们需要通过 JavaScript 给片元着色器传递这两个常量：

```javascript
var u_AmbientFactor = gl.getUniformLocation(program, 'u_AmbientFactor');
var u_LightColor = gl.getUniformLocation(program, 'u_LightColor');
```

找到这两个常量位置，我们需要为他们传递强度因子和光线颜色，这里我们使用滑块来改变强度因子，并使用颜色选择器改变光线颜色，强度因子默认值是 0.2，光线颜色默认是白色：

```html
<div>
    环境光因子：
    <input id="ambientFactor" class="range" type="range" min="0" max="1" step="0.01" value="0.2" /> 
</div>
<div>
  	光线颜色：
  	<input id="lightColor" class="color" type="color" value="#FFFFFF" />
</div>
```

我们看下效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/10/1665d141d1c28518~tplv-t2oaga2asx-image.image)

>大家可以通过调节 1 处的滑块来改变强度因子，观察台体的亮度变化，调节 2 处的颜色选块来改变光线颜色，观察台体的在不同颜色光线照射下的变化。

为了便于观察，通过程序自动改变光线颜色：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/10/1665d30d064c856f~tplv-t2oaga2asx-image.image)


可以看到，在不同颜色的光线照射下，人眼观察到的物体颜色也会不同。


## 回顾
本节讲解了计算机如何模拟现实生活中的颜色以及如何给物体增加环境光，下一节我们学习如何在计算机中模拟真实世界中的光照效果。




## 11.中级进阶 --- 冯氏光照模型：为物体增加漫反射效果

我们已经学会了给物体增加环境光，但现实世界中一个物体展示出来的颜色除了受环境光的影响，还要看该物体是否被光源直接照射，以及物体本身的材质。如果物体被光源直接照射，它会比没有光源直接照射的物体更亮一些。物体本身如果是光滑的，那么在被光源照射时会显得更加亮，甚至刺眼，比如一面镜子，不锈钢等。假设物体粗糙不平，那么它给人的感觉就平和一些。

除了物体本身的因素会对最终进入人眼的颜色产生影响，人眼、物体、光源之间的位置也会决定进入人眼的颜色。一个很常见的例子就是光线照射在镜面时，当反射出来的光线没有进入人眼的时候，人眼看到的镜子是正常的。当我们移动自身位置，正好能够让镜子的反射光线进入人眼，此时看到的镜面就会很刺眼。

现实生活中的光照效果如此复杂，而且受到很多因素的影响，即使在计算机硬件飞速发展的今天，也依然会消耗很大的算力，无法精确模拟这种效果，所以需要一种能够近似现实光照效果的简化模型。业界比较著名的是`冯氏光照模型`（Phong Lighting Model）。

## 冯氏光照模型
冯氏光照模型模拟现实生活中的三种情况，分别是环境光(Ambient)、漫反射(Diffuse)和镜面高光(Specular)。

* 环境光：环境光在上节已经讲过了，主要用来模拟晚上或者阴天时，在没有光源直接照射的情况下，我们仍然能够看到物体，只是偏暗一些，通常情况我们使用一个`较小的光线因子乘以光源颜色`来模拟。
* 漫反射：漫反射是为了模拟`平行光源`对物体的方向性影响，我们都知道，如果光源正对着物体，那么物体正对着光源的部分会更明亮，反之，背对光源的部分会暗一些。在冯氏光照模型中，漫反射分量占主要比重。
* 镜面高光：为了模拟光线照射在`比较光滑`的物体时，物体正对光源的部分会产生`高亮效果`。该分量颜色会和光源颜色更接近。

有了冯氏光照模型，我们就可以通过这三个分量模拟出相对真实的光照效果了。

环境光分量我们上节已经讲过了，本节将跳过，不再赘述，本节主要讲解漫反射分量。


## 计算漫反射光照
我们知道，当一束光线照射到物体表面时，光线的入射角越小，该表面的亮度就越大，看上去也就越亮。反之，该表面的亮度就越小，看上去越暗。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/12/166661b64f0983a6~tplv-t2oaga2asx-image.image)

这种现象我们该如何在计算机中表示呢？

关键在于`入射角的表示`与`光线强度的计算`。

### 入射角的表示与计算

我们需要定义一个类似`法线`的概念，即`法向量`，法向量垂直于物体表面，并且朝向平面外部，如下图：

有了法向量，我们还需要光线照射方向，光线照射方向根据光源的不同有两种表示方法：

* 平行光线
	* 光线方向是全局一致的，与照射点的位置无关，不会随着照射点的不同而不同，不是很真实。
* 点光源。
	* 向四周发射光线，光线方向与照射点的位置有关，越靠近光源的部分越亮，光照效果比较真实。

> 接下来我们用这二种方式来演示。

有了法向量以及光线照射方向，我们也就知道了入射角，有了入射角，那么反射光强度的计算就轻而易举了。

#### 计算反射光强度
因为入射角的大小与反射光的亮度成`反比`，所以我们使用`入射角的余弦值`来表示漫反射的`光线强`度。

#### 法向量


法向量是垂直于顶点所在平面，指向平面外部的向量，只有方向，没有大小，类比光学现象中的法线，如下所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/15/16675cb83a87cba9~tplv-t2oaga2asx-image.image)

法向量存储在顶点属性中，为了便于计算入射角的余弦值，法向量的长度通常设置为 1。

除了`法向量`，我们还需要知道`光线的入射角`，即光源的照射方向向量和法向量的夹角，上图中 $\theta$ 即是入射角。


#### 光源照射方向向量的计算

> 光源位置坐标是基于世界坐标系的，所以我们在计算光源入射方向向量的时候，需要将照射点的坐标也转换到世界坐标系中。

在世界坐标系中，假设有一光源 p0 (x0, y0, z0)。

```glsl
vec3 p0 = vec3(10, 10, 10);
```

光线照射到物体表面上的一点 p1 (x1, y1, z1)。

```glsl
vec3 p1 = vec3(20, 25, 30);
```

那么光线照射在该点的方向向量为：

```glsl
vec3 light_Direction = p1 - p0。
```

> GLSL中的 `+`、`-`、`*`、`/` 操作符的左右两个数如果是向量的话，得出的新向量的各个分量等于原有向量逐分量的相减结果。

这样我们就得出了光源的照射方向向量。


#### 计算漫反射光照

有了入射角，我们的漫反射光照分量就可以求出来了。

* 漫反射光照 = 光源颜色 * 漫反射光照强度因子
* 漫反射光照强度因子 = 入射角的余弦值

通常我们如果要求入射角的余弦值，需要首先知道入射角，然后再求入射角的余弦值。不过由于我们使用的是向量，根据向量的运算规则，我们可以使用向量之间的`点积`，再除以向量的长度之积，就可以得出余弦值。

我们首先将两个向量`归一化`，转换成单位向量，然后进行点积计算求出夹角余弦。

>归一化向量的实质是将向量的长度转换成 1，得出的一个单位向量。

所以我们需要两个数学方法来操作他们

 * dot
	* 求出两个向量的点积。
 * normalize
 	* 将向量转化为长度为 1 的向量。

所幸的是，GLSL 内置了这两个函数方便我们计算，一些有名的 3D 框架中也包含这两个方法。

所以，我们的入射角余弦值就可以这样求出了：

```glsl
//light_Direction表示光源照射方向向量。
//normal 代表当前入射点的法向量
vec3 light_Color = vec3(1, 1, 1);
float diffuseFactor = dot(normalize(light_Direction), normalize(normal))
vec4 lightColor = vec4(light_Color * diffuseFactor, 1);
```

这样我们就求出了漫反射光照的分量，接下来我们实际操作一下，比较一下物体在加入光照前后的效果。

#### 平行光漫反射
前面讲了那么多理论，是时候上手实践一下了。我们按照 WebGL 的编码流程，看看各个阶段需要做何处理。

##### 顶点着色器
顶点着色器需要接收顶点法向量，`插值化`后传递给片元着色器，所以我们需要定义一个`varying`类型的 3 维向量来表示法向量，完整的顶点着色器如下：

```glsl
// 顶点坐标
attribute vec4 a_Position;
// 顶点颜色
attribute vec4 a_Color;
// 顶点法向量
attribute vec3 a_Normal;
// 传递给片元着色器的法向量
varying vec3 v_Normal;
// 传递给片元着色器的颜色
varying vec4 v_Color;
// 模型视图投影变换矩阵。
uniform mat4 u_Matrix;

void main(){
	// 将顶点坐标转化成裁剪坐标系下的坐标。
	gl_Position = u_Matrix * vec4(a_Position, 1);
	// 将顶点颜色传递给片元着色器
	v_Color = a_Color;
	// 将顶点法向量传递给片元着色器
	v_Normal = a_Normal;
}
```

细心的读者已经看到了，着色器中我们使用了 GLSL 中的矩阵容器类型 `mat4`，4 * 4 矩阵，用来表示模型视图投影变换。我们将 4 阶矩阵左乘 4 维向量，即可表示对 4 维向量所表示的点执行 4 阶矩阵所表示的变换。

> 关于矩阵和向量的运算意义，我会在之后的章节讲解。这里大家只要了解了矩阵左乘向量的意义，并且学会使用就可以了。


##### 片元着色器
漫反射光照分量在片元着色器中计算，按照上面的计算公式，我们需要接收顶点着色器传递过来的插值后的法向量`v_Normal`和全局光源位置 `u_LightPosition`，以及光线的颜色`u_LightColor`。

```glsl
// 片元法向量
varying vec3 v_Normal;
// 片元颜色
varying vec4 v_Color;
// 光线颜色
uniform vec3 u_LightColor;
// 光源位置
uniform vec3 u_LightPosition;
void main(){
      // 环境光分量
      vec3 ambient = u_AmbientFactor * u_LightColor; 
      // 光源照射方向向量
      vec3 lightDirection = u_LightPosition - vec3(0, 0, 0);
      // 漫反射因子
      float diffuseFactor = dot(normalize(lightDirection), normalize(v_Normal));
      // 如果是负数，说明光线与法向量夹角大于 90 度，此时照不到平面上，所以没有光照，即黑色。
      diffuseFactor = max(diffuseFactor, 0.0);
      // 漫反射光照 = 光源颜色 * 漫反射因子。
      vec3 diffuseLightColor = u_LightColor * diffuseFactor;
      // 物体在光照下的颜色 = （环境光照 + 漫反射光照） * 物体颜色。
      gl_FragColor = v_Color * vec4((ambient + diffuseLightColor),1); 	
}
```

##### JavaScript部分
着色器的程序完成了，接下来我们需要给着色器传递数据了。和之前的例子相比，我们多了两个全局变量`光照颜色`、`光照位置`，以及一个顶点属性`法向量`。

首先我们给顶点增加法向量：

```javascript
var normalInput = [
    [0, 0, 1],  //前平面
    [0, 0, -1], //后平面
    [-1, 0, 0], //左平面
    [1, 0, 0], //右平面
    [0, 1, 0], //上平面
    [0, -1, 0] //下平面
];
```
各个平面的法向量准备好后，我们就可以为组成平面的顶点设置法向量属性了，限于篇幅，此处不再展示源码，大家可以在此处查看完整源代码 [光照演示源码]()。

接下来，创建立方体的顶点数据：

```javascript
var cube = createCube(10, 10, 10);
```

此处创建一个长、宽、高各位 10 的立方体，坐标原点在立方体中心。

接下来，我们设置光源位置，我们希望将光源放在立方体前面 z 轴坐标正方向 10 的位置。

```javascript
gl.uniform3f(u_LightPosition, 0, 0, 10);
```

设置光源颜色为白色：

```javascript
gl.uniform3f(u_LightColor, 1, 1, 1);
```


按照这种放置，光源在立方体的正前方，它始终照亮前面。我们看下演示效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667aeaa119882d6~tplv-t2oaga2asx-image.image)

可以看到我们设置的白色光源把立方体的前平面（红色面）照亮了。

等等，好像有些不对劲。

一个很大的问题是：立方体在转动时，转动到正对光源方向的平面并没有被照亮。


大家考虑下为什么？

#### 动态计算法向量
其实是因为在转动的时候，各个顶点的法向量还是初始值，并没有随着物体的转动而更新，所以即使有平面转动到正对光源的位置，它的法向量还是原先的法向量，计算出来的漫反射光照仍然是 0。所以，我们需要在物体发生变换的时候，让法向量也跟着发生变换。


我们来修正这个问题，解决办法很简单，只要将立方体的`模型变换矩阵`传递给`顶点着色器`，然后与`顶点的法向量`相乘，即可得到变换后的法向量。

>此处又提到了矩阵，可见矩阵的重要性非同一般，在后面的矩阵章节大家一定要认真学习。

##### 顶点着色器
顶点着色器需要做些改动，用来接收模型矩阵，然后将模型矩阵与法向量相乘，得到变换后的法向量，传递给片元着色器。

```glsl
// 顶点坐标
attribute vec4 a_Position;
// 顶点颜色
attribute vec4 a_Color;
// 顶点法向量
attribute vec3 a_Normal;
// 传递给片元着色器的法向量
varying vec3 v_Normal;
// 传递给片元着色器的颜色
varying vec4 v_Color;
// 模型视图投影变换矩阵。
uniform mat4 u_Matrix;
// 模型变换矩阵。
uniform mat4 u_ModelMatrix;

void main(){
	gl_Position = u_Matrix * vec4(a_Position, 1);
	v_Color = a_Color;
	v_Normal = mat3(u_ModelMatrix) * a_Normal;
}
```

##### 片元着色器不需要修改。
##### JavaScript部分
JavaScript 部分需要为顶点着色器传入模型矩阵`u_ModelMatrix`的值，那么，模型矩阵如何计算呢？还好矩阵库为我们解决了这个问题。

```javascript
var modelMatirx = matrix.identity();
modelMatrix = matrix.rotateX(modelMatrix, Math.PI / 180 * (uniforms['xRotation']));
```

这里利用了矩阵库的两个方法`identity` 和 `rotateX`：

* identity 用来初始化一个 4 维矩阵，对角线分量均为1。
* rotateX 将原来的矩阵沿着 X 轴旋转，得到一个新的矩阵。

>关于矩阵的变换细节在后面章节有详细介绍，此处只讲如何使用。

改造完成，我们看下效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667af87250c972b~tplv-t2oaga2asx-image.image)


可以看到，立方体正对光源的平面都能够被照亮了。

#### 点光源的漫反射

前面的平行光漫反射可以模拟遥远的光源，比如太阳光，由于太阳距离地球过于遥远，所以光线照射在物体各个点的方向还是可以近似平行的。

但现实生活中还有很多人造光源，这些光源距离物体比较近，照在物体不同点时，入射角也会不一样，所以光照强度也有差别，在一个平面上产生距离光源近的部分比较亮，距离光源远的部分比较暗的效果。

接下来我们模拟这种情况。

我们在之前平行光漫反射的基础上进行改造，大家可以看到，之前的平行光漫反射计算入射角余弦时，是根据`光源位置`和世界坐标系的`原点`计算的入射角，只要我们不改变光源位置，那么光线方向就始终一致。

但是，点光源需要根据光源位置和入射点位置计算入射角，所以我们需要计算出入射点的世界坐标系坐标。

入射点的世界坐标系坐标的求法也比较简单，只需要左乘模型矩阵就可以了。

我们对上面的例子加以升级。

##### 顶点着色器
顶点着色器需要定义一个入射点位置，插值化后传给片元着色器计算入射角的余弦。

```glsl
...略
varying vec3 v_Position;
void main(){
	...略
	v_Position = vec3(u_ModelMatrix * vec4(a_Position, 1));
}

```

##### 片元着色器

片元着色器部分的改变只有在计算光源入射方向时，用光源位置减去入射点位置：

```glsl
...略
// 光源照射方向向量
vec3 lightDirection = u_LightPosition - v_Position;
...略
```

JavaScript部分不需要改动，我们看下演示效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667b07af2e5471b~tplv-t2oaga2asx-image.image)


可以看到，在点光源的作用下，平面上的不同点也产生了明暗效果。

#### 物体缩放时的表现。
结束了吗？当然没有，我们还有一个问题没有解决。

假设有一物体表面被光线照射：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667bde9ecd79a3d~tplv-t2oaga2asx-image.image)

当对物体执行非等比缩放时，顶点法向量也会执行非等比缩放，但是执行缩放后的法向量却不再垂直于顶点所在平面了，如下图：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667bdf9f3938115~tplv-t2oaga2asx-image.image)

法向量不正确带来的后果是光照计算不准，表现如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667c0384e2efd13~tplv-t2oaga2asx-image.image)

可以看到，当我们队球体执行纵向放大的时候，放大的部分虽然正对着光源，但是没有光照。

因此，我们不能使用简单的模型矩阵来变换顶点法向量了。为了解决这个问题，我们需要专门为法向量的变换定义一个单独的矩阵`法线矩阵`，法线矩阵可以用「模型矩阵左上角的3维矩阵的逆矩阵的转置矩阵」来代替。听起来比较复杂，其实很简单。

* 1、对模型矩阵执行逆矩阵操作。
* 2、对上一步得出的矩阵执行转置矩阵。
* 3、取上一步得出的矩阵的前三阶矩阵。

我们修改一下程序，顶点着色器和片元着色器部分不用改变，我们需要修改 JavaScript 部分。

我们使用矩阵库的两个方法 transpose 和 inverse 来对模型矩阵执行转置操作和求逆操作。

```javascript
var normalMatrix = matrix.transpose(matrix.inverse(modelMatrix));
```

然后将该矩阵传递给顶点着色器即可，我们看下修改后的效果：



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667bf6e4313e83e~tplv-t2oaga2asx-image.image)


## 回顾

至此，冯氏光照模型的漫反射部分就讲解完了，原理比较简单，但是计算量比较多，尤其是涉及到的一些矩阵运算知识，大家可能有些蒙，这是正常现象。大家只要会使用矩阵就可以了，至于为什么要用矩阵表示变换，之后的章节再向大家揭开这个谜团。

下一节，我们学习冯氏光照模型的第三个分量，`镜面高光`。

## 12.中级进阶 --- 冯氏光照模型：为物体增加镜面高光效果

前两个章节我们讲述了冯氏光照模型的环境光和漫反射光，本节我们学习组成冯氏光照的最后一个因素：镜面高光。

## 镜面高光现象

大家小时候应该都做过这样的恶作剧，上课的时候拿一面镜子，对准某个同学，慢慢调整镜子的角度，直到反射的太阳光照在对方的脸上，然后引起该同学的极度不适。

有没有想过为什么会有这种现象？

有的同学答了，这是因为镜子的反射光正好进入了同学的眼睛里。

说的没错，那假如我拿一件衣服来反射太阳光，能不能达到同样的效果。

很多同学脱口而出：不能。

是的，可是大家有没有想过为什么不能？

也许大家会出于直觉回答，因为衣服不反光，镜子反光。其实也对，但不太严谨。事实上衣服也反光，只是衣服表面过于粗糙，光线被散射到了各个方向，不能集中射向一个方向，导致进入人眼的光线强度大大削弱。镜子就不同了，镜子比较光滑，光线反射方向比较统一，进入人眼的光线强度也就越多，从而产生刺眼的效果。

冯氏光照模型使用`镜面高光分量`来模拟这种现象。

## 镜面高光的表示与计算
与漫反射分量相同，镜面高光也是根据光线的入射方向向量和法向量来决定的，只不过镜面高光还需要依赖视线的观察方向，也就是眼睛是从什么方向观察的物体。


视线方向向量与反射光向量的之间的夹角越小，夹角余弦值就会越大，那么人眼感受到的光照就会越强，反之，光照越暗。因此，我们使用夹角的余弦值表示镜面高光因子，然后再用镜面高光因子乘以光线颜色即可求出镜面高光分量：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/16/1667c881d9ddb04c~tplv-t2oaga2asx-image.image)


* 1、首先需要求出反射光向量`reflectDirection`和人眼视线方向向量`viewDirection`。
* 2、归一化两个向量。
* 3、求出两个归一化向量的点积，得到镜面高光因子。
* 4、将上一步求出的高光因子乘以光线颜色，得到镜面高光分量。

本节我们使用 GLSL 内置的反射向量算法`reflect(inVec, normal)`，其中 `inVec` 为入射向量，方向由光源指向入射点，`normal` 为入射点的法向量。



## 如何实现镜面高光
接下来，我们开始编码实现镜面高光效果。

### 计算反射光向量
反射光向量在片元着色器中实现，参照上一节漫反射分量的计算，我们已经有了光源位置`u_LightPosition`和入射点位置`v_Position`，所以可以求得入射光向量：

```glsl
//求出入射光向量
vec3 lightDirection = v_Position - u_LightPosition
```

> 切记，在使用GLSL 的reflect 函数计算反射光向量时，一定要确保入射光向量的方向是从光源位置指向入射点位置。

有了入射光向量，我们还需要入射点的法向量`v_Normal`，这个值已经从顶点着色器中插值化后传到片元着色器了，所以我们可以直接拿来用：

```glsl
vec3 reflectDirection =reflect(normalize(lightDirection), normalize(v_Normal));
```

这样就求出了反射光向量，接下来我们计算视线观察向量。

### 计算视线观察向量

我们将入射点到观察者的方向向量定义为视线观察向量，为了计算这个向量，我们需要知道入射点的位置以及观察者的位置，入射点的位置我们有了，现在需要观察者的位置，我们将人眼在世界坐标系下的坐标作为观察者位置，然后将其用 `uniform` 变量的形式传递到片元着色器中。

因此我们的片元着色器要增加一个 `uniform` 变量接收观察者坐标。

```glsl
// 观察者坐标。
uniform vec3 viewPosition;
```

有了观察者坐标，我们就可以计算出视线观察向量了。

```glsl
// 视线观察向量
vec3 viewDirection = viewPosition - v_Position;
```

### 计算镜面高光因子

前面求出了视线观察向量和反射光向量，接下来我们就可以计算镜面高光因子了。

首先，归一化`视线观察向量`和`反射光向量`

```glsl
viewDirection = normalize(viewDirection);
reflectDirection = normalize(reflectDirection);
```
然后计算这两个向量的点积，这里要注意一点，就是如果这两个向量的点积为负数，则说明视线观察向量和反射光向量大于 90 度，是没有反射光进入眼睛的，所以我们使用 `max`函数取点积和 0 之间的最大值。

```glsl
// 镜面高光因子
float specialFactor = dot(viewDirection, reflectDirection);
// 如果为负值，一律设置为 0。
specialFactor = max(specialFactor, 0.0);
```



完整的片元着色器程序如下：

```glsl
    precision mediump float;
    varying vec4 v_Color;
    uniform vec3 u_LightColor;
    uniform float u_AmbientFactor;
    uniform vec3 u_LightPosition;
    varying vec3 v_Position;
    varying vec3 v_Normal;
    uniform vec3 u_ViewPosition;
    void main(){
      // 环境光分量
      vec3 ambient = u_AmbientFactor * u_LightColor; //环境光分量
      // 光线照射向量
      vec3 lightDirection =  v_Position - u_LightPosition;
      // 归一化光线照射向量
      lightDirection= normalize(lightDirection);
      // 漫反射因子
      float diffuseFactor = dot(normalize(lightDirection), normalize(v_Normal));
      // 如果大于 90 度，则无光线进入人眼，漫反射因子设置为0。
      diffuseFactor = max(diffuseFactor, 0.0);
      // 漫反射光照
      vec3 diffuseLightColor =u_LightColor * diffuseFactor;
      
      // 归一化视线观察向量
      vec3 viewDirection = normalize(v_Position - u_ViewPosition);
		//反射向量
      vec3 reflectDirection = reflect(-lightDirection, normalize(v_Normal));
      
      // 初始化镜面光照因子
      float specialFactor = 0.0;
      // 如果有光线进入人眼。
      if(diffuseFactor > 0.0){
       	specialFactor = dot(normalize(viewDirection), normalize(reflectDirection));
        specialFactor = max(specialFactor,0.0);
     }
     // 计算镜面光照分量
      vec3 specialLightColor  = u_LightColor * specialFactor * 0.5;
      // 计算总光照
      vec3 outColor = ambient + diffuseLightColor + specialLightColor;
      // 将物体自身颜色乘以总光照，即人眼看到的物体颜色。
      gl_FragColor = v_Color * vec4(outColor, 1); 
    }

```

加入光照之后，我们的着色器代码就变多了，但其实并不复杂，仅仅是`取值`、`计算`、`赋值`操作而已。

### JavaScript 部分
镜面光照我们需要为着色器传递一个人眼观察位置，所以我们的JavaScript 部分需要修改：

```javascript
// 获取着色器全局变量 `u_ViewPosition`
var u_ViewPosition = gl.getUniformLocation(program, 'u_ViewPosition');
```

将人眼观察位置放置在 z 轴正方向 10 位置，即物体的前面。


```javascript
var uniforms = {
	eyeX: 0,
	eyeY: 0,
	eyeZ: 10
};

gl.uniform3f(u_ViewPosition, uniforms['eyeX'], uniforms['eyeY'], uniforms['eyeZ']);
```

完整的代码大家可以参见[这里]()，我们比较下加入镜面高光前后的效果。

无镜面高光时：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/16685394ede269fc~tplv-t2oaga2asx-image.image)

添加镜面高光后：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166853931eb2c864~tplv-t2oaga2asx-image.image)

观察上面两幅图，我们能很直观地看到添加镜面高光后，球体正中央有一个明晃晃的光圈，符合真实世界中的场景。



## 反光度

但是，这个刺眼的光圈面积太大了，我们需要给它添加一个称为`反光度`(shininess)的参数约束光圈的大小，一个物体的反光度越大，反光率就越强，散射的光就越少，我们看到的高光面积就越小。

我们定义一个`u_Shininess`的变量表示物体的反光度，然后用前面求得的高光因子乘以 2 的shininess次幂作为最终的高光因子。这样就可以让我们的光圈变得小一些。

>求幂计算可以通过GLSL 内置的公式 pow(2, shininess)求得。

```glsl
specialFactor = max(specialFactor, 0.0);
specialFactor = pow(specialFactor, u_Shininess);
```

一般情况下，我们设置物体的反光度为 32 就可以了，但是特殊场景下，效果可能不理想，这时候，我们就需要根据实际情况调整反光度了。

我们将反光度设置成 32，看下增加反光度后的效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/17/16682af8af2b40a2~tplv-t2oaga2asx-image.image)

这会效果明显好多了，我们可以看到光圈点很小了，大家可以[点击此处]()查看我做的 demo，调节反光度看下效果。

### Blinn-Phong光照模型
冯氏光照模型不仅能够很好的近似真实光照，而且性能也相当高。但是
这种光照在某些场景下仍然有些缺陷，大家观察前面没有添加反光度时的图片，应该能发现高光光圈边缘有一圈很明显的暗灰色断痕，但大家再看一下增加反光度后的效果，却没发现这种现象。这是为什么呢？

产生这个问题的原因是，在高光边缘部位，由于人眼视线向量和反射光向量夹角大于90度，那么夹角的余弦值便小于 0，按照冯氏光照模型的镜面光照算法，夹角余弦值小于 0 时， 我们的镜面高光分子系数就会用 0 来代替。所以高光边缘部位及以外的部分就没有了镜面光照分量，试想一下，如果反光度越小，镜面高光区域就越大，那高光区域边缘部位漫反射光的分量所占比重就会比较小，在高光边缘部位就会产生一种较大的亮度差，给人一种暗灰色断痕的感觉。反之，反光度越小，光圈越小，相应地，光圈周围漫反射光的分量所占比重就比较大，所以不会在高光边缘产生过大的亮度差。

如下图，反射光线和视线观察向量之间的夹角γ 大于90度，所以此时镜面高光分量为 0。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/1668555808c1edac~tplv-t2oaga2asx-image.image)

其实，这种观察角度，镜面高光分量还是应该有的，只是值比较小而已。所以，出现了 Blin Phong 光照模型，这种光照模型不再利用反射向量，而是采用了`半程向量` ，半程向量是视线和反射光之间夹角的一半方向上的单位向量，利用半程向量和法向量之间的夹角余弦来表示镜面高光因子，半程向量和法向量之间的夹角越小，镜面高光分量越大，如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166855f7d5303bea~tplv-t2oaga2asx-image.image)


### 实现 Blin Phong 光照
我们在冯氏光照代码的基础上加以修改，实现 Blin 光照模型。与冯氏光照模型不同的是，我们需要半程向量，半程向量该如何求呢？

按照向量的计算规则，半程向量只需要我们将视线观察向量和反射向量相加，然后将得出的结果归一化就可以求出了。

```glsl
// 计算半程向量
vec3 halfVector = normalize(reflectDirection + viewDirection);
// 计算高光因子
float specialFactor = dot(normalize(v_Nomral), halfVector);
```

利用 GLSL 的内置函数，我们就很容易的求出来了。

从冯氏光照模型进化成 Blin光照模型，我们只需要改动这么一处就可以了，是不是觉得很简单呢？

算法是很简单，但是我希望大家还是能够把算法背后的原理搞清楚。这才是大家学习的目的。

好了，我们比较一下反光度同时为 1 的时候，冯氏光照和 Blin 光照之间的差别。


冯氏光照效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166853931eb2c864~tplv-t2oaga2asx-image.image)

Blin 光照效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/166856699653738b~tplv-t2oaga2asx-image.image)

可以看到，采用 `Blin光照模型`后， 镜面高光区域过度的更加自然。


## 回顾

至此，我们就讲完了冯氏光照模型，以及为了解决冯氏光照的缺陷而引入的 `Blin 光照模型`。

本节也涉及到了许多向量矩阵之间的计算，大家多加练习，不要被这些计算搞晕了。


接下来我们进入下一个环节的学习，对 GLSL 的语法进行一个总结。

## 13. 中级进阶 --- 深入理解 GLSL 语法

经过前面几个章节的学习，相信大家对 GLSL 的部分语法已经熟稔于心了，但我们终究没有对 GLSL 有系统的认知，所以开辟一小节对 GLSL 的常用语法做一个详细介绍。

## 你能学到什么？

* GLSL 中的数据类型
* GLSL 中的内置变量
* 向量、矩阵的表示与运算。
* GLSL 中的内置函数

GLSL 属于 GPU 层面的编程语言，因此它必须有能力支持图形相关的操作。除了绘制 API，还要支持各种数学运算，主要体现在向量和矩阵。

GLSL 主要是在 C 语言的基础上新增了一些`内置变量`、`数据类型`和`数学函数`，因为是基于 C 语言的拓展，所以在语法规则上和 C 语言基本相同。

## 变量命名

GLSL 的语法和 C 语言类似，因此 GLSL 的变量命名方式和 C 语言基本一致。但由于 GLSL 新增了一些数据类型、内置属性和保留前缀，所以变量命名除了满足 C 语言的命名规则之外，还要满足 GLSL 的特殊规则：

* 不能以 `gl_` 作为前缀，gl_ 开头的变量被用于定义 GLSL 的内部变量，这是 GLSL 保留的命名前缀。
* GLSL 的一些保留名称也不能作为变量名称，比如 `attribute`、`uniform`、`varying` 等。

## 数据类型

GLSL 最突出的部分是新增了向量和矩阵相关的数据类型，比如存储向量的容器 `vec{n}`，存储四阶矩阵的容器`mat4`，2D纹理采样器 `sampler2D`，3D纹理采样器`samplerCube`等等。下面我们着重介绍向量和矩阵在 GLSL 中的用法。

### 向量

向量是 GLSL 中很重要的一种数据类型，着色器程序的很多地方都需要用到向量，用来储存包含多个分量的数据，比如`颜色信息`、`齐次坐标`、`法向量`等。

向量按照维度分为`2维`、`3维`、`4维`，按照存储的数据类型分为浮点向量`vec{n}`，整型向量`ivec{n}`，布尔向量`bvec{n}`。

#### 浮点向量

* vec2：存储2个浮点数。
* vec3：存储3个浮点数。
* vec4：存储4个浮点数。

浮点向量的赋值相对浮点数宽松一些，比如在为一个浮点变量赋值的时候，我们必须这样写：

* 正确
```glsl
float size = 10.0;
```

像下面这样赋值就会报错，因为类型不匹配，size 是浮点变量，10 是一个整数，`变量类型`和`要赋值的类型`不匹配。

* 错误

```
float size = 10;
```

但是在为向量赋值时，就会宽松一些，比如我们构建一个2维浮点向量，分量都是 1。

我们可以这样写：

* 正确

```glsl
vec2 texcoords = vec2(1.0, 1.0);
```
也可以这样写：

```glsl
vec2 texcoords = vec2(1, 1);
```

vec 向量类型会自动对元素做类型转换。


> 之所以讲这些细节，有一个原因是 GLSL 程序的调试有一定局限性，没有特别好用的调试器能够让我们逐行逐变量地进行调试，所以我们只能减少低级失误。  

>怎样才能减少低级失误？只有夯实基础。但减少失误并不意味着消除，即使我们万般小心，也仍然会出现问题导致编译或者运行异常，这时只能用肉眼排查问题。拥有好的基础，也会促使你很快地找到问题产生的原因。

#### 整型向量

* ivec2：存储2个整数。
* ivec3：存储3个整数。
* ivec4：存储4个整数。

整型向量和浮点向量类似，向量的各个元素都是整型数字，此处不做重复讲解。

#### 布尔向量
* bvec2：存储2个布尔值。
* bvec3：存储3个布尔值。
* bvec4：存储4个布尔值。

布尔向量的各个元素都是布尔值`true`或者`false`，此处也不做重复讲解。

### 向量的使用技巧
每个向量我们都可以用 `{s、t、p、q}`,`{r、g、b、a}`,`{x、y、z、w}`来表示。获取各个位置的元素，我们可以使用`.`操作符。

比如一个 4 维向量：

```
vec4 v = vec(1, 2, 3, 4);
```

那么`v.s`、`v.r`、`v.x`、`v[0]`表示的是该向量第 1 个位置的元素。  

同理：  

* `v.t`、`v.g`、`v.y`、`v[1]`表示的是该向量第 2 个位置的元素。  
* `v.p`、`v.b`、`v.z`、`v[2]`表示的是该向量第 3个位置的元素。  
* `v.q`、`v.a`、`v.w`、`v[3]`表示的是该向量第 4 个位置的元素。

除此之外，我们还可以使用这种方式对低维向量赋值，假设我们有一个 4 维向量 v，现在想以 v 的前两个元素创建一个 2 维向量 v1，那么我们可以这样赋值：

```glsl
vec4 v = vec4(1, 2, 3, 4);

// xyzw 方式赋值
vec2 v1 = v.xy;
// stpq 赋值
vec2 v1 = v.st;
// rgba 赋值
vec2 v1 = v.rg;

// 构造函数式
vec2 v1 = vec2(v.x, v.y);
vec2 v1 = vec2(v.s, v.t);
vec2 v1 = vec2(v.r, v.g);
```

还可以这样使用：

```glsl
vec4 v = vec4(1, 2, 3, 4)
vec2 v1 = vec2(v.xx);
```

通过 `v.xx` 的方式将 `v1` 的两个元素设置成 `v` 的第一个元素值，变成 `(1, 1)`。


#### 向量的运算规则
GLSL 中关于向量的另一个重要部分就是运算规则，向量的运算对象分为如下几类：

**向量和基础数字类型的运算**。

向量和基础数字类型之间的运算比较简单，规则是将数字和向量的各个分量进行运算，并返回新的向量。

假设有一个 4 维向量 `v(x, y, z, w)`，浮点数 `f`。

向量 v 和 f 之间的加减乘除运算，GLSL 会将各个分量分别和数字 f 进行加减乘除，并返回新的向量 v1。

```glsl
// 加法
vec4 v1 = v + f = (x + f, y + f, z + f, w + f);
// 减法
vec4 v1 = v - f = (x - f, y - f, z - f, w - f);
// 乘法
vec4 v1 = v * f = (x * f, y * f, z * f, w * f);
// 除法
vec4 v1 = v / f = (x / f, y / f, z / f, w / f);
```

**向量和向量之间的运算**

向量和向量之间也可以进行运算，返回一个新的向量，前提是两个向量之间的维度必须相同。

运算规则是两个向量对应位置的元素分别进行运算。

假设向量 v1 (x1, y1, z1, w1)，向量 v2（x2, y2, z2, w2），那么有：

```glsl
// 加法
vec4 v3 = v1 + v2 = (x1 + x2, y1 + y2, z1 + z2, w1 + w2);
// 减法
vec4 v3 = v1 - v2 = (x1 - x2, y1 - y2, z1 - z2, w1 - w2);

// 乘法
vec4 v3 = v1 * v2 = (v1 * v2, y1 * y2, z1 * z2, w1 * w2);
// 减法
vec4 v3 = v1 / v2 = (x1 / x2, y1 / y2, z1 / z2, w1 / w2);
```

看起来很简单，但是有一点需要注意，向量之间乘法有三种，上面的 * 号乘法规则是为了使用方便。

在数学领域，向量之间还有两种乘法`点乘`和`叉乘`，具体区别我们在[中级进阶 --- 数学：点、向量、矩阵]()章节详细介绍。

GLSL 中增加了两种内置函数，用来实现`点乘`和`叉乘`运算，它们分别是 `dot`和`cross`，使用起来也很简单：

```glsl
// 点乘
float v3 = dot(v1, v2);

// 叉乘
vec3 v3 = cross(v1, v2);
```

在计算光照效果时，会经常使用这两个函数。

以上就是向量相关内容，大多数运算规则和线性代数一致。

### 矩阵

矩阵是 GLSL 中和数学相关的另一块重要内容，在着色器程序中，我们会经常使用矩阵来完成各种变换，比如坐标转换、计算光照时的法向量转换等。


#### 矩阵分类

矩阵按照维度分为二阶、三阶、四阶，其中三阶和四阶矩阵用的较多，我们下面主要讲解四阶矩阵。

#####  四阶矩阵

四阶矩阵，包含 4 行 4 列共 16 个浮点数，在着色器程序中初始化一个四阶矩阵有很多种方式。

* 用 16 个浮点数构造矩阵。

这是最简单最直观的构造方式：

```glsl
mat4 m = mat4(
    1, 2, 3, 4,  //第一列
    5, 6, 7, 8,  //第二列
    9, 10, 11, 12, //第三列
    13, 14, 15,16 // 第四列
);
```
* 用 1 个浮点数构造对角线矩阵。

```glsl
mat4 a = mat4(1.0);
```

mat4 传入一个浮点数构造出的矩阵，对角线上的值都是 1.0:

```javascript
[  
    1.0, 0, 0, 0,
    0, 1.0, 0, 0,
    0, 0, 1.0, 0,
    0, 0, 0, 1.0
]
```

* 利用列向量构造

四阶矩阵可以理解为四个列向量组合而成，所以 GLSL 提供了利用向量构造矩阵的方法。

```glsl
//第一列
vec4 c0 = vec4(1, 2, 3, 4);
//第二列
vec4 c1 = vec4(5, 6, 7, 8);
//第三列
vec4 c2 = vec4(1, 2, 3, 4);
//第四列
vec4 c3 = vec4(5, 6, 7, 8);

mat4 m = mat4(c0, c1, c2, c4);
```

* 向量与浮点数混合构造。
当然除了纯数字构造、纯向量构造，GLSL 也允许向量和数字混合构造：

```glsl
vec4 c0 = vec4(1, 2, 3, 4);
vec4 c1 = vec4(5, 6, 7, 8);
vec4 c2 = vec4(1, 2, 3, 4);

mat4 m = mat4(c0, c1, c2, 5, 6, 7, 8);
```

观察上面的构造方式，我们发现，mat4构造函数 中传入的数字只要满足 16 个就可以构造成四阶矩阵。

所以，大家还可以想到利用二维、三维向量进行构造的方式。

总之，GLSL 为矩阵提供的构造方式很灵活，毕竟，在 GLSL 中我们用的最多的除了`向量`就是`矩阵`了。

* 矩阵运算

##### 乘法运算
我们用的最多的就是乘法运算了，在GLSL 中，矩阵乘法用 `*` 来表示，但大家要记住，由于 GLSL 中矩阵采用的是`列主序`，所以，矩阵和向量相乘时，要置在乘号左侧，如下：

```glsl
mat4 m = mat4(1.0);
vec4 v1 = m * vec4(1, 2, 3, 4);
```

还有一些其他的矩阵运算方法，比如`转置`、`求逆`等：

```glsl
mat4 m0 = mat4(1.0);
// 转置
mat4 m1 = transpose(m0);
// 求逆
mat4 m2 = inverse(m0)
```



## 内置变量

内置属性在前面章节中已经学过一些了，比如大家很熟悉的 `gl_Position`、`gl_FragColor` 等，除此之外，还有一些不常用的属性。

### 顶点着色器

* gl_Position：顶点坐标。
* gl_PointSize：点的尺寸。
* gl_Normal：顶点法线。

### 片元着色器
* gl_FragColor，当前片元的颜色，类型 vec4。
* gl_FragCoord，屏幕像素的x，y，z，1 / w。
* gl_FragDepth，片元的最终深度值，在后面的深度测试用到，在片元着色器中我们无法修改`x, y`值，但是可以修改`z`值。

## 内置函数
GLSL 内置了很多数学函数，下面列举一些经常用到的。
### 向量函数

|函数|作用|
|--|--|
|cross|计算两个向量的叉积
|dot|计算向量的点积。
|normalize|归一化向量，返回一个和原向量方向相同，但是长度为1的单位向量。|
|reflect|根据入射向量和法线向量，计算出反射向量。|
|length|计算向量的长度|
|distance|计算两个向量之间的距离。|

### 常用数学函数
|函数|作用|
|--|--|
|abs|将某个数的绝对值
|floor|返回不大于某个数的最大整数。
|round|四舍五入值|
|ceil|返回大于某个数的最小整数。|
|fract|返回浮点数的小数部分|
|mod|取模|
|min|返回两个数中比较小的数|
|max|返回两个数中比较大的数|

### 三角函数
GLSL 提供了很多三角函数，方便我们进行角度求值：

|函数|作用|
|--|--|
|radians|将角度（如90度）转化为弧度（PI/2）。
|degrees|将弧度（如PI / 2）转化为角度（90 度）。
|sin|求弧度的正弦|
|cos|求弧度的余弦|
|tan|求弧度的正切|
|asin|根据正弦值求对应的弧度|
|acos|根据余弦值求对应的弧度|
|atan|根据正切值求对应的弧度|

以上就是常用的三角函数，GLSL 还提供了一些更复杂但是不常用的函数，此处不一一列举了，大家感兴趣的话可以查查 GLSL 语法规范。

## 限定符

限定符在之前章节也已经陆续讲过了，再次做个总结。

### attribute

attribute 变量只能定义在`顶点着色器`中，它的作用是接收 JavaScript 程序传递过来的与`顶点`有关的数据，比如在之前程序中定义的`顶点颜色`、`法线`、`坐标`等，它们是顶点的属性。

也就是说，如果有一类数据，它是跟随顶点而存在的，每个顶点所对应的数据不尽相同，那么我们就需要用 attribute 限定符定义变量。


### uniform

uniform 用来修饰全局变量，它既可以在顶点着色器中定义，也可以在片元着色器中定义，用来接收与顶点无关的数据。

比如，在之前程序中，我们定义了一个 uniform 变量 `u_Matrix`，它用来接收 JavaScript 中传递过来的 模型视图投影矩阵，该数据与顶点无关，也就是每个顶点共用变换矩阵，所以我们应该用 uniform 修饰该变量。



### varying

varying变量一般是成对定义的，即在顶点着色器中定义，在片元着色器中使用。它所修饰的变量在传递给片元着色器之前会进行插值化处理。



## 回顾
以上是对常用 GLSL 语法的一个总结，事实上还有一些比较罕见的函数我们没有列举，大家在用到的时候可以查阅 WebGL 官方文档。

* [WebGL 规范](https://www.khronos.org/registry/webgl/specs/latest/2.0/)
* [OpenGL ES 规范](https://www.khronos.org/files/opengles_shading_language.pdf)

接下来的章节我们开始 3D 数学知识的学习，因涉及到一些推导，建议线性代数基础不好的同学准备好纸笔。

## 14.中级进阶 --- WebGL 与数学：我们需要哪些数学知识？

在前面章节的学习中，大家已经接触过`矩阵`、`向量`等数学概念了。那么除了`矩阵`和`向量`， 关于 3D 开发我们还需要哪些数学知识？这些数学知识又能够帮助我们解决什么问题呢?

本节为大家做一个概括，接下来的章节我们就深入学习这些数学知识。

## 你能学到什么？

* 明确图形学开发与数学基础的密切关系。
* 学好图形学开发需要掌握哪些数学知识。
* 这些数学知识能够帮助我们解决什么问题。

那么，3D 应用涵盖哪些数学知识呢？

## 一、 坐标系

`坐标系`是一个重中之重的概念，我们在开发 3D 应用的过程中，经常会涉及到坐标系之间的转换，最经典的坐标转换流水线就涉及到六种坐标系，由此可见坐标系的重要性。

## 二、 点

`点`在 3D 领域通常指`顶点坐标`，3D 世界由很多`模型`组成，模型又由很多`面`组成，而面又由很多`点`组成。因此，`点`是组成 3D 世界的基本元素。WebGL 渲染的过程，就是将组成模型的`顶点`传递给 `GPU`，GPU 按照指定图元`装配`并`插值`这些顶点数据，然后通过片元着色器对像素进行着色，最终渲染成 `3D 模型`。由此可见`顶点`是模型的起始数据，重要性可见一斑。

## 三、向量

`向量`是另一个非常重要的知识点。物理和数学中的向量代表既有`大小`又有`方向`的量。

通常我们使用`向量容器`来表示数学中的`点`和`向量`。


比如我们经常会使用 `3 维向量`来表示`顶点坐标`，3 维向量还可以理解为一个 `3 x 1` 阶矩阵，将 `3 x 3` 阶变换矩阵左乘顶点坐标（3 * 1 阶矩阵），按照矩阵的运算法则，`m行n列` 矩阵左乘 `n 行 o 列`矩阵可以得到一个 `m 行 o 列`矩阵，所以我们矩阵和向量相乘结果是一个新的 3 * 1 阶 矩阵，也就是 3 维向量，它表示变换后的顶点坐标。

>这从数学角度解释了`变换矩阵`左乘`顶点坐标向量`的结果是一个新的顶点坐标的原因。

通常在对模型执行坐标转换的时候，`变换矩阵`左乘`顶点坐标`代表对这个顶点执行`坐标转换`，这是顶点着色器中对顶点执行的最常用的操作。

又比如在为模型表面计算光照强度的时候，我们会用到法向量和光线入射向量，利用他们之间的点积计算光照强度。

向量的重要性可见一斑。

### 向量计算

3D 编程中经常使用的向量运算有以下几种。

* 点积
* 叉积
* 归一化向量
* 向量长度
* 两个向量之间的距离
* 向量基本运算
    * 向量相加  
    * 向量相减
    * 向量相乘
    * 向量相除

后续章节我们会详细学习它们的运算规律，并提供 JavaScript 版本的分析与实现。


## 四、矩阵
3D 数学中最重要的一个知识点我想就是`矩阵`了，矩阵能够帮助我们以一种非常简单的方式解决大量运算的问题。

比如坐标转换。

那有同学会问了，坐标转换无非就是对顶点坐标的计算，我用普通的`加减乘除`和`三角函数`运算也能做到呀。

说的没错，那大家有没有想过，如果要对一个坐标执行多种变换，大家需要写多少计算逻辑？

我想大家会崩溃的。

`矩阵`就是为了帮助我们解决这个问题，一个矩阵代表一种变换，多个矩阵相乘就代表多个变换。有了矩阵，我们就不用再使用三角函数，加减乘除等繁杂的数学公式来完成坐标转换，仅仅使用一个矩阵就可以代替多种运算步骤。

前面在构建立方体的章节我们已经接触到了矩阵，仅仅让一个`旋转矩阵`左乘`顶点坐标`，就实现了立方体的旋转，由此可见矩阵在 3D 数学运算中的重要性。

这就是矩阵的主要作用。但使用矩阵还有一点考虑，就是在 GPU 中执行矩阵运算性能会高很多，这得益于 GPU 并行计算的优势，在绘制大量顶点的场景下会有很大的性能提升。

### 矩阵运算

3D 编程中经常用到的矩阵运算有以下几种。

* 单位化矩阵
* 矩阵基本运算  
    * 矩阵相加。 
    * 矩阵相减。
    * 矩阵相乘。
    * 转置矩阵
    * 逆矩阵
* 旋转矩阵
	* 绕 X 轴旋转。
	* 绕 Y 轴旋转。
	* 绕 Z 轴旋转。
	* 绕轴向量旋转。
	* 根据欧拉角推导旋转矩阵。
	* 根据四元数推导旋转矩阵。
	* 旋转矩阵与欧拉角、四元数之间的变换。
* 平移
	* 沿 X 轴平移。
	* 沿 Y 轴平移。
	* 沿 Z 轴平移。
* 缩放
	* 沿 X 轴缩放。
	* 沿 Y 轴缩放。
	* 沿 Z 轴缩放。
* 观察矩阵
* 正射投影矩阵
* 透视投影矩阵


如果我们不理解矩阵和向量的运算规则，我们就写不出数学库，自然就没办法开发 3D 应用。接下来我们就要着重讲解这方面的内容，另外我还会详细推导变换矩阵的 JavaScript 算法实现，封装出一个我们自己的数学库。

## 五、 常用数学函数
3D 开发时我们经常需要使用一些数学函数完成一些数值运算，常用的有如下几种：

* sin (θ)
    * 指定角度 θ 的正弦值。
* asin (value)
    * 指定正弦值 value 对应的角度值。

* cos (θ)
    * 指定角度 θ 的余弦值。
* acos (value)
    * 指定余弦值 value 对应的角度值。
* atan (value)
    * 指定正切值 value 对应的角度。
* tan (θ)
    * 求 θ 的正切值。
* abs (value)
    * 取 value 的绝对值。
* max (value1, value2)
    * 取 value1 和 value2 之间的最大值。
* min (value1, value2)
    * 取 value1 和 value2 之间的最小值。
* clamp (value, min, max)
    * 如果 value 小于 min，返回 min，如果 value 大于 max ，返回 max，如果 value 介于 min 和 max 之间，返回 value。
* pow (x, n)
    * 求 x 的 n 次幂。
* 。。。

还有一些函数就不一一介绍了，在需要的时候大家可以查一下。

## 六、其它高等函数

上面的数学知识，足以支撑我们完成大部分 3D 效果了，但在做一些曲线相关应用的时候，我们还会用到一些曲线公式来求坐标，如`正弦`、`余弦`、`贝塞尔`公式等。本小册不对它们做过多介绍，感兴趣的话大家可以去看看 ThreeJS 对它们的实现。

## 回顾

以上就是我们在 3D 编程中将会用到的数学知识，业界一般将这些数学算法抽象出来以方便调用，比如 `Threejs` 就有单独的 `matrix` 、`vector`、`euler`等数学类。JavaScript没有提供向量和矩阵的表示和运算，所以我们需要封装。但是 `GLSL` 内置了大部分数学运算。

有的同学会问，既然 `GLSL` 内置了这些计算，`Threejs`  为什么还要封装呢？

这是因为有些运算没有必要放在 `GLSL` 中，如果放在 `GLSL` 中反而会影响性能。比如`全局变换矩阵`，如果放在 `GLSL` 中计算，那么每个顶点变换前，都要重新计算出矩阵。模型的顶点都是很多的，这会造成大量重复运算。尽管 `GPU` 的运算能力很强，但那么多的无用运算还是会造成性能问题。

下一节，我们开始详细介绍这些数学知识。

## 15.中级进阶 --- 数学：点、向量、矩阵。

今天我们着重讲解计算机图形学中的数学理论，这部分内容不仅适合 WebGL 开发同学阅读，同样适用 OpenGL、 Direct3D 等 3D 领域的开发同学。

数学之于图形学，就像空气与人类的关系，人类的生存离不开空气，同样地，如果要学好图形开发，数学功底也是必不可少的。因此，从本节开始，我会向大家详细地介绍图形学相关的数学知识，帮助大家打好这方面的基础。之后，大家不管是去学 WebGL 还是其他 3D 开发，都会轻松很多。

图形学内容其实不仅会让 3D 领域的开发同学受益，也能让 Web 开发同学受益。CSS3 新出了`transorm`和`perspective` 属性，我们可以用这两个属性实现 3D 效果，这两个属性的底层也是基于矩阵实现的。再比如一些手机适配库，也都是用一些简单的数学公式实现的。

## 图形学与数学

计算机图形学是一种使用数学算法将 2D、3D 模型渲染到 2D 计算机屏幕的科学，主要应用在游戏、数据可视化、地图导航、虚拟现实(AR)、增强现实(VR)等领域。

大家要知道一点，我们在计算机中模拟现实生活，只能达到近似模拟，而不能精确模拟。所以我们的数学算法只要能满足视觉上的近似效果就可以了。这也是图形学中的一个近似准则。

## 坐标系

3D 世界中的每个物体都有自己的位置，为了精确地表示这种位置，我们需要引入坐标系的概念，`坐标系`我相信大家在初中都学过，使用最为广泛的就是笛卡尔坐标系。

标准的笛卡尔坐标系 X 轴向右，Y 轴向上，如下图所示：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/16686d06208ba3f4~tplv-t2oaga2asx-image.image" width="300px"/>

而屏幕坐标系往往是 X 轴向右，Y 轴向下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/16686d23b30626c5~tplv-t2oaga2asx-image.image" width="300px" />


扩展到 3D时，笛卡尔坐标系的 Z 轴方向则有两种表示方式：`左手坐标系`和`右手坐标系`。左手坐标系的判定方式是张开左手，拇指伸直指向的方向代表 X 轴正方向，食指伸直指向的方向代表 Y 轴正方向，其余手指弯曲指向的方向则代表 Z 轴正方向。右手坐标系则是用右手，得到的 Z 轴正方向和左手坐标系相反，如下图所示：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/18/16686d956d61dad7~tplv-t2oaga2asx-image.image" width="500px" />


大家可以用左手和右手比划一下。

WebGL 中的坐标系遵循右手坐标系，Z 轴正向轴朝向屏幕外。


## 点

有了坐标系，我们就可以精确定位坐标系上的一个物体了，模型由点组成，点在坐标系中的位置用坐标来表示。比如 2D 笛卡尔坐标系上有一点 P。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/19/1668a4e9f2dd672a~tplv-t2oaga2asx-image.image" width ="500px" />


我们就可以用坐标 (3, 4) 表示这个点的位置，扩展到 3 维坐标系时，只需要增加顶点在 Z 轴上的坐标就可以了。

坐标系和点的知识相信大家在初中就已经学过了，而且比较简单，这里就不做过多阐述了。

接下来学习`向量`的相关内容。

## 向量

### 概念
`向量`是既有大小，又有方向的量，在物理和工程学中又称为`矢量`。

与之对应的是`标量`，标量只有大小，没有方向。如`身高`、`体重`、`距离`等。

日常生活中常见的向量有`位移`，`速度`，`加速度`、`光线方向`等等。

向量在坐标系中通常用一根带箭头的线段来表示。

### 向量的表示方式

向量一般用一个上方带一个箭头符号的字母表示， 如$\vec{a}$ 代表一个名称为 `a` 的向量。在 2D 笛卡尔坐标系中，假设某向量起点为 O(0, 0)，终点为 P(X, Y)，那么通常使用 $\vec{OP}$ 来表示这个 2 维向量，并且这个向量也可以用坐标的形式来表示：
$
\vec{OP} = (x - 0, y - 0) = (x, y)。
$

3D 笛卡尔坐标系中：
$
\vec{OP} = (x - 0, y - 0, z - 0) = (x, y, z)。
$

看到这里，有的同学或许有疑问了。GLSL 程序中有一个向量数据结构 vec，我们经常使用它来定义点坐标或者向量，那么如果给定一个变量：

```glsl
vec3 p = vec3(x, y, z);
```

如何判断 P 代表向量还是代表顶点坐标呢？

这是一个好问题。同时也是一个比较重要的知识点，我们必须有能力区分。

通常使用`齐次坐标系`来解决这种混乱。齐次坐标系使用 `N + 1` 维向量来表示 `N 维点坐标`和 `N 维向量`。假设在 3 维坐标系中，有一个点(X, Y, Z)，那么在齐次坐标系中会使用 4 维向量来表示它 (X, Y, Z, W)。注意：` W > 0`。如果是向量的话，齐次坐标将向量表示为`(X, Y, Z, 0)`。

请谨记：W 为 0 时代表向量。W 不为 0 代表点。

>齐次坐标系的引入除了解决这种概念混乱，还有一个重要的作用，透视除法。稍后讲到投影矩阵时我们再细说。



比较两个标量是否相等，只要比较他们大小是否相同即可。但是两个向量相等需要要满足以下两个条件：

* 大小相等
* 方向相同



在 2D 坐标系中，假设有两个向量 $\vec{OP2}$ 和 $\vec{P0P1}$，这两个向量虽然起点和终点都不相同，但是他们的的方向相同，大小相同，所以这两个向量相等。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/19/1668b0bc43f47111~tplv-t2oaga2asx-image.image" width="500px" />

$
\vec{OP2} = (2 - 0, 1 - 0) = (2, 1)。
$
$
\vec{P0P1} = (3 - 1, 4 - 3) = (2, 1)。
$

可以看出，这两个向量在各个坐标轴的坐标相同。

因此，判断两个向量是否相等，还可以通过它们在各个坐标轴上的分量是否相等来判断。

### 向量的运算

向量有多种不同于标量的运算规则，我们必须要熟练掌握。


假设有如下两个向量：

$
\vec{a} = (x0, y0)，\vec{b} = (x1, y1)。
$

我们看下他们是如何进行运算的。

#### 向量加减

* 维度相同的两个向量才可以相加或者相减，得到的新向量维度和原向量相同，新向量各个分量等于原向量各个分量之和或之差。
* 向量不能和标量相加。
* 向量减法不满足交换律。
* 向量加法满足交换律。
$
\vec{a} + \vec{b} = (x0 + x1, y0 + y1)
$

$
\vec{a} - \vec{b} = (x0 - x1, y0 - y1)
$

向量相加在坐标系中表示如下：


<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/19/1668b392ddecb5d8~tplv-t2oaga2asx-image.image" width="500px" />

向量相减在坐标系中表示如下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/19/1668b4349988c54c~tplv-t2oaga2asx-image.image" width="500px" />

$
\begin {aligned}
\vec{a} - \vec{b} &= (x0 - x1, y0 - y1)\\\
\vec{b} - \vec{a} & = (x1 - x0, y1 - y0) \\\
& = (-(x0 - x1), -(y0 - y1))
\end {aligned}
$


可见 $\vec{a} - \vec{b}$ 和 $\vec{b} - \vec{a}$ 的结果大小相同，方向相反，所以不满足交换律。 

#### 零向量

零向量是唯一一个大小为 0 的向量，对于其他任意大小不为 0  的向量，它们都存在无数个方向不同的向量，这些向量构成一个圆，零向量我们用的比较少。

#### 负向量

负向量其实是原向量的反方向向量，大小不变，方向相反。求一个向量的负向量，只需将原向量的各个分量变成它们的相反数即可，并且负向量和原向量维度相同。

 $-\vec{a} = (-x, -y, -z)$  
 
 负向量可以理解为原向量与 -1 的乘法运算。
 
 #### 向量大小
 向量的大小，也就是向量的长度（也叫向量的模），通常用 $|\vec{a}|$来表示，向量的大小等于向量各个分量平方之和的平方根。
 
$
 |\vec{a}| = \sqrt[2]{x^2+y^2}
$

#### 向量与标量乘除
向量不能和标量相加减，但是向量可以和标量相乘除，向量和标量相乘或者相除返回一个新向量，新向量的各个分量等于原向量的各个分量和标量的乘积或者商。

$\vec{a} \times 2 = (x \times 2, y \times 2)$

$\vec{a} \div 2 = (x \div 2, y \div 2)$

向量与标量相乘的几何解释是：向量乘以标量 n 的意义是以因子|n|缩放向量的长度，例如：为了使向量的长度加倍，应使向量乘以 n 。如果 n < 0，则向量的方向与原向量相反。

#### 单位向量
单位向量是长度为 1 的向量，对于大部分向量，我们只关心向量的方向，而不在意向量的长度，这种情况下就适合用单位向量来表示。比如光线入射方向、反射方向等向量，单位向量通常也被称为标准向量。

对于任意一个不为 0  的向量，我们都能将它转变成同方向的单位向量，这个转变过程我们称之为`归一化向量`或者`标准化向量`。

归一化向量只需要将原向量除以原向量的长度（模）即可，一定要注意，原向量不能是零向量。

归一化向量 $\vec{a}$的过程：

$ (x \div |\vec{a}|, y \div |\vec{a}|)$

#### 向量点乘
标量和向量可以相乘，向量和向量也可以相乘，向量之间乘法包含两种点乘和叉乘。

向量点乘就是将两个向量的各个分量的乘积相加，返回一个`标量`。

点乘的计算方式如下：

$\vec{a} \cdot \vec{b} = x0 \times x1 + y0 \times y1 $

点乘的几何意义是两个向量的模相乘然后再乘以夹角的余弦。

$\vec{a} \cdot \vec{b} = |\vec{a}| \times |\vec{b}| \times cos(\theta) $

所以，我们经常会用点乘来计算两个向量之间的夹角大小，比如在光照模型中，我们在计算漫反射分量时，就使用了点乘公式，求出入射光和法向量之间夹角的大小，通常只求夹角的话，一般先将两个向量归一化，这样就不用再去计算向量模了，直接取点乘结果即可。

#### 叉乘
向量叉乘是另一个重要的运算，两个向量叉乘结果是一个新向量，新向量的方向垂直于原来两个向量所在的平面，方向可以通过右手定则来判定，大小等于两个向量模的乘积再乘以向量夹角的正弦值，即向量组成的平行四边形的面积。

$| \vec{a} \times \vec{b} | = |\vec{a}| \times |\vec{b}| \times sin(\theta) $


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669b1eb944c38c6~tplv-t2oaga2asx-image.image)

如上图，利用右手定则，当右手的四指从向量 a 以不超过 180 度的转角转向 b 时，竖起的大拇指指向是叉乘结果向量的方向。

叉乘一般用于3D坐标系中。

以下公式可以用向量来表示叉乘结果。

假设有向量$\vec{a}$和向量$\vec{b}$：

$\vec{a} = (x0, y0, z0)$

$\vec{b} = (x1, y1, z1) $

那么，向量 $\vec{a}$ 和 $\vec{b}$ 的叉乘：

$\vec{a} \times \vec{b} = (y0z1 - y1z0, x1z0 - x0z1, x0y1 - x1y0)$


### 向量的用途

向量用的最多的运算形式就是点乘和叉乘，我们经常会使用点乘判断两个向量夹角大小。

比如在计算光照时，判断物体表面是否被光源照射，就是通过法向量和光源入射光线的点积来判断，为正表示光源在表面正面，能被照射到，为负表示光源在表面背面，不能被照到。

又比如在游戏中判断怪物在自己前面还是后面，也会用点积来判断，点积结果为正，表示怪物在自己前面。点积结果为负，表示怪物在自己后面。

至此，向量的相关知识就介绍完了，大家看了也许当时懂了，但是过不久又忘了，所以一定要多加练习，让这些运算规则深入骨髓，就像我们对加减乘除的理解，能够很熟练地手写计算，才算真正掌握。

## 矩阵

前面讲了向量，接下来该亮出另一大神器`矩阵`了。

### 矩阵是什么

矩阵是按照行列排列的一系列数值得的集合，一个矩阵通常是由 m 行 n 列组成，我们称之为 $ m \times n $矩阵，如果 m 和 n 相同，该矩阵代表一个方阵，我们就可称这个方阵为 m 阶矩阵(方阵)，矩阵一般用大写字母来表示。

$  M = \begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix} $

这个矩阵由两行两列组成，也就是 2 阶矩阵。

可以看出，这个 2 阶矩阵还可以理解为 2 个行向量或者 2 个列向量的集合。

要注意，向量可以理解为一个特殊的矩阵，4 维向量既可以理解为一个 1 行 4 列矩阵，此时这个向量被称为行向量。

也可以理解为一个 4 行 1 列矩阵，此时这个向量被称为列向量。

$
\begin{aligned}
\vec{P} &= (1, 2, 3, 4) \\\
&=\begin{bmatrix} 1 & 2 & 3 & 4 \\ \end{bmatrix}
\\\
&=\begin{bmatrix} 1 \\ 2 \\ 3 \\ 4 \\ \end{bmatrix}
\end{aligned}
$


矩阵的表示方式比较简单，接下来我们看矩阵有哪些运算规则。

### 矩阵运算

矩阵的运算在图形学中非常重要，而矩阵的运算又包括矩阵之间的加减乘除等基本运算，以及转置矩阵、逆矩阵的求法。

#### 矩阵加减
两个矩阵相加或者相减需要满足一个条件，即两个矩阵必须同型，同型的意思是，行数和列数都必须一样。一个 m x n 矩阵 和一个 n x m 矩阵（m 不等于 n ）是不能进行加减的。

如果满足了以上条件，矩阵加法和减法的运算只需将两个矩阵对应位置上的元素相加或相减即可，得到的新矩阵和原矩阵同型：

$ \begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix} + \begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix} = \begin{pmatrix} 1 + 1 & 2 + 2 \\ 3 + 3 & 4 + 4 \\ \end{pmatrix} = \begin{pmatrix} 2 & 4 \\ 6 & 8 \\ \end{pmatrix} $


#### 矩阵乘法

矩阵既可以和标量相乘，也能和矩阵相乘，也能和向量相乘。在讲解乘法运算之前，我们必须先明确相乘的顺序，因为矩阵相乘不满足交换律。

##### 左乘与右乘
所谓左/右乘，是指参与运算的两个因子（向量或者矩阵）在运算中的相对位置，A 左乘 B 即$A \times B$，A 右乘 B即 $ B \times A $。

因此在说左乘或者右乘时，必须指定参与运算的两个因子。比如在 OpenGL 或者 WebGL 中对顶点进行矩阵变换，通常使用左乘，即矩阵 M 左乘向量 P，$M\times P$。

比较容易的理解方式就是： 左乘就是从左边过来乘，右乘就是从右边过来乘。

之所以要明确左右乘，是因为矩阵和矩阵不满足交换律，左乘和右乘的结果不一定相同。

$ M \times N \neq N \times M$

##### 矩阵与标量相乘

矩阵和标量相乘，返回一个新矩阵，新矩阵的各个元素等于原矩阵各个元素与标量的乘积。

$\begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix} \times 2 = \begin{pmatrix} 1 \times 2 & 2 \times 2 \\ 3 \times 2 & 4 \times 2 \\ \end{pmatrix} = \begin{pmatrix} 2 & 4 \\ 6 & 8 \\ \end{pmatrix}$

#####  矩阵与矩阵相乘

矩阵与矩阵相乘也要满足一定条件，假设两个矩阵能够相乘：

$P = M \times N$

那么，他们之间必须满足以下条件：

**M 的列数等于 N 的行数**

其次，一个 m 行 n 列矩阵 乘以 n 行 q 列矩阵，所得到的新矩阵为 m 行 q 列，即 `m行n列 * n行q列 = m行q列`。

新矩阵的各个位置的值按照如下规则计算：

矩阵 P 第 m 行 q 列位置的元素等于矩阵 M 第 m 行的各个分量和矩阵 N 第 q 列的各个分量的乘积之和，说起来比较绕，我们用一个公式来表示，矩阵 M 和 N 相乘，得到新的矩阵 P：

$
\begin {aligned}
P = M \times N &= 
\begin{pmatrix} a00 & a01 \\ a10 & a11 \\ \end{pmatrix} \times \begin{pmatrix} b00 & b01 \\ b10 & b11 \\ \end{pmatrix} \\\ &=\begin{pmatrix} a00 \times b00 + a01 \times b10 & a00 \times b01 + a01 \times b11  \\ a10 \times b00 + a11 \times b10  & a10 \times b01 + a11 \times b11 \\ \end{pmatrix} 
\end {aligned}
$

矩阵 P 第一行第一列位置的元素等于矩阵 M 第一行的各个分量分别乘以矩阵 N 的第一列的各个分量，然后相加。

矩阵 P 第二行第一列位置的元素等于矩阵 M 的第二行的各个分量分别乘以矩阵 N 第一列的各个分量，然后相加。

以此类推。。

如下图：


<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/19/1668cb9f75080931~tplv-t2oaga2asx-image.image" width="500px" />

总的来说，矩阵乘法比较复杂，但是不难，掌握好这个规律就很容易理解了。

另外需要谨记的是，矩阵乘法不满足交换律，但是满足结合律，有如下矩阵：

$
\begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix} \times \begin{pmatrix} 5 & 6 \\ 7 & 8 \\ \end{pmatrix} = \begin{pmatrix} 19 & 22 \\ 43 & 50 \\ \end{pmatrix}
$

$
\begin{pmatrix} 5 & 6 \\ 7 & 8 \\ \end{pmatrix} \times \begin{pmatrix} 1 & 2 \\ 3 & 4 \\ \end{pmatrix} = \begin{pmatrix} 23 & 34 \\ 31 & 46 \\ \end{pmatrix}
$

##### 矩阵与向量相乘
矩阵与向量相乘其实等价于矩阵与一阶矩阵相乘，其实质是将向量变换为另一个向量，但是要注意乘法的顺序。

假设有一个4 维向量 P 和一个4 阶方阵 M，当 P 左乘 M 时，P 一定要表示成行向量，即 1 * 4 矩阵。。当 P 右乘 M 时，P要表示成列向量，即 4 * 1 矩阵。

#### 转置矩阵
矩阵转置就是将原来矩阵的行向量转变为列向量，矩阵 M的转置矩阵用符号 $M^T$来表示，假设有一个矩阵M：

$
M = \begin{pmatrix} a00 & a01 \\ a10 & a11 \\ \end{pmatrix}
$
，那么 M的转置矩阵为：

$
M^T = \begin{pmatrix} a00 & a10 \\ a01 & a11 \\ \end{pmatrix}
$

转置运算比较简单。

#### 逆矩阵
假设有一个 m 阶方阵 A ，如果存在一个n 阶方阵 B，使得 $A \times B = B \times A = I $
其中 I 是单位矩阵，那么 B 是 A 的逆矩阵， A 矩阵就是可逆矩阵，也称非奇异矩阵，矩阵 A 的逆矩阵 用 $ {A^{-1}}$ 表示。

这里要说明一下什么是单位矩阵，单位矩阵首先是一个方阵，其次方阵对角线上的元素都为 1，其余元素为 0，比如下面就是一个 3 阶单位矩阵：


$
\begin{pmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \end{pmatrix} 
$

但并不是所有矩阵都存在逆矩阵，逆矩阵首先必须是`方阵`，其次存在另一个矩阵与之相乘，能够得到一个单位矩阵。

##### 逆矩阵的重要应用
逆矩阵在图形学中有着非常重要的作用，在图形学中，将一个变换矩阵左乘一个列向量（此处列向量代表顶点坐标），代表了对原始顶点执行了某种变换，比如旋转、缩放、平移等。逆矩阵的意义就是能够撤销这种变换，将变换后的坐标再还原回去。

假设有一个缩放矩阵 M，该矩阵代表放大两倍的变换，还有一个表示顶点坐标的向量 P，那么变换后的顶点 P1：

$
P_1 = M \times P
$

P1 是 将顶点 P 放大两倍后的新顶点。如果，我们想撤销这种变换，那么只需要求得 M 矩阵的逆矩阵$M^{-1}$，然后将逆矩阵左乘变换后的顶点 P1 即可。

$
P = M^{-1} \times P_1
$


当然，推导过程也比较简单：

$
\begin{aligned}
P &= P \times I \\\
& = P \times M \times M^{-1} \\\
& = P_1 \times M^{-1}
\end{aligned}
$

那么，既然逆矩阵这么有用，如何求出逆矩阵呢？

逆矩阵的求解比较复杂，但是不难，只需要按照步骤进行简单的算术运算即可，但是一定要保证每一步不出差错。

[这里](https://www.shuxuele.com/algebra/matrix-inverse-minors-cofactors-adjugate.html)是求解逆矩阵的步骤，大家可以按照步骤练习一下，限于篇幅本节不再赘述计算过程。



#### 正交矩阵
假设有一个方阵M，当且仅当 M 与其转置矩阵$M^T$的乘积等于单位矩阵时，称其为正交矩阵。即：
$
M \times M^T = I
$

所以很容易地得出，$M^T = M^{-1}$

正交矩阵的一个好处是，如果一个矩阵是正交矩阵，那么计算它的逆矩阵时，只需要对原矩阵转置即可，从而减少了计算量（逆矩阵的求解过程是很繁琐的），3D图形学中的最常见的旋转和镜像变换就都是正交的。 

判断一个矩阵 M 是否正交的重要条件是：M 的行向量是一个相互正交的单位向量组，什么意思呢？
假设有一个矩阵 M： 
$
M = \begin{pmatrix} \beta_i \\ \beta_j \\ ... \\ \end{pmatrix} 
$

其中 $\beta_i$为矩阵每一行的行向量，那么矩阵 M 是正交矩阵的充分必要条件是：

$
\beta_i \times \beta_j = \begin{cases}
 1 & (i = j) \\ 0 & (i \neq j)
\end{cases}
$

可能大家看不懂，其实就是两个条件

* 矩阵的每一行都是单位向量
* 矩阵的某一行和其他行向量相互垂直，点积为 0。

这两个条件可以利用$MM^T=I$公式来证明。利用这个充要条件可以快速判断一个矩阵是否是正交矩阵。同时也可以得到，如果$M$是正交矩阵，则$M^T$也是正交矩阵。

###### 正交矩阵示例
如下是图形学中的一个旋转矩阵$R_x$，它表示一个绕X轴旋转 $\theta$角度的变换：

$
R_x(\theta) = \begin{pmatrix} 1 & 0 & 0&0 \\ 0 & cos(\theta) & -sin(\theta) & 0 \\ 0 & sin(\theta) & cos(\theta) & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix} 
$

大家可以将这个矩阵验证上面正交重要条件，看看是否符合。

其实是符合的，所以它是正交矩阵。

其实这个也比较容易理解，撤销旋转 $\theta$角度的变换，就是将变换后的坐标旋转 $-\theta$角度。

## 回顾

以上就是常见的图形学数学理论，这些方法在图形学语言中普遍内置了，比如 GLSL。GLSL 内置了大部分关于向量的运算，以及一小部分的矩阵运算。

有同学或许会问，既然内置了，我们只要会用就可以了，为什么还要学习这些东西呢？

刚才也说了，只是在某些语言内实现了，大部分语言还是没有实现这些运算的，比如 JavaScript，在JavaScript 中计算向量和矩阵需要我们自己实现。那么实现这些运算算法就要必须了解运算规则。而且掌握了这些数学理论，也方便我们扩展新的运算方法。

当然，业界已经有一些成熟的数学库了。我们可以直接拿来使用，但是作为一个有追求的开发者，还是要能够知道它们实现的机理是什么。只有夯实基础功底，才能打造出更稳定，更高质的应用。

趁热打铁，下一节我们使用 JavaScript 实现这些运算，打造出属于自己的数学库。

## 16.中级进阶 ---  通用数学库的 JavaScript 实现。

上一节我们介绍了图形学涉及到的数学知识，并介绍了了它们的各种运算规则，掌握这些规则对我们开发 3D 应用有着至关重要的作用。本节我们看一下如何将这些运算规则表示出来。

业界已经有一些有名的数学库，比如基于 JavaScript 的`Threejs`框架中就内置了 `matrix` 和 `vector` 的操作类，还有基于 C++ 语言进行实现的 `GLM`。

由于我们是 WebGL 开发，所以我将带大家使用 JavaScript 实现这些数学算法。

## 需要实现哪些功能？

那么，我们即将编写的数学库要能够实现哪些功能呢？

上一节已经讲了，主要是`向量`和`矩阵`的表示、运算。

在此罗列一下：

* 向量
    * 初始化向量
    * 归一化向量
    * 向量相加
    * 向量相减
    * 向量与标量相乘
    * 向量与标量相除
    * 向量与向量相乘
    * 点积
    * 叉积
* 矩阵
    * 初始化矩阵   
    * 创建单位矩阵
    * 矩阵与矩阵相乘
    * 矩阵相加
    * 矩阵相减
    * 求转置矩阵
    * 求逆矩阵

## 矩阵在 GLSL 中的存储特点。
在用 JavaScript 实现数学库之前，我们必须先想清楚如何使用开发出来的库。大家应该都知道，WebGL 应用中的数据一般是从 CPU 传入 GPU 的，语言层面从 JavaScript 传入 GLSL。假如我们要把在 JavaScript 中生成的矩阵传入到 GLSL 中，那么就得保证生成的矩阵能够被 GLSL 所理解，换句话说，JavaScript 矩阵和 GPU 中的矩阵要有相同的表示形式，避免不必要的转换过程。
那么 GPU 中向量和矩阵是如何存储的呢？

在前面章节的初级练习中，我们已经频繁接触了 GLSL 中的向量`vec`和矩阵`mat`，GLSL遵循的是线性代数的标准，也就是上一节我们所讲的内容，只是在存储方式上有所不同。

### 行主序和列主序
存储顺序说明了线性代数中的矩阵如何在线性的内存数组中存储，按照存储方式分为行主序和列主序。

行主序是按照行向量的方式组织矩阵。列主序是按照列向量的方式组织矩阵，为了便于理解，我们看下图示。


假设有一个 3 阶方阵 M：

$
\begin{aligned}
M = \begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{pmatrix}
\end{aligned}
$

那么它在内存中的排布方式如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/20/1669106cb868043c~tplv-t2oaga2asx-image.image)

观察上面的图，就能够一目了然地看出行主序和列主序的区别了。

请务必谨记，D3D 中矩阵采用的是行主序的存储方式，GLSL 中采用的是列主序。

## 实现JavaScript数学库 
那么，既然 GLSL 采用的是列主序存储，为了保持一致，我们在JavaScript中最好也采用列主序的方式存储，和 GLSL 保持一致。

### JavaScript中 用什么数据结构来表示矩阵
我们用`数组`来表示矩阵，但由于 JavaScript 数组是弱类型的，并没有严格按照内存位置进行排布，而 GLSL 中的矩阵元素是严格按照内存地址顺序排列的，所以我们需要将弱类型数组转化成二进制形式，通常我们使用 Float32Array 把弱类型数组转化成强类型数组。

```javascript
let M = [1, 2, 3, 4, 5, 6, 7, 8, 9];
M = new Float32Array(M);
```

### 实现数学库中的方法
图形学中多用方阵来表示变换，因为我们要在 3D 坐标系中变换，所以我们要用 4 阶方阵，所以关于矩阵的运算，我们主要以 4 阶矩阵为基础。

#### 3维向量初始化
 图形学编程中用的比较多的是 3 维、4 维向量，3 维向量多用来表示笛卡尔坐标系中的顶点坐标(X, Y, Z)，4维向量通常表示齐次坐标，如(X, Y, Z, W)，以及颜色信息(R, G, B, A)。
 我们需要初始化向量的方法，默认值为 0。
 
 下面以 3 维向量为例进行实现， 4 维向量和 3维类似。
 
 ##### 3 维向量初始化
 * 输入参数 source 是 JavaScript 弱类型数组（Array），包含3个元素，比如[0, 0, 1]。
 * 返回结果是强类型数组，包含 3 个元素[0, 0, 1]。
 ```javascript
 function Vector3(x, y, z){
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
 }
 ```
##### 设置各个分量

```javascript
Vector3.prototype.setX = function(x) {
    this.x = x || 0;
    return this;
}
Vector3.prototype.setY = function(y) {
    this.y = y || 0;
    return this;
}
Vector3.prototype.setZ = function(z) {
    this.z = z || 0;
    return this;
}

```
#### 归一化向量
归一化向量比较简单，首先求出向量的长度（模），然后将各个分量除以模即可。


```javascript
Vector3.prototype.normalize = function() {
    var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    if(length > 0.00001){
        return new Vector3(this.x / length, this.y / length, this.z / length);
    }
    return new Vector3();
}
```

#### 向量与向量相加

```javascript
Vector3.prototype.addVectors = function(vec1, vec2){
    this.x = vec1.x + vec2.x;
    this.y = vec1.y + vec2.y;
    this.z = vec1.z + vec2.z;
    return this;
}
```

```javascript
Vector3.prototype.add = function(vec1, vec2){
    if(vec2){
       return this.addVector(vec1, vec2);
    }
    this.x += vec1.x;
    this.y += vec1.y;
    this.z += vec1.z;
    return this;
}
```
#### 向量与向量相减
```javascript
Vector3.prototype.sub = function(vec1, vec2){
    if(vec2){
       return this.addVector(vec1, -vec2);
    }
    this.x -= vec1.x;
    this.y -= vec1.y;
    this.z -= vec1.z;
    return this;
}
```

#### 向量与标量相乘

```javascript
Vector3.prototype.multiplyScalar = function(scalar){
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
}
```
#### 向量与向量相乘
其实数学中是没有向量和向量相乘这一说法的，只是为了更方便的计算两个向量各个分量的乘积，所以增加这个计算，在GLSL 中 vec4 和 vec4 相乘返回的新向量就是将各个分量相乘，在计算光照时经常用到。

```javascript
Vector3.prototype.multiplyVector = function(vec1, vec2){
    this.x = vec1.x * vec2.x;
    this.y = vec1.y * vec2.y;
    this.z = vec1.z * vec2.z;
    return this;
}
Vector3.prototype.multiply = function(vec1, vec2){
    if(vec2){
        return this.multiplyVector(vec1, vec2);
    }
    this.x *= vec1.x;
    this.y *= vec1.y;
    this.z *= vec1.z;
    return this;
}
```

#### 点乘
上一节讲过了，点乘就是将向量的各个分量相乘然后再相加，返回的结果是一个标量。

```javascript
function dot(vec1, vec2){
    return vec1.x * vec2.x + vec1.y *vec2.y + vec1.z * vec2.z;
}
```

#### 叉乘
叉乘的计算方法也比较简单，上一节我们讲了计算公式：

```javascript
function cross(vec1, vec2){
    var x = vec1.y * vec2.z - vec2.y * vec1.z;
    var y = vec2.x * vec1.z - vec1.x * vec2.z;
    var z = vec1.x * vec2.y - vec1.y * vec2.x;
    return new Vector3(x, y, z);
}
```


#### 初始化 4 阶单位矩阵
我们需要一个方法能够自动生成一个单位矩阵：

$
\begin{pmatrix}
1 &  0 &  0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1 \\
\end{pmatrix}
$

4 阶矩阵包含 16 个元素，所以我们要初始化 16 个元素的类型化数组，处于性能考虑，我们需要支持对一个矩阵进行单位化。

```javascript
function identity(target) {
    target = target || new Float32Array(16);
}
```
默认各个元素值都是 0 ，我们要将该数组中各个元素的值与数学中的单位矩阵对应上，又由于矩阵以列主序存储，所以每四个数字代表一列：

```javascript
function identity(target) {
    target = target || new Float32Array(16);
    // 第一列
    target[0] = 1;
    target[1] = 0;
    target[2] = 0;
    target[3] = 0;
    // 第二列
    target[4] = 0;
    target[5] = 1;
    target[6] = 0;
    target[7] = 0;
    // 第三列
    target[8] = 0;
    target[9] = 0;
    target[10] = 1;
    target[11] = 0;
    // 第四列
    target[12] = 0;
    target[13] = 0;
    target[14] = 0;
    target[15] = 1;
    
    return target;
}
```

初始化单位矩阵的方法就算完成了，我们还可以用另一种方式来生成，先用 JavaScrpt 数组存储矩阵各个元素，然后用 Float32Array 转化成强类型数组。

```javascript
function identity(){
    var m = 
        [
            1, 0, 0, 0, // 第一列
            0, 1, 0, 0, // 第二列
            0, 0, 1, 0, // 第三列
            0, 0, 0, 1  // 第四列
        ]
    return new Float32Array(m);
}
```
这两种方法用哪种方法都可以，我们使用第一种方法。

#### 初始化 4 阶方阵
有时我们需要根据一个列主序的弱类型数组初始化成矩阵。

* 输入参数
    * source：源数组，包含16个元素。
    * target：目标数组，将目标数组初始化成source对应的元素。
* 返回结果
    * 如果source 不为空，返回该数组对应的强类型数组矩阵。  
    * 如果 source 为空，返回单位矩阵
```javascript
function initialize(source, target) {
    if(source){
        if(target){
            for(var i = 0;i < source.length; i++){
                target[i] = source[i];
            }
            return target;
        }
        return new Float32Array(source);
    }
    return identity(target);
}

//使用方法
initialize([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
```

#### 矩阵和矩阵相加减

虽然矩阵和矩阵相加减的场景很少，但我们仍然要支持它们。实现比较简单，但有一个前提：相加减的两个矩阵的行列必须相同。
* 输入参数
    * m1，操作符左边矩阵。
    * m2，操作符右边矩阵。
    * target，将结果存入 target 数组。
* 返回结果
    * 返回相加、减后的新矩阵。

```javascript
// m1 + m2
function addMatrix(m1, m2, target){
    target = target || new Float32Array(16);
    for(var i = 0; i < m1.length; i++){
        target[i] = m1[i] + m2[i]
    }
    return target;
}

// m1 - m2
function subtractMatrix(m1, m2, target){
    target = target || new Float32Array(16);
    for(var i = 0; i < m1.length; i++){
        target[i] = m1[i] - m2[i]
    }
    return target;
}
```

#### 矩阵和矩阵相乘

矩阵相乘是最经常用到的运算，我们看下如何用 JavaScript 实现。

假设有两个 4 阶方阵 M 和 N，其中：

```javascript
M = 
    [
        a00, a01, a02, a03, //第一列
        a10, a11, a12, a13, //第二列
        a20, a21, a22, a23, //第三列
        a30, a31, a32, a33, //第四列
    ] 
N = 
    [
        b00, b01, b02, b03, //第一列
        b10, b11, b12, b13, //第二列
        b20, b21, b22, b23, //第三列
        b30, b31, b32, b33, //第四列
    ]
```
 参考上一节的矩阵乘法， $N \times M $的算法表示如下：
 
 ```javascript
 // 此处的 prev 代表 M，next 代表 N
 function multiply(next, prev, target){
    target = target || new Float32Array(16);
    // 第一列
    var p00 = prev[0];
    var p10 = prev[1];
    var p20 = prev[2];
    var p30 = prev[3];
    // 第二列
    var p01 = prev[4];
    var p11 = prev[5];
    var p21 = prev[6];
    var p31 = prev[7];
    // 第三列
    var p02 = prev[8];
    var p12 = prev[9];
    var p22 = prev[10];
    var p32 = prev[11];

    // 第四列
    var p03 = prev[12];
    var p13 = prev[13];
    var p23 = prev[14];
    var p33 = prev[15];

    // 第一行
    var n00 = next[0];
    var n01 = next[4];
    var n02 = next[8];
    var n03 = next[12];
    // 第二行
    var n10 = next[1];
    var n11 = next[5];
    var n12 = next[9];
    var n13 = next[13];
    // 第三行
    var n20 = next[2];
    var n21 = next[6];
    var n22 = next[10];
    var n23 = next[14];

    // 第四行
    var n30 = next[3];
    var n31 = next[7];
    var n32 = next[11];
    var n33 = next[15];

    target[0] = p00 * n00 + p10 * n01 + p20 * n02 + p30 * n03;
    target[1] = p00 * n10 + p10 * n11 + p20 * n12 + p30 * n13;
    target[2] = p00 * n20 + p10 * n21 + p20 * n22 + p30 * n23;
    target[3] = p00 * n30 + p10 * n31 + p20 * n32 + p30 * n33;

    target[4] = p01 * n00 + p11 * n01 + p21 * n02 + p31 * n03;
    target[5] = p01 * n10 + p11 * n11 + p21 * n12 + p31 * n13;
    target[6] = p01 * n20 + p11 * n21 + p21 * n22 + p31 * n23;
    target[7] = p01 * n30 + p11 * n31 + p21 * n32 + p31 * n33;

    target[8] = p02 * n00 + p12 * n01 + p22 * n02 + p32 * n03;
    target[9] = p02 * n10 + p12 * n11 + p22 * n12 + p32 * n13;
    target[10] = p02 * n20 + p12 * n21 + p22 * n22 + p32 * n23;
    target[11] = p02 * n30 + p12 * n31 + p22 * n32 + p32 * n33;

    target[12] = p03 * n00 + p13 * n01 + p23 * n02 + p33 * n03;
    target[13] = p03 * n10 + p13 * n11 + p23 * n12 + p33 * n13;
    target[14] = p03 * n20 + p13 * n21 + p23 * n22 + p33 * n23;
    target[15] = p03 * n30 + p13 * n31 + p23 * n32 + p33 * n33;

    return target;
 }
 ```
 
 我们一共要计算 16 个元素，可以看出计算步骤很繁琐，但都没有难度，都是简单的基本运算，我们只要保证好顺序正确就可以。
 
#### 矩阵和标量相乘

矩阵和标量相乘比较简单，各个位置的元素分别乘以标量就可以了。

```javascript
function multiplyScalar(m, scalar){
    if(scalar === undefined || scalar === null){
        return m;
    }
    for(var i = 0; i < m.length; i++){
        m[i] *= scalar;
    }
    return m;
}
```

 

#### 转置矩阵

转置矩阵其实就是将原矩阵的行变成列。
有一个矩阵 M ：

$
\begin{pmatrix}
1 & 2 & 3 & 4 \\\
5 & 6 & 7 & 8 \\\
9 & 10 & 11 & 12 \\\
13 & 14 & 15 & 16
\end{pmatrix}
$

M 的转置矩阵：
$
\begin{pmatrix}
1 & 5 & 9 & 13 \\\
2 & 6 & 10 & 14 \\\
3 & 7 & 11 & 15 \\\
4 & 8 & 12 & 16
\end{pmatrix}
$

我们转置函数接收一个输入参数，表示待转置的矩阵，用m 表示：
* 输入参数：
    * m，原矩阵
* 输出结果
    * target，转置矩阵。 
```javascript
function transpose(m, target){
    target  = target || new Float32Array(16);
    //转置矩阵的第一列
    target[0] = m[0];
    target[1] = m[4];
    target[2] = m[8];
    target[3] = m[12];
    //转置矩阵的第二列
    target[4] = m[1];
    target[5] = m[5];
    target[6] = m[9];
    target[7] = m[13];
    //转置矩阵的第三列
    target[8] = m[2];
    target[9] = m[6];
    target[10] = m[10];
    target[11] = m[14];
    //转置矩阵的第四列
    target[12] = m[3];
    target[13] = m[7];
    target[14] = m[11];
    target[15] = m[15];
    
    return target;
}
```

#### 计算逆矩阵
逆矩阵的计算是最复杂的计算，很容易把人绕晕，如果大家感兴趣，按照上一节讲的逆矩阵求解步骤，可以自己写一下这个算法。

回忆一下，逆矩阵的计算分为 4 步：

* 求出余子式矩阵。
* 为余子式矩阵增加符号。
* 转置第二步的矩阵。
* 将第三步得出的矩阵乘以 1/行列式。

完成以上四步，最后得出的矩阵就是逆矩阵了。
我们实现一下该算法：

#####  1、求出余子式矩阵
假设矩阵M，$m_{ij}$来表示各个位置的元素，i 表示第几行，j 表示第几列。

例如m00，就代表处于第一行第一列的元素。

$
\begin{pmatrix}
m00 & m01 & m02 & m03 \\\
m10 & m11 & m12 & m13 \\\
m20 & m21 & m22 & m23 \\\
m30 & m31 & m32 & m33 
\end{pmatrix}
$


```javascript
function inverse(m){
    //第一列
    var m00 = m[0];
    var m10 = m[1];
    var m20 = m[2];
    var m30 = m[3];
    // 第二列
    var m01 = m[4];
    var m11 = m[5];
    var m21 = m[6];
    var m31 = m[7];
    // 第三列
    var m02 = m[8];
    var m12 = m[9];
    var m22 = m[10];
    var m32 = m[11];
    // 第四列
    var m03 = m[12];
    var m13 = m[13];
    var m23 = m[14];
    var m33 = m[15];
}

```

矩阵的行列式：

```javascript
  var tmp_22_33 = m22 * m33;
  var tmp_32_23 = m32 * m23;
  var tmp_21_33 = m21 * m33;
  var tmp_31_23 = m31 * m23;
  var tmp_12_23 = m12 * m23;
  var tmp_22_13 = m22 * m13;
  var tmp_10_23 = m10 * m23;
  var tmp_20_13 = m20 * m13;
  var tmp_11_23 = m11 * m23;
  var tmp_21_13 = m21 * m13;
  var tmp_20_32 = m20 * m32;
  var tmp_10_22 = m10 * m22;
  var tmp_20_12 = m20 * m12;
  var tmp_10_21 = m10 * m21;
  var tmp_20_11 = m20 * m11;
  var tmp_31_22 = m31 * m22;
  var tmp_30_23 = m30 * m23;
  var tmp_30_22 = m30 * m22;
  var tmp_20_33 = m20 * m33;
  var tmp_20_31 = m20 * m31;
  var tmp_30_21 = m30 * m21;
  var tmp_21_32 = m21 * m32;
  var tmp_12_33 = m12 * m33;
  var tmp_32_13 = m32 * m13;
  var tmp_11_32 = m11 * m32;
  var tmp_31_12 = m31 * m12;
  var tmp_11_33 = m11 * m33;
  var tmp_31_13 = m31 * m13;
  var tmp_10_33 = m10 * m33;
  var tmp_30_13 = m30 * m13;
  var tmp_10_32 = m10 * m32;
  var tmp_30_12 = m30 * m12;
  var tmp_10_31 = m10 * m31;
  var tmp_30_11 = m30 * m11;
  var tmp_11_22 = m11 * m22;
  var tmp_21_12 = m21 * m12;

  var t00 =
    m11 * (tmp_22_33 - tmp_32_23) -
    m12 * (tmp_21_33 - tmp_31_23) +
    m13 * (tmp_21_32 - tmp_31_22);
  var t01 =
    m10 * (tmp_22_33 - tmp_32_23) -
    m12 * (tmp_20_33 - tmp_30_23) +
    m13 * (tmp_20_32 - tmp_30_22);
  var t02 =
    m10 * (tmp_21_33 - tmp_31_23) -
    m11 * (tmp_20_33 - tmp_30_23) +
    m13 * (tmp_20_31 - tmp_30_21);
  var t03 =
    m10 * (tmp_21_32 - tmp_31_22) -
    m11 * (tmp_20_32 - tmp_30_22) +
    m12 * (tmp_20_31 - tmp_30_21);

  // 矩阵的行列式
  var determinant = m00 * t00 - m01 * t01 + m02 * t02 - m03 * t03;
```

##### 余子式矩阵
余子式矩阵是将原矩阵各个位置的行列式求解出来放在对应位置，生成的一个新矩阵。

求解行列式是一个很繁琐但是很简单的过程，因为它涉及到的只是简单的算术运算。

```javascript
// 第一行
  var n00 = t00;
  var n01 = t01;
  var n02 = t02;
  var n03 = t03;

  // 第二行
  var n10 =
    m01 * (tmp_22_33 - tmp_32_23) -
    m02 * (tmp_21_33 - tmp_31_23) +
    m03 * (tmp_21_32 - tmp_31_22);
  var n11 =
    m00 * (tmp_22_33 - tmp_32_23) -
    m02 * (tmp_20_33 - tmp_30_23) +
    m03 * (tmp_20_32 - tmp_30_22);
  var n12 =
    m00 * (tmp_21_33 - tmp_31_23) -
    m01 * (tmp_20_33 - tmp_30_23) +
    m03 * (tmp_20_31 - tmp_30_21);
  var n13 =
    m00 * (tmp_21_32 - tmp_31_22) -
    m01 * (tmp_20_32 - tmp_30_22) +
    m02 * (tmp_20_31 - tmp_30_21);

  // 第三行
  var n20 =
    m01 * (tmp_12_33 - tmp_32_13) -
    m02 * (tmp_11_33 - tmp_31_13) +
    m03 * (tmp_11_32 - tmp_31_12);
  var n21 =
    m00 * (tmp_12_33 - tmp_32_13) -
    m02 * (tmp_10_33 - tmp_30_13) +
    m03 * (tmp_10_32 - tmp_30_12);
  var n22 =
    m00 * (tmp_11_33 - tmp_31_13) -
    m01 * (tmp_10_33 - tmp_30_13) +
    m03 * (tmp_10_31 - tmp_30_11);
  var n23 =
    m00 * (tmp_11_32 - tmp_31_12) -
    m01 * (tmp_10_32 - tmp_30_12) +
    m02 * (tmp_10_31 - tmp_30_11);

  // 第四行
  var n30 =
    m01 * (tmp_12_23 - tmp_22_13) -
    m02 * (tmp_21_33 - tmp_31_23) +
    m03 * (tmp_11_22 - tmp_21_12);
  var n31 =
    m00 * (tmp_12_23 - tmp_22_13) -
    m02 * (tmp_10_23 - tmp_20_13) +
    m03 * (tmp_10_22 - tmp_20_12);
  var n32 =
    m00 * (tmp_11_23 - tmp_21_13) -
    m01 * (tmp_10_23 - tmp_20_13) +
    m03 * (tmp_10_21 - tmp_20_11);
  var n33 =
    m00 * (tmp_11_22 - tmp_21_12) -
    m01 * (tmp_10_22 - tmp_20_12) +
    m02 * (tmp_10_21 - tmp_20_11);

```

##### 代数余子式矩阵
把"纵横交错"排列的正负号放在"余子式矩阵"上。换句话说，我们需要每隔一个格改变正负号，像这样：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/21/16696adefc66dacf~tplv-t2oaga2asx-image.image)

```javascript
n01 = -n01;
n03 = -n03;
n10 = -n10;
n12 = -n12;
n21 = -n21;
n23 = -n23;
n30 = -n30;
n32 = -n32;
```

##### 转置代数余子式矩阵

将上面经过转换符号的余子式矩阵转置。

```javascript
target = target || new Float32Array(16);
target[0] = n00;
target[1] = n01;
target[2] = n02;
target[3] = n03;
target[4] = n10;
target[5] = n11;
target[6] = n12;
target[7] = n13;
target[8] = n20;
target[9] = n21;
target[10] = n22;
target[11] = n23;
target[12] = n30;
target[13] = n31;
target[14] = n32;
target[15] = n33;
```

##### 乘以 1/原矩阵的行列式
最后一步，我们将上面得到的转置矩阵乘以 1/原矩阵的行列式，得出的新矩阵就是所求逆矩阵。

```javascript
for(var i = 0; i< result.length; i++){
    target[i] = target[i] * 1 / determinant;
}

return target;
```

哇哦，历尽九九八十一难，我们终于求出了逆矩阵。

大家可以看到，数学库所做的就是将数学中的矩阵、向量以及它们之间的运算表示出来，步骤很繁琐，但是都不难。这些函数我们只要会用，知道它们所适用的场景就可以了。

## 回顾
本节主要实现了图形学涉及到数学中的向量和矩阵的基本运算，除此以外，我们还有一些3D 开发中经常用到的方法没有实现，比如顶点旋转、平移、缩放等变换矩阵。

但在这之前，我们要先学习为什么需要这些变换，具体需要哪些变换。
 
这些东西在下一节揭晓，下一节主要涉及到 WebGL  中的常见坐标系以及坐标系之间的变换，让我们拭目以待吧~





## 17.中级进阶 --- WebGL 坐标系

在第十四章节我们简单介绍了数学中常用的笛卡尔坐标系，以及 3D 笛卡尔坐标系中判断 `Z` 轴正向的`左右手坐标系`，本节详细介绍`坐标系`在 3D 开发过程中所扮演的重要角色。

## WebGL 坐标系
WebGL 是如何把 3D 世界中的模型（物体）渲染到屏幕上的呢？
这其中的最大难点就是`坐标系的变换`。在坐标系转换过程中都涉及哪些坐标系？为什么会有这么多的坐标系存在？他们存在的意义是什么？

带着这三个问题，我们往下看，寻求答案。

### 顶点如何渲染到屏幕上。

如果想在屏幕上绘制一个点，我们需要将点的坐标从 CPU 通过 JavaScript 传递给 GPU ，GPU 接收到顶点坐标，进行一些坐标转换（通常将转换过程放在 JavaScript 中），然后将坐标赋值给 gl_Position：

```glsl
gl_Position = vec4(x, y, z, 1);
```

请注意：gl_Position 接收一个 4 维向量表示的坐标，即(X, Y ,Z ,W)，W 不等于 0，这个坐标是在`裁剪坐标系`中，我们称它为裁剪坐标。

#### 透视除法
GPU 得到裁剪坐标后，下一步会对坐标进行透视除法。所谓透视除法就是将裁剪坐标的各个分量同时除以 W 分量，使得 W 分量为 1。经过透视除法得到的坐标便处在 `NDC` 坐标系（设备独立坐标系）中， NDC 坐标系是一个边长为 2 的正方体，超出正方体的顶点都将被抛弃，不会显示到屏幕上。

>在 NDC 坐标系内的坐标都会落在【-1，1】之间，因此很多顶点坐标往往都是小数。

#### 视口转换
接下来，GPU 就要将顶点绘制到屏幕上了，顶点此时的坐标已经转变到 NDC 坐标系中，但是 NDC 坐标系和屏幕坐标系不一致，所以就产生了最后一个坐标变换，视口转换，将顶点坐标从 NDC 坐标系下转换到屏幕坐标系下的坐标，最终将顶点显示在屏幕指定位置上。

以上便是顶点的坐标转换过程。

按照这种规则，我们传给 GPU 的顶点坐标需要遵循裁剪坐标系或者 NDC 坐标系的特点，将顶点坐标控制在 【-1，1】之间，这样的坐标往往掺杂着很多小数，不是很直观。

我们给出的模型坐标一般都是易于理解的，比如：

* 玩家的坐标是 (10, 10, 20)
* 箱子长度、宽度、高度都是 10。

但是 GPU 希望接收的是：
* 玩家坐标(0.2333333, 0.222333, 0.3333444)。
* 正方体边长 0.333333。

难以理解的小数！

为了将易于理解的起始坐标转换成 GPU 希望 接收的晦涩坐标，于是就有了坐标系的划分，开发者可以专心在各个坐标系内处理对应数据，至于具体的坐标转换过程交给通用的特定转换算法完成。

## 坐标系分类
为了将模型坐标转换成裁剪坐标，我们增加了坐标转换流水线。顶点坐标起始于模型坐标系，在这里它被称为模型坐标。模型坐标在 CPU 中经过一系列坐标系变换，生成裁剪坐标，之后 CPU 将裁剪坐标传递给 GPU。

WebGL 坐标系分为如下几类：  
模型坐标系 -- 世界坐标系 -- 观察坐标系（又称相机坐标系、视图坐标系） -- 裁剪坐标系（`gl_Position`接收的值） -- NDC 坐标系 -- 屏幕坐标系。

>其中，裁剪坐标系之前的这几个坐标系，我们都可以使用 JavaScript 控制。从裁剪坐标系到 NDC 坐标系，这一个步骤是 顶点着色器的最后自动完成的，我们无法干预。

### 坐标转换流水线

* CPU 中将模型坐标转换成裁剪坐标
    * 顶点在模型坐标系中的坐标经过模型变换，转换到世界坐标系中。
    * 然后通过摄像机观察这个世界，将物体从世界坐标系中转换到观察坐标系。
    * 之后进行投影变换，将物体从观察坐标系中转换到裁剪坐标系。
* GPU 接收CPU 传递过来的裁剪坐标。
    * 接收裁剪坐标，通过透视除法，将裁剪坐标转换成 NDC 坐标。
    * GPU 将 NDC 坐标通过视口变换，渲染到屏幕上。



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669b4e4af96327b~tplv-t2oaga2asx-image.image)









### 模型坐标系

一个物体通常由很多点构成，每个点在模型的什么位置？我们需要用一个坐标系来参照，这个坐标系就叫模型坐标系，模型坐标系原点通常在模型的中心，各个坐标轴遵循右手坐标系，即 X 轴向右，Y 轴向上，Z 轴朝向屏幕外。

一般在建模软件中创建模型的时候，各个顶点的坐标都是以模型的某一个点为参照点建立的。



### 世界坐标系
我们创建好的模型需要放置在世界中的各个位置，默认情况模型坐标系和世界坐标系重合。如果模型不在世界坐标系中心，那么就需要对模型坐标系进行转换，将模型的各个相对于模型中心的顶点坐标转换成世界坐标系下的坐标。

世界坐标系也是遵循右手坐标系，X 轴水平向右，Y 轴垂直向上，Z 轴指向屏幕外面。

假如模型中有一点 P ，相对于模型中心的坐标（1，1）。
该模型在世界坐标系的（3，0）位置，那么，顶点 P 在世界坐标系中的坐标就变成了（4，1）。

### 观察坐标系

观察坐标系是将世界空间坐标转化为用户视野前方的坐标而产生的结果。人眼或者摄像机看到的世界中的物体相对于他自身的位置所参照的坐标系就叫观察坐标系。

在我们日常生活中，精准描述一个街道，我们一般用经纬度来表示，但是如果有人问你：某某街道在什么位置？如果我们告诉他世界坐标：某某街道在东经 M 度，北纬 N 度，我想他会打你。。

一般我们都会用这样易于理解的描述：在`前面多远，往左或右走多远`。

这种坐标就称为观察坐标，也叫相机坐标，他是以人眼/摄像机为原点而建立的坐标系。

之所以有相机坐标系，是为了模仿人眼看待世界的效果。世界很大，有很多物体，但是不能把整个世界都显示到屏幕上，只显示人眼所能看到的一部分，这样我们就能通过改变`人眼所处的方位`，`人眼所在的位置`，看到整个 3D 空间的不同部分。




### 裁剪坐标系
裁剪坐标是将相机坐标进行投影变换后得到的坐标，也就是 gl_Position 接收的坐标，顾名思义，以裁剪坐标系为参照。

裁剪坐标系遵循`左手坐标系`。

相机坐标系观察的空间是整个 3D 世界，而裁剪坐标系是希望所有的坐标都落在一个特定的范围内，超出这个范围的顶点坐标都将被裁剪掉，被裁剪掉的坐标就不会显示，这就是裁剪坐标系的由来。

我们将坐标全部表示成【-1.0 , 1.0】之间的方式不是很直观，所以我们希望先将观察空间中的某一部分裁剪出来，这一部分作为要显示的区域。

比如，我们希望将各个坐标轴在 【-1000-1000】 范围内的空间区域作为可视空间区域，这一区域的所有物体都将显示到屏幕上。那么如果一个顶点 P 的坐标是（1300，500，10），那么它就会被裁剪掉，因为它没有坐落在可视空间区域。



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669ee4661f2b664~tplv-t2oaga2asx-image.image)

投影矩阵会创建一个观察箱`Viewing Box`，称为平截头体`Frustum`，出现在平截头体范围内的坐标最终都会显示在屏幕上。裁剪坐标系中的坐标转化到标准化设备坐标系的过程就很容易，这个过程被称之为投影`Projection`，使用投影矩阵能将 3D 坐标投影很容易地映射到 2D 的标准设备坐标系中。





将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。

#### 正射投影矩阵
又名正交投影，正射投影矩阵创建的是一个立方体的观察箱，它定义了一个裁剪空间，在该裁剪空间之外的坐标都会被丢弃。
正射投影矩阵需要指定观察箱的长度、宽度和高度。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669f0269348d42d~tplv-t2oaga2asx-image.image)

经过正射投影矩阵映射后的坐标 w 分量不会改变，始终是 1，所以在经过透视除法后物体的轮廓比例不会发生改变，这种投影一般用在建筑施工图纸中，不符合人眼观察世界所产生的近大远小的规律。
所以就有了另一种投影：透视投影。

####  透视投影矩阵
实际生活中给人带来的感觉是，离我们越远的东西看起来更小。这个奇怪的效果称之为透视`Perspective`，透视的效果在我们看远处时尤其明显，比如下图：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669f0901e7ede7a~tplv-t2oaga2asx-image.image)

实际上，远处的群山是比近处的房屋大的，但是人眼看上去，群山比房屋小，这就是透视投影要实现的效果。

透视投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外它还会修改每个顶点坐标的 w 值，使得离人眼越远的物体的坐标 w 值越大。被变换到裁剪空间的坐标都会在 -w 到 w 的范围之间（任何大于这个范围的坐标都会被裁剪掉）。WebGL 要求所有可见的坐标都落在【-1.0 -  1.0】范围内，因此，一旦坐标转换到裁剪空间，透视除法就会被应用到裁剪坐标上。



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669ff5e4796f287~tplv-t2oaga2asx-image.image)

透视除法要求顶点坐标的每个分量除以它的 W 分量，距离观察者越远，顶点坐标也就会越小，这就是 W 分量非常重要的另一个原因，它能够帮助我们进行透视投影，经过透视除法后，所有在【-W，W】范围内的坐标都会被转变到 NDC 坐标系中。

透视投影需要设置近平面、远平面、透视深度。

### NDC 坐标系

一旦所有顶点被变换到裁剪空间，GPU 会对裁剪坐标执行透视除法，在这个过程中 GPU 会将顶点坐标的 X，Y，Z 分量分别除以齐次 W 分量。这一步会在每一个顶点着色器运行的最后被自动执行。最终所有坐标分量的范围都会在【-1，1】之间，超出这个范围的坐标都将被 GPU 丢弃。

NDC 坐标系遵循`左手坐标系`，Z 轴朝向屏幕里面，Z轴值越小，越靠近我们的眼睛，我们可以通过开启 WebGL 的深度检测机制验证一下：

绘制两个三角形，第一个三角形各个顶点 Z 轴坐标为 -0.5，颜色为红色， 第二个三角形各个顶点 Z 轴坐标为 0，颜色为绿色。

开启深度检测前：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/166a016e9c2fde05~tplv-t2oaga2asx-image.image)

可以看到，第二个三角形绘制在了前面。不是说左手坐标系吗？按理说 Z 轴越小的越靠近视野，就会显示在前面。其实，在深度检测不开启的情况下，哪个顶点越靠后绘制，哪个顶点就绘制在前面，这时 Z 轴坐标不再决定顶点是否绘制在前面。

开启深度检测后：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/166a01846b1cbed0~tplv-t2oaga2asx-image.image)

深度检测开启之后，可以看到 Z 轴小的红色三角形显示在了前面，从而验证了 NDC 坐标系是左手坐标系。

### 屏幕坐标系

有了 NDC 坐标之后，GPU 会执行最后一步变换操作，`视口变换`，这个过程会将所有在【-1, 1】之间的坐标映射到屏幕空间中，并被变换成片段。

我们的模型历尽九九八十一难，终于显示到了屏幕上。


## 坐标变换举例
上面的描述大家可能不太理解，接下来我们就以一个简单的例子演示坐标系变换的步骤。

### 模型坐标
我们以一个顶点 P 为例，该顶点在边长为 3 的正方体上，初始时顶点所在坐标系是模型坐标系，也就是相对于正方体中心位置，该顶点在模型坐标系中的坐标：

$P_m=（3，3，0）$


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669f6f2b6020078~tplv-t2oaga2asx-image.image)


### 世界坐标系

默认情况下，模型坐标和世界坐标系重合，那该顶点在世界坐标系下的坐标：

$P_w = (3, 3, 0)$

假设我们将立方体向右移动 5 个单位，向上移动 5 个单位，那么立方体的原点 O 在世界坐标系中的坐标就变成了：

$O_w = (5, 5, 0)$

那顶点 P 在世界坐标系的坐标也就变成了：

$P_w = P_m + O_w = (5+3, 5+3, 0+0) = (8, 8, 0)$



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/1669f79276462624~tplv-t2oaga2asx-image.image)

到这里也很容易理解。

### 观察坐标系
世界坐标系中有个人 `E` 在位置(3, 3, 0)处：

$E_w = (3, 3, 0)$

E 所看到的世界处于观察坐标系中，X 轴、Y 轴和世界坐标系一致，Z 轴和世界坐标系相反，指向屏幕里面。我们很容易就能想到世界坐标系在观察坐标系中的坐标为：

$O_e = -E_w = (-3, -3, 0)$

>$O_e$代表世界坐标系的原点在观察坐标系中的坐标。

因此顶点 P 在观察坐标系的坐标就变成了：

$P_e = P_w + O_e = (8, 8, 0) + (-3, -3, 0) = (5, 5, 0)$


### 裁剪坐标系

这里我们为裁剪坐标系指定一个正射投影观察箱，观察箱左侧坐标 -5，右侧坐标 5，上方坐标 5，下方坐标 -5，近平面坐标 0， 远平面坐标 5，那么处于这个观察箱之间的顶点都将被转换到裁剪坐标系中。

由于顶点 P 在观察坐标系的坐标为 (5, 5, 0)，所以它转变到裁剪坐标系下的坐标为：

$P_c = (5 / 5, 5 / 5, 0 / 2.5) = (1, 1, 0)$

正射投影下， W 分量为 1，到了这一步就有了 W 分量：
$P_c =  (1, 1, 0, 1)$

###  NDC 坐标系

NDC 坐标是在 GPU 中 将裁剪坐标执行透视除法，所以：

$P_n = (1/1, 1/1, 0/1, 1/1) = (1, 1, 0, 1)$

坐标没有改变。

### 视口变换
接下来该执行视口变换了，视口变换将 NDC 坐标映射到屏幕坐标系。这一步是将 3D 坐标转变成 2D 坐标，在 GPU 中执行，我们无法通过编程干预，

视口我们是通过 WebGL API 中的 `gl.viewport`来  设置，我们可以设置任意尺寸的视口，这里我们设置宽 500 ，高 300 的尺寸。

```javascript
gl.viewport(0, 0,  500, 300);
```

接下来 GPU 就会将 NDC 坐标映射到视口范围内，即将 【-1，1】 的立方体范围内的坐标映射到宽 500，高 300 的屏幕坐标范围。

我们仍然需要先找到 NDC 坐标系原点在 屏幕坐标系中的坐标。



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/27/169bcf47c921c68f~tplv-t2oaga2asx-image.image)

由于 NDC 坐标系 X 轴上的一个单位长度就等于视口宽度的一半，Y 轴上的一个单位长度等于视口高度的一半，所以 NDC 坐标系原点在屏幕坐标系下的坐标为

$O_s = (250, 150)$

又由于 NDC 坐标系 Y 轴方向和 屏幕坐标系 Y 轴方向相反，所以 NDC 坐标系下的 Y 轴坐标转化到屏幕坐标系时要取Y轴坐标的相反数。

那么，顶点 P 转换到屏幕坐标系下的坐标为：

$P_s = P_n + O_s = (1 \times 250, -1 \times 150) + (250, 150) = (500, 0)$

很明显，顶点显示在 canvas 视口的右上角，这和顶点在裁剪坐标系中设置的观察箱中的位置相吻合。


一个顶点的转换过程大致经历这么几步，我这里只是简单使用坐标偏移演示了一下，其实如果涉及到坐标系的旋转、缩放、Z 轴的加入、透视投影，计算过程将会更复杂。

>所幸的是，业界已经有成熟的坐标系变换算法，我们只需要调用他们的方法，传入指定参数，就能生成坐标变换矩阵。


顶点从一个坐标系转换到另一个坐标系，只需要计算出这几点就可以：

* 计算出原坐标系的原点 O 在新坐标系的坐标。（平移变换）
* 计算出新坐标系坐标分量的单位向量在原坐标系下的长度。（缩放变换）
* 计算出原坐标系的坐标分量（基向量）的方向。（旋转变换）


看到平移、缩放、旋转，我们立刻想到了一种快速执行复杂计算的工具：矩阵。

下一节我们讲解矩阵在坐标系变换过程中发挥了什么作用？



## 回顾
本节我们讲述了WebGL 开发过程中涉及到的坐标系以及它们的作用，但它们之间具体是如何转换的呢？我相信有同学会有这样的好奇心。所以下一节，我们用矩阵实现坐标转换算法。














## 18.中级进阶 --- 坐标系变换：基本变换原理与算法实现

上一节我们讲了 WebGL 坐标系的分类以及它们之间的转换方式，本节开始详细介绍坐标系基本变换的算法实现，图形学中实现变换的主要数学工具是`矩阵`，所以在讲解坐标系变换之前，我们先温习一下矩阵。

**温馨提示：**

在学习矩阵变换时，一定要搞清楚以下三点：

* 所使用的向量是`行向量`还是`列向量`。
    * 如果是`行向量`，按照`数学领域`中矩阵相乘的规则，向量要放在`左侧`相乘。
    * 如果是`列向量`，向量要放在`右侧`相乘。
* 矩阵是`行主序`还是`列主序`。
    * 如果是行主序，内存存储矩阵的数组的前四个元素表示的是对应数学矩阵的`第一行`
    * 如果是列主序，内存存储矩阵的数组的前四个元素表示的是对应数学矩阵的`第一列`
* 多个矩阵变换时的相乘顺序。
    * 在多个矩阵变换时，不同的相乘顺序会导致不同的结果，所以我们要保证矩阵相乘的顺序是我们期望的。假设有三个变换矩阵：旋转矩阵 R，平移矩阵 T，缩放矩阵 S，以及顶点向量 P，那么 P 变换到 P1 的顺序一般是这样的：
    
        $P1 = T \times R \times S \times P$

        即先`缩放`，再`旋转`，最后`平移`。

## 矩阵到底代表什么？
3D 学习过程中的一大难点就是矩阵变换，我们经常看到矩阵左乘一个列向量就能够实现平移、旋转、缩放等效果。

那么，矩阵背后的神秘力量是什么呢？

其实矩阵并不神秘，只是矩阵可以对一些数字按照矩阵的规则执行一系列运算操作，简化了我们使用` +`、 `-`、 `*`、 `/`进行变换运算的步骤而已。


一个矩阵可以理解为一种变换，多个矩阵相乘代表多个变换。


### 矩阵变换

常见的矩阵变换有如下几种：

* 平移
* 缩放
* 旋转
* 切变



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/23/166a0297d6ae7194~tplv-t2oaga2asx-image.image)

但是在坐标系转换中，最常应用的是前三种。我们看一下如何用矩阵表示这些变换。在讲解矩阵变换之前，我们先从头捋一下`点`和`向量`的表示。



### 点和向量
前面章节我们讲了`齐次坐标`，它用来区分`点`和`向量`，齐次坐标使用 `N+1` 维向量表示 N 维空间，第 N+1 维数字如果是 0 的话，则代表 N 维空间中的`向量`，如下用 4 维向量表示 3 维空间中的一个向量：

$\vec{P} = (3, 2, 1, 0)$

第 `N+1` 维数字如果是`非0数字`的话，则代表 N 维空间下的`点`：

$\vec{P} = (3, 2, 1, 1)$

使用 N+1 维数字表示 N 维空间中的点或向量的方式就是齐次坐标。

齐次坐标除了能够区分`点`和`向量`，还有两大用处：

#### 1、模拟透视投影效果。

模拟透视效果我们上一节已经介绍了，在裁剪坐标系中，w 值越大，经过透视除法后的坐标越小，于是也就有了近大远小的投影效果。

#### 2、用矩阵来表示平移变换。
前面章节已经讲过，n 阶矩阵只能和 n 维列向量相乘，得到一个新的 n 维列向量。

$M_{ij} \times P_{j1} $

乘得的结果只能表示缩放和旋转变换，没有办法表示平移变换，因为平移是在原向量的基础上加上一个常量位移，属于加法操作，但是 n 阶矩阵和 n 维列向量相乘的话，每一步都是相乘操作，没有加法运算，所以无法用 n 阶矩阵和 n 维列向量表示 n 维列向量的平移。

>要注意：上面所说的列向量指的是坐标，不是数学意义上的向量。

$$
\begin{pmatrix}
a & b & c \\
d & e & f  \\
g & h & i
\end{pmatrix} \times \begin{pmatrix}x \\
y \\
z
\end{pmatrix} = \begin{pmatrix}
ax + by + cz \\
dx + ey + fz  \\
gx + hy + iz
\end{pmatrix}
$$


可以看到 n 维矩阵和 n 维向量相乘，不能实现 n 维向量和一个常量进行加减的操作。

我们期待的是得到这样一个向量：

$(ax + by +cz + p)$

其中 p 是常数，代表平移的大小。

我们看一下齐次坐标是如何帮助我们解决这个问题的。

顶点 P 用齐次坐标表示如下：

$P = (x, y, z, 1)$

因为 3 维坐标用齐次坐标的话需要增加到 4 维，所以表示平移变换的矩阵也要相应地变成 4 阶矩阵，我们看下这个 4 阶矩阵如何构成：

$$
\begin{pmatrix}
a & b & c & tx \\
c & d & e & ty \\
f & g & h & tz \\
0 & 0 & 0 & 1
\end{pmatrix}
$$

在原来基础上增加一行和一列，其中第四行前三个分量为 0，第四个分量为 1，这样矩阵和向量的乘积得到的新的向量的第四个分量也是 1，所以也是代表点。

第四列tx、ty、tz分别代表沿 x 轴、y 轴、 z 轴方向上的平移量。

我们推算验证一下：

$$
\begin{pmatrix}
a & b & c & tx \\
d & e & f & ty \\
g & h & i & tz \\
0 & 0 & 0 & 1
\end{pmatrix} \times \begin{pmatrix}x \\
y \\
z \\ 1
\end{pmatrix} = \begin{pmatrix}
ax + by + cz +tx \\
dx + ey + fz + ty \\
gx + hy + iz + tz \\
0 + 0 + 0 + 1
\end{pmatrix}
$$


转换后的向量的每一个分量都实现了`ax + by + cz + 常数`的格式，也就是说，向量可以通过乘以一个矩阵实现平移操作。



##  变换矩阵的推导

### 变换矩阵的求解思路
首先我们要知道，对物体（顶点）做平移、旋转、缩放的变换操作相当于对原来的坐标系做平移、旋转、缩放变换，得到一个新坐标系。了解了这一点，我们就可以学习一种求解变换矩阵的简单方式：

* 首先求出新坐标系的基向量 U 在原坐标系下的表示 U’，其中U =(Ux, Uy, Uz)， U' = (Ux', Uy', Uz')。
    * Ux：X轴基向量，由三个分量构成，
        * Uxx, X轴分量。
        * Uxy, Y轴分量。
        * Uxz，Z轴分量。
    * Uy：Y轴基向量，由三个坐标轴分量组成
        * Uyx：X轴分量。
        * Uyy：Y轴分量。
        * Uyz：Z轴分量。
    * Uz：Z轴基向量，由三个坐标轴分量组成
        * Uzx：X轴分量。
        * Uzy：Y轴分量。
        * Uzz：Z轴分量。

>基向量是指坐标系中各个坐标轴正方向的单位向量，假设 Ux 代表 X 轴的单位向量，那么 Ux = (1, 0, 0)，同理， Uy = (0, 1, 0)，Uz = (0, 0, 1)。 

* 其次求出新坐标系的坐标原点O(Ox, Oy, Oz)在原坐标系下的坐标O1（Ox1, Oy1, Oz1）

> 基向量是坐标系变换的基础，我们求解坐标变换矩阵关键就是要找到原坐标系的基向量在新坐标系中的表示。


* 最后，将上面求出的各个值代入下面的矩阵框架：

$$
\begin{pmatrix}
U_{xx} & U_{yx} & U_{zx} & O_{x1}\\
U_{xy} & U_{yy} & U_{zy} & O_{y1}\\
U_{xz} & U_{yz} & U_{zz} & O_{z1}\\
0 & 0 & 0 & 1
\end{pmatrix}
$$

这是一个简单易于理解的求解思路，掌握了这个思路，不管进行什么样的变换，我们都能很快地求出来变换矩阵，只需要找到这些值，然后将其代入`矩阵框架`就行啦。

下面是一个坐标系变换的例子，坐标系 oxyz 绕 Z 轴旋转 β 角度后形成了新坐标系 ox'y'z'：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a6a27af075ce0~tplv-t2oaga2asx-image.image)

大家一定要分清，新坐标系是 `ox'y'z'`，原坐标系是 `oxyz`，新坐标系的`基向量`在原坐标系下的表示我们利用三角函数运算即可求出，如上图所示，所以按照求解思路的第一步，新坐标系的基向量在原坐标系表示为：

$U' =  (Ux', Uy', Uz')$

$Ux' = (cos\beta, sin\beta, 0)$

$Uy' = (-sin\beta, cos\beta, 0)$

$Uz' = (0, 0, 1)$

原坐标系的坐标原点和新坐标系重合，所以新坐标系原点在原坐标系下的表示：

$O1 = (Ox1 ,Oy1, Oz1) = (0, 0, 0)$

代入通用矩阵框架后得出变换矩阵为：

$$
\begin{pmatrix}
cos\beta & -sin\beta & 0 & O_{x1}\\
sin\beta & cos\beta & 0 & O_{y1}\\
0 & 0 & 1 & O_{z1}\\
0 & 0 & 0 & 1
\end{pmatrix}
$$



###  平移变换
按照上面的矩阵变换求解思路来寻找平移矩阵：

* tx 代表沿着 X 轴方向的位移量。
* ty 代表沿着 Y 轴方向的位移量。
* tz 代表沿着 Z 轴方向的位移量。


**1、求出原坐标系的基向量在新坐标系的表示。**

由于没有进行旋转和缩放操作，所以新坐标系的基向量和原坐标系一样：

$Ux = (1, 0, 0)$

$Uy = (0, 1, 0)$

$Uz = (0, 0, 1)$

**2、新坐标系坐标原点的坐标：**

$
Ox1 = Ox + t_x = t_x
$

$
Oy1 = Oy + t_y= t_y
$

$
Oz1 = Oz + t_z = t_z
$

将这些值代入变换矩阵框架

$
\begin{pmatrix}
1 & 0 & 0 & tx \\
0 & 1 & 0 & ty \\
0 & 0 & 1 & tz \\
0 & 0 & 0 & 1
\end {pmatrix}
$




##### 算法实现
我们用 JavaScript 实现上述平移矩阵。

* 输入参数
    * tx：沿 X 轴方向平移量。
    * ty：沿 Y 轴方向平移量。
    * tz：沿 Z 轴方向平移量。
* 输出结果
    * 返回一个平移矩阵。 

还记得吗？WebGL 矩阵是列主序的，每隔 4 个数代表一列。

```javascript
function translation(tx, ty, tz, target){
    target = target || new Float32Array(16);
    // 第一列
    target[0] = 1;
    target[1] = 0;
    target[2] = 0;
    target[3] = 0;
    // 第二列
    target[4] = 0;
    target[5] = 1;
    target[6] = 0;
    target[7] = 0;
    // 第三列
    target[8] = 0;
    target[9] = 0;
    target[10] = 1;
    target[11] = 0;
    // 第四列
    target[12] = tx;
    target[13] = ty;
    target[14] = tz;
    target[15] = 0;
    
    return target;
}
```

平移矩阵的生成算法很简单，按照数学关于矩阵的定义，在指定位置设置正确的值即可。

之后我们就可以用该算法生成一个平移矩阵实现顶点的平移变换了。

**平移矩阵的演示**

我们绘制两个半径为 5 的球体，第一个球体在世界坐标系中心，第二个球体沿着 X 轴偏移 10 个单位，为了演示方便，我们先设置一个正射投影矩阵，左平面位于 -15 处，右平面位于 15 处，上平面位于 15 处，下平面位于 -15 处，远平面位于 1000，近平面位于 -1000。

```javascript
//获取视口宽高比
var aspect = canvas.width / canvas.height;
//获取正射投影观察箱
var perMatrix = matrix.ortho(-aspect * 15, aspect * 15, -15, 15, 1000, -1000);
// 获取平移矩阵
var translationMatrix = matrix.translation(10, 0, 0);
// 将矩阵传往 GPU。
gl.uniformMatrix4fv(u_Matrix, translationMatrix);
```
  
    1、gl.uniformMatrix4fv该方法的作用是 JavaScript 向着色器程序中的`u_Matrix`属性传递一个 4 阶`列主序`矩阵。  
    2、ortho 方法是生成正射投影矩阵的方法，讲到投影变换时我们再对它的实现做讲解。

右侧球体是平移后的效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a1c143421a4f3~tplv-t2oaga2asx-image.image)

可以看出，平移矩阵能够正常工作。

### 缩放

缩放是将组成物体的各个顶点沿着对应坐标轴缩小或者放大，一种方法是：使用顶点向量乘以缩放向量即可实现。请注意数学领域向量和向量只有点乘和叉乘，并没有一种运算可以实现向量与向量各个分量相乘得到一个新的向量。
不过在上一节我们使用 JavaScript 实现了这样一个算法，在这里就可以用到了：

```javascript
Vector3 vec = new Vector3(3, 2, 1);
Vector3 scale = new Vector3(2, 2, 1);
vec = vec.multiply(scale);
```


$P \times S = (x, y, z) \times (2, 2, 1) = (2x, 2y, z, 1)$

但是这里我们要实现的是通过向量和矩阵相乘的方式来实现。

我们要构建一个缩放矩阵，缩放矩阵也比较简单，按照上面的求解思路：



**1、新坐标系基向量在原坐标系下的表示：**

沿着  X 轴缩放  sx 倍，相当于将原来的基向量放大了 sx 倍，所以新坐标系下一个单位的长度相当于原来坐标系下的 sx 个长度，以此类推，我们很容易地推导出 Y 轴和 Z 轴的基向量

$Ux = (sx, 0, 0)$

$Uy = (0, sy, 0)$

$Uz = (0, 0, sz)$


**2、原坐标系原点在新坐标系下的坐标：**

由于缩放操作没有改变原点位置，所以，原点坐标在新坐标系下仍然是（0，0，0）。

$
O1 = (0, 0, 0)
$


将这些值代入变换矩阵框架，可以得出：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a3da75f85ba1b~tplv-t2oaga2asx-image.image)

上面这个图就是一个典型的缩放矩阵：

* sx：沿着 X 轴方向的缩放比例
* sy：沿着 Y 轴方向的缩放比例
* sz：沿着 Z 轴方向的缩放比例

#### 缩放矩阵算法实现：

```javascript
function scale(sx, sy, sz, target){
    target = target || new Float32Array(16);
    
    // 第一列
    target[0] = sx;
    target[1] = 0;
    target[2] = 0;
    target[3] = 0;
    
    // 第二列
    target[4] = 0;
    target[5] = sy;
    target[6] = 0;
    target[7] = 0;
    
    // 第三列
    target[8] = 0;
    target[9] = 0;
    target[10] = sz;
    target[11] = 0;
    
    // 第四列
    target[12] = 0;
    target[13] = 0;
    target[14] = 0;
    target[15] = 1;
    
    return target;
}
```
调用该方法需要指定三个方向的缩放比例，但是有时我们可能只缩放某个方向，所以需要再衍生三个缩放函数

* 沿 X 轴缩放矩阵
* 沿 Y 轴缩放矩阵
* 沿 Z 轴缩放矩阵

```javascript
function scaleX(sx){
    return scale(sx, 1, 1);
}
function scaleY(sy){
    return scale(1, sy, 1);
}
function scaleZ(sz){
    return scale(1, 1, sz);
}
```

### 旋转 
相比平移和缩放，旋转矩阵相对复杂一些，我们从 2D 平面上一个顶点的旋转说起。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a3f4f493efad8~tplv-t2oaga2asx-image.image)

点 P(x, y) 旋转 β 角度后，得到一个新的顶点 P1(x1, y1) ， P1 和 P 之间的坐标关系：

**P 点坐标：**

$
x = r \times cos\alpha
$

$
y = r \times sin\alpha
$

**旋转后的 P1 点坐标：**

$
x1 = r \times cos(\alpha + \beta) = r \times cos\alpha  cos\beta - r \times sin\alpha sin\beta
$

$
y1 = r \times sin(\alpha + \beta) = r \times cos\alpha sin\beta + r \times sin\alpha cos\beta
$


**将 P 点坐标带入 P1点可以得到：**

$
x1 = xcos\beta - ysin\beta
$

$
y1 = xsin\beta + ycos\beta
$

我们使用齐次坐标和矩阵表示：

$
P1 = 
\begin{pmatrix}
cos\beta & -sin\beta & 0 \\\
sin\beta & cos\beta & 0 \\\
0 & 0 & 1
\end{pmatrix}
 \times \begin{pmatrix}
x \\ y \\ 1
\end{pmatrix}
=\begin{pmatrix}
xcos\beta - ysin\beta \\ xsin\beta + ycos\beta \\ 1
\end{pmatrix}
$

扩展到 3D 空间，我们同样能推导出下面三种旋转矩阵。
#### 绕 X 轴旋转



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a6abab10b4063~tplv-t2oaga2asx-image.image)

JavaScript 的实现，相信大家已经熟记于心了，我们只需要在矩阵的各个位置指定对应数字即可。

```javascript
function rotationX(angle, target){
    target = target || new Float32Array(16);
    let sin = Math.sin(angle);
    let cos = Math.cos(angle);
    target[0] = 1;
    target[1] = 0;
    target[2] = 0;
    target[3] = 0;
    
    target[4] = 0;
    target[5] = cos;
    target[6] = sin;
    target[7] = 0;
    
    target[8] = 0;
    target[9] = -sin;
    target[10] = cos;
    target[11] = 0;
    
    target[12] = 0;
    target[13] = 0;
    target[14] = 0;
    target[15] = 1;

    return target;
    
}
```

>只要你理解了矩阵的运算规则，并推导出变换矩阵，之后只需将各个位置的元素赋值到一个类型化数组中即可。

#### 绕 Y 轴旋转



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684bb58b07334c9~tplv-t2oaga2asx-image.image)

算法和 X 轴旋转极其相似，就不在这里写了，具体实现请看[这里](https://github.com/lucefer/webgl/blob/master/utils/webgl-matrix.js)。
#### 绕 Z 轴旋转

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/24/166a6ac18384889f~tplv-t2oaga2asx-image.image)

具体实现请看[这里]()。

请注意：以上每一种旋转都是单一旋转，但往往我们需要既沿 X 轴旋转，又要沿 Y 轴旋转，这种情况，我们只需要将旋转矩阵相乘，得到的新的矩阵就是包含了这两种旋转的变换矩阵。


#### 绕任意轴旋转
上面三种是绕坐标轴进行旋转，但实际上我们往往需要绕空间中某一根轴旋转，绕任意轴旋转的矩阵求解比较复杂。

>这里我们采用过原点的任意轴旋转，不考虑平移情况，如果是绕一个不过原点的任意轴旋转的话，我们可以利用一个旋转矩阵和一个平移矩阵来完成。

我们看下如何推导，如下图所示：

* C：空间中一点。
* A：坐标原点。
* 向量$\vec{AF}$：旋转轴单位向量 。

点 C 旋转 β 角之后，来到 C' 点。

假设这个变换矩阵为 M，那么 M 和 角度 β以及旋转轴 $\vec{AF}$ 有关，

$
\vec{M} = (β, \vec{AF})
$

如下图所示：
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/25/166a969395da019a~tplv-t2oaga2asx-image.image)

我们现在需要求得如何用点C、 旋转角β以及旋转轴 $\vec{AF}$ 表示 C'。

##### 求解步骤

* 首先，求出$\vec{AC}$在旋转轴$\vec{AF}$上的分量$\vec{AB}$，同时向量$\vec{BC}$垂直于 $\vec{AB}$，
* 接着根据$\vec{BZ'}$ 和旋转角度 β，求出 $\vec{B}C'$，然后根据向量加法公式，求出 $\vec{AC'}$，即 C' 转换后的坐标。

用数学公式表示：

1、向量$\vec{AC}$点乘$\vec{AF}$,求出向量$\vec{AB}$ 。

$
\vec{AB} = (\vec{AC} \cdot \vec{AF}) \times \vec{AF}
$

2、求出$\vec{BC}$

$
\vec{BC} = \vec{AC} - \vec{AB}
$

3、通过向量$\vec{AF}$叉乘$\vec{BC}$ 求得$\vec{BZ'}$

$
\begin{aligned}
\vec{BZ'} &= \vec{AF} \times \vec{BC} \\\
&=\vec{AF} \times \vec{AC} - \vec{AF} \times \vec{AB} \\\
& = \vec{AF} \times \vec{AC} - 0 \\\
& = \vec{AF} \times \vec{AC}
\end{aligned}
$

4、利用三角函数求出 $\vec{BC'}$

$\vec{BC'} = \vec{BZ'} sin\beta + \vec{BC} cos\beta$

5、利用向量加法求出 $\vec{AC'}$

$
\vec{AC'} = \vec{AB} + \vec{BC'} 
$

6、将1-4步代入第5步，得出：

$
\vec{AC'} = (\vec{AC} \cdot \vec{AF}) \times \vec{AF} + (\vec{AF} \times \vec{AC}) sin\beta + (\vec{AC} - (\vec{AC} \cdot \vec{AF}) \times \vec{AF}) cos\beta
$

假设旋转轴向量表示为：

$
\vec{AF} = (t_x, t_y, t_z)
$

新坐标系基向量U(Ux,Uy,Uz)在原坐标系中的坐标位置求解如下：

![QianJianTec1694166564264.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac63e60ce1d4f25b3a95f8b64f349b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3908&h=441&s=135418&e=png&a=1&b=000000)


利用向量点乘、叉乘规则最终推导出：

$
Ux = \begin{pmatrix}
t_x^2  (1-cos\beta) + cos\beta \\\
t_xt_y(1-cos\beta) + t_zsin\beta \\\
t_xt_z(1-cos\beta) - t_ysin\beta
\end{pmatrix}
$

同理，将Y 轴基向量 (0, 1, 0) 代入上面公式，推导可得：

$
Uy = \begin{pmatrix}
t_xt_y  (1-cos\beta) - t_zsin\beta \\\
t_y^2(1-cos\beta) + cos\beta \\\
t_yt_z(1-cos\beta) + t_xsin\beta
\end{pmatrix}
$

$
Uz = \begin{pmatrix}
t_xt_z  (1-cos\beta) + t_ysin\beta \\\
t_yt_z(1-cos\beta) - t_xsin\beta \\\
t_z^2(1-cos\beta) + cos\beta
\end{pmatrix}
$

这样我们就求出了新坐标系的基向量在原坐标系的表示。

接下来，我们找出新坐标系的原点在原坐标系下的坐标，因为是绕原点旋转，所以坐标不变，仍然是（0，0，0）。将这些值代入矩阵框架，得出绕任意旋转轴的变换矩阵：


![QianJianTec1694166506653.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24c66f9097f249949fb1312e71525e45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3877&h=717&s=235594&e=png&a=1&b=000000)


有了变换矩阵，那么我们就可以实现JavaScript的任意轴旋转矩阵了：

```javascript
function axisRotation(axis, angle, target){
    var x = axis.x;
    var y = axis.y;
    var z = axis.z;
    var l = Math.sqrt(x * x + y * y + z * z);
    x = x / l;
    y = y/ l;
    z = z /l;
    var xx = x * x;
    var yy = y * y;
    var zz = z * z;
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    var oneMCos = 1 - cos;
    
    target = target || new Float32Array(16);
    
    target[0] = xx + (1 - xx) * cos;
    target[1] = x * y * oneMCos + z * sin;
    target[2] = x * z * oneMcos - y * sin;
    target[3] = 0;
    
    target[4] = x * y * oneMCos - z * sin;
    target[5] = yy + (1 - yy) * cos;
    target[6] = y * z * oneMCos + x * sin;
    target[7] = 0;
    
    target[8] = x * z  * oneMCos + y * sin;
    target[9] = y * z * oneMCos - x * sin;
    target[10] = zz + (1 - zz) * cos;
    target[11] = 0;
    
    target[12] = 0;
    target[13] = 0;
    target[14] = 0;
    target[15] = 1;
    
    return target;
}
```

以上就是绕任意轴进行旋转的矩阵。

##### 任意轴旋转演示
我们利用上面的算法演示一下，使用四根旋转轴：

```javascript
// 中间立方体绕 X 轴旋转。
var axisX = {x: 1, y: 0, z: 0}
//右边立方体绕 Y 轴旋转
var axisY = {x: 0, y: 1, z: 0}
// 左边立方体绕 Z 轴旋转
var axisZ = {x: 0, y: 0, z: 1}
// 上边立方体绕对角线轴旋转。
var axisXYZ = {x: 1, y: 1, z: 1}
```

效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/25/166aaf1eaec1aec8~tplv-t2oaga2asx-image.image)

绕任意轴旋转的推导比较复杂，涉及到立体几何以向量点乘叉乘等运算，不过它的使用方法还是很简单的。

## 回顾

本节主要讲解坐标系变换过程中涉及到的基本变换的原理与实现，涉及几何和三角函数的运算比较多，大家看一遍可能不能明白，不妨多看几遍，拿纸笔写写画画，很快就会豁然开朗。

虽然说这些 API 只要能看懂、会用就足够了，没有必要去掌握推导过程，但我仍然建议大家尝试推导一遍，掌握推导过程对巩固学过的数学知识很有帮助，也可以培养自己利用数学知识解决疑难问题的能力。


下一节我们学习如何利用这些基本变换实现各个坐标系之间的变换。

## 19.中级进阶 --- 坐标系变换：模型空间变换到世界空间

上一节我们学习了基本变换的原理与实现，本节我们学习如何把这些变换应用到坐标系变换中。

## 坐标系变换的分类

前面我们讲过，在 3D 编程中，可控制的坐标系变换分为3类，分别是：

* 模型变换
    * 模型变换负责将模型坐标转换成世界坐标。 
* 视图变换
    * 视图变换负责将世界坐标转换成相机坐标。
* 投影变换
    * 投影变换负责将相机坐标转换成裁剪坐标，也就是将 3D 坐标投影到 2D 平面上。
    
需要强调一点变换矩阵相乘的顺序，假设最终变换矩阵为 F，模型矩阵为 M， 视图矩阵为 V，投影矩阵为 P，那么有：

$ F = P \times V \times M $

这个顺序不能有错，否则效果与预想的会不一致。

接下来，我们从第一个变换`模型变换`讲起。

## 坐标系变换的起点

编程之初，我们首先能拿到的是模型数据，模型中各个点的位置是相对于模型的某个位置确定的，一般这个位置是模型的中心点，下面这个坐标系就是模型坐标系，立方体的所有顶点坐标都是相对于中心位置。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166cd2eb7d531b0b~tplv-t2oaga2asx-image.image)

默认情况下，模型坐标系和世界坐标系重合，所有创建好的模型首先会放置在世界坐标系中心位置，我们创建一个立方体和一个球体：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166cd5693a608e92~tplv-t2oaga2asx-image.image)

可以看到，我们创建的模型叠加在了一起。

那么，我们需要将我们的模型摆放在 3D 世界中的特定位置，3D 世界所遵循的参照就是世界坐标系。

这就涉及到模型变换了，模型变换的作用是将模型顶点从`模型坐标系`转换到`世界坐标系`。


## 模型变换

模型变换是由多个基本变换组合而成，那么对矩阵而言，就是由多个基本变换矩阵相乘而得到，既然提到相乘，那么`相乘的顺序`就至关重要，因为矩阵不满足交换律，两个矩阵相乘顺序不同，结果也不同。体现到坐标系变换上，就会发现模型经过变换后的坐标也不同，这一点很重要，请大家一定要牢记。

### 变换顺序

接下来我们演示下，对一个立方体进行平移旋转变换。

#### 平移与旋转  
我们先将立方体平移5 个单位，然后逆时针旋转 45 度，看一下立方体是什么状态。

平移矩阵：

```javascript
var translateMatrix = matrix.translate(5, 0, 0);
```

旋转矩阵:

```javascript
var rotateMatrix = matrix.rotateX(Math.PI / 180 * 45);
```

创建两个立方体，红色立方体先旋转再平移，黄色立方体先平移再旋转。

先旋转再平移矩阵：

```javascript
var redMatrix = matrix.multiply(translationMatrix, rotateMatrix);
```

先平移再旋转矩阵：

```javascript
var yellowMatrix = matrix.multiply(rotateMatrix, translationMatrix);
```


将两个矩阵应用到立方体上，我们可以看到下面的效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166ce31a5fe2ff25~tplv-t2oaga2asx-image.image)

很容易发现，当我们需要模型自身绕着模型中心旋转时，要先执行旋转再平移，党需要模型绕世界中心旋转时，需要先平移再旋转。但通常情况，我们都是先执行旋转再执行平移，也就是红色立方体的旋转效果。


#### 考虑缩放

当然，除了平移与旋转，有时也会涉及到模型缩放，很显然，对模型进行缩放也是要放在平移之前，但是缩放和旋转哪个在先，哪个在后呢？

**先缩放再旋转，还是先旋转再缩放？**

依然通过两个立方体来比较，红色立方体先执行缩放，再进行旋转，黄色立方体则先旋转再缩放，在这里缩放比例采用 X 轴放大 2 倍， Y 轴放大 1.5 倍来处理。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166ce9597ae0d78e~tplv-t2oaga2asx-image.image)

可以看到，先旋转再缩放的黄色立方体不是我们所期望的结果，它会改变模型的形状。而`先缩放再旋转`的红色立方体则是我们所期望的。

上例我们采用的是不一样的缩放比例，大家能很容易地看出差别，这次我们采用一样的缩放比例，看下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166cea140d8adf1c~tplv-t2oaga2asx-image.image)

可以看到，当缩放矩阵的缩放比例一致时，旋转与缩放的顺序就不那么重要了，表现都是一样的。


#### 模型变换公式

假设模型变换矩阵为 M，其中缩放矩阵为 S，旋转矩阵为 R，平移矩阵为 T，考虑到我们是列主序，所以有如下公式：

$M = T（平移矩阵） \times R（旋转矩阵） \times S（缩放矩阵） $


## 模型变换的意义
前面我们讲了，3D 世界中会有很多模型，每个模型所处的位置和朝向都不一样，这就需要我们对它们进行安放，模型变换就是我们安放模型的手段。

## 回顾
本节主要讲解坐标系变换的分类，以及`模型变换`的作用以及使用时需要注意的地方，主要是矩阵相乘顺序。

下一节，我们讲解视图变换的推导与应用。

## 2.初级入门 --- 从一个点开始：掌握 WebGL 的编程要素

本节内容涉及一些术语，为了便于大家理解，在讲解之前，我对相关术语做个简单解释：

* 图元：WebGL 能够绘制的基本图形元素，包含三种：`点`、`线段`、`三角形`。
* 片元：可以理解为像素，像素着色阶段是在片元着色器中。
* 裁剪坐标系：裁剪坐标系是顶点着色器中的 `gl_Position` 内置变量接收到的坐标所在的坐标系。
* 设备坐标系：又名 NDC 坐标系，是裁剪坐标系各个分量对 w 分量相除得到的坐标系，特点是 x、y、z 坐标分量的取值范围都在 【-1，1】之间，可以将它理解为边长为 2 的正方体，坐标系原点在正方体中心。

## 目标
本节实现一个最简单的 WebGL 程序：鼠标点击一次，就会在点击位置处绘制一个随机颜色的点。

效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc5bf0fe41b~tplv-t2oaga2asx-image.image)

希望通过这个例子，能够让大家掌握 WebGL 的绘制过程。

* [演示地址](http://ifanqi.top/webgl/pages/lesson1.1.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson1.1.html)。

## 编写第一个 WebGL 程序


上节我们讲到 WebGL 应用包含两个要素：`JavaScript程序`和`着色器程序`。本节我们通过绘制一个点来演示这个过程，麻雀虽小，但五脏俱全。使用 WebGL 绘制一个点虽然简单，但是它仍需要 JavaScript 程序和着色器程序共同完成。


我们的目标是绘制一个在屏幕中心，大小为 10，颜色是红色的点。  



### 1、准备着色器源码

我们从`着色器程序`开始入手，先用GLSL编写`顶点着色器`和`片元着色器`。
  
  * 顶点着色器
  
顶点着色器的主要任务是告诉 GPU 在`裁剪坐标系`的原点（也就是屏幕中心）画一个大小为 10 的点。

```glsl
void main(){
    //声明顶点位置
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    //声明待绘制的点的大小。
    gl_PointSize = 10.0;
}
  ```
  
 * 片元着色器

顶点着色器中的数据经过`图元装配`和`光栅化`之后，来到了`片元着色器`，在本例中，片元着色器的任务是通知 GPU 将光栅化后的像素渲染成红色，所以片元着色器要对内置变量 `gl_FragColor` （代表像素要填充的颜色）进行赋值。

 
```glsl
void main(){
    //设置像素的填充颜色为红色。
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); 
}
```


至此，我们完成了着色器的开发，是不是很简单呢？

但是我相信会有一部分细心的同学产生了疑问：

* gl_Position、gl_PointSize、gl_FragColor 代表什么？为什么没有声明就可以赋值？
* vec4 的含义？
* 在 CSS 语法中或者一些制图软件中，`RGBA` 模式下红色用（255, 0, 0, 1）来表示，为什么片元着色器中颜色用 `vec4(1.0, 0.0, 0.0, 1.0)` 来表示呢？

这些是 GLSL 的语法细节，后面章节我会对 GLSL 语法作详细介绍，但在这之前，我们先要认识一下它们。


那么，解释一下上面列出的三个疑问：

* gl\_Position、gl\_PointSize、gl_FragColor 是 GLSL 的内置属性。

	* gl_Position：顶点的`裁剪坐标系坐标`，包含 X, Y, Z，W 四个坐标分量，顶点着色器接收到这个坐标之后，对它进行透视除法，即将各个分量同时除以 W，转换成 `NDC 坐标`，NDC 坐标每个分量的取值范围都在【-1, 1】之间，GPU 获取这个属性值作为顶点的最终位置进行绘制。
	
	* gl_FragColor：片元（像素）颜色，包含 R, G, B, A 四个颜色分量，且每个分量的取值范围在【0,1】之间，GPU 获取这个值作为像素的最终颜色进行着色。
	
	* gl\_PointSize：绘制到屏幕的点的大小，需要注意的是，gl\_PointSize只有在绘制图元是`点`的时候才会生效。当我们绘制线段或者三角形的时候，gl_PointSize是不起作用的。
	
* vec4：包含四个浮点元素的`容器类型`，vec 是 vector（向量）的单词简写，vec4 代表包含 4 个浮点数的向量。此外，还有 `vec2`、`vec3` 等类型，代表包含`2个`或者`3个`浮点数的容器。

* GLSL 中 gl\_Position 所接收的坐标所在坐标系是裁剪坐标系 ，不同于我们的浏览器窗口坐标系。所以当我们赋予 gl\_Position 位置信息的时候，需要对其进行转换才能正确显示。

* gl_FragColor，属于 GLSL 内置属性，用来设置片元颜色，包含 4 个分量 (R, G, B, A)，各个颜色分量的取值范围是【0，1】，也不同于我们常规颜色的【0，255】取值范围，所以当我们给 gl\_FragColor 赋值时，也需要对其进行转换。平常我们所采用的颜色值（R, G, B, A），对应的转换公式为： (R值/255，G值/255，B值/255，A值/1）。拿红色举例，在CSS中，红色用 `RGBA` 形式表示是（255，0，0，1），那么转换成 GLSL 形式就是(255 / 255, 0 / 255, 0 / 255, 1 / 1)，转换后的值为（1.0, 0.0, 0.0, 1.0)。

> 注意，GLSL 是强类型语言，定义变量时，数据类型和值一定要匹配正确，比如我们给浮点数 a 赋值 1，我们需要这样写：`float a = 1.0;` 如果用 `float a = 1;` 的话会报错。

至此，着色器源码部分编写好了，那么着色器源码该如何使用呢？

着色器源码本质是字符串，所以我们既可以把着色器源码存储在 JavaScript 变量里，也可以放在 script  标签里，甚至存储在数据库中并通过 ajax 请求获取。之后的章节，为了使用方便，我们把着色器源码放在 `script` 标签中。

### 2、准备 HTML 文件
HTML 文件至少需要包含一个 `canvas` 标签，另外需要两个存储`着色器源码`的 script 标签。

```html
<body>
	<!-- 顶点着色器源码 -->
	<script type="shader-source" id="vertexShader">
	 void main(){
  		//声明顶点位置
  		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
  		//声明要绘制的点的大小。
  		gl_PointSize = 10.0;
  	}
	</script>
	
	<!-- 片元着色器源码 -->
	<script type="shader-source" id="fragmentShader">
	 void main(){
	 	//设置像素颜色为红色
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); 
	}
	</script>
	
	<canvas id="canvas"></canvas>
</body>
```

### 3、JavaScript 程序
准备好了 HTML 文件，我们接着编写 JavaScript 部分。

首先，获取 WebGL 绘图环境：

```javascript
var canvas = document.querySelector('#canvas');
var gl = canvas.getContext('webgl') || canvas.getContext("experimental-webgl");
```
> 在某些浏览器中，我们还需要做下兼容处理，加上实验前缀。


创建顶点着色器对象：

```javascript
// 获取顶点着色器源码
var vertexShaderSource = document.querySelector('#vertexShader').innerHTML;
// 创建顶点着色器对象
var vertexShader = gl.createShader(gl.VERTEX_SHADER);
// 将源码分配给顶点着色器对象
gl.shaderSource(vertexShader, vertexShaderSource);
// 编译顶点着色器程序
gl.compileShader(vertexShader);
```

接下来，创建片元着色器，该过程和顶点着色器的创建过程类似，区别在于`着色器源码`和`着色器类型`。

```javascript
// 获取片元着色器源码
var fragmentShaderSource = document.querySelector('#fragmentShader').innerHTML;
// 创建片元着色器程序
var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
// 将源码分配给片元着色器对象
gl.shaderSource(fragmentShader, fragmentShaderSource);
// 编译片元着色器
gl.compileShader(fragmentShader);
```

着色器对象创建完毕，接下来我们开始创建着色器程序

```javascript
//创建着色器程序
var program = gl.createProgram();
//将顶点着色器挂载在着色器程序上。
gl.attachShader(program, vertexShader); 
//将片元着色器挂载在着色器程序上。
gl.attachShader(program, fragmentShader);
//链接着色器程序
gl.linkProgram(program);
```

有时候一个 WebGL 应用包含多个 program，所以在使用某个 program 绘制之前，我们要先启用它。

```javascript
// 使用刚创建好的着色器程序。
gl.useProgram(program);
```

准备工作做好了，接下来开始绘制：

```javascript
//设置清空画布颜色为黑色。
gl.clearColor(0.0, 0.0, 0.0, 1.0);

//用上一步设置的清空画布颜色清空画布。
gl.clear(gl.COLOR_BUFFER_BIT);

//绘制点。
gl.drawArrays(gl.POINTS, 0, 1);
```


gl.drawArrays 的语法简单介绍如下，详细介绍参见[这里](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/drawArrays)。
> void gl.drawArrays(mode, first, count);
* 参数：
    * mode，代表图元类型。
    * first，代表从第几个点开始绘制。
    * count，代表绘制的点的数量。
    


`gl.drawArrays` 是执行绘制的 API，上面示例中的第一个参数 `gl.POINTS` 代表我们要绘制的是`点图元`，第二个参数代表要绘制的顶点的起始位置，第三个参数代表顶点绘制个数。

至此，着色器部分和 JavaScript 程序都写完了，运行看下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc66b729ea4~tplv-t2oaga2asx-image.image)

上面这些代码实现了点的绘制。大家应该发现了，在 `gl.drawArrays` 方法之前有很多重复的代码，这些重复代码是我们实现每个 WebGL 应用都要编写的，为了避免重复工作，我们把这些代码封装一下，封装出的函数库放在 webgl-helper.js 文件中，优化过后的代码如下：

```javascript
//获取canvas
var canvas = getCanvas(id);

//获取webgl绘图环境
var gl = getWebGLContext(canvas);

//创建顶点着色器
var vertexShader = createShaderFromScript(gl, gl.VERTEX_SHADER,'vertexShader');
//创建片元着色器
var fragmentShader = createShaderFromScript(gl, gl.FRAGMENT_SHADER,'fragmentShader');

//创建着色器程序
var program = createProgram(gl ,vertexShader, fragmentShader);
//告诉 WebGL 运行哪个着色器程序
gl.useProgram(program);

//设置清空画布颜色为黑色。
gl.clearColor(0.0, 0.0, 0.0, 1.0);
//用上一步设置的清空画布颜色清空画布。
gl.clear(gl.COLOR_BUFFER_BIT);
//绘制点
gl.drawArrays(gl.POINTS, 0, 1);
```

九行代码就实现了绘制点的程序，是不是简洁了很多？

## 点的动态绘制
上例只是实现了一个静态点的绘制，但是真正的 WebGL 应用总是需要通过网页和用户进行交互，进而改变画面的。所以接下来，我们要实现一个简单交互程序：在鼠标点击过的位置绘制一个点，而且这个点的颜色是随机的。

这要求我们有能力通过 JavaScript 往着色器程序中传入顶点位置和颜色数据，从而改变点的位置和颜色。

### 着色器程序
我们修改一下着色器程序，修改后的着色器程序要能够接收 JavaScript 传递过来的数据：

* 顶点着色器

```glsl
//设置浮点数精度为中等精度
precision mediump float;
//接收点在 canvas 坐标系上的坐标 (x, y)
attribute vec2 a_Position;
//接收 canvas 的宽高尺寸
attribute vec2 a_Screen_Size;
void main(){
    //start 将屏幕坐标系转化为裁剪坐标（裁剪坐标系）
   vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0; 
   position = position * vec2(1.0, -1.0);
   gl_Position = vec4(position, 0, 1);
   //end 将屏幕坐标系转化为裁剪坐标（裁剪坐标系）
   //声明要绘制的点的大小。
   gl_PointSize = 10.0;
}
```

* 片元着色器

```glsl
//设置浮点数精度为中等精度
precision mediump float;
//接收 JavaScript 传过来的颜色值（RGBA）。
uniform vec4 u_Color;
void main(){
    //将普通的颜色表示转化为 WebGL 需要的表示方式，即将【0-255】转化到【0,1】之间。
   vec4 color = u_Color / vec4(255, 255, 255, 1);
   gl_FragColor = color; 
}
```

这次的着色器和上例中的着色器有很大不同，大家可以发现，顶点着色器中在给 `gl_Position` 赋值之前，进行了一系列运算。片元着色器中给 `gl_FragColor` 赋值之前，也进行了一系列运算。代码注释大家应该能看懂，我简单讲一下：

* 顶点着色器  

我们在顶点着色器中定义两个 attribute 变量： `a_Position` 和 `a_Screen_Size`，a_Position 接收 `canvas 坐标系`下的点击坐标。  
`vec2` 代表存储两个浮点数变量的容器，因本节不涉及`深度计算`，所以我们只接收顶点的 x 和 y 坐标。  
a_Screen_Size 变量用来接收 JavaScript 传递过来的 canvas 的宽高尺寸。

```glsl
vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0
```
上面这句代码用来将浏览器窗口坐标转换成裁剪坐标，之后通过透视除法，除以 w 值（此处为 1 ）转变成设备坐标（NDC坐标系）。这个算法首先将(x,y) 转化到【0, 1】区间，再将 【0, 1】之间的值乘以 2 转化到 【0, 2】区间，之后再减去 1 ，转化到 【-1, 1】之间的值，即 `NDC 坐标`。   

事实上，这是我们第一次接触坐标系变换: 从 Canvas 坐标系转变到 NDC 坐标系（即设备坐标系），这个变换比较简单，我们用基本运算就可以实现。

>在中级进阶阶段，我会给大家介绍一种更通用的转换方法：矩阵变换。



* 片元着色器  

片元着色器定义了一个`全局变量` (被 uniform 修饰的变量) ，用来接收 JavaScript 传递过来的随机颜色。

大家应该注意到了，到目前为止，我们定义变量采用过两种形式，一种是通过 attribute 修饰，一种是通过 uniform 修饰。同样都是用来接收 JavaScript 传递过来的信息，它们有什么区别呢？

* attribue 变量：只能在`顶点着色器`中定义。

* uniform 变量：既可以在`顶点着色器`中定义，也可以在`片元着色器中`定义。

* 最后一种变量类型 `varing` 变量：它用来从`顶点着色器`中往`片元着色器`传递数据。使用它我们可以在顶点着色器中声明一个变量并对其赋值，经过插值处理后，在片元着色器中取出插值后的值来使用。


### HTML 部分

```html
<script type="shader-source" id="vertexShader">
    precision mediump float;
	//接收点在 canvas 坐标系上的坐标 (x, y)
    attribute vec2 a_Position;
	//接收 canvas 窗口尺寸(width, height)
    attribute vec2 a_Screen_Size;
    void main(){
	    //将屏幕坐标系转化为 GLSL 限定的坐标值（NDC坐标系）
   	    vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0; 
   	    position = position * vec2(1.0, -1.0);
   	    gl_Position = vec4(position, 0, 1);
   	    //声明要绘制的点的大小。
   	    gl_PointSize = 10.0;
    }  
 </script>

  <!-- 片元着色器源码 -->
  <script type="shader-source" id="fragmentShader">
    precision mediump float;
    //接收 JavaScript 传过来的颜色值（rgba）。
    uniform vec4 u_Color;
    void main(){
   	    vec4 color = u_Color / vec4(255, 255, 255, 1);
   	    gl_FragColor = color; 
    }
   </script>

  <canvas id="canvas"></canvas>

```

### JavaScript 程序
JavaScript 部分的实现与静态点的绘制大致相同，只是增加了为着色器中变量进行赋值的代码。

动态绘制点的逻辑是：

* 声明一个数组变量 `points`，存储点击位置的坐标。
* 绑定 canvas 的点击事件。
* 触发点击操作时，把点击坐标添加到数组     `points` 中。
* 遍历每个点执行 `drawArrays(gl.Points, 0, 1)` 绘制操作。

```javascript
...省略着色器创建部分。
//找到顶点着色器中的变量a_Position
var a_Position = gl.getAttribLocation(program, 'a_Position');
//找到顶点着色器中的变量a_Screen_Size
var a_Screen_Size = gl.getAttribLocation(program, 'a_Screen_Size');
//找到片元着色器中的变量u_Color
var u_Color = gl.getUniformLocation(program, 'u_Color');
//为顶点着色器中的 a_Screen_Size 传递 canvas 的宽高信息
gl.vertexAttrib2f(a_Screen_Size, canvas.width, canvas.height);
//存储点击位置的数组。
var points = [];
canvas.addEventListener('click', e => {
   var x = e.pageX;
   var y = e.pageY;
   var color = randomColor();
   points.push({ x: x, y: y, color: color })
   gl.clearColor(0, 0, 0, 1.0);
   //用上一步设置的清空画布颜色清空画布。
  	gl.clear(gl.COLOR_BUFFER_BIT);
   for (let i = 0; i < points.length; i++) {
     var color = points[i].color;
     //为片元着色器中的 u_Color 传递随机颜色
     gl.uniform4f(u_Color, color.r, color.g, color.b, color.a);
     //为顶点着色器中的 a_Position 传递顶点坐标。
     gl.vertexAttrib2f(a_Position, points[i].x, points[i].y);
     //绘制点
     gl.drawArrays(gl.POINTS, 0, 1);
   }
 })
 // 设置清屏颜色
 gl.clearColor(0, 0, 0, 1.0);
 // 用上一步设置的清空画布颜色清空画布。
 gl.clear(gl.COLOR_BUFFER_BIT);

```



至此，我们实现了在 canvas 上进行点击，在点击位置处绘制一个随机颜色的点的程序。



#### 不足之处：  
本示例我们采用 `gl.vertexAttrib2f ` 直接给 a_Position 赋值，所以每绘制一个点，都要给着色器变量赋值一次，并且绘制一次，效率比较低。后面我们会介绍一种更快速的方式：利用缓冲区传递多个顶点数据。

## 回顾

本小节通过演示如何使用 WebGL 绘制一个动态位置、随机颜色的点，向大家介绍 WebGL 程序的组成要素，以及一些简单的 GLSL 语法。
总结一下本节所学内容：

* GLSL
	* gl_Position： 内置变量，用来设置顶点坐标。
	* gl_PointSize： 内置变量，用来设置顶点大小。
	* vec2：2 维向量容器，可以存储 2 个浮点数。
	* gl_FragColor： 内置变量，用来设置像素颜色。
	* vec4：4 维向量容器，可以存储 4 个浮点数。
	* precision：精度设置限定符，使用此限定符设置完精度后，之后所有该数据类型都将沿用该精度，除非单独设置。
	* 运算符：向量的对应位置进行运算，得到一个新的向量。  
	    * vec * 浮点数： vec2(x, y) * 2.0 = vec(x * 2.0, y * 2.0)。  
	    * vec2 * vec2：vec2(x1, y1) * vec2(x2, y2) = vec2(x1 * x2, y1 * y2)。  
	    * 加减乘除规则基本一致。但是要注意一点，如果参与运算的是两个 vec  向量，那么这两个 vec 的维数必须相同。
	
* JavaScript 程序如何连接着色器程序
	* createShader：创建着色器对象
	* shaderSource：提供着色器源码
	* compileShader：编译着色器对象
	* createProgram：创建着色器程序
	* attachShader：绑定着色器对象
	* linkProgram：链接着色器程序
	* useProgram：启用着色器程序
* JavaScript 如何往着色器中传递数据
	* getAttribLocation：找到着色器中的 `attribute 变量`地址。
	* getUniformLocation：找到着色器中的 `uniform 变量`地址。
	* vertexAttrib2f：给 `attribute 变量`传递两个浮点数。
	* uniform4f：给`uniform变量`传递四个浮点数。
* WebGL 绘制函数
	* drawArrays: 用指定的图元进行绘制。
* WebGL 图元
	* gl.POINTS: 将绘制图元类型设置成`点图元`。
	
另外需要注意，本节例子的坐标系转换我们是在着色器阶段完成的，事实上，我们通常在 JavaScript 上计算出`转换矩阵`，然后将`转换矩阵`连同`顶点信息`一并传递给着色器。大家可以尝试把这部分坐标转换算法移到 JavaScript 中试试，效果是一样的。

好好消化一下本节内容，之后的章节仍然会用到这些知识。

接下来让我们进入下一环节，学习三角形图元的绘制吧~






## 20.中级进阶 --- 坐标系变换：世界空间变换到观察空间

上一节我们学习了坐标系变换的基本变换的原理以及算法实现，模型空间通过基本变换会转变到世界空间，转变到世界空间之后，就需要将世界空间映射到观察空间，本节我们学习世界空间向观察空间转换的算法实现。

## 什么是观察空间
`观察空间`是从人眼或者摄像机看到的 3D 空间，是整个3D 世界的一部分，观察变换的主要作用是将模型的顶点坐标从`世界坐标系`变换到`观察坐标系`中。

> 观察坐标系也可以理解为相机坐标系。

还记得上一节我们求解变换矩阵的思路吗？

* 求出新坐标系原点在原坐标系中的位置。
* 求出新坐标系基向量在原坐标系中的表示。


## 视图变换

世界空间转变到观察空间这个过程通常称为视图变换，变换矩阵称为视图矩阵。在做视图变换之前，我们会在世界坐标系里指定摄像机或者人眼的位置`eyePosition`，以及摄像机头顶方向向量`upDirection`，然后我们要根据这两个条件计算出视图变换矩阵。

按照矩阵求解步骤进行分析。

### 新坐标系原点在原坐标系中的位置
首先我们要分清哪个是新坐标系，哪个是原坐标系。
在世界空间变换到观察空间的过程中，新坐标系是观察坐标系，原坐标系是世界坐标系，我们已经知道的是世界坐标系下的顶点位置 P0，需要求出顶点在观察坐标系中的位置 P1。

$P1 = M \times P0。$

其中 M 是世界坐标系变换到观察坐标系的观察矩阵。

为了求M，我们需要知道世界坐标系的原点在观察坐标系中的位置，还需要知道世界坐标系基向量在观察坐标系中的表示。

我们目前的已知量有如下三个：

* 1、观察坐标系原点在世界坐标系中的位置。
* 2、观察坐标系的 Z 轴在世界坐标系中的表示。
* 3、顶点在世界坐标系中的位置P0。

根据 1、2 两项可以得出观察坐标系到世界坐标系的观察矩阵 M 。

但是我们需要求出的是 世界坐标系到观察坐标系的视图矩阵 N。



### 逆变换

大家还记得在数学章节，我们学习了逆矩阵的含义与算法实现。在坐标系变换中，逆矩阵有着重要的意义。

假设有一顶点在坐标系A中坐标 P0，经过矩阵变换 M 后顶点在坐标系 B 中的坐标 P1，

$P1 = M \times P0$

又有

$M \times M^{-1} = I $

$I \times P1 = P1$

所以

$M \times M^{-1} \times P1 = M \times P0$

两边约去 M，可得

$M^{-1} \times P1 = P0$

什么意思呢？

意思就是顶点 P1 经过矩阵 M 的逆矩阵就可以变换回顶点 P0。我们看下逆矩阵在视图变换中如何应用。

假设顶点在世界坐标系中的坐标 P0，观察坐标系变换到世界坐标系的变换矩阵为 M，那么顶点在观察坐标系中的坐标 P1 为：

$P0 = M \times P1 $

$\Longrightarrow M \times M^{-1} \times P0 = M \times P1$

$\Longrightarrow M^{-1} \times  P0 = P1$

同样地，我们只要求出观察坐标系变换到世界坐标系 的逆矩阵即可求出物体在观察坐标系中的坐标。

在此，我们定义观察坐标系变换到世界坐标系的矩阵为相机矩阵 E，世界坐标系变换到观察坐标系的矩阵为视图矩阵 V，其中 E 和 V 互逆。


### 求解相机矩阵

求解相机矩阵仍然按照上一节的求解步骤。

我们已经知道的几个条件：

* 假设相机在世界坐标系中的位置 `Pe (ex, ey, ez)`。
* 看向目标位置为`T (tx,ty,tz)`。
* 摄像机上方方向向量 `upDirection 为(ux, uy, uz)`。

接下来我们要根据这些条件求出相机矩阵。

#### 1、相机坐标系的原点在世界坐标系的位置

由上面条件可知，相机坐标系原点在世界坐标系中的位置如下：

$
P_e = (ex， ey， ez)
$

#### 2、 求解相机坐标系的基向量在世界坐标系中的表示

从相机位置看像目标位置的方向称为观察方向，观察方向可以看做相机坐标系的 Z 轴方向，那么世界坐标系的 Z 轴基向量方向可以这样求出：

$
\begin{aligned}
zAxis &= P_e - T \\\
& =(ex - tx, ey - ty, ez - tz)
\end{aligned}
$

有了 Z 轴方向向量`zAxis`和临时 Y 轴 方向`upDirection`，我们就可以利用向量叉乘来计算 X 轴方向了。

$
xAxis = zAxis \times upDirection
$

计算出 X 轴方向之后，我们需要将 `xAxis` 和 `zAxis` 归一化，得到它们的`基向量`，这时还需要求一遍 Y 轴的方向向量，因为 `upDirection` 是我们一开始假想的，只是为了求解 X 轴方向，`upDirection` 和 `zAxis` 不一定是垂直关系。

仍然利用向量叉乘求解 Y 轴方向：

$
yAxis = zAxis \times xAxis
$

将 xAxis(xx, xy, xz)、yAxis(yx, yy, yz)、zAxis(zx, zy, zz)以及相机位置 Pe(ex, ey, ez) 代入矩阵变换框架，可以求得相机坐标系变换到世界坐标系的矩阵 E

$
\begin{aligned}
\begin{pmatrix}
xx & yx & zx & ex \\\
xy & yy &  zy & ey \\\
xz & yz & zz & ez \\\
0 & 0 & 0 & 1
\end{pmatrix}
\end{aligned}
$

这就是`相机矩阵E`，有了它 ，我们利用逆矩阵的算法求出 E 的逆矩阵 $E^{-1}$，即视图矩阵。

之后就可以利用`视图矩阵`左乘顶点在世界坐标系的坐标，计算出顶点在观察坐标系中的坐标，也就完成了世界坐标系到观察坐标系的变换。

### 算法实现

有了上面的分析，我们的算法就很容易实现了。

**1、 首先，求出Z 轴基向量，即观察方向：**

```javascript
function lookAt(cameraPosition, target, upDirection){
    var zAxis  = (Vector3.subtractVectors(cameraPosition, target)).normalize();
}
```
**2、 其次，根据 zAxis 和 upDireciton 求出 X 轴基向量：**

```javascript
var xAxis = (Vector3.cross(upDirection, zAxis)).normalize();
```

**3、处理 zAxis 和 upDirection 平行的情况：**

```javascript
if(xAxis.length() == 0){
    if (Math.abs(upDirection.z == 1)) {
      zAxis.x += 0.0001;
    } else {
      zAxis.z += 0.0001;
    }
    zAxis.normalize();
    xAxis = Vector3.cross(upDirection, zAxis).normalize();
}

```

**4、接着，根据 zAxis 和 xAxis ，重新计算Y轴基向量 yAxis：**

```javascript
var yAxis = (Vector3.cross(zAxis, xAxis)).normalize();
```

**5、最后，将各个值代入矩阵框架**

```javascript
var target = new Float32Array(16);

// 第一列，x 轴基向量
target[0] = xAxis.x;
target[1] = xAxis.y;
target[2] = xAxis.z;
target[3] = 0;

// 第二列，y 轴基向量
target[4] = yAxis.x;
target[5] = yAxis.y;
target[6] = yAxis.z;
target[7] = 0;

// 第三列，z 轴基向量
target[8] = zAxis.x;
target[9] = zAxis.y;
target[10] = zAxis.z;
target[11] = 0;

// 第四列，坐标系原点位置
target[8] = cameraPosition.x;
target[9] = cameraPosition.y;
target[10] = cameraPosition.z;
target[11] = 1;

return target;
```

### 使用方法

有了上面的算法，我们构造一个观察矩阵就轻而易举了。

* 首先定义摄像机的位置：

```javascript
var cameraPosition = new Vector3(0, 0, 10);
```

* 接着指定视线看向的点：

```javascript
var target = new Vector3(0, 0, 0);
```

* 假定一个方向向量代表摄像机上方：

```javascript
var upDirection = new Vector3(0, 1, 0);
```

* 将这三个参数代入 lookAt 方法，求出相机矩阵：

```javascript
var cameraMatrix = matrix.lookAt(cameraPosition, target, upDirection);
```

* 最后一步，求相机矩阵的逆矩阵，即观察矩阵。

```javascript
var viewMatrix = matrix.inverse(cameraMatrix);
```


### 效果演示

接下来，我们利用上面的观察矩阵，演示轨道摄像机和第一人称摄像机的效果。

#### 轨道摄像机

我们创建一个围绕场景中心的圆形摄像机轨道，半径为10，观察处于场景中心的一个立方体。其中，摄像机在圆形轨道上移动，并且观察方向始终看向场景中心的立方体，


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/31/166c9538cea406e6~tplv-t2oaga2asx-image.image)

这是圆形轨道摄像机的观察效果，咋看之下，它给我们的感觉是立方体自己在动。其实是我们的摄像机在绕着圆形轨道移动，立方体的位置并没有变化。

>移动摄像机靠近物体等价于移动物体、远离摄像机的观察效果。

#### 跟踪摄像机

在一些第一人称游戏中，摄像机往往是跟随人物而动的，接下来我们模拟人物走动的视觉效果。

我们将摄像机的位置和人物的位置保持一致，摄像机看向的目标点始终保持在人物前方 20 单位处，于是就产生了下面的效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/1/166cadd121525b83~tplv-t2oaga2asx-image.image)


## 回顾

本节我们讲解了如何实现视图矩阵的推导，以及视图矩阵的简单应用，推导过程仍然涉及了很多数学知识的应用，在此建议大家一定要多加练习，熟练掌握这些数学知识。

下一节，我们学习投影矩阵的推导以及应用。





## 21.中级进阶 --- 坐标系变换：观察空间变换到裁剪空间

上节介绍了世界空间到观察空间（相机空间）的视图变换，本节介绍下一个转换步骤：观察空间到裁剪空间的投影变换。

> 观察空间也称为相机空间。

投影变换，顾名思义，就是将 3D 坐标投影到 2D 平面的过程。上节我们讲到，观察空间也沿用了右手坐标系，即 Z轴正向朝向屏幕外侧，但是裁剪坐标系是左手坐标系，即 Z 轴正向朝向屏幕内侧，那么在投影变换阶段，我们除了要将 3D 坐标投影到 2D 平面，还要将右手坐标系变换成左手坐标系。

## 投影分类

业界有两种常用的投影方式：`正交投影`、`透视投影`。


### 正交投影

正交投影，又名平行投影，常用在机械制图、施工图纸领域，投影后的比例和投影前的比例一致。

### 透视投影

透视投影多用在成像领域，比如人看世界、相机拍照等场景，这个场景有一个特点就是投影后能够实现近大远小的效果。


## 投影原理

正交投影和透视投影的原理大体相同，基本过程如下：
* 首先指定可视范围，即什么范围内的物体能投影。此过程通过指定近平面和远平面来圈定范围。
* 将可视范围内的所有物体坐标投影到近平面上，投影后的坐标根据相似三角形原理求得，比较简单。

不同之处：

* 正交投影的投影线是平行线，可视范围是一个立方体盒子。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/16755ce8c1c5b8d9~tplv-t2oaga2asx-image.image)


* 透视投影的投影线是相交线，可视范围是一个棱锥体盒子，这样经过投影后才能达到近大远小的效果。


如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/16755c26a9777b94~tplv-t2oaga2asx-image.image)


上面两种投影坐标系原点均位于投影盒正中心位置，因为是左手坐标系，所以，Z轴朝向屏幕内侧。

## 投影算法推导

接下来，我们推导一下投影变换算法。假设模型中有一点 P，且P的坐标为 （x,y,z），那么投影到近平面后的坐标P' = （x',y',z'）。那么 P'和P 之间的关系是什么呢？

我们已知的条件有以下几个：

* 近平面的 z 值 zNear。
* 近平面的宽度 width 和高度 height。
* 远平面的 z 值 zFar。

zFar 和 zNear 是相机坐标系中的Z轴坐标，由于相机坐标系是右手坐标系，Z轴朝向屏幕外侧，所以 zNear 是大于 zFar 的，这点在做坐标转换时需要注意。

接下来分析一下如何根据这些已知条件推导出 P'坐标，当推导出 P' 坐标之后，也就有了相应地投影矩阵。

### 正交投影

通过上面的示意图，我们能看到，正交投影盒中的一点 P(x, y, z)，其中：

* x坐标在【-width/2, width / 2】之间，通常我们不指定width，而是指定相机坐标系下的投影盒的左右两侧坐标，left和right。
* y坐标在【-height/2， height/2】之间，通常我们不指定height，而是指定相机坐标系下的投影盒的左右两侧坐标，top和bottom。
* z坐标在【zNear，zFar】之间。

投影后的点 P'（x',y',z'），其中：
* x' 在【-1，1】之间
* y' 在【-1，1】之间
* z' 在【-1，1】之间

我们最终需要一个矩阵M，使用该矩阵左乘顶点向量 P，即可得到P'。

按照惯例，我们还是找出P'和P之间的关系：

####  x' 和 x 的关系：

$
\begin{aligned}
x'&= \frac{x - (left + right)/2} {(right - left)/2} \\\
&= \frac{2x}{right - left}  - \frac{right + left}{right - left}
\end{aligned}
$

#### y'和y的关系

$
\begin{aligned}
y'&= \frac{y - (top + bottom)/2} {(top - bottom)/2} \\\
&= \frac{2y}{top - bottom}  - \frac{top + bottom}{top - bottom}
\end{aligned}
$

#### z' 和 z 的关系

$
\begin{aligned}
z'&= \frac{z - (zFar + zNear)/2} {(zNear - zFar)/2} \\\
&= \frac{2z}{zNear - zFar}  - \frac{zFar + zNear}{zNear - zFar}
\end{aligned}
$


找出 P'和P之间的关系之后，我们就能够将这个关系用矩阵表示出来，还记得我们的矩阵生成公式吗？

$
\begin{aligned}
M = \begin{pmatrix}
x'_x & y'_x & z'_x & t_x' \\\
x'_y & y'_y & z'_y & t_y' \\\
x'_z & y'_z & z'_z & t_z' \\\
0 & 0 & 0 & 1 
\end{pmatrix}
\end{aligned}
$


将上面的 x'、y'、z'代入上式，即可求出正交投影矩阵：

$
\begin{aligned}
M = \begin{pmatrix}
\frac{2}{right - left} & 0 & 0 & \frac{right + left}{left - right} \\\
 0 & \frac{2}{top - bottom} & 0 & \frac{top + bottom}{bottom - top} \\\
 0 & 0 & \frac{2}{zNear - zFar} & \frac{zFar + zNear}{zNear - zFar}  \\\
 0 & 0 & 0 & 1 \\\
\end{pmatrix}
\end{aligned}
$



以上就是正交投影变换矩阵的推导过程，很简单。

那么，有了矩阵表示方式，正交投影算法就能够实现了。

```javascript
function ortho(left, right, bottom, top, near, far, target){
  target = target || new Float32Array(16);

  target[0] = 2 / (right - left);
  target[1] = 0;
  target[2] = 0;
  target[3] = 0;
  target[4] = 0;
  target[5] = 2 / (top - bottom);
  target[6] = 0;
  target[7] = 0;
  target[8] = 0;
  target[9] = 0;
  target[10] = 2 / (near - far);
  target[11] = 0;
  target[12] = (left + right) / (left - right);
  target[13] = (bottom + top) / (bottom - top);
  target[14] = (near + far) / (near - far);
  target[15] = 1;

  return target;
}
```

#### 实践

我们用一个立方体来演示一下，你会发现，无论远平面距离多远，立方体的大小是不会变的。

我们将摄像机放在 Z 轴正向 20 个单位处，Y轴正向为上方，看向坐标系原点，同时将
投影盒设置为一个上下左右边界坐标在【 -5，5】之间，近平面坐标为 20， 远平面坐标为 -20 的立方体。

```javascript
var cube = createCube(3, 3, 3);
var cameraPosition = {x: 0, y: 0, z: 20};
var target ={x: 0, y: 0, z: 0};
var up = {x: 0, y: 1, z: 0};
var cameraMatrix = matrix.lookAt(cameraPosition, target, up);
var viewMatrix = matrix.inverse(cameraMatrix);
var projectionMatrix = matrix.ortho(-5, 5, -5, 5, -20，20);
...略
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/28/16759b62a70afdc2~tplv-t2oaga2asx-image.image)

可以看到，无论我们将镜头移到多远，物体投影后的大小始终不变。

那么什么会影响物体投影后的大小呢？有的同学已经猜到了，投影盒的宽度和高度。

我们试一下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/28/16759b75066d50e1~tplv-t2oaga2asx-image.image)

可以看到，将宽度和高度增大之后，物体投影后变小了。

### 透视投影
透视投影是我们比较常用的投影方式，它能够实现现实生活中人眼看向世界产生的近大远小的效果。接下来我们推导一下透视算法。


和正交投影类似，透视投影也接收近平面和远平面参数，不同的是，透视投影的投影盒是一个棱锥体。正因为如此，透视投影才可以实现近大远小的效果。

通过上面透视投影示例图，根据相似三角形原理，我们可以知道如下关系：

$
\frac{zNear}{z} = \frac{y_1}{y} = \frac{x_1}{x}
$


所以有
$
\begin{aligned}
x_1 = \frac{zNear * x}{z} \\\
y_1 = \frac{zNear * y}{z}
\end{aligned}
$

其中 $x_1$和$y_1$是相机坐标系坐标经过视线看向物体后在近平面上的交点坐标，此时 $x_1$和$y_1$还是相机坐标系下坐标，并没有变换到裁剪坐标系，我们还要将$x_1$和$y_1$变换到【-1，1】之间。

$
\begin{aligned}
x' = \frac{x_1}  {z * width /2} = \frac{zNear * x}  {z * width /2} \\\
\\\
y' = \frac{y_1}  {z * height /2} = \frac{zNear * y}  {z * height /2} \\\
\end{aligned}
$

又由于投影坐标系和相机坐标系 Z 轴相反，所以需要对Z轴坐标取反。

$
\begin{aligned}
x' = - \frac{zNear * x}  {z * width /2} \\\
\\\
y' = - \frac{zNear * y}  {z * height /2} \\\
\end{aligned}
$
看到这里，你会发现，x' 和 y' 不仅和投影面的宽度和高度有关系，还和 z 轴坐标有关系，z 轴坐标越大，x'和 y' 越小，也就产生了近大远小的效果，我们将齐次坐标 w 分量设置为 z，此时 x' 和 y' 的值为

$
\begin{aligned}
x' = - \frac{zNear * x}  {width /2} \\\
\\\
y' = - \frac{zNear * y}  {height /2} \\\
\end{aligned}
$

接下来，我们看下 z' 和 z 之间的关系，因为是线性关系，所以：
$
z' = az + b;
$

又因为齐次坐标w分量为 z，所以有
$
z' = a + b / z
$
其中 a和b 是常量，待求。

我们还知道当 z 为 zNear 时，裁剪空间 z 轴坐标为 -1，当 z 为 zFar 时，z轴坐标为 1，所以有如下两个等式：
$
a + \frac {b} { zNear} = -1
$

$
a + \frac {b}  {zFar} = 1
$


解这两个方程，可以求出 a 和 b 的值：

$
a = \frac{zFar + zNear}{zFar - zNear}
$

$
b = \frac{2 \times zFar \times zNear}{zFar - zNear}
$


依然按照正交投影的参数，width 由 left和right决定，height 由top和bottom决定，
根据上述推导过程，我们可以得出透视投影的变换矩阵 M

$
\begin{aligned}
M = \begin{pmatrix}
\frac{2 \times zNear}{right - left} & 0 & 0 & \frac{right + left}{left - right} \\\
 0 & \frac{2 \times zNear}{top - bottom} & 0 & \frac{top + bottom}{bottom - top} \\\
 0 & 0 & \frac{2(zFar + zNear)}{zNear - zFar} & \frac{2 \times zFar \times zNear}{zNear - zFar}  \\\
 0 & 0 & -1 & 0 
\end{pmatrix}
\end{aligned}
$

有了推导公式，算法的实现水到渠成：

```javascript
function makePerspective(left, right, top, bottom, zNear, zFar, target){
  target = target || new Float32Array(16);
  var a = (2 * near) / (right - left);
  var b = (2 * near) / (top - bottom);

  var c = (right + left) / (right - left);
  var d = (top + bottom) / (top - bottom);
  var e = (zFar + zNear) / (zNear - zFar);
  var f = (2 * zFar * zNear) / (zNear - zFar);

  target[0] = a;
  target[1] = 0;
  target[2] = 0;
  target[3] = 0;
  
  target[4] = 0;
  target[5] = b;
  target[6] = 0;
  target[7] = 0;
  
  target[8] = c;
  target[9] = d;
  target[10] = e;
  target[11] = -1;
  
  target[12] = 0;
  target[13] = 0;
  target[14] = f;
  target[15] = 0;

  return target;
}
```

除了传递以left 、right、top、bottom 方式传递近平面参数以外，为了方便，业界往往用视角`fovy` 和宽高比 `aspect` 的方式代替它们，推导过程和上面几乎一样，只不过我们以aspect 和 fovy角度 θ 来代替 x' 和 y'

$
\begin{aligned}
x' &= \frac {2 \times zNear} {width}\\\
&=\frac{1}{aspect \times tan(\theta/2)}
\end{aligned}
$

$
\begin{aligned}
y' &= \frac {2 \times zNear} {height}\\\
&=\frac{1}{tan(\theta/2)}
\end{aligned}
$

所以这种方式下的透视投影矩阵为：

$
\begin{aligned}
M = \begin{pmatrix}
\frac{2 \times zNear}{right - left} & 0 & 0 & \frac{right + left}{left - right} \\\
 0 & \frac{2 \times zNear}{top - bottom} & 0 & \frac{top + bottom}{bottom - top} \\\
 0 & 0 & \frac{2(zFar + zNear)}{zNear - zFar} & \frac{2 \times zFar \times zNear}{zNear - zFar}  \\\
 0 & 0 & -1 & 0 \\\
\end{pmatrix}
\end{aligned}
$


算法实现：

```javascript
function perspective(fovy, aspect, zNear, zFar, target){
  var top = zNear * Math.tan((Math.PI / 180) * 0.5 * fovy),
    height = 2 * top,
    width = aspect * height,
    left = -0.5 * width;
  return perspective2(left, left + width, top, top - height, zNear, zFar, target);
}
```

#### 实战演练
接下来，我们试试写的算法能不能正常工作。

首先，将摄像机放在 z 轴正向 20 单位处，然后采用透视投影，视角为 60 度，宽高比设置为屏幕宽高比。

```javascript
var aspect = canvas.width / canvas.height;
var projectionMatrix = matrix.perspective(60, aspect, 1, 1000);
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/28/1675ac519d6c0ef6~tplv-t2oaga2asx-image.image)

大家可以点击[这里]()查看演示。

可以看到，影响投影的因素有如下几个：

* 摄像机所在位置，距离越远，投影越小，反之，投影越大。
* 投影盒宽高比会影响显示比例。
* 视角会影响显示大小，视角越大，投影越小，反之，投影越大。


####  CSS3 中的 perspective
不知道大家有没有发现，`perspective` 这个名词在 CSS3 中出现过，perspective 代表摄像机距离近平面的距离，增加了此属性，就能实现近大远小的透视效果。

>其实它们的底层实现大体也是基于上面的算法。


## 回顾

以上就是投影矩阵的推导过程以及算法实现，建议大家拿笔在纸上推导一下，做到真正掌握，以后碰到一些坐标变换场合就能做到灵活运用。





## 22.深入研究 --- 更高级的旋转：欧拉角、四元数。

在之前的`坐标系基本变换`章节中，我们学习了 3D 基本旋转的四个方法：绕 3 个坐标轴、绕任意轴的旋转，并讲述了推导过程。本节介绍另外两个旋转的表示方法：`欧拉角`与`四元数`。


任何一个概念的提出都有它自身的意义，新概念的诞生大多是为了解决一些问题，欧拉角与四元数也不例外。

## 欧拉角


我们看下前四种旋转的特点，前四种旋转可以归结为旋转矩阵。

* 首先，旋转矩阵是一个 3 X 3 矩阵，需要 9 个数字来表示一个旋转。
* 其次，旋转矩阵通过 3 个绕基本坐标轴的矩阵相乘得到，计算过程相对繁琐。
* 最后，物体旋转用矩阵来描述的话不易理解。为什么不易理解，是因为我们习惯于用角度来描述旋转状态，比如向左旋转多少度，绕着什么什么旋转多少度，这种说法很容易在脑子里想象出来。但如果我们看到一种旋转用如下方式来表示：

$
\begin{aligned}
R = \begin{pmatrix}
0.25 & 0.1 & 0.3 \\\
0.1 & 0.02 & 0.2 \\\
0.1 & 0.02 & 0.2
\end{pmatrix}
\end{aligned}
$

我想，这种反人类的`旋转表示方法`，人类是无法理解的，当然计算机是能读懂这种旋转的。


那么，如何表示才能让人很容易地理解旋转呢？于是欧拉角的表示方法诞生了。关于欧拉角的详细介绍，大家可以从[这里](https://en.wikipedia.org/wiki/Euler_angles)了解，本节不做具体描述。

欧拉角是飞控系统中用于描述飞行器姿态的方式，使用三个角度来表示，分别是yaw`偏航角`、pitch`俯仰角`、roll`滚转角`。

* yaw：偏航角，是指飞行器偏离原来航线的角度。
* pitch：俯仰角，是指飞行器机头抬起的角度。
* roll：滚转角，是指飞行器绕着自身头尾轴线翻滚的角度。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672ab81527c0715~tplv-t2oaga2asx-image.image)


对比到笛卡尔坐标系，偏航角是绕着 Y 轴旋转的角度 α，俯仰角是绕着 X 轴旋转的角度 β，滚转角是绕着 Z 轴旋转的角度 γ。

>欧拉角旋转时绕的轴系，既可以参照世界坐标系，也可以参照自身坐标系。本节所讲的内容都是参照自身坐标系。

可以看出，欧拉角很容易就能表示出一个旋转运动，而且用角度来描述旋转，容易被人理解。

$R = (
\alpha, \beta, \gamma)$



### 欧拉角旋转顺序。
上面讲到，欧拉角是由三个角度构成，那么这三个角度的旋转顺序又是如何表示呢？

我们必须清楚，欧拉角的旋转顺序必须保证统一性。如果顺序不统一，同样的三个角度，旋转结果也会不一样。就好比我们平常走路，向左转α然后向右转β，向右转α然后向左转β，两种旋转最终表示的姿态也会不同。

我们常说的欧拉角严格意义上还可以细分为欧拉角`Euler-angles`和泰特布莱恩角`Tait-Bryan-angles`，这两种方法都利用了笛卡尔坐标系的三个坐标轴作为旋转轴，区别主要在于绕轴的旋转顺序。

#### 欧拉角

欧拉角的选取顺序有以下6种：

* XYX
* XZX
* YZY
* YXY
* ZXZ
* ZYZ


以 XYX 欧拉角为例，最开始物体的坐标系和世界坐标系保持一致，首先物体绕 X 轴旋转 α角度，此时物体的坐标系发生了变化，产生了新的坐标系E1，然后绕新坐标系E1的 Y 轴旋转 β角度，这时又产生了新的坐标系 E2， 接着绕 E2 的 X 轴旋转 γ 角度，此时即物体的最终姿态。

可以看到，这种顺序有一个共同点：第一个旋转轴和最后一个旋转轴在物体这个参照系下相同，可以理解为对称型欧拉角。



#### 泰特布莱恩角。
泰特布莱恩角的选取顺序有如下 6 种：

* XYZ
* XZY
* ZXY
* ZYX
* YXZ
* YZX

可以看出，此种旋转顺序是非对称型的，我们前面所说的 yaw-pitch-roll 旋转就是采用的泰特布莱恩角。


    


### 欧拉角的矩阵表示

欧拉角的定义有了，那么我们最终还是要将它推导成对应的旋转矩阵才能使用。

[这里](https://en.wikipedia.org/wiki/Euler_angles)有这几种顺序的最终推导公式，但接下来我还是要讲解一下这个公式是如何推导出来的。

前面说过了，顺序不同，所对应的旋转矩阵不同，旋转结果也不同。那么我们根据不同的顺序推导对应的旋转矩阵：

####  XYZ 顺序

在坐标系基本变换章节我们讲解了矩阵的基本旋转，那么，本节的欧拉旋转其实相当于矩阵绕基本坐标轴的复合旋转。
以 XYZ 顺序为例，XYZ 顺序的欧拉旋转可以表示如下：

$
R_{xyz} = R_x R_y R_z
$

看到这个表达式，我们首先要思考一个问题，上面这个表达式表示的是什么样的旋转呢？

请谨记，上面表示的旋转可以用以下两种方式理解：

* 参照自身坐标系，先绕X轴旋转，再绕 Y 轴旋转，最后绕 Z 轴旋转。
* 参照世界坐标系，先绕 Z 轴旋转，再绕 Y 轴旋转，最后绕 X 轴旋转。

这两种旋转顺序相反。下面的两个方法可以验证，点击[这里查看源码]()。

如何验证参照世界坐标系的旋转顺序？

* 首先改变 Z 轴旋转角度，直到旋转 90 度。
* 其次改变 Y 轴旋转角度，直到旋转 90 度。
* 最后改变 X 轴旋转角度，直到旋转 90 度。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672b7709ac748ba~tplv-t2oaga2asx-image.image)

我们发现，以世界坐标系为参照，旋转按照先 Z 、再 Y 、最后 X 轴的顺序依次进行。

如何验证参照自身坐标系的旋转顺序？
* 首先改变 X 轴旋转角度，直到旋转 90 度。
* 其次改变 Y 轴旋转角度，直到旋转 90 度。
* 最后改变 Z 轴旋转角度，直到旋转 90 度。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672b7b924f82e5a~tplv-t2oaga2asx-image.image)

我们发现，以自身坐标系为参照，旋转按照先 X 、再 Y 、最后 Z 轴的顺序依次进行。

所以我们得出以下结论：一个复合变换矩阵，既可以理解为世界坐标系下的依次变换，也可以理解为模型坐标系下的依次变换，变换顺序相反。





#### 根据欧拉角推导旋转矩阵

接下来，我们按照 XYZ 的顺序推导旋转矩阵，如下所示：


![MommyTalk1677065558787.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb107d2f57ad44279193c229b8c394d9~tplv-k3u1fbpfcp-watermark.image?)

有了推导公式，我们就可以很容易编写JavaScript 算法了：

```javascript
function makeRotationFromEuler(euler, target){
    target = target || new Float32Array(16);
    
    var x = euler.x, y = euler.y, z = euler.z;
    var cx = Math.cos(x), sx = Math.sin(x),
        cy = Math.cos(y), sy = Math.sin(y),
        cz = Math.cos(z), sz = Math.sin(z);
    var sxsz = sx * sz;
    var cxcz = cx * cz;
    var cxsz = cx * sz;
    var sxcz = sx * cz;
    target[0] = cy * cz;
    target[1] = sxcz * sy + cxsz;
    target[2] = sxsz - cxcz * sy;
    target[3] = 0;
    
    target[4] = -cy * sz;
    target[5] = cxcz - sxsz * sy;
    target[6] = sxcz + cxsz * sy
    target[7] = 0;
    
    target[8] = sy;
    target[9] = -sx * cy;
    target[10] = cx * cy;
    target[11] = 0;
    
    target[12] = 0;
    target[13] = 0;
    target[14] = 0;
    target[15] = 1;
    
    return target;
}
```

#### 其它顺序推导

其它顺序的推导公式和 XYZ 类似，大家只需要按照矩阵相乘顺序推导即可，比如：

* XZY 顺序的推导公式：

$
R_{xzy} = R_x R_z R_y
$

* YXZ 顺序的推导公式：

$
R_{yxz} = R_y R_x R_z
$

* YZX 顺序的推导公式：

$
R_{yzx} = R_y R_z R_x
$

* ZXY 顺序的推导公式：

$
R_{zxy} = R_z R_x R_y 
$

* ZYX 顺序的推导公式：

$
R_{zyx} = R_z R_y R_x
$


[点击这里]()可以查看不同顺序的欧拉角算法实现。

有了欧拉角生成旋转矩阵的算法之后，我们就可以按照任意顺序进行旋转了。但请注意，在一个应用中尽量要统一旋转顺序，否则物体的旋转姿态将不是我们期望的。

#### 实战演练

上面推导出的算法使用起来相当简单，只需传入一个能够表示欧拉角的对象即可：

> 一个欧拉角对象包含x、y、z 三个属性，分别表示绕 X 轴、Y 轴、Z 轴旋转的角度，以及一个表示欧拉旋转的顺序 order。


```javascript

var rotateMatrix = matrix.getMatrixFromEuler({
    x: deg2radians(uniforms.xRotation),
    y: deg2radians(uniforms.yRotation),
    z: deg2radians(uniforms.zRotation),
    order:'XYZ'
});
```



### 欧拉角的缺点

尽管欧拉角易于理解，但它还是有一些缺点的：

* 计算过程涉及到大量三角函数计算，运算量大，这点在推导公式的过程中显而易见。
* 给定方位的欧拉角不唯一，有多个，这会对旋转动画的插值造成困难。同样一个姿态可以由好多个欧拉角来表示，即多对一的关系，那么在插值过程中就可能会引起姿态突变，产生抖动效果。
* 万向节死锁，这个现象会在第二个旋转轴旋转了90 度时产生，当第二个旋转轴旋转 90 度时，会导致第三个旋转轴和第一个旋转轴重合，此时如果继续绕第三个旋转轴，相当于在第一个旋转轴上旋转。所谓死锁并不是旋转不了了，而是少了一个自由度。

#### 万向节死锁
我们看一下万向节死锁的表现：

 首先绕 X 轴旋转30度。
 
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672b95a50c92be1~tplv-t2oaga2asx-image.image)

接着绕 Y 轴旋转90 度。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672b96751efbb08~tplv-t2oaga2asx-image.image)

绕 Y 轴旋转 90 度后，此时自身坐标系的 Z 轴和最开始的 X  轴重合，触发了万向节死锁，那么它会产生什么后果呢？

我们绕 Z 轴做的旋转，等价于在最开始的 X 轴上旋转。那还要 Z 轴有什么用呢？是的，Z 轴的旋转已经没用了，此时我们无论怎么绕物体自身的 Z 轴旋转，都只能在原先 X 轴和 Y 轴上进行旋转，失去了原先 Z 轴方向上的的自由度。

上面的例子最终的旋转角度是(x: 30, y: 90, z: 50)。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672b9c1369c1766~tplv-t2oaga2asx-image.image)

接下来，我们把 Z 轴的旋转角度放到 X 轴上，不再绕 Z 轴旋转了，此时的欧拉角（x：80， y：90，z：0）。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672b9ba8ef07dd1~tplv-t2oaga2asx-image.image)


可以看出，欧拉角（x: 80, y: 90, z: 0）和(x: 30, y: 90, z: 50) 表示的旋转一模一样。也就是说，多个欧拉角会对应一个旋转。这在做旋转动画时会导致旋转动画不准确的问题。

#### 欧拉角缺陷演示

有句话说得好，当你没有碰到过使用欧拉角进行旋转所产生的缺陷时，你永远无法理解它的缺点，接下来我通过两个例子来演示一下：

##### 大圆弧与小圆弧

我们知道 (0, 0, 330)和(0, 0, -30)所表示的方位一样，如果把物体从(0, 0, 0)旋转到（0，0，330）所代表的方位，我们期望的旋转动画应该是这样的：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/20/167304a01f8b6ceb~tplv-t2oaga2asx-image.image)

但是实际上，欧拉角旋转路径却是这样的：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/20/167304eb7e5ddcf4~tplv-t2oaga2asx-image.image)

欧拉角的这个特点会导致插值动画产生抖动、跳跃的副作用。

##### 动画路径怪异
除了上述大小圆弧产生的路径不正确以外，欧拉角的旋转路径有时很怪异，比如下面这个动画过程。

准备一个球体，球体初始状态处于万向节死锁状态，如下：

```javascript
    xRotation: 0,
    yRotation: -90,
    zRotation: 0,
```

接下来我们让球体转动到如下状态：

```
    xRotation: 0,
    yRotation: -90,
    zRotation: 0,
```

我们看一下球体的旋转路径是怎样的：



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/15/167b1ccaf1e51bf3~tplv-t2oaga2asx-image.image)。

* 白色轨迹是采用欧拉角旋转时的运动路线。

* 红色轨迹是我们正常的旋转路线。

可见，欧拉角有时会让我们的旋转绕个弯，产生比较怪异的动画效果，万向节死锁还是那么讨厌。

##### 连续旋转

万向节死锁除了会产生上面的问题以外，还会导致在做连续增量旋转时姿态不准确的问题，这个问题在一些跟踪系统中导致的后果是跟丢目标。

举个例子，假设现在我们的飞行器先绕自身 X 轴（此时 X 轴和世界坐标系的 X 轴重合）旋转47 度，接着绕 Y 轴旋转 41 度，最后绕 Z 轴旋转 55 度。


```javascript
var rotateMatrix = matrix.getMatrixFromEuler({
    x: deg2radians(47),
    y: deg2radians(41),
    z: deg2radians(55),
    order:'XYZ'
});
```

接着我们再绕飞行器自身坐标系的 X 轴旋转 8 度。

```javascript
var rotateMoreMatrix = matrix.getMatrixFromEuler({
    x: deg2radians(8),
    y: deg2radians(0),
    z: deg2radians(0),
    order:'XYZ'
});
```

经过两次连续旋转之后，物体姿态如下图：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672ca68414f6aa2~tplv-t2oaga2asx-image.image)


那么，如果我们不分为两次旋转，而是采用一次旋转，那么物体的旋转姿态有什么不同呢？看一下一次旋转的效果：

```javascript
var rotateMatrix = matrix.getMatrixFromEuler({
    x: deg2radians(55),
    y: deg2radians(41),
    z: deg2radians(55),
    order:'XYZ'
});
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672ca5f659c7f1e~tplv-t2oaga2asx-image.image)

可以看出，虽然有一些差异，但是大体上是一致的。

接下来我们逐渐改变 Y 轴的旋转角度，当 Y 轴旋转角度为 90 度时，我们再用上面的方法比较一下插值和不插值旋转的区别：

插值旋转：

```javascript
var rotateMatrix = matrix.getMatrixFromEuler({
    x: deg2radians(47),
    y: deg2radians(90),
    z: deg2radians(55),
    order:'XYZ'
});

var rotateMoreMatrix = matrix.getMatrixFromEuler({
    x: deg2radians(8),
    y: deg2radians(0),
    z: deg2radians(0),
    order:'XYZ'
});
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672cada3bd27c21~tplv-t2oaga2asx-image.image)

那么我们看下一次性旋转后的方位：

```javascript
var rotateMatrix = matrix.getMatrixFromEuler({
    x: deg2radians(55),
    y: deg2radians(90),
    z: deg2radians(55),
    order:'XYZ'
});
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/19/1672cad6b817fc9b~tplv-t2oaga2asx-image.image)

这次能够很明显的感觉出插值前和插值后的区别了，结论是当第二个旋转轴越靠近 90 度，经过插值后的旋转姿态与一次旋转后的姿态产生的偏差越大。

#### 结论
实际上欧拉角足以应对大部分场景，虽然它有一些缺点。我们可以做出一些限制来避免它们，比如我们可以将第二个旋转轴的旋转角度限制在 -90 到 +90 之间。但尽管如此，我们仍然无法规避死锁的产生，所以我们急需一种能够避免死锁的旋转方法，也就是接下来要出场的四元数。

## 四元数

还记得我们在基本变换里推导出的绕任意轴进行旋转的算法吗？但是通过轴角方式的旋转插值不是很直观，四元数的引入是对轴角旋转的升级，它能够完美地避免欧拉角的缺陷，并且能够很容易地对旋转进行插值，使物体旋转更自然，更平滑。

### 四元数基础

四元数，顾名思义，是由四个数字组成，包含一个实数和三个复数，可以表示为：

$
q = (w, x, y, z)
$

或者

$
q = w + xi + yj + zk
$

并且有以下特点：

$
i^2= j^2 = k^2 = -1
$

四元数还可以理解为一个实数 w 和一个向量 $\vec u(x,y,z)$

$
q = (w, \vec u)
$

### 基本运算
####  加法/减法运算  

四元数的加减是将对应位置的元素相加或者相减，得到新的四元数。

$
\begin{aligned}
q0 + q1 &= (w_0, x_0i, y_0j, z_0k) + (w_1, x_1i, y_1j,z_1k)  \\\
&=(w_0 + w_1, (x_0 + x_1)i, (y_0 + y_1)j,(z_0+z_1)k)
\end{aligned}
$

$
\begin{aligned}
q0 - q1 &= (w_0 + x_0i+ y_0j+ z_0k) - (w_1+ x_1i+ y_1j+z_1k)  \\\
&=w_0 - w_1 + (x_0 - x_1)i+(y_0 - y_1)j+(z_0-z_1)k
\end{aligned}
$

#### 乘法运算


![MommyTalk1677066507263.jpg](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/881fc3554b12479597dfcc86ac7de810~tplv-k3u1fbpfcp-watermark.image?)

#### 四元数的模


$
\begin{aligned}
|q| = \sqrt{w^2+x^2+y^2+z^2}
\end{aligned}
$

#### 四元数的共轭
$
\begin{aligned}
q^* &= (w+xi+yj+zk)^* \\\
&=(w-xi-yj-zk)
\end{aligned}
$
#### 四元数的倒数



q^{-1} . q &= q . q^{-1} = 1



$
q^{-1} = \cfrac{q^*}{w^2+x^2+y^2+z^2} 
$

#### 四元数的性质

共轭与倒数的性质：

$
(q_0q_1)^{-1} = q_1^{-1}q_0^{-1}
$

$
(q_0q_1)^{*} = q_1^{*}q_0^{*}
$

加法乘法满足结合律和分配律

$
q_0+q_1+q_2 = q_0 + (q_1 + q_2)
$
$
q_0q_1q_2 = q_0(q_1q_2)
$

$
q_0(q_1+q_2) = q_0q_1+ q_0q_2
$

以上是四元数的运算法则和运算性质，我们对它们进行基本封装。

### 如何用四元数表示旋转？

四元数的旋转原理如下：
先将原向量表示为四元数$ q_0=(0,\vec{v})$ ，将旋转角度和旋转轴的信息用`单位四元数 q` 表示，下面是一个代表旋转的四元数：

$
q = cos\theta + \vec u sin\theta
$

>其中旋转轴 $\vec{u}$ 必须是单位向量。

该四元数表示绕轴 $\vec u$ 旋转 2 * θ 角度，注意是 θ 角的2倍哦。

旋转后得到的向量坐标利用公式 $r = q\cdot p\cdot q^*$ 或$ r = q \cdot p\cdot q^{-1}$ 计算得出。

### 多个四元数旋转
一个四元数代表一个旋转过程，那么多个四元数代表多个旋转过程。

假设有一个旋转 M 用四元数表示为 Q1，另一个旋转 N 用四元数表示为 Q2。

那么如果我们按顺序实现这两个旋转，先进行 M 旋转，再执行 N 旋转，我们有两种方式：

* 将 Q2 和 Q1 相乘，然后将乘积转化为旋转矩阵。
    * 注意顺序：Q2 * Q1。
* 将 Q2 和 Q1 分别转换成旋转矩阵，再将旋转矩阵相乘。
    * 注意顺序：N * M


注意：在计算四元数乘积或者旋转矩阵乘积时，一定要注意顺序，先进行的旋转矩阵或者旋转四元数要放在乘号右侧。


这两种方式所表达的旋转是一致的，但是显然，第一种方式计算量更小一些。






### 利用四元数实现旋转。

我们至少需要以下三个方法才能对物体进行旋转：

* 通过如下三种方式构造出四元数。
    * setFromEuler，将一组欧拉角转化成四元数。
    * setFromAxis，将轴角转化成四元数。
    * setFromRotationMatrix，将旋转矩阵转化成四元数。
* 已知初始状态四元数和结束状态四元数，构造某一阶段的四元数。
    * `slerp`。
* 根据四元数计算出该四元数所代表的旋转矩阵。
    * `makeRotationFromQuaternion`

公式的推导比较复杂，这里就不讲述推导过程了，感兴趣的同学可以点击[这里]()，自己动动手试着推导一下。同时，`THREEJS` 已经为我们封装了关于四元数的函数，在这里我们掌握它提供的一些方法就能覆盖大部分应用场景。

除了上面的一些方法，THREEJS 还做了一些转换方法：

* 将四元数转换成对应欧拉角。
* 将四元数转换成对应轴向量。
* 将四元数转换成绕轴向量旋转的角度。
* 从当前四元数旋转到另一个四元数所经过的角度。

利用这些方法，很容易地将易于理解的欧拉旋转或者轴角旋转，转换成易于线性插值的四元数。

### 四元数的用法

看一下如何使用四元数进行插值，我们将物体从欧拉角（30，40，50）代表的方向旋转到（70，90，120）。

首先，我们将起始时刻和结束时刻的欧拉角转化为对应的四元数：

```javascript
var startQuaternion = matrix.setFromEuler({
    _x: deg2radians(30),
    _y: deg2radians(40),
    _z: deg2radians(50)
});

var endQuaternion = matrix.setFromEuler({
    _x: deg2radians(70),
    _y: deg2radians(90),
    _z: deg2radians(120)
});

```

有了起始四元数和结束四元数，我们就可以利用`球面插值算法slerp`来求旋转矩阵了。假设我们本次旋转过程设置为 30 帧，那么由初始角度到当前帧所代表角度的旋转用四元数表示如下：

```javascript
var currentQuaternion = matrix.slerp(startQuaternion, endQuaternion, progress / 30);
```

那么当前方位的旋转矩阵通过以下方法求得：

```javascript
var currentMatrix = matrix.makeRotationFromQuaternion(unitQuaternion);
```

有了初始角度到每一帧角度的旋转矩阵 U ，那么左乘该旋转矩阵 U 可以实现平滑均匀的旋转动画了，如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/21/16735a0e43948b8b~tplv-t2oaga2asx-image.image)


> 如果让欧拉角来做 30 次连续插值旋转，最终的动画路径和旋转方向可能会不准确。


四元数在平滑插值上表现出了极大的优势，如果我们想做插值动画，那么四元数无疑是最佳选择。


### 总结

四元数相比欧拉角的优势还是很大的：

* 计算量相对小一些。
* 能够更平滑地插值。

但是四元数也有一定缺点：

* 概念复杂，不易理解。

## 回顾

本节介绍了表示旋转的两种很重要的方法：欧拉角与四元数，并分析了它们的优缺点。在实际编程中，四元数的使用场景比较多，动画中的旋转往往需要平滑线性，这种情况我们采用四元数是最佳选择。

下一节，我们结合学过的算法，学习利用鼠标控制模型旋转的原理。





## 23.深入研究 --- 四元数的应用：使用鼠标控制模型的旋转

前面章节我们学习了控制模型旋转的各种算法，所展示的效果都是通过程序设定的，实际上，我们往往需要人为的通过鼠标、触摸等方式实现对模型的旋转、位移等变换的控制。本节我们利用前面的知识实现用鼠标或者触摸的方式对模型进行控制。


## 原理分析
利用鼠标控制模型旋转的本质是求出鼠标在按下后并进行移动的轨迹，如何对应到 3D 空间中的旋转矩阵。

### 鼠标滑动
通常情况下，我们会在鼠标按下后，捕捉起始位置P0，由于屏幕是 2D 的，所以我们只能捕捉到屏幕的 X、Y 轴的坐标信息，所以我们的 `P0` 是一般是这样的：

```javascript
var start = {x: 30, y: 50};
```

当鼠标滑动或者触摸 move 时，我们能够监听到鼠标或者触摸点在屏幕的当前坐标：

```javascript
var current = {x: 300, y: 200};
```

我们拿到了鼠标滑动的轨迹坐标，那么这两个坐标值能不能和模型的旋转进行对应呢？如果可以对应，这中间的对应模型该如何建立呢？

我们从实际场景分析一下：

* 当鼠标向右或者向左做水平滑动时，我们期望的是能够让模型向右或者向左旋转，也就是绕 Y 轴旋转。
* 当鼠标向上或者向下做垂直滑动时，我们期望的是能够让模型向上或者向下旋转，也就是绕 X 轴旋转。
* 当鼠标做上述两种滑动时，滑动的距离与旋转的角度成正比，即距离越大，角度越大。

上面是三个很重要的建模依据。

### 滑动距离与旋转的映射关系

通过之前章节的学习，我们知道旋转的表示有如下三种：

* 欧拉角。
* 四元数。
* 轴角。

那么，按照上面的建模思路，能够直观的表示角度的只有欧拉角和轴角。

### 欧拉角旋转

我们先使用最直观的欧拉角来看下如何将鼠标的移动关联到模型的旋转。

很容易想到的策略是：

* 鼠标沿着 X 轴移动一像素时，绕 Y 轴旋转 1 度。
* 鼠标沿着 Y 轴移动一像素时，绕 X 轴旋转 1 度。

按照这个策略实现一下，看看是否符合我们的期望。

首先定义一个旋转矩阵`currentMatrix`，用于保存模型渲染时采用的变换矩阵。
接着定义一个临时矩阵`tempMatrix`，用于保存鼠标滑动时的临时矩阵。
最后定义一个最近一次的变换矩阵`lastMatrix`，用于保存上一次的变换。

```javascript
var currentMatrix = matrix.identity();
var tempMatrix = matrix.identity();
var lastMatrix = matrix.identity();
```

其次，我们需要监听鼠标或者触摸屏的坐标。

```javascript
// 判断是否支持触摸事件。
var supportTouchEvent = 'ontouchstart' in window;
var dragStartEvent =  supportTouchEvent? 'touchstart': 'mousedown';
var dragMoveEvent =  supportTouchEvent? 'touchmove': 'mousemove';
var dragEndEvent =  supportTouchEvent? 'touchend': 'mouseup';

var startX = 0, startY = 0, currentX = 0, currentY = 0;

//绑定拖拽开始事件
document.body.addEventListener(dragStartEvent, function dragStart(e){
    e = supportTouchEvent ? e.changedTouches[0] : e;
    startX = e.clientX;
    startY = e.clientY;
});
// 绑定拖拽事件
document.body.addEventListener(dragMoveEvent, function dragMove(e){
    e = supportTouchEvent ? e.changedTouches[0] : e;
    currentX = e.clientX;
    currentY = e.clientY;
    rotate();
});

// 绑定拖拽结束事件
document.body.addEventListener(dragEndEvent, function dragEnd(e){
    matrix.clone(currentMatrix, lastMatrix);
});

```
在拖拽结束事件中，我们将currentMatrix 矩阵拷贝给 lastMatrix。

你还会发现在拖拽事件中，我们执行了一个函数 `rotate`，这个函数的作用是根据起始坐标与当前坐标，算出旋转矩阵，我们看下如何实现这个函数。

```javascript
var euler = {x:0, y:0, z:0};
var radian = Math.PI / 180;
function rotate(){
    var dx = currentX - startX;
    var dy = currentY - startY;
    
    euler.x = dy * radian;
    euler.y = dx * radian;
    
    // 本次拖拽的临时矩阵
    tempMatrix = matrix.getMatrixFromEuler(euler, tempMatrix);
    // 最近一次变换矩阵与临时矩阵的乘积，得出最终渲染矩阵。
    currentMatrix = matrix.multiply(tempMatrix, lastMatrix);
    
    render();
}
```

看下效果吧：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/27/167ef2ec7f80347d~tplv-t2oaga2asx-image.image)

可能你会觉得旋转的灵敏度太大了，那我们可以定义一个系数，用来设置鼠标移动距离与旋转角度的比例。

```javascript
var rate = 0.6;
euler.x = rate * dy * radian;
euler.y = rate * dx * radian;
```

大家可以根据自己的需要调整这个系数，直到符合自己的直觉为止。

看到这里，你会不会觉得太简单了。是的，当你掌握了之前章节的内容之后，写这个交互确实是很简单，无非就是和矩阵打交道。

接下来，我们看一下如何利用轴角的方式实现鼠标移动距离和旋转角度之间的映射关系。

### 轴角

轴角轴角，肯定要有一个旋转轴，外加旋转角度。我们就是要根据在 X 轴和 Y 轴的移动距离，找出对应的旋转轴和旋转角度。

我们看分别看下鼠标运动时的旋转轴。

* 沿着 X 轴移动时。

下图中 $\vec{P_0P_1}$ 为鼠标移动轨迹，$\vec{P_0R_1}$ 是对应的旋转轴，很容易看出旋转轴和移动轨迹垂直，为 Y 轴上的单位向量。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/27/167ef475f642b7ba~tplv-t2oaga2asx-image.image)

* 沿着 Y 轴移动时，旋转轴为 X 轴方向的单位向量。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/27/167ef4a5f5bc7164~tplv-t2oaga2asx-image.image)

* 沿着 X 轴和 Y 轴移动时。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/27/167ef4afdb5415a9~tplv-t2oaga2asx-image.image)

当同时沿着 X 轴和 Y 轴移动时，轴向量和运动轨迹垂直，如上图 $\vec{P_0R_1}$，通过分解，我们可以求出旋转轴向量。

* X 轴分量为：

$
\vec{rx} = \frac{dy} {|\vec{P_0R_1}|}
$

* Y 轴分量为：

$
\vec{ry} = \frac{dx}{ |\vec{P_0R_1}|}
$

* Z 轴分量为0：

$
\vec{rz} = 0
$

其中$\vec{P_0R_1}$为鼠标移动的距离。

既然有了轴向量，我们还需要绕轴向量旋转的角度θ。旋转角度的选取也是一个经验值，在此我们以$\vec{P_0R_1}$的长度作为旋转的角度，大家可以根据自己的感觉适当调整。

有了轴向量和旋转角度，记下来就可以计算旋转矩阵了：

```javascript
var l = Math.sqrt(dx * dx + dy * dy);
if(l <= 0)return;
var x = dx / l, y = dy / l;
var axis = {x:x, y:y, z:0};
tempMatrix = matrix.axisRotation(axis, l);
currentMatrix = matrix.multiply(tempMatrix, lastMatrix, currentMatrix);
render();
```

我们看下效果：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/28/167f2948ceeff763~tplv-t2oaga2asx-image.image" width = "60%"/>

可见，利用轴角和欧拉角都能够实现利用鼠标控制模型的旋转。

那么，观察上面这个轴角计算方式，你会发现，我们在计算 tempMatrix 和 currentMatrix 的时候，计算量比较多，能不能优化一下呢？

嗯，我们可以采用四元数，利用四元数相乘来取代矩阵相乘，毕竟四元数的乘法运算量比矩阵乘法运算 量要小。

### 四元数

通过前面章节的学习，我们知道四元数可以由轴角转化而成，利用下面的公式：

$
\begin{aligned}
q &= |q|[cos\theta, \vec{n}\cdot sin\theta] 
\end{aligned}   
$

其中 $\vec{n}$ 为轴向量，$\theta$为旋转角度的一半。

根据这个公式，我们可以很方便的将轴角转化为四元数。

```javascript
function fromAxisAndAngle(axis, angle, target){
    let halfAngle = angle / 2,
        s = Math.sin(halfAngle);
    target = target || {};
    target.x = axis.x * s;
    target.y = axis.y * s;
    target.z = axis.z * s;
    target.w = Math.cos(halfAngle);

    return target;
}
```

有了轴角转化为四元数的方法，改造一下 rotate 方法。

```javascript
var currentQ = {x:0, y:0, z:0, w:1};
var lastQ = {x:0, y:0, z:0, w:1};
var l = Math.sqrt(dx * dx + dy * dy);
if(l <= 0)return;
var x = dx / l, y = dy / l;
var axis = {x:x, y:y, z:0};
var q = matrix.fromAxisAndAngle(axis, l);
currentQ = matrix.multiplyQuaternions(q, lastQ);
currentMatrix = matrix.makeRotationFromQuaternion(currentQ);
render();
```

当然拖拽结束事件我们也要修改一下，我们将不再保存上一次的旋转矩阵 lastMatrix，而是保存上一次的旋转四元数 lastQ。

```javascript
// 绑定拖拽结束事件
document.body.addEventListener(dragEndEvent, function dragEnd(e){
    Object.assign(lastQ, currentQ);
});
```

改造完毕，旋转控制效果和欧拉角与轴角一致，但是计算量和存储量少了很多。

## 回顾

本节我们学习了利用欧拉角、四元数、轴角对模型进行控制的原理，学完之后，你会发现只要考虑好映射模型，其余的就很简单了，无非就是对四元数或者矩阵的操作。

接下来，我们先搁置 WebGL 的学习，探讨 CSS 中的 3D 属性以及如何将数学算法应用到 CSS 的 3D 属性中。




## 24.深入研究 --- CSS 与 3D 之 transform

前面介绍了 3D 变换的原理和算法实现，并通过一些简单的 demo 演示了变换效果，但这些 demo 都是使用 WebGL 技术渲染。本节我们暂时不使用 WebGL，而是改用前端同学最熟悉的 CSS 技术来实现 3D 效果，并进一步了解 CSS 中的 3D 属性和 WebGL 中 3D 概念的异同之处。
 
 ## CSS 中的 3D 属性
 

下面是 CSS3 中的几个很重要的 3D 属性：
 
 * transform：对 DOM 进行变换，相当于 WebGL 中对模型进行的变换。
 * transform-origin：设置变换的中心点。
 * perspective-origin：视点，相当于 WebGL 中摄像机的 X、Y 轴坐标。
 * perspective：视距，启用该属性相当于在 WebGL 中设置摄像机和 DOM 元素之间在 Z 轴方向上的距离，设置该属性不等于 0 时会自动启用透视投影效果。
 * transform-style：是否启用 3D 变换。
 * backface-visibility：背面是否可见。
 
本节我们主要讲述 CSS 中的变换属性`transform`，变换分为`基本变换`和`矩阵变换`，基本变换大家都比较熟悉了，本节不做过多介绍，我们主要介绍`矩阵变换`和`组合变换`。



### 变换：transform

`transform` 是大家最常用的一个属性，我们经常会使用它实现一像素的边框和以及容器或者内容的水平、垂直居中，又或者利用它实现强制 GPU 渲染，提升动画性能。

transform 分为 2D 和 3D 变换，3D 变换只是在 2D 的基础上增加了 Z 轴方向的变换。

一般情况下，如果对一个 DOM 施加变换，那么变换的中心往往是 DOM 的中心位置，类比到 WebGL 中，也就是模型的中心，我们可以把 CSS 中的 DOM 看做 WebGL 中的模型。

transform 包含四个基本变换属性值：`translate`、`rotate`、`skew`、`scale`，对应的 3D 变换属性值为 `translate3d`、`rotate3d`、`scale3d`。

> 注意，skew 没有对应的 3D 变换设置。

基本变换大家应该都很熟悉了，后面重点要讲解的是 `matrix` 、`matrix3d`的计算与使用，以及`组合变换`的使用技巧。


当然，下面我们还是先回顾一下 `transform` 的基本用法。

####  平移

平移的使用方法：

* translate(tx, ty)
* translate3d(tx, ty, tz)
* translateX(tx)
* translateY(ty)
* translateZ(tz)

将 dom 元素分别沿着 X、Y、Z 轴向平移 30 px。

```css
/* 分别沿 X 轴和 Y 轴平移 30 px。*/
transform: translate(30px, 30px);
/* 分别沿 X 轴、 Y 轴、Z 轴平移 30 px。*/
transform: translate3d(30px, 30px, 30px);
/* 沿 X 轴平移 30 px。*/
transform: translateX(30px);
/* 沿 Y 轴平移 30 px。*/
transform: translateY(30px);
/* 沿 Z 轴平移 30 px。*/
transform: translateZ(30px);
```



#### 旋转

旋转用法也比较简单，在此不做过多描述。

* rotate(angle)，绕 Z 轴旋转。
* rotate3d(x, y, z, angle)。绕轴`axis = {x:x, y:y, z:z}`旋转指定角度`angle`。
* rotateX(angle)，绕 X 轴旋转。
* rotateY(angle)，绕 Y 轴旋转。
* rotateZ(angle)，绕 Z 轴旋转。


```css
/*绕 X 轴旋转 45 deg。*/
transform: rotate(45deg);
/* 将第一个参数设置为 1， 代表绕 X 轴旋转 45 deg。*/
transform: rotate3d(1, 0, 0, 45deg);
/* 将第二个参数设置为 1， 代表绕 Y 轴旋转 45 deg。*/
transform: rotate3d(0, 1, 0, 45deg);
/* 将第三个参数设置为 1， 代表绕 Y 轴旋转 45 deg。*/
transform: rotate3d(0, 0, 1, 45deg);
/* 将三个参数都设置为 1， 代表绕 Y 轴旋转 45 deg。*/
transform: rotateZ(45deg);
```


##### 绕任意轴的旋转。
关于旋转，我想说明一下`rotate3d` 的使用方式，它接收一个`轴向量`和一个`角度`，代表绕`轴向量`旋转某个`角度`。

举个例子来说，我们想让模型绕轴 axis= {x: 1,y: 1,z: 1}进行旋转，那么用rotate3d表示如下：

```
.box{
    animation: rotate 3s infinite linear;
}
@keyframes rotate{
    0% {
        transform:rotate3d(1, 1, 1, 0deg);
    }
    100% {
        transform:rotate3d(1, 1, 1, 360deg);
    }
}
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/10/167974020596bd07~tplv-t2oaga2asx-image.image)

##### 变换参照点 transform-origin

根据上图的例子，你会发现，默认的旋转是绕着模型的中心位置进行的，这个位置是浏览器默认的。但事实上，CSS 仍然提供了对变换中心的设置功能，通过设置 `transform-origin` 来实现。

* transform-origin 包含 X、Y、Z 轴坐标的设置。
* transform-origin 接收百分比数值时，是以自身尺寸为基准的。

比如，我们让一个 DOM 元素沿着上边沿进行进行旋转，只需要将 transform-origin 的 Y 轴分量设置为 0% 或者 0 即可。

```css
transform-origin: 50% 0%;
transform: rotateX(90deg);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/10/16797ac6ac7cad17~tplv-t2oaga2asx-image.image)


这个概念比较简单，但是很灵活。利用它我们能实现很多有意思的 3D 效果，比如 CSS 版的`魔方`。

### 缩放

缩放的使用方法也很简单。

* scale(sx, sy)，沿 X 轴方向缩放 sx 倍，沿 Y 轴方向缩放 sy 倍。
* scale(sx)，沿 X 轴方向和 Y 轴方向缩放 sx 倍。
* scale3d(sx, sy, sz)，分别沿 X、Y、Z 轴方向缩放 sx、sy、sz 倍。
* scaleX(sx)，沿 X 轴方向缩放 sx 倍。
* scaleY(sy)，沿 Y 轴方向缩放 sy 倍。

代码示例：

```css
/* 沿 X 轴和 Y 轴 放大两倍。*/
transform: scale(2);
/* 沿 X 轴方向当大 3 倍，沿 Y 轴方向放大 2 倍。*/
transform: scale(3, 2);
/* 分别在 X 、Y、 Z 轴方向放大 2倍、3倍、4倍。*/
transform: scale3d(2, 3, 4);
/* 在 X 轴方向放大两倍。*/
transform: scaleX(2);
/* 在 Y 轴方向放大两倍。*/
transform: scaleY(2);
```

### 斜切

斜切的使用方法：

* skew(xAngle, yAngle)，DOM 元素沿着 X 方向切变 xAngle 度，沿 Y 轴方向切变 yAngle 度。
* skewX(xAngle)，沿 X 轴方向切变 xAngle 度。
* skewY(yAngle)，沿 Y 轴方向切变 yAngle 度。

斜切可以理解为将 DOM 元素沿 X 轴或者 Y 轴拉伸，切变会改变物体的形状。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/167817da6a38183a~tplv-t2oaga2asx-image.image)


代码示例：

```css
/* 沿 X 轴切变 30 度。*/
transform: skew(30deg);
/* 沿 X 轴切变 30 度，沿 Y 轴切变 40 度。*/
transform: skew(30deg, 40deg);
/* 沿 X 轴方向切变 30 度。*/
transform: skewX(30deg);
/* 沿 Y 轴方向切变 40 度。*/
transform: skewY(40deg);
```

以上就是 `transform` 的常见用法，接下来我们开始讲重点了：`组合变换`和 `matrix`

### 组合变换

`组合变换`就是在 transform 的属性值中附加多个变换效果，而不只是单一的变换。

比如下面这个变换样式：

```css
transform: rotateX(60deg) rotateY(60deg);
```

这个样式的作用是先让 DOM 元素绕着 X 轴旋转 60 度，注意此时 DOM 元素的坐标系改变了，再绕变换后的坐标系的 Y 轴旋转 60 度。

需要谨记的是：

* transform 后的多个变换要用空格分开。
* 从前往后理解这些变换，后一个变换都是基于前一个变换后的新坐标系进行，也称`动态坐标系变换`。
* 从后往前理解，每一个变换都是按照 DOM 元素最开始的坐标轴（可以理解为世界坐标系）进行，也称为`静态坐标系变换`。

至于多个变换是基于动态坐标系进行构思，还是基于静态的世界坐标系进行构思，取决于每个人的理解习惯，但最终的变换效果都是一样的。

>在欧拉角章节我们也讲过了多个矩阵相乘时，从前往后和从后往前理解变换所基于的坐标系是不同的。transform 多个变换理解顺序和前面所讲的保持一致。

再举个比较明显的例子，我们先让 DOM 旋转 60 度，然后将其沿 X 轴平移 200 像素，大家觉得 DOM 会按照怎样的轨迹变换？

我们看一下：

```css
transform: rotateX(60) translateX(200px);
```

为了更方便观察 3D 组合变换的效果，我将图片外层容器的`视点`设置在了右上方：

```css
.imgWrapper{
    perspective: 300px;
    margin-top:300px;
    position: relative;
    perspective-origin: 100% -100px;
}
```

关于视点 `perspective-origin` 和 视距 `perspective` 我们放在下一节讲述。

#### 从前往后理解变换，需要按照`模型坐标系`理解：

下图，白色坐标轴是图片默认的坐标系，当图片绕 X 轴旋转 60 度后，坐标系变成红色坐标轴的指向。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/1678241bcd2eb3a7~tplv-t2oaga2asx-image.image" width="80%" />

接着沿当前图片坐标系的红色 X' 轴平移 200 像素，此时，应该朝向屏幕里侧和右侧移动。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/16782469359b66e3~tplv-t2oaga2asx-image.image)

#### 从后往前理解多个变换，需按照世界坐标系理解

请注意，`CSS` 中的`世界坐标系`就是 施加变换的 DOM 节点（本例为图片）最开始的坐标系，即图中的白色坐标轴。

* 首先沿着 X 轴平移 200 像素。
* 接着绕世界坐标系的 Y 轴旋转 60 度。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/16782664ef6d8d2e~tplv-t2oaga2asx-image.image)

可以看出，无论我们按照哪种坐标系理解，最终变换效果都是一样的，看下图：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/16782681da82aeb6~tplv-t2oaga2asx-image.image)


这就是`组合变换`要注意的地方，了解了组合变换的规律，我们才能做出很有意思的特效，比如照片墙：

照片墙的核心原理就是先将图片沿着 Z 轴方向移动一定距离，之后绕世界坐标系的Y 轴旋转指定角度。

```css
transform: rotateY(30deg) translateX(200px);
```

当然，这只是核心原理，事实上我们还需要做如下几步：
* 让图片能够显示出 3D 效果，这一步需要让图片父容器的 `transform-style` 属性设置为 `preserve-3d`。
* 为父容器加上透视属性`perspective`，设置为透视投影，并调整合适的视距 ，这样才能实现近大远小的效果。

这几个属性我们下节细讲，先贴下照片墙的效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/4/16778c9cd6a5b210~tplv-t2oaga2asx-image.image)

具体的实现我们在讲视点和视距属性时再分析。

又比如 3D 盒效果：
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/16783e9b138a5848~tplv-t2oaga2asx-image.image)


这是一个立方体盒子，每个面上都对应一张图片，当然，你也可以根据自己的需要往各个面上放置自己的内容。

立方体盒子的原理也是利用组合变换实现的：

* 前面：沿着 Z 轴往前（朝向屏幕外）平移指定像素。
* 后面，沿着 Z 轴往后（朝向屏幕里）平移指定像素。
* 上面，沿着 Y 轴往上平移，接着绕 X 轴旋转 90 度。
* 下面，沿着 Y 轴往下平移，接着绕 X 轴旋转 90 度。
* 左面，沿着 X 轴往左平移，接着绕 Y 轴旋转 90 度。
* 右面，沿着 X 轴往右平移，接着绕 Y 轴旋转 90 度。

当然，为了实现 3D 效果，也要在图片的父容器上设置 `transform-style` 为 `preserve-3d` 才可以。

这里主要展示组合变换顺序的理解与强大，不对实现做分析，`实现过程`留在下一节和`视点`以及`视距`一起介绍。


我们还是先把变换讲完，接下来介绍 `transform` 的另一个重要用法，`matrix` 和 `matrix3d`。

### matrix

transform 除了提供一些基本变换，还提供了 `matrix` 和 `matrix3d` 属性值，这两个属性值是做什么的呢？

`matrix` 是矩阵的意思，transform 是变换属性，所以 matrix 就是对 DOM 执行变换的矩阵，这和我们前面讲的 WebGL 的变换矩阵概念相同。

根据前面的学习，我们知道 2 维平面的变换矩阵，是一个 3 阶矩阵，包含 9 个数字：

$
\begin{aligned}
\begin{pmatrix}
x0 & y0 & tx \\\
x1 & y1 & ty \\\
0 & 0 & 1
\end{pmatrix}
\end{aligned}
$

按照我们之前章节坐标系变换的原理分析：

* x0、x1 代表变换之后的 X 轴基向量在原坐标系中的表示。
* y0、y1 代表变换之后的 Y 轴基向量在原坐标系中的表示。
* tx、ty 代表坐标原点的偏移量。

如果没有看之前章节的话，可能不太理解基向量的含义以及坐标系的概念，大家可以去看一下，理解一下坐标系变换的原理。

你会看到第三行的数值是固定的` 0 0 1 `，所以，浏览器为了简化赋值，规定 transform 中的 matrix 只接受 3 阶矩阵的前两行参数，共 6 个数字。

请记住，matrix 的参数顺序对应上面的矩阵元素如下：

```css
transform: matrix(x0, x1, y0, y1, tx, ty);
```

前面章节我们推导过基本变换的矩阵表示：

* 平移

沿 X 轴平移 tx 像素，沿 Y 轴平移 ty 像素：
$
\begin{aligned}
\begin{pmatrix}
1 & 0 & tx \\\
0 & 1 & ty \\\
0 & 0 & 1
\end{pmatrix}
\end{aligned}
$



* 缩放

沿 X 轴方向缩放 sx 倍， 沿 Y 轴缩放 sy 倍：
$
\begin{aligned}
\begin{pmatrix}
sx & 0 & 0 \\\
0 & sy & 0 \\\
0 & 0 & 1
\end{pmatrix}
\end{aligned}
$

也就是说基本变换我们都可以用 `matrix` 来表示。

* 斜切
沿着 X 轴倾斜 α 度，沿着 Y 轴倾斜 θ 度：

$
\begin{aligned}
\begin{pmatrix}
1 & tan\alpha & 0 \\\
tan\theta & 1 & 0 \\\
0 & 0 & 1
\end{pmatrix}
\end{aligned}
$


* 旋转

绕 Z 轴旋转 θ 角度：

$
\begin{aligned}
\begin{pmatrix}
cos\theta & -sin\theta & 0 \\\
sin\theta & cos\theta & 0 \\\
0 & 0 & 1
\end{pmatrix}
\end{aligned}
$

* 绕 Z 轴旋转 60 度。

用 rotateZ 表示上面的旋转很简单，我们看下用 matrix 如何表示：

 $ cos(60) = 0.5$
 
 $sin60 = \frac{\sqrt3}{2} = 0.866（约等）$

将这两个数字代入 matrix 公式，得出变换样式为：

```css
transform: matrix(0.5, 0.866, -0.866, 0.5, 0, 0);
```

你会发现无论我们是用 rotateZ 表示，还是用 matrix 表示，变换效果都是一样的。

### matrix3d
matrix3d，顾名思义，代表 3 维变换，它是一个 4 阶矩阵，需要 16 个数字来表示。

$
\begin{aligned}
\begin{pmatrix}
x0 & y0 & z0 & tx \\\
x1 & y1 & z1 & ty \\\
x2 & y2 & z2 & tz \\\
0 & 0 & 0 & 1
\end{pmatrix}
\end{aligned}
$

可以看到，每一个基向量都增加了一个 Z 轴方向分量 x2、y2、z2、tz。


事实上，3D 的基本变换都可以用 matrix 或者 matrix3d 来表示，但是一些复杂变换只能使用 matrix 或者 matrix3d 来实现。




### matrix 对我们来说有什么用呢？

这是一个很关键的问题，大家会觉得，基本变换的用法更容易理解，更方便书写，matrix 需要的参数太多，而且参数值需要计算，更糟糕的是，我们往往不知道怎么计算，那 matrix 有什么用呢？

这是个好问题，但我想说的是 matrix 能完成基本变换不能完成的变换，能做出基本变换完成不了的效果。

这时你就该考虑使用 matrix 了。

紧跟而来的问题是，matrix 如何求得呢？

我们前面章节讲述了 matrix 矩阵的求法，一旦你确定了需要的变换，你就可以计算变换后的基向量，然后将基向量的各个分量代入矩阵的各个位置即可求出变换矩阵，有了变换矩阵，也就有了 matrix 所需要的各个元素，将矩阵转化成 matrix 或者 matrix3d 所需要的字符串就轻而易举了。



* 镜像效果

镜像效果，采用基本变换是实现不了的，只能借助于矩阵。
比如左右镜像，左右镜像无非就是 Y 轴基向量不变，X 轴坐标对调，原坐标与新坐标关系如下：

$
\begin{aligned}
x^{'} &= -x \\\
y^{'} &= y
\end{aligned}
$

所以有：

$
\begin{aligned}
x0 &= -1 \\\
x1 &= 0 \\\
y0 &= 0 \\\
y1 &= 1
\end{aligned}
$

将这些值，代入 matrix公式中，可以得出变换：

```css
transform: matrix(-1,0,0,1,0,0);
```

我们看下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/16783fcc8bcfd906~tplv-t2oaga2asx-image.image)

当然大家也可以举一反三，比如上下镜像：

```css
transfom: matrix(1,0,0,-1,0,0)
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/16783fea86654f76~tplv-t2oaga2asx-image.image)


* 绕任意轴旋转。

绕任意轴的旋转，除了可以使用 rotate3d 来实现，还可以使用 matrix3d。这个旋转矩阵该如何计算呢？

还记得基本变换章节我们推导出的绕固定轴旋转的矩阵方法`axisRotation`吗？

`axisRotation(axis, angle)`，其中 axis 是一个三维向量，angle 是一个弧度值。

这里我不准备举绕基本轴旋转的例子，因为它们不需要matrix3d 出手，我们想绕`{x:1, y: 1, z: 1}`的倾斜轴旋转，上面的 axisRotation 方法该出场了，它会为我们提供变换矩阵，但是我们还需要将变换矩阵转化为 css 样式，我们先封装一个矩阵转 css 的方法：

```javascript
function matrix2css(mt){
    var transformStyle = 'matrix(';
    if(mt.length == 16){
        css = 'matrix3d('
    }
    for(let i =0; i< mt.length; i++){
        transformStyle += mt[i];
        if(i !== mt.length - 1){
            transformStyle += ','
        }else{
            transformStyle +=')'
        }
    }
    return transformStyle;
}
```

接着可以通过 axisRotation 方法计算出变换矩阵了，比如旋转 90 度。

```javascript
let mt = matrix.axisRotation({x:1, y:1, z:1}, Math.PI / 180 * 90)
```

在这里我用绕轴向量 axis = {x:1, y:1, z:1} 不停旋转的动画演示：

```javascript
function render(){
    if(!playing){
        return;
    }
    angle ++;
    mt = matrix.axisRotation({x: 1,y: 1,z: 1}, Math.PI / 180 * angle);
    let css = matrix2css(mt);
    ?('.box')[0].style.transform = css;
    requestAnimationFrame(render);
}
document.body.addEventListener('click',function(){
  playing = !playing;
  render();
})
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/6/16784262a1dc9805~tplv-t2oaga2asx-image.image)


是不是很简单呢？

### 总结

transform 中的基本变换都可以使用 matrix 和 matrix3d 来表示，只有当基本变换表示不了我们的变换时，我们才考虑使用 matrix 或者 matrix3d 。

可见，即使不做 WebGL 开发，我们之前学到的内容也会对普通开发者大有帮助，掌握变换原理，配合 CSS3 中的 3D 属性，照样可以做出很酷炫的 3D 动画效果。



## 回顾

本节讲述了 CSS 中的 3D 变换，以及它们与 WebGL 变换的相同之处。总的来说，基本原理都是一样的，之前封装的数学矩阵库，不仅可以用在 WebGL 领域，也可以用在 css 领域。

下一节，我们讲述 CSS 中 3D 变换 的其它几个重要属性，`变换类型(transform-style)`、`视点(perspective-origin)`、`视距(perspective)`。





## 25.深入研究 --- CSS 与 3D 之 perspective

上节我们讲述了 CSS 中的变换方式以及对它们原理的深入理解。本节我们介绍一下 3D 变换的投影方式`perspective`相关属性，并通过`照片墙`和`图片盒`的实现学习它们的深入使用方法。

本节要介绍的主要属性有如下几个：

* transform-style：子元素变换的表现形式。
* perspective：视距。
* perspective-origin： 视点位置。
* backface-visibility：背面是否可见。

本节教大家掌握这几个属性，之后用 CSS 就能够很轻松地做出有创意的 3D 效果了。

## transform-style

该属性是用来设置子元素变换的展示形式，默认是 2D 平面展示，当我们需要让子元素的渲染有 3D 效果时，那么我们要将当前元素的 transform-style 属性设置为 preserve-3d。

我们用一张图片做示例：

```html
<div class="image-wrapper">
    <img src="xxx" />
</div>
```

```css
.image-wrapper{
    text-align: center;
    font-size: 0;
    margin-top: 200px;
}

.image-wrapper img{
    width: 150px;
    height: 110px;
}
```

我们不对图片施加变换，图片是正常状态：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/7/167884e85db72163~tplv-t2oaga2asx-image.image)

记住图片默认时的样子。

此时，我们对图片施加变换，让图片绕 X 轴旋转 60 度。

```css
.image-wrapper img{
    transform: rotateX(60deg);
}
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/7/167885037d697934~tplv-t2oaga2asx-image.image)

可以看出，图片因为旋转，展示到屏幕上已经变形了，正常情况下，绕 X 轴旋转，图片的上半部分应该转到屏幕内侧，下半部分转到屏幕外侧。

我们看一下，是不是这样子的。

我们让图片的父容器也绕 X 轴旋转，这样就能看出图片到底是不是真的有了 3D 效果。

```css
.img-wrapper{
    transform: rotateX(0deg);
    animation: rotate 3s linear;
}
@keyframes rotate{
    0%{
        rotateX(0deg);
    }
    50%{
        transform: rotateX(120deg);
    }
    100%{
        transform: rotateX(0deg);
    }
}
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/8/1678d28a3c32c952~tplv-t2oaga2asx-image.image)

可以看到，图片并没有呈现出立体效果。

那如何让图片呈现立体效果呢？

transform-style 要闪亮登场了。



我们将 transform-style 设置为 preserve-3d 即可。

另一个问题是，为哪个元素设置 transform-style 属性呢？

### 舞台

WebGL 中有舞台和场景的概念， CSS 中也有类似概念。

我们需要一个舞台，然后为舞台设置展示方式。

上面的示例，大家觉得哪个元素是舞台呢？

很简单，图片的祖先容器都可以当做图片的舞台，我们将一个祖先容器设定为舞台，祖先容器的子元素就是舞台上的元素。

因此，既然我们想让元素呈现立体效果，我们就要在元素所在的舞台上设置 transform-style 属性，对于图片来说，图片的任何一个祖先元素都可以作为舞台，我们将图片的父容器作为舞台，为它设置舞台元素的呈现效果。

```css
.img-wrapper{
    transform-style: preserve-3d;
}
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/8/1678d2b82976fbad~tplv-t2oaga2asx-image.image)

很明显，图片呈现出了 3D效果。

通过这两幅动图，我相信大家已经明白 transform-style 的作用了。

我们总结一下：

transform-style用来设置容器中子元素的呈现方式
。
* 当设置为 preserve-3d 时，子元素进行 3D 变换会呈现出 3D 立体效果。
* 当不设置或者设置为 `flat` 时，子元素不管采用 2D 变换还是 3D 变换，总是呈现出平面效果。


## 观察点位置

如何改变观察点位置呢？

这就涉及到两个新属性 `perspective`和`perspective-origin`，这两个属性用来设置观察点的坐标，并让投影产生透视效果，透视效果最明显的现象就是近大远小。


perspective 用来设置观察点在 Z 轴方向的位置，默认时观察点在元素中心，即 z = 0 位置，我们可以调整它到元素中心的距离。

设置这个属性会产生两个效果：

* 改变了观察点距离元素的 Z 轴距离.
* 使得子元素的 3D 变换产生透视效果。

### 舞台

我们想换个角度看图片，那观察点需要设置在哪个元素上呢？

perspective 这个属性也是在舞台上设置的。

我们为舞台设置 perspective属性。


> 请注意，perspective 默认值是 0，此时不产生透视效果。只有不为 0 时才会形成透视效果。


那么，观察点距离元素中心的远近对视觉呈现有什么影响呢？

千言万语抵不过一幅图。

我们通过一张动图感受一下，在这个动画里，我将观察点的 Z 轴坐标从 1 像素匀速改变到 100 像素，再从 100 像素移近到 1 像素，另外为了区别舞台和舞台元素在 Z 轴上的不同，我将舞台的背景颜色改为透明度为 70% 的红色。

```css
.img-wrapper{
    perspective: 300px;
    animation: camera 3s linear;
    background-color: rgba(255, 0, 0, .7);
}
@keyframes camera {
    0% {
        perspective: 1px;
    }
    50% {
        perspective: 100px;
    }
    100% {
        perspective: 1px;
    }
}
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/8/1678970a14c4eb7f~tplv-t2oaga2asx-image.image)


因为图片大小是 150 ，高度是 110px，当绕 X 轴旋转 60 度后，图片底边在 Z 轴的坐标为：

$
z = 110 \div 2 * \frac{\sqrt{3}}{2} \approx 49
$


所以，我们的观察点的 Z 轴坐标至少要大于这个值，才能看到图片的全貌。

距离越近，就越看不到图片在观察点后面的部分。

我们将 perspective （观察点的 Z 轴坐标）移动到 100px 处。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/8/1678cc5fc18c3c15~tplv-t2oaga2asx-image.image)

此时，图片有了近大远小的透视效果，这就是 perspective 的作用。

从感官上我们是能感受到它好像有了 3D 的感觉，但是还是看不出它在 Z 轴上的状态。

改变 perspective 只是改变了在 Z 轴的位置，也就是拉远或者拉近镜头，但是并没有将镜头移到图片上方去观察。


### 观察点在 X、Y 轴的位置

让观察点沿着左、右、上、下方向进行移动的话，该如何做呢？

这就是 perspective-origin 所扮演的重要角色。

它负责设置观察点在 X、Y 轴的偏移，即屏幕的左右、上下方向。

我们看下他的用法：

perspective-origin，接收两个参数，一个代表 X 轴偏移，一个代表 Y 轴偏移。

请谨记：该属性的默认值是 （50%，50%），在舞台 DOM 的中心位置。

回到上面的话题，移动镜头到图片上方，也就是设置观察点在舞台上的 Y 轴坐标，我们将镜头往上移动一定高度，从舞台上方观察图片。

还是用动图来演示这个过程。

```css
.img-wrapper{
    perspective: 200px;
    animation: camera 3s linear infinite;
}
@keyframes{
    0%{
        perspective-origin: 50% 50%;
    }
    50%{
        perspective-origin: 50% -200%;
    }
    100%{
        perspective-origin: 50% 50%;
    }
}
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/8/1678d97bfccd73ed~tplv-t2oaga2asx-image.image)

上面就是我们将镜头慢慢移动到上方时，对舞台元素的观察过程。

注意，图片本身并没有动，我们移动的只是镜头，虽然你会有一种镜头没动，图片在动的感觉。

通过这几幅动图，我相信大家对这几个属性有了更深刻的认识，接下来，我们介绍如何利用这几个属性实现照片墙和图片盒。

## 照片墙

在上一节，我介绍了照片墙的原理，简单来说，就是图片先旋转一定度数，之后沿着 Z 轴方向移动一定距离。

在动手写代码之前，我们要想清楚两个问题：

* 每张图片绕 Y 轴旋转的角度。
* 沿 Z 轴方向至少移动多少像素。

我想，只要你想清楚了这四个问题，代码就信手拈来了。

### 每张图片绕 Y 轴旋转的角度。
我们准备 12 张图片，并将每张图片设置成宽 150px，高 110px 。

```
img{
    width: 150px;
    height: 110px;
}
```

那么，每张图片旋转的角度是 360 / 12 = 30度。

### 沿 Z 轴方向最少移动距离

为了让图片能够不交叉，我们需要沿图片 Z 轴平移一定距离，那么，这个距离是多少呢？

当然我们可以一点点地区尝试，但是我想我还是教给大家一个严谨的思路比较好。

大家看下图：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/8/1678e79b9936cde6~tplv-t2oaga2asx-image.image)

根据下图，我们能够知道，图片在 Z 轴平移的最小距离是 $\vec{OB}$，那么如何求得 $\vec{OB}$ 的长度呢？

由最简单的三角公式可以得出：

$
OB =  BC \times \sqrt3 = （BD + DC）\times \sqrt3
$


仍然根据三角公式可以知道：

$
BD = AD \div 2 = 150 \div 2 = 75
$

$
DC = DE \div \frac{\sqrt3}{ 2} = 75 \times 2 \div \sqrt3 \approx 89
$

所以：

$
OB = (BD + DC) \times \sqrt3 \approx 280
$

也就是说，我们至少要让图片沿着 Z 轴移动 280 像素，才能让各个图片正好衔接。

口说无凭，看看效果吧。

```javascript
Array.prototype.forEach.call(?('img'), (item, i) => {
    item.style.transform = 'rotateY(' + i * 30 + 'deg) translateZ(280px)';
});
```

仍然用一幅动图来演示，我们将观察点移动到舞台上方：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/1678e93e5f22b564~tplv-t2oaga2asx-image.image)

可以看到，当我们让图片沿Z 轴移动 282 像素之后，各个图片的边缘正好能够对齐，和我们推导的结果一致。

将舞台绕 X 轴旋转 90 度，以自下而上的角度观察照片墙是如何从默认位置沿着 Z 轴移动到指定位置：

```css
.img-wrapper{
    transform: rotateX(90deg);
}
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/1678e9a7e142deb5~tplv-t2oaga2asx-image.image)

从不同角度观看我们的舞台，展现效果也会不同。

### 背面是否可见

照片墙这个效果，大家应该能看到处于背面的元素还是能够可见的，这与实际有所差异，如果大家不想背面元素可见，我们可以设置 backface-visibility 属性来实现：

```css
backface-visibility: hidden;
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/1679202ab61c6b7d~tplv-t2oaga2asx-image.image)

大家可以看到，设置完背面不可见属性之后，位于后面的图片此时已经看不到了。



以上就是图片墙的主要原理，可见，了解一些图形学知识对于我们做 3D 动效有莫大的帮助。

接下来，我们看一下另一个效果`图片盒子`的分析实现过程。

## 图片盒

图片盒是一个包含 6 个面的立方体，每个面其实就是一个 DOM 元素。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/9/16791e7ad7c1ff01~tplv-t2oaga2asx-image.image)

上图就是一个图片盒子的例子，我们接下来的目标就是利用 CSS 的 3D 属性实现这样一个效果。

写代码之前还是先思考一下，不考虑动效，我们如何实现这样一个立方体。

其实很简单，主要思考清楚六个面的状态就可以了。

* 首先我们需要六个 DOM 元素，此时六个元素在同一位置。
* 处理前后两个平面在 Z 轴方向的差别。
* 对上下两个平面施加绕 X 轴旋转90度的效果，然后处理 Y 轴方向的差别。
* 对左右两个平面施加绕 Y 轴旋转90度的效果，然后处理 X 轴方向的差别。

想清楚这几个步骤，代码就很简单了。

为了让图片展示 3D 效果，我们需要为图片父容器设置 transform-style 属性：


```css
.img-wrapper{
    transform-style: preserve-3d;
    position: relative;
}
```

接下来，我们为图片元素设置宽高，并对六张图片采用绝对定位，使他们重合。

```css
img{
    width: 150px;
    height: 110px;
    position: absolute;
}
```

然后，开始处理各个面的状态，对于图片盒子的前后两个面，我们只需要改变它们的 Z 轴坐标就可以了，那么 Z 轴坐标设置多少呢？

聪明的同学已经想到了， Z 轴坐标是图片高度的一半。

```css
.front{
    transform: translateZ(55px);
}
.back{
    transform: translateZ(-55px);
}
```

前后平面处理完了，接下来处理上下两个面，上下两个面要绕 X 轴翻转 90 度，然后沿着 Y 轴分别向上下两个方向移动图片高度的一半距离。

```css
    .top{
        transform: translateY(-55px) rotateX(90deg);
    }
    .back{
        transform: translateZ(-55px) rotateX(180deg) ;
    }
```

最后，处理左右两个平面，左右两个平面需要绕 Y 轴旋转 90 度，然后沿着 X 轴进行平移，分别向左、向右平移图片宽度的一半。

```css
.left{
    transform: translateX(-75px) rotateY(90deg);
}
.right {
    transform: translateX(75px) rotateY(-90deg);
}
```

这样，就完成了一个图片盒子，很简单吧？



## 回顾

本节主要讲述了如何设置观察点在三维层面的坐标，并结合上节的变换属性实现照片墙和图片盒子的特效，主要目的不是教会大家做这些效果，而是教大家思考 3D 特效的分析过程。通过这两个例子，我想大家认识到了 css 的强大。即使不使用 WebGL ，我们依然可以用 DOM 元素结合 CSS 实现 3D 效果。

下一节，我们详细阐述一下数学库在 CSS 3D 属性中的高级应用。


## 26.深入研究 --- 数学库在 CSS 的 3D 动画中扮演的重要角色

前面两节，我们详细讲述了CSS 3D 属性的相关概念与使用方法，本节我们看一下 3D 数学库如何与 CSS 中的 tranform 属性实现复杂的 3D 效果。


我们依然从最简单的平移、旋转、缩放开始演示，但是不再使用 translate、scale、rotate 等属性来实现，而是采用 matrix 和 matrix3d。

## matrix 和 matrix3d
作为 transform 属性最冷门的两个属性值，我想大家很少有人会用到它们，或者不知道它们是做什么的，以及不知道该如何使用它们。

上一节我简单介绍了 matrix 和 matrix3d  的使用方法，本节我会详细介绍一下它们。

* matrix 和 matrix3d 的作用。
* 它们的使用方法。
* 属性值的生成方式。


### matrix 
matrix 是 transform 的 2 维变换矩阵，由六个数字组成。

> transform: matrix(a, b, c, d, e, f);

事实上，二维变换矩阵是一个 3 阶矩阵，包含 3 x 3 = 9 个数字，但是你会发现 matrix 是由 6 个数字组成，它们对应一个 3 阶矩阵的如下部分：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/12/16841fb9efa3a4fd~tplv-t2oaga2asx-image.image)

很容易理解，由于第三行的数字始终是固定的，所以 css 规范中把第三行给省略了，matrix 只需要接收前两行数字即可。

对于基本变换，matrix 各个元素表示如下：

#### 平移


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/12/168420213d728550~tplv-t2oaga2asx-image.image)

如果 matrix 只表示平移时，只需要改变 tx 和 ty 即可，其中 tx 代表沿着 X 轴平移的像素值，ty 代表沿着 Y 轴平移的像素值。其余元素都是固定值，仅仅改变 tx 和 ty即可。

比如，让一个 dom 元素沿着 X 轴平移 30 像素，沿着 Y 轴平移 40 像素，那么，用 matrix 表示如下：

```css
transform: matrix(1, 0, 0, 1, 30, 40);
```

> 注意，`tx` 和 `ty` 只能用数字表示，后面不可接 `px` 。

#### 缩放
单一矩阵表示缩放时，各个位置的元素如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/12/168420a52a9fb0da~tplv-t2oaga2asx-image.image)

其中 sx 代表 X 轴方向的缩放比例，sy 代表 Y 轴方向的缩放比例，其余位置的元素都是固定的。
比如，沿着 X 轴放大两倍，沿着 Y 轴放大两倍时，css 表示如下：

```css
transform: matrix(2, 0, 0, 0, 2, 0, 0, 0, 1);
```

等价于

```css
transform: scale(2);
transform: scale(2, 2);
```

当我们想通过 matrix 设置缩放比例时，只需要改变 sx、sy 即可。

#### 旋转
单一矩阵表示旋转时，各个位置元素表示如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/13/168457c7ab0fc5ec~tplv-t2oaga2asx-image.image)

由于 2D 旋转是在 XY 平面的旋转，也就是绕 Z 轴的旋转，所以 θ 角度是绕 Z 轴旋转的角度。
比如旋转 45 度时：

$
cos45^。 = \frac{\sqrt{2}}{2} \approx 0.7071
$

$
sin45^。 = \frac{\sqrt{2}}{2} \approx 0.7071
$

将各个数字代入公式后，css 表示如下：

```css
transform: matrix(0.7071, 0.7071, -0.7071, 0.7071, 0, 0);
```
等价于

```css
transform: rotate(45deg);
transform: rotateZ(45deg);
```


以上就是通过单一矩阵介绍了 matrix 的用法。大家可能会有如下疑惑：transform 已经内置了基本变换属性`translate`、`rotate`、`scale`，所以，我们为什么还要用 matrix？况且 matrix 更复杂，更不易于理解。回答这个问题之前，我们趁热打铁，先了解下 3 维变换 matrix3d 的用法。

### matrix3d
顾名思义，matrix3d 是transform 的 3 维变换矩阵，由 16 个数字组成。

> transform: matrix3d(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p);

CSS 中 matrix3d 的参数顺序对应变换矩阵的元素位置如下图所示。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684a5d49cf364c7~tplv-t2oaga2asx-image.image)


16 个数字乍看之下很多，初学者容易犯晕，不过大家可以根据上图对这 16 个数字进行分类，分为四组，每组 4 个数字，每组数字代表变换矩阵的每一列，每一列数字代表的含义如下：

* 第一列，代表变换后的坐标系的 X 轴在原坐标系下的坐标。
    * a：X 轴坐标分量
    * b：Y 轴坐标分量
    * c：Z 轴坐标分量
    * d：通常为 0，代表向量。
* 第二列，代表变换后的坐标系的 Y 轴在原坐标系下的坐标。
    * e：X 轴坐标分量
    * f：Y 轴坐标分量
    * g：Z 轴坐标分量
    * h：通常为 0，代表向量。
* 第三列，代表变换后的坐标系的 Z 轴在原坐标系下的坐标。
    * i：X 轴坐标分量
    * j：Y 轴坐标分量
    * k：Z 轴坐标分量
    * l：通常为 0，代表向量。
* 第四列，代表变换后的坐标系原点在原坐标系下的坐标
    * m：X 轴坐标分量。
    * n：Y 轴坐标分量。
    * o：Z 轴坐标分量。
    * p：通常为 1，代表点。

如果你看过在之前章节坐标系变换原理的话，相信你会很容易理解上面的解释，如果你没看过，那也没关系，只需要掌握数学矩阵库的使用即可生成这么一个`变换矩阵`，之后将矩阵的各个元素填入 matrix3d 的 对应位置即可。

接下来看一下 matrix3d 是如何达到 transform 基本变换效果的。
###  3D 平移

3D 平移无非就是增加了一个 Z 轴的平移效果。

平移时，matrix3d 对应变换矩阵的各个元素位置如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684b07647e78b71~tplv-t2oaga2asx-image.image)

其中：
* tx：代表沿 X 轴的平移量。
* ty：代表沿 Y 轴的平移量。
* tz：代表沿 Z 轴的平移量。


如果，我们想通过 matrix3d 表示平移的话，只需要改变 tx、ty、tz 三个元素即可，其余元素如上图，无需变化。

假设我们要实现沿 X 轴平移 30 像素，沿 Y 轴平移 40 像素，沿 Z 轴平移 50 像素，那么 CSS 可以像下面这样设置：

```css
transform: matrix3d(
1, 0, 0, 0, 
0, 1, 0, 0, 
0, 0, 1, 0, 
30, 40, 50, 1
);
```

等价于

```css
transform: translate(30px, 40px, 50px);
```

注意哦，当使用 translate 时需要带上单位 `px`。

> 大家仍然不难发现，使用 matrix3d 比 translate 复杂，要书写的属性内容也多，并且不易于理解。

### 3D缩放
3D 缩放仍然增加了 Z 轴方向的缩放效果，当 transform-style 设置为 preserve-3d 时，能够看到缩放 Z 轴所带来的视觉效果。

缩放对应的变换矩阵各个元素的位置如下图：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684b328f0962081~tplv-t2oaga2asx-image.image)

其中：
* sx：代表沿 X 轴缩放的比例。
* sy：代表沿 Y 轴缩放的比例。
* sz：代表沿 Z 轴缩放的比例。

除了 sx、sy、sz 这三个元素需要我们自己设置，其余位置的元素都是固定值，如上图。

假设我们要将一个 dom 元素沿 X 轴、Y 轴、Z 轴各放大两倍，那么用 matrix3d 表示如下：

```css
transform: matrix3d(
    2, 0, 0, 0,
    0, 2, 0, 0,
    0, 0, 2, 0,
    0, 0, 0, 1
);
```

等价于：

```css
transform: scale3d(2, 2, 2);
```

我们通过一个小例子，看下效果。

```html
<div class="parent">
    <div class="son"></div>
</div>
```

```css
.parent{
    transform-style: preserve-3d;
    background: bisque;
    transition: 2s;
}
.parent:hover{
    transform: rotateY(80deg);
}
.son{
    width: 100px;
    height: 100px;
    background-color: blueviolet;
    transform: matrix3d(1 , 0, 0, 0,
    0, 1, 0, 0, 
    0, 0, 4, 0,
    0, 0, 0, 1) 
    rotateX(60deg);
}
```
>为了便于观察 Z 轴放大效果，此处我对子元素做了一个多重变换，首先将子元素沿着 X 轴旋转 60 度，之后再执行缩放变换。多重变换的细节大家可以参见[CSS 与 3D 变换之 transform](https://juejin.cn/book/6844733755580481543/section/6844733755945402382)章节。

我们将子元素沿着 Z 轴放大四倍，X 轴和 Y 轴比例不变，观察下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684b783f6e95e9b~tplv-t2oaga2asx-image.image)

大家可以发现， Z 轴长度变为了之前的 4 倍。
上面我们是用 matrix3d 实现的，使用 scale3d 同样能达到上述效果，大家不妨试一试。

### 旋转
3D 旋转是基本变换最复杂的一个，涉及到绕基本坐标轴的旋转、绕任意轴的旋转、欧拉角旋转、四元数旋转等，但是 CSS 中除了 matrix 和 matrix3d 以外，只提供了绕基本轴旋转、绕任意轴旋转，欧拉角旋转和四元数旋转需要通过数学库计算出对应的旋转矩阵。我们还是先看下如何使用 matrix3d 实现基本旋转。


#### 绕 X 轴旋转
绕 X 轴旋转 θ 角度对应的变换矩阵各个元素的位置如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684baa31098682e~tplv-t2oaga2asx-image.image)

举个例子，假设我们实现绕 X 轴旋转 45 度的效果，那么对应的 css 表示如下：

```css
transform: matrix3d(
    1, 0, 0, 0,
    0,  0.7071, 0.7071, 0,
    0, -0.7071, 0.7071, 0,
    0, 0, 0, 1
);
```
等价于

```css
transform: rotateX(45deg);
transform: rotate3d(1, 0, 0, 45deg);
```

效果如下图：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/1684f46a4978eabe~tplv-t2oaga2asx-image.image)

#### 绕 Y 轴旋转

绕 Y 轴旋转 θ 角度对应的变换矩阵各个元素的位置如下图所示：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684bec76da1333f~tplv-t2oaga2asx-image.image)

举个例子，假设我们实现绕 Y 轴旋转 45 度的效果，那么对应的 css 表示如下：

```css
transform: matrix3d(
    0.7071, 0, 0.7071, 0,
    0,  1, 0, 0,
    -0.7071, 0, 0.7071, 0,
    0, 0, 0, 1
);
```
等价于

```css
transform: rotateY(45deg);
transform: rotate3d(0, 1, 0, 45deg);
```

效果如下图：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/1684f4708c2daaa6~tplv-t2oaga2asx-image.image)

#### 绕 Z 轴旋转

绕 Z 轴旋转 θ 角度对应的变换矩阵各个元素的位置如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/14/1684bee618018b04~tplv-t2oaga2asx-image.image)

举个例子，假设我们实现绕 Z 轴旋转 45 度的效果，那么对应的 css 表示如下：

```css
transform: matrix3d(
    0.7071, -0.7071, 0, 0,
    0.7071, 0.7071, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
);
```
等价于

```css
transform: rotateZ(45deg);
transform: rotate3d(0, 0, 1, 45deg);
```

效果如下图：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/1684f473b63d8879~tplv-t2oaga2asx-image.image)

以上就是使用 matrix 和 matrix3d 来代替基本变换属性的讲解内容。大家应该能明白它们的用法了，归纳起来如下：

* matrix 接收二维变换矩阵。
* matrix3d 接收三维变换矩阵。


很简单。

那另一个问题是，如何求得变换矩阵呢？这就需要用到我们前面总结的数学矩阵库了。

### 矩阵库与 matrix 的搭配。

对于基本变换，我们没有必要使用 matrix 来实现，但是对于一些基本变换满足不了的效果，我们就需要考虑 matrix 了。

比如，我需要为一个 dom 元素进行如下变换：

* 首先绕 X 轴旋转 45 度。
* 接着沿 Y 轴平移 30 像素。
* 然后绕 Z 轴旋转 45 度。
* 最后沿 Y 轴方向旋转 90 度。

> 以上变换基于静态坐标系（世界坐标系）进行的。

对于这么一个复杂的变换，我们有两种方式来实现：

* 组合变换，上节已经讲过。
* matrix 变换。

首先，我们看下如何使用组合变换来实现：

```css
transform: rotateY(90deg) 
    rotateZ(45deg) 
    translateY(30px) 
    rotateX(45deg);
```

> 在 css transform 章节中介绍了 transform 组合变换时各个变换的顺序与坐标系的关系，如果大家还没忘记的话，应该记得变换属性从后往前排列代表按照世界坐标系进行变换。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/1684fa203ee5ce01~tplv-t2oaga2asx-image.image)


变换的分步执行过程如上图。

你会发现，如果变换过程比较多的话，transform 中要书写很多属性，所以可以尝试另一种思路，matrix3d。

我们看下如何使用 matrix3d 来表示。

利用之前的矩阵库，我们需要如下几个方法计算最终的变换矩阵：

* rotateZ：绕 Z 轴旋转。
* rotateX：绕 X 轴旋转。
* rotationY：绕 Y 轴旋转。
* translate：平移。

> 你可能没有发现矩阵相乘的方法，这是因为 rotateZ、rotateX、translate 方法允许传入一个矩阵作为左乘矩阵，返回一个组合矩阵。当然，你也可以用矩阵相乘方法来实现组合矩阵的求值，但是那样会多执行一些重复运算。


这几个方法在之前章节已经讲述过，所以我们拿来使用即可：

```javascript
var deg = Math.PI / 180;
// 首先创建一个沿 Y 轴旋转矩阵。
var target = matrix.rotationY(90 * deg); 
// 接着计算 Y 轴旋转矩阵与 Z 轴旋转矩阵的组合变换。
// 等价于 matrix.multiply(target, matrix.rotationZ(45 * deg));
target = matrix.rotateZ(target, 45 * deg);
// 等价于 matrix.multiply(target, matrix.translate(0, 30, 0));
target = matrix.translate(target, 0, 30, 0, target);
// 等价于 matrix.multiply(target, matrix.rotationX(45 * deg));
target = matrix.rotateX(target, 45 * deg, target);
```

我们将 target 打印出来看一下：

```javascript
[
    4.329780632585522e-17, 0.7071067690849304,
    -0.7071067690849304, 0,
    0.7071067690849304, 0.5, 0.5, 0,
    0.7071067690849304, -0.5, -0.5, 0,
    -1.298934236097771e-15, 21.21320343017578,
    21.21320343017578, 1
]
```

target 就是上面几种变换组合后的最终矩阵，我们将它转化为 css 的 matrix3d 属性：

```javascript
// 将矩阵转化为transform matrix 属性值。
function matrix2css(m){
    var style = 'matrix(';
    if(m.length == 16){
        style = 'matrix3d('
    }
    for(let i =0; i< m.length; i++){
        style += m[i];
        if(i !== m.length - 1){
            style += ','
        }else{
            style +=')'
        }
    }
    return style;
}
```

最终效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/168506ba371e5fbf~tplv-t2oaga2asx-image.image)


很显然，通过组合变换和 matrix，我们达到了同样的效果。

通过比较上面的两种实现，我们发现，组合变换相较于 matrix 更容易理解，当变换次数较少时，使用组合变换更优一些。但是当变换次数越来越多时，就需要使用 matrix 了。那么，什么时候变换次数会越来越多呢？

* 分段动画
    * 当一段动画分成很多段时，变换次数会越来越多，这时，需要针对动画做关键帧处理，每一个关键帧处使用 matrix 来表示。
* 复杂交互
    * 当交互比较复杂时，每一次交互都会在原来的变换属性上触发一次或者多次变换，这就需要使用数学库的矩阵乘法来计算组合矩阵。
    
下面，我会通过一个魔方格子的旋转来讲述 matrix3d 的使用场景。

## 魔方格子的旋转。

大家都玩过魔方吧，沿不同方向进行旋转，可以将一个面的格子绕指定轴旋转 90 度。

接下来我们构造一个魔方格子，演示一下如何通过 matrix3d 完成这种交互。

### 构造魔方格子。
首先，我们要构造一个魔方格子，魔方格子是一个立方体，在前面章节我曾经介绍过图片盒的实现，此处仍然采用图片盒的实现方式，只不过将图片换成 DIV 容器。

```html
<div class="block" id="block">
    <div class="face front"></div>
    <div class="face back"></div>
    <div class="face up"></div>
    <div class="face down"></div>
    <div class="face left"></div>
    <div class="face right"></div>
</div>
```

样式如下：

```css
.block {
    position: absolute;
    transform-style: preserve-3d;
    width: 100px;
    height: 100px;
    transform-origin: 50px 50px;
}
.front {
    background: fuchsia;
}

.back {
    transform: translate3d(0, 0, 100px) rotateY(180deg);
    background: red;
}
.left {
    transform-origin: 100% 50% 0px;
    transform: rotateY(90deg);
    background: aqua;
}
.right {
    transform-origin: 0% 50% 0px;
    transform: rotateY(-90deg);
    background: blueviolet;
}
.up {
    transform-origin: 50% 0% 0px;
    transform: rotateX(90deg);
    background: darkorange;
}
.down {
    transform-origin: 50% 100% 0px;
    transform: rotateX(-90deg);
    background: darkviolet;
}
```

为了便于观察，我们为让魔方格子旋转起来：

```css
@keyframes rotate {
    0% {
        transform: translate(-50%, -50%) rotate3d(1, 1, 1, 0deg);
    }

    100% {
        transform: translate(-50%, -50%) rotate3d(1, 1, 1, 360deg);
    }
}

.block{
    animation: rotate 3s linear infinite;
}
```

魔方格子效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/16850e6ba543ba69~tplv-t2oaga2asx-image.image)


上图魔方格子的旋转是通过CSS 中的 `animation` 属性 来实现的，并没有通过交互来触发，接下来，我们讲解一下如何通过鼠标滑动进行旋转。

### 旋转。

鼠标滑动分为左、右、上、下滑动，每种滑动对应一种方向的格子旋转。

* 从右往左：绕 Y 轴旋转 θ 角。
* 从左往右：绕 Y 轴旋转 -θ 角。
* 从上往下：绕 X 轴旋转 θ 角。
* 从下往上：绕 X 轴旋转 -θ 度。

当然旋转需要有一个参照点，默认盒子中心。在 23 章节[深入研究 --- 四元数的应用：使用鼠标控制模型的旋转]()我们使用四元数、欧拉角分别实现了模型的旋转交互，本节我们依然采用旋转矩阵的生成原理，区别就是将生成的矩阵转化为 CSS 中 transform 的 matrix3d 属性值。

```javascript
var currentQ = {x:0, y:0, z:0, w:1};
var lastQ = {x:0, y:0, z:0, w:1};
var currentMatrix = matrix.identity();
var l = Math.sqrt(dx * dx + dy * dy);
if(l <= 0)return;
var x = dx / l, y = dy / l;
var axis = {x: x, y: y, z: 0};
var q = matrix.fromAxisAndAngle(axis, l);
currentQ = matrix.multiplyQuaternions(q, lastQ);
currentMatrix = matrix.makeRotationFromQuaternion(currentQ);
```
通过上述方式我们计算出了当前旋转矩阵 currentMatrix，接下来，我们使用上面介绍的矩阵转化成对应 css 的函数，生成对应的 transform 属性。

```javascript
var style = matrix2css(currentMatrix);
```

最后将生成的样式应用到魔方格子上。

```javascript
document.querySelector('#block').style.transform = style;
```

至此，我们通过 matrix3d 实现了使用鼠标控制魔方格子旋转的效果。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/1685233083461428~tplv-t2oaga2asx-image.image)

## 回顾
以上就是数学矩阵库与 CSS transform 属性的高级使用技巧，通过这两个例子的学习，大家应该对 transform 的 3D 属性更有信心了，希望大家以后碰到交互给出的 3D 特效时不再畏手畏脚，而是大胆的拥抱它。

至此，我们对 CSS 的 3D 属性的学习就告一段落了。下一节，我们还是回到 WebGL 的学习内容上来。

## 27.深入探究 --- 层级建模：行走的机器人

本节我们学习如何建立模型与模型之间的层级关系，层级关系通常用树形结构来表示。比如人体模型，人是由头部、躯干、胳膊、腿、脚等局部模型组成，当人在走路的时候，腿部相对于腰部做旋转运动，膝盖会相对于大腿内侧进行旋转，小腿会相对于膝盖进行旋转，这些不同部位间的相对运动通过多个矩阵变换的方式可以转化成相对世界坐标系的绝对运动，如下图，便是一个行走中的机器人：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/15/16716697500485d2~tplv-t2oaga2asx-image.image)

同样地，可以类比到动物、汽车、太阳系、银河系、宇宙等，涉及到相对运动的多个物体之间我们都可以用层级对它们进行建模。
## 为什么需要层级建模

如果没有层级建模，那么模型只能做整体的刚性运动，模型的一部分不能相对整体进行局部运动，这在某些场景下就会产生一些问题。比如在游戏中的人物在行走时，手臂、腿会随着步伐做适当摆动，如果没有层级建模，我们就需要单独为手臂、腿计算相对世界坐标系的变换矩阵，比较复杂。如果有了层级建模，我们可以只考虑手臂、腿相对于自身的变换，不需再考虑世界坐标系下的变换。

> 不需考虑世界坐标系下的变换并不代表我们不计算世界矩阵，只不过计算世界矩阵的方法在已经被我们抽象出来，我们不用关心这块逻辑，而是交由库来实现。我们只需要设置好平移、旋转、缩放这三个属性即可。

我们需要用一棵树型结构来表示层级关系，节点与节点之间存在父子关系，即每个节点都会有 parent 和 children 属性，其中，parent 表示当前节点的父节点，children 表示当前节点的子节点属性，用数组来表示。除此之外，节点还需要保存世界变换矩阵和局部变换矩阵，世界变换矩阵用来保存子节点的世界变换矩阵，局部变换矩阵用来保存子节点自身的变换矩阵。

我们知道，变换分为 3 种：平移、缩放、旋转。每个节点都需要有这三个属性，但请大家一定要记住，在使用层级进行建模时，这三个属性都是相对于模型自身坐标系的。各个节点的世界变换矩阵如何得来呢？

* 1、通过平移、旋转、缩放属性我们可以计算出节点的局部变换矩阵，
* 2、将每个节点的父节点的世界变换矩阵右乘当前节点的局部变换矩阵可以计算出当前节点的世界变换矩阵。

我们以手臂的运动加以分析，手臂由前臂和小臂组成，小臂绕着肘关节（即前臂的末端）进行旋转，不需要考虑其他因素。手臂的层级表示如下：

```javascript
let arm = {
    name:'arm',
    translation: [0, 0, 0],
    rotation: [0, 0, 0],
    scalation: [1, 1, 3],
    parent:null,
    children:[
        {
            name:'forearm',
            translation: [0, 0, 0],
            rotation: [0, 0, 0],
            scalation: [1, 2, 1],
            parent:null,
        }
    ]
}
```

接下来我们看一下如何根据这些属性实现层级建模。

## 如何实现层级建模

还记得我们重构过的 Model 类吗？为了实现层级关系，我们需要为 `Model` 类增加 `children` 、`parent`、`localMatrix`、`worldMatrix` 四个属性：


```javascript
function Model(name) {
  this.uniforms = {};
  this.bufferInfo = {};
  this.u_Matrix = matrix.identity();
  this.translation = [0, 0, 0];
  this.scalation = [1, 1, 1];
  this.rotation = [0, 0, 0];
  this.parent = null;
  this.children = [];
  this.localMatrix = matrix.identity();
  this.worldMatrix = matrix.identity();
  this.name = name || '未命名';
}
```

另外，我们给模型增加设置父节点的方法：

```javascript
Model.prototype.setParent = function(parent){
    // 若当前模型有父节点，从父节点中移除
    if(this.parent){
        let index = this.parent.children.indexOf(this);
        if(index >= 0){
            this.parent.children.splice(index, 1);
        }
    }
    // 将模型添加到指定 parent 节点的子列表尾部。
    if(parent){
        parent.children.push(this);
    }
    this.parent = parent || null;
}
```

在预渲染阶段，我们为模型计算 MVP 矩阵的时候，计算出来的只是相对于自身的局部变换矩阵，需要转化成相对世界坐标系的矩阵，转化过程也比较简单，将当前节点的本地矩阵右乘父节点的世界矩阵即可，我们需要有这样一个算法来更新模型的世界矩阵。

```javascript
Model.prototype.getWorldMatrix = function(worldMatrix){
    if (worldMatrix) {
    this.worldMatrix = matrix.multiply(worldMatrix, this.localMatrix);
  } else {
    this.worldMatrix = matrix.clone(this.localMatrix);
  }
  let currentWorldMatrix = this.worldMatrix;
  this.children.forEach(function(model) {
    model.getWorldMatrix(currentWorldMatrix);
  });
}
```

有了更新世界矩阵的方法，那么接下来要考虑的是在何时执行更新方法呢？还记得 Model 的preRender 方法吗，我们把 getWorldMatrix 方法的执行时机放在 preRender 中。

```javascript
let modelMatrix = matrix.identity();
  if (this.translation) {
    modelMatrix = matrix.translate(
      modelMatrix,
      this.translation[0],
      this.translation[1],
      this.translation[2]
    );
  }
  if (this.rotation) {
    if (this.rotation[0] !== undefined)
      modelMatrix = matrix.rotateX(modelMatrix, degToRadians(this.rotation[0]));
    if (this.rotation[1] !== undefined)
      modelMatrix = matrix.rotateY(modelMatrix, degToRadians(this.rotation[1]));
    if (this.rotation[2] !== undefined)
      modelMatrix = matrix.rotateZ(modelMatrix, degToRadians(this.rotation[2]));
  }
  modelMatrix = matrix.translate(
    modelMatrix,
    -this.origination[0] * this.scalation[0],
    -this.origination[1] * this.scalation[1],
    -this.origination[2] * this.scalation[2]
  );
  if (this.scalation) {
    modelMatrix = matrix.scale(
      modelMatrix,
      this.scalation[0],
      this.scalation[1],
      this.scalation[2]
    );
  }

  this.localMatrix = modelMatrix;
  this.children.forEach(function(child) {
    child.preRender(viewMatrix, projectionMatrix);
  });
  
  if (!this.parent) {
    this.getWorldMatrix();
  }
  
  //重新计算 MVP 矩阵
  this.u_Matrix = matrix.multiply(viewMatrix, this.worldMatrix);
  this.u_Matrix = matrix.multiply(projectionMatrix, this.u_Matrix);

  this.uniforms.u_Matrix = this.u_Matrix;
  this.uniforms.u_ModelMatrix = this.worldMatrix;
  
```

你会发现，我在preRender方法中执行getWorldMatrix 时增加了一个判断条件，当前节点没有父节点时才开始执行世界矩阵的更新。
### 层级建模实战

好了，经过改造后的 Model 满足层级建模的需求了，我们实现一个手臂模型演示 Model 使用方法。

我们创建一个手臂 arm 和 前臂 forearm，简单起见，将他们的形状设置为顶点边长为 1 的立方体：

```javascript
let cube = createCube(1, 1, 1);
let bufferInfo = createBufferInfoFromObject(gl, cube);
let arm = new Model('arm');
arm.setBufferInfo(bufferInfo);
let forearm = new Model('forearm');
smallArm.setBufferInfo(bufferInfo);
```

接下来要将 forearm 的父节点设置为arm，建立层级关系，并将 arm 添加到模型列表中，这里由于forearm 和 arm 建立了父子关系，所以此处我们只把arm 添加到模型列表和渲染列表即可。

```javascript
forearm.setParent(arm);
objectList.add(arm);
renderList.add({
    model: arm,
    programInfo: program
});
```

接下来开始渲染，渲染仍然是遍历渲染列表，传递 渲染对象对应的模型对象的 uniforms 属性和 attribute 属性：

```javascript
renderList.forEach(function(object) {
    let programInfo = object.programInfo;
    let programChanged = false;
    object.model.preRender(viewMatrix, projectionMatrix);
    if (programInfo != lastProgramInfo) {
        lastProgramInfo = programInfo;
        programChanged = true;
    }

    renderObject(
        object.model,
        programChanged,
        object.renderType,
        object.primitive
    );
});
```

我们看下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/14/16711dfcf8990c2d~tplv-t2oaga2asx-image.image)

我们只看到了一个立方体，原因是我们没有给 forearm 设置平移，forearm和arm重叠了。

#### 增加平移
为 forearm 设置一个平移属性：

```javascript
forearm.translateX(1);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/14/16711e19ce7ea9fc~tplv-t2oaga2asx-image.image)

嗯，这次我们可以看到两个挨着的立方体了，靠右的是 forearm。

层级建模的一个优势是，我们只需要考虑局部的变换，不需要考虑世界坐标系变换，库会为我们自动计算。接下来我们演示一下，这次我们只让 arm 进行平移：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/14/16712ade469a330d~tplv-t2oaga2asx-image.image)

可以看到，不管 arm 移动到什么位置，forearm 始终在 arm 的 X 轴右侧 1 个单位处。


#### 增加缩放
手臂过于方正了，我们将 arm 和 forearm 沿着X轴放大一倍：

```javascript
arm.scaleX(2);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/14/16711e29ab3b8039~tplv-t2oaga2asx-image.image)

啊哦，我们只给 arm 设置了放大倍数，但是同时影响了 forearm，这在某些时候可不是我们想要的结果，在一些特定的场景下，我们能只对父节点执行缩放，而不缩放子节点。

如何解决这个问题呢？

事实上，我们可以将需要放大的节点拆出来，只对它执行缩放变换。像下面这样：

```javascript
let arm = {
    name: 'arm',
    children:[{
        name: 'bigArm',
        rotation:[2, 1, 1]
    },{
        name: 'forearm',
        translation: [1, 0, 0]
    }]
}
```


额外增加一个需要缩放的节点 bigArm 作为 arm 的子节点，此时bigArm 和 forearm 同级，并且都以  arm 作为父节点。有一点需要注意，arm 此时不再需要渲染了，作为父节点的它，只是为了给子节点提供旋转和平移的变换矩阵，所以，我们修改Model ，为 Model 增加一个参数 isDraw，设置为 false即可不必对它执行渲染操作。

```javascript
function Model(name, isDraw){
    ...略
    if(isDraw === false){
        this.isDraw = false;
    }
    else {
        this.isDraw = true;
    }
    ...略
}
```


```
let arm = new Model('arm', false);
let bigArm = new Model('bigArm');
bigArm.scaleX(2);
bigArm.setParent(arm);
forearm.translateY(1);
...略

```

效果如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/14/16711e93eccba498~tplv-t2oaga2asx-image.image)

可以看到，通过额外增加一个节点的方式，我们可以解决父节点的缩放效果影响到子节点问题。


### 增加旋转

解决了缩放问题，接下来我们增加旋转效果，这里我们让 forearm 绕自身原点旋转，默认情况下节点的坐标系原点位于中心位置。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/14/16712d1a70f0f6e7~tplv-t2oaga2asx-image.image)

可以看到，forearm 围绕自身中心在旋转了，但是这不是我们期待的效果，我们期待的是 forearm 绕 forearm 和 arm 先接触进行旋转。

如何解决这个问题，我们可以给 Model 增加一个新的属性，改变模型自身原点：

```javascript
function Model = (name, isDraw){
    ...略
    this.origination = [0, 0, 0];
    ...略
}

Model.prototype.setOrigin = funcition(ox, oy, oz){
    this.origination[0] = ox || 0;
    this.origination[1] = oy || 0;
    this.origination[2] = oz || 0;
}
```

我们改变 forearm 原点到左侧：

```javascript
forearm.setOrigin(-0.5, 0, 0);
```

试试看下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/15/167155e9f123c86a~tplv-t2oaga2asx-image.image)

嗯，这次 forearm 可以绕着自身左侧旋转了，但是还有一些问题，forearm 有一部分和 arm 重叠了，我们需要将 forearm 向右平移 bigArm 的长度，即 2 个单位。


```javascript
forearm.translateX(2);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/15/16715669ce1f8a79~tplv-t2oaga2asx-image.image)

这回像个手臂了，但还有个问题， forearm 有些过于短小了，我们把它拉长一些：


```javascript
forearm.scaleX(2);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/15/167156a1b273a716~tplv-t2oaga2asx-image.image)

嗯，这个动作看起来像是在秀肌肉了。


## 行走的机器人

我们利用上面的层级代码实现本节开头的机器人行走动画，首先画一下机器人的层级结构：



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/15/167167a6e64c57a0~tplv-t2oaga2asx-image.image)


我们设计的机器人由上图中的节点组成，所有节点都是由边长为 1 的立方体通过缩放平移组合而成。

如果按照前面的开发方式，每个节点的生成、平移、缩放、旋转等都需要用代码来控制，比如这个机器人：


```javascript
let person = new Model('person', false);
// 创建头部
let head = new Model('head');
head.setBufferInfo(bufferInfo);
head.translate(0, 2, 0);
head.scale(1.5,1.5,1.5);
head.setParent(person);
// 胸部
let torso  = new Model('torso');
torso.setBufferInfo(bufferInfo);
torso.scale(2.2, 3, 2.2);
torso.setParent(person);

// 腰部
let waist  = new Model('waist');
waist.setBufferInfo(bufferInfo);
waist.translate(0, -2, 0);
waist.setParent(person);
//左胳膊
...略
// 右胳膊
...略
...
```

你会发现，我们的节点越多，我们就要重复编写这些设置代码，比较繁琐，所以，我们最好能有一个描述机器人的结构体，通过一个方法解析这个结构体，自动生成person 对象。

我们用对象结构来描述模型之间关系，每个节点都有如下属性：

* name：节点名称
* isDraw：是否渲染
* scalation：缩放
* translation：平移
* rotation：旋转
* origination：原点位置
* children：子节点
* parent：父节点
* uniforms：当前节点的全局属性，用于传往着色器程序。


```javascript
    let description = {
        name: 'person',
        isDraw: false,
        scalation: [0.4, 0.4, 0.4],
        children: [
          {
            name: 'head',
            scalation: [1.5, 1.5, 1.5],
            translation: [0, 2, 0],
            uniforms: {
              u_ColorFactor: [0.5, 0.5, 0],
              u_ColorOffset: [0.5, 0.5, 0]
            }
          },
          {
            name: 'torso',
            scalation: [2.2, 3, 2.2]
          },
          {
            name: 'leftArm',
            isDraw: false,
            translation: [-2, 1, 0],
            children: [
              {
                name: 'leftBigArm',
                scalation: [0.8, 1.5, 0.8],
                origination: [0, 0.5, 0]
              },
              {
                name: 'leftSmallArm',
                scalation: [0.8, 1.5, 0.8],
                origination: [0, 0.5, 0],
                translation: [0, -1.5, 0]
              }
            ]
          },
          {
            name: 'rightArm',
            isDraw: false,
            translation: [2, 1, 0],
            children: [
              {
                name: 'rightBigArm',
                scalation: [0.8, 1.5, 0.8],
                origination: [0, 0.5, 0]
              },
              {
                name: 'rightSmallArm',
                scalation: [0.8, 1.5, 0.8],
                origination: [0, 0.5, 0],
                translation: [0, -1.5, 0]
              }
            ]
          },
          {
            name: 'waist',
            translation: [0, -2, 0],
            children: [
              {
                name: 'leftLeg',
                translation: [-1, 0.5, 0],
                isDraw: false,

                children: [
                  {
                    name: 'thigh',
                    origination: [0, 0.5, 0],
                    scalation: [1, 2, 1]
                  },
                  {
                    name: 'crus',
                    translation: [0, -2, 0],
                    isDraw: false,
                    children: [
                      {
                        name: 'crusScale',
                        origination: [0, 0.5, 0],
                        scalation: [1, 2, 1]
                      },
                      {
                        name: 'foot',
                        scalation: [1, 0.5, 1.6],
                        translation: [0, -2, -0.25]
                      }
                    ]
                  }
                ]
              },
              {
                name: 'rightLeg',
                translation: [1, 0.5, 0],
                isDraw: false,
                children: [
                  {
                    name: 'thigh',
                    origination: [0, 0.5, 0],
                    scalation: [1, 2, 1]
                  },
                  {
                    name: 'crus',
                    translation: [0, -2, 0],
                    isDraw: false,
                    children: [
                      {
                        name: 'crusScale',
                        origination: [0, 0.5, 0],
                        scalation: [1, 2, 1]
                      },
                      {
                        name: 'foot',
                        scalation: [1, 0.5, 1.6],
                        translation: [0, -2, -0.25]
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      };
```

接下来我们要有一个能够解析这个结构体的方法，通过这个结构体能够返回模型对象：

```javascript
    function createModel(node) {
        let model = new Model(node.name, node.isDraw);
        if (model.isDraw) {
          model.setBufferInfo(bufferInfo);
        }
        // 节点是否设置了平移
        if (node.translation) model.translate(node.translation);
        // 节点是否设置了旋转
        if (node.rotation) model.rotate(node.rotation);
        // 节点是否设置了缩放
        if (node.scalation) model.scale(node.scalation);
        // 节点是否设置了原点
        if (node.origination) model.setOrigin(node.origination);
        // 节点是否设置了全局变量
        if (node.uniforms) model.setUniforms(node.uniforms);
        // 节点是否有子节点，若有，遍历子节点
        if (node.children) {
          node.children.forEach(function(childNode) {
            let childModel = createModel(childNode);
            childModel.setParent(model);
          });
        }
        // 返回模型对象。
        return model;
      }
```

利用这种方式，我们就不必每次都编写重复的设置代码了，只需要修改表示模型的结构体就可以了。

利用上面的方法创建 person 对象就很简单了：

```
let person = createModel(description);
```

有了机器人模型，接下来我们要让它动起来。
首先，机器人走动时整体会移动。
其次，胳膊和大腿会有幅度地摆动，同时，前臂和小腿会随着胳膊和大腿进一步摆动。

在每次 render 的时候，更新 `person` 节点的 translate 平移属性，同时更新以下节点的旋转属性，假设某一刻，左臂旋转角度为 N 度时：

* 左臂旋转 N 度
    * 左前臂在左臂的基础上额外旋转 N / 2 度
* 右臂旋转 -N 度
    * 右臂旋转 -N 度代表往后旋转，此时右前臂不设置旋转。
* 左腿旋转 -N 度
    * 左腿旋转 -N 度，代表往后摆动，此时左小腿设置旋转。
* 右腿旋转 N 度
    * 右小腿在右腿的基础上额外旋转 N / 2 度

分析出模型以及模型局部的运动规律之后，我们就可以在每一帧动画中改变他们的属性了：

```javascript
    function animate(person){
        let object = person.moveInfo;
        if (Math.abs(object.leftRotation) > rotationMax) {
          object.leftIndex = -object.leftIndex;
        }
        object.leftRotation += object.leftIndex;
        object.rightRotation += -object.leftIndex;
        object.leftLegRotation -= object.leftIndex;
        object.rightLegRotation += object.leftIndex;

        if (Math.abs(person.translation[2]) > 4) {
          object.moveIndex = -object.moveIndex;
        }

        person.translateZ(
          calFloat(person.translation[2], -0.2 * object.moveIndex)
        );

        if (
          Math.abs(person.translation[2]) > 3 &&
          person.translation[2] * object.moveIndex > 0
        ) {
          let unitAngle = (180 * object.moveIndex) / 5;
          person.rotateY(person.rotation[1] + unitAngle);
        }

        person.children.forEach(function update(child) {
          if (child.name == 'leftArm') {
            child.rotateX(object.leftRotation);
          }
          if (child.name == 'rightArm') {
            child.rotateX(object.rightRotation);
          }
          if (child.name == 'leftSmallArm') {
            if (object.leftRotation > 0) {
              child.rotateX(object.leftRotation / 2);
            }
          }
          if (child.name == 'rightSmallArm') {
            if (object.rightRotation > 0) {
              child.rotateX(object.rightRotation / 2);
            }
          }
          if (child.name == 'rightLeg') {
            child.rotateX(object.rightLegRotation);
          }
          if (child.name == 'leftLeg') {
            child.rotateX(object.leftLegRotation);
          }
          if (child.name == 'crus' && child.parent.name == 'leftLeg') {
            if (object.leftLegRotation > 0) {
              child.rotateX(-object.leftLegRotation);
            } else {
              child.rotateX(object.leftLegRotation / 2);
            }
          }
          if (child.name == 'crus' && child.parent.name == 'rightLeg') {
            if (object.rightLegRotation > 0) {
              child.rotateX(-object.rightLegRotation);
            } else {
              child.rotateX(object.rightLegRotation / 2);
            }
          }
          child.children.forEach(update);
        });
}
```



核心代码就是以上这些了，大家可以[点击这里]()查看完整代码。


## 回顾
以上就是层级建模的思路以及实现方法，主要是利用了矩阵乘法将节点间的世界变换矩阵和本地变换矩阵串联起来，从这里我们更能感受到矩阵和坐标系变换的重要性。

层级建模原理比较简单，但前提是大家深刻理解了矩阵的运算法则以及坐标系变换的原理本质。如果大家模棱两可，那说明还是没有真正掌握，还需要下功夫搞明白。





## 28.深入研究 --- 使用立方体纹理绘制天空盒

在初级进阶课程，我们学习了纹理的绘制方法，不过那节我们只学习了如何使用`2D纹理`进行贴图。事实上，WebGL 还支持将多个 2D 纹理组合成一个单一纹理，然后采用该单一纹理进行贴图，这种纹理称为立方体纹理`CubeMap`，本节我们学习如何使用立方体纹理进行贴图。

## 采样原理

在讲解贴图方法之前，我们简单了解一下立方体纹理的采样原理。立方体纹理实质上由 6 个 2D 纹理组成，这 6 个2D 纹理对应立方体的每个面，立方体纹理可以理解为 6 个面都是图像的立方体。

那如何对立方体纹理进行采样呢？首先，立方体纹理对应的 6 个图像资源宽度和高度要相等。其次，使用一束从立方体中心位置发出的方向向量进行采样，方向向量就是我们传递给 GPU 的纹理坐标，该向量和立方体交点处的图像像素就是我们需要的采样值。

> 当模型是单位为 1 的立方体时，模型的顶点坐标即立方体纹理坐标。

## 贴图过程
立方体纹理的贴图过程和之前的 2D 纹理贴图有所区别，接下来我们演示一下。
### 着色器
因为是纹理操作，所以着色器部分需要增加纹理坐标和纹理资源。

#### 顶点着色器
顶点着色器需要增加纹理坐标，立方体纹理的一个优点就是纹理坐标采用原始坐标值就可以。

```glsl
precision mediump float;
// 接收顶点坐标 (x, y, z)
attribute vec3 a_Position;
uniform mat4 u_Matrix;
varying vec3 textCoord;
void main(){
    gl_Position = u_Matrix * vec4(a_Position,1);
    // 将顶点原始坐标赋值给纹理坐标。
    textCoord = a_Position;
}
```

#### 片元着色器
片元着色器部分也比较简单，将立方体纹理上纹理坐标对应的颜色信息赋值给 gl_FragColor 作为像素颜色。

```glsl
precision mediump float;
//接收纹理坐标坐标 (x, y, z)
varying vec3 textCoord;
//samplerCube变量，用来接收立方体纹理。
uniform samplerCube u_Skybox;

void main()
{
    gl_FragColor = textureCube(u_Skybox, textCoord);
}
```

###  加载资源
和 2D 纹理一样，在使用纹理之前，我们还是要先把资源加载到内存中，由于立方体纹理需要 6 个图像，所以我们需要定义一个图像资源加载器，它包含一个资源列表和加载完成后的回调事件。

```javascript
function loadImages(imgList, callback){
    let i = 0;
    function ready (){
        if(i >= resourceList.length){
            callback();
            return;
        }
        i++;
    }
    for(let i =0;i<resourceList.length;i++){
        let img = new Image();
        img.onload = ready;
        img.src= resourceList[i];
    }
    
}
```

有了加载器，我们将需要的六张图片加载到内存中。

```javascript
loadImages(['right.png','left.png','top.png','down.png','back.png','front.png'], renderSkyBox);
```

> renderSkyBox是图片加载完成后执行的回调，也就是下面的绘制过程。

### 纹理操作
图片资源加载到内存之后，我们就可以对纹理进行操作了。

1、创建纹理对象，并激活 0 号纹理单元。

```javascript
//1、创建纹理对象
let texture = gl.createTexture();
//2、激活0号纹理单元
gl.activeTexture(gl.TEXTURE0);
//3、将 0 号纹理单元传入 GPU。
gl.uniform1i(u_Skybox, 0);
//4、当创建的纹理对象texture绑定到立方体纹理上
gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
```

2、将 6 个面对应的纹理图像传到 GPU

```javascript
gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, document.getElementById('sky0'));
gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, document.getElementById('sky1'));
gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, document.getElementById('sky2'));
gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, document.getElementById('sky3'));
gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, document.getElementById('sky4'));
gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, document.getElementById('sky5')); 
```

>这里要注意一点，sky4是背面图像，sky 5 是正面图像，我们需要将背面图像传递给正面纹理 `TEXTURE_CUBE_MAP_POSITIVE_Z` ，将正面图像传递给背面纹理`TEXTURE_CUBE_MAP_NEGATIVE_Z`。

3、设置图片放大缩小时的过滤参数，此处我们设置为就近取值。

```javascript
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
```

4、设置当纹理坐标没有落在任何一个面上，而是落在两个面之间时的纹理采样，使用gl.CLAMP_TO_EDGE 表示采用边缘的纹理像素。

```javascript
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
```

至此，纹理部分的操作就完成了，接下来我们要创建一个立方体代表天空盒，将图像贴在立方体的各个面上。

### 创建天空盒

我们先从立方体外部看一下立方体纹理的渲染效果，然后将摄像机放到立方体内部，讲解天空盒的实现方式。

#### 在外部观察天空盒

1、创建一个边长为 500 的立方体，并将立方体转化成无索引形式。

>边长长度没有限制，只要保证摄像机位置在立方体内部即可。

```javascript
//索引立方体
let cube = createCube(500, 500, 500);
//无索引立方体
cube = transformIndicesToUnIndices(cube);
// 创建顶点缓冲对象。
let bufferInfo = createBufferInfoFromObject(gl, cube);

// 创建渲染对象
let object = new Model('sky');
object.setBufferInfo(bufferInfo);
objectList.add(object);
renderList.add({
    programInfo: program,
    model: object,
    primitive: 'TRIANGLES',
    renderType: 'drawArrays'
});

```

2、创建摄像机

```javascript
let cameraPosition = new Vector3(0, 0, 600);
let target = new Vector3(0, 0, -1);
let up = new Vector3(0, 1, 0);
let cameraMatrix = matrix.lookAt(cameraPosition, target, up);
// 从相机矩阵取逆获取视图矩阵。
let viewMatrix = matrix.inverse(cameraMatrix);
```

3、创建视图投影矩阵，近平面20，远平面 900。

```javascript
let projectionMatrix = matrix.perspective(
    fieldOfViewRadians,
    window.innerWidth / window.innerHeight,
    20,
    900
);
```

4、设置 MVP 矩阵，执行渲染操作。

```javascript
object.uniforms.u_Matrix = matrix.multiply(projectionMatrix, viewMatrix);

renderList.forEach(function(object){
    ...略
})
```

以上就是主要代码，我们看下贴图效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/26/1674fabbc9ccfa10~tplv-t2oaga2asx-image.image)

可以看到， 6 张图像都能正确的贴到对应的面上。接下来，我们将摄像机位置逐步放到立方体内部，看看呈现给我们的是什么。

#### 在立方体内部观察。

在立方体内部观察时，呈现在我们面前的是天空盒的背面，但是由于背面剔除机制，我们是看不到背面的，所以这时候，我们要将背面剔除方式改成`正面剔除`：

```
gl.cullFace(gl.FRONT);
```

上面的摄像机坐标是在Z轴正向 600 单位距离处，接下来我们将摄像机慢慢靠近立方体，当到达立方体中心后停止，我们看下这个过程。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/26/16750530bccf4a98~tplv-t2oaga2asx-image.image)

可以看到，在内部观察时，会发现图像渲染是左右相反的，我们要修改一下顶点着色器，将纹理坐标的X值取反。

```javascript
textCoord = vec3(-a_Position.x, a_Postion.y, a_Position.z);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/26/1675056947d9c8fc~tplv-t2oaga2asx-image.image)

这次大家会发现，在外面观察立方体时图像左右相反了，内部观察时正常了。我们这次做天空盒，就要在立方体内部观察，只要内部观察正常就可以。

我们将视线水平旋转进行观察。

```javascript
target.x = Math.cos(deg2radians(uniforms.xRotation)) * Math.cos(deg2radians(uniforms.yRotation));
target.y = Math.sin(deg2radians(uniforms.xRotation));
target.z = Math.cos(deg2radians(uniforms.xRotation)) * Math.sin(deg2radians(uniforms.yRotation));
target.normalize();
// 重新计算视图矩阵

cameraMatrix = matrix.lookAt(cameraPosition, target, up);
viewMatrix = matrix.inverse(cameraMatrix);
```

效果如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/26/16750976f415f483~tplv-t2oaga2asx-image.image)

以上天空盒的实现方式，我们用稍微真实一些的图片演示一下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/26/167509bb8868ec11~tplv-t2oaga2asx-image.image)

## 渲染时机

上面的例子中，我们只绘制了天空盒，没有绘制其他物体，实际应用中往往还有其他物体存在。当然，我们不能够让物体阻挡天空盒的渲染。

在上面的例子里，我们增加一个箱子，该箱子是长宽高均为 20 的立方体，上面的天空盒是长宽高为 500 的立方体，很明显，箱子在天空盒内部。

同时，我们的摄像机在坐标系原点位置，所以为了能够看到箱子，我们需要将箱子往后移至少 10 个单位长度，这里我们将它往后移动 100 个单位

```javascript
let boxCube = createCube(20, 20, 20);
let boxBuffer = createBufferInfoFromObject(gl, boxCube);
...略

let box = new Model('box');
box.setBufferInfo(boxBuffer);
box.translateZ(-100);
```

此时包围盒和箱子的状态应该是这样的：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/167548478f7d265f~tplv-t2oaga2asx-image.image)

我们看下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/1675487b2a6f3e5e~tplv-t2oaga2asx-image.image)


盒子显示在了天空盒前面，但是有一点不正常，就是我们看不到盒子的正面了。原因是什么呢？

在绘制天空盒的时候，摄像机在盒子内部，所以需要看到盒子背面，而箱子在摄像机外部，正常情况要能够看到盒子正面，所以在绘制箱子时，我们要把背面剔除方式改回背面剔除：

```javascript
gl.cullFace(gl.BACK);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/27/167548cdb1688d85~tplv-t2oaga2asx-image.image)

这回正常了。

有时候，天空盒经过视图投影矩阵作用之后，不一定在场景的最后面（也就是 Z 值坐标不是 1.0），所以，在天空盒后面的物体我们就看不到了。针对这个问题，一般采取的做法是修改顶点着色器，将天空盒的 Z 值强制改为 1.0，即在裁剪坐标系的最后面。

```glsl
gl_Position = (u_Matrix * a_Position).xyww;
```

w/w = 1.0。所以经过裁剪变换后，gl_Position 的Z 值坐标始终会是 1.0。

那么，即便如此，也会有一些物体的 Z 值也是 1.0，同样是 1.0 的物体，哪个物体显示是根据绘制顺序决定的，因为深度测试函数默认是 gl.LESS，即当前片元的深度值要小于之前的深度值，才算测试通过，也就是能被渲染。所以，深度值是 1.0 的多个物体，哪个物体最先绘制，就渲染哪个物体。当然，我们可以改变深度测试函数。

针对种种规则，我们约定一个绘制顺序。



* 首先绘制物体（不包括天空盒）。
* 最后绘制天空盒，将天空盒的深度值和当前物体的深度值进行比较，如果通过深度测试就绘制天空盒。默认情况下，深度缓存为 1.0 表示深度最大，即在场景最后面。为了让天空盒能够通过深度测试，我们改变默认的深度测试函数，将`gl.LESS`改为`gl.LEQUAL`，如下：

```javascript
gl.depthFunc(gl.LEQUAL)
```


## 天空盒的应用

在实时场景渲染中，如果我们想要绘制非常远的物体，比如远山、天空等，当观察者往前或者往后移动时，远山、天空的大小是几乎没什么变化的。假如很远的地方有一座山，即使我们往前走进十米、百米，这座山在视野中的大小也是几乎没什么变化的，这个时候我们可以采用天空盒技术来实现。

又或者一些房屋装修、汽车内饰等只是为了展示环境的场景，这时也可以考虑采用天空盒技术。




## 回顾

本节讲述了立方体纹理的贴图过程以及天空盒的开发方式，涉及了前面的一些知识点，诸如`背面剔除`、`深度测试原理`等，如果我们对每一个知识点都能灵活运用的话，就能够实现很多强大的效果。







## 29.深入研究 --- 混合效果

到现在为止，我们还没有接触过如何为模型增加透明度效果，大家也许会说，在模型的顶点缓冲信息中，改变颜色的  `alpha` 值不就是增加透明度了吗？没错，透明度信息是这么传入着色器中的，但是仅仅有透明度信息，并不能实现透过前面透明物体看到后面物体的效果，我们只能改变前面物体的颜色，后面的物体在深度检测阶段会检测失败，相应的片段就会被抛弃，不被渲染。



## 片元舍弃

片元是像素的前置阶段，片元在成为屏幕像素之前要经历一些检测过程，如果检测失败的话 GPU 会舍弃该片元，从而不被渲染。也就是说片元要么显示，要么不显示，不存在片元混合的现象。比如前后两个物体，处于后面的物体，由于被前面物体遮挡，深度测试就会失败，GPU 便会舍弃该片元不再进行渲染。

### 深度检测
下面这个例子：

```javascript
let face1 = createFace(2, 3, 1, [255，0, 0, 125]);
let face2 = createFace(3, 2, 0, [0, 255, 0, 255]);
```

创建了两个矩形，`face1` 为世界空间下深度值为 1 的半透明红色矩形，`face2` 为世界空间下深度值为 0 的不透明绿色矩形，此时 face1 在face2 的前面。当开启深度检测的时候，`face1` 会遮挡住 `face2`，大家猜猜看能不能透过红色矩形看到后面的绿色矩形？

下图是显示结果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/23/1673fd14a34bb7cb~tplv-t2oaga2asx-image.image)

事实上，由于深度检测，尽管 face1 的颜色信息包含半透明，但是 GPU 检测到 face2 的片元在 face1 的后面，基于深度检测机制，GPU 舍弃了 face2 的片元，使得我们只能看到红色的face1。


### 主动舍弃片元

舍弃片元的时机除了深度测试不通过以外，我们还可以用编程的手段来主动舍弃。
这涉及到一个着色器命令`discard`。

下面这段代码演示了舍弃片元操作：

```glsl
varying vec4 v_Color;
uniform bool u_Discard;
void main(){
    if(v_Color.r < 0.8){
        if(u_Discard)
        discard;
    }
    gl_FragColor = v_Color;
}
```

当我们启用 discard 命令时候，片元着色器就会判断当前片元颜色的 r 分量是否小于 0.8 ，小于 0.8 的话，就将该片元舍弃不再渲染。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/22/1673b15f67a7f119~tplv-t2oaga2asx-image.image)

那么，如何实现真正的透明效果呢？这就是本节要讲的混合`Blending`技巧，混合的实质就是将前后多个重叠模型的颜色混合成一种新的颜色，该颜色包含前后多个模型的颜色信息。换句话说，这种技术能够实现透过透明物体（也可以是其他有透明度的物体）看到后面的物体效果。

## 透明度
我们知道，透明度是一个从 0 到 1 之间的浮点数，0 代表全透明，1 代表不透明，介于 0 和 1  之间的数值代表半透明。

全透明的特点是能够让后面物体的颜色完全体现出来，半透明效果体现的颜色则是透明物体和后面物体颜色的混合颜色，比如当透明度为 0.5 时，显示的颜色由自身颜色的一半和后面物体颜色的一半混合而成，不透明则是完全不显示后面物体的颜色成分。




## 如何实现混合
那么，如何实现颜色的混合呢？

首先我们需要开启混合特效。

```javascript
gl.enable(gl.BLEND);
```

接下来我们需要告诉 GPU 如何混合两种颜色。

下面是 WebGL 混合两种颜色的方式之一：

$
Result = C_{source} * F_{source} + C_{dest} * F_{dest}
$

>此处我们以相加的方式来混合两种颜色，事实上，WebGL 可以设置运算方式，不一定是相加，也可以是相减、取两者中较大值、取两者中较小值、以及一些逻辑运算等。

思考如下一个场景，有一个绿色物体，在它前面放一个透明度为 0.6 的红色玻璃，那么透过红色玻璃看到绿色物体的颜色是什么呢？我们找出公式中四个参数：


* $C_{source}$：源颜色，代表将要绘制的RGBA 颜色信息，用向量（Rs, Gs, Bs, As） 来表示，此处即红色玻璃的颜色RGBA（1， 0，0 ，0.6）。

* $F_{source}$：源因子，代表将要绘制的颜色的透明度，用向量（Sr, Sg, Sb, Sa）来表示，此处代表红色玻璃使用的透明度因子，我们可以采用玻璃自身的透明度，也可以重新设置。


* $ C_{dest}$：目标颜色的颜色信息，用向量（Rd, Gd, Bd, Ad）来表示，此处代表绿色物体的RGBA颜色。

* $F_{source}$：目标（绿色物体）颜色的透明度因子，用向量（Dr, Dg, Db, Da）来表示。通常我们用 1 减去源颜色（即玻璃）的透明度因子作为目标颜色的透明度因子，即(1- Sr, 1- Sg, 1- Sb, 1- Sa)。

需要记住的是，这四个参数都是 4 维向量，分别代表 RGBA 对应位置的信息。

#### 因子设置
那么，源颜色和目标颜色是已知的，我们只需要设置好源因子和目标因子就可以了，WebGL 为我们内置了一些因子：

|参数|值|
|--|--|
|gl.ZERO|(0,0,0,0)|
|gl.ONE|(1,1,1,1)|
|gl.SRC_COLOR|(Rs, Gs, Bs, As)|
|gl.DST_COLOR|(Rd, Gd, Bd, Ad)|
|gl.ONE_MINUS_SRC_COLOR| (1- Rs, 1- Gs, 1- Bs, 1- As)|
|gl.ONE_MINUS_DST_COLOR|(1- Rd, 1- Gd, 1- Bd, 1- Ad)|
|gl.SRC_ALPHA| (As, As, As, As)|
|gl.DST_ALPHA|(Ad,Ad, Ad, Ad)|
|gl.ONE_MINUS_SRC_ALPHA|(1-As, 1- As, 1- As, 1- As)|
|gl.ONE_MINUS_DST_ALPHA| （1-Ad, 1- Ad, 1- Ad, 1- Ad）|
|gl.CONSTANT_COLOR|常量颜色的RGBA值|
|gl.ONE_MINUS_CONSTANT_COLOR| 1 减去常量颜色的 RGBA值|
|gl.CONSTANT_ALPHA|常量透明度|
|gl.ONE_MINUS_CONSTANT_ALPHA|1减去常量透明度|

以上就是内置的因子系数，这些系数都是包含 4 个分量的向量。

>请一定要分清源颜色和目标颜色：
>* 源颜色：将要绘制的颜色，通常指将要绘制的拥有透明度物体的颜色。
>* 目标颜色：已经绘制的颜色，通常指被透明度物体盖住的后面物体的颜色。



有了这四个参数，GPU 就会按照如下公式替我们计算像素的最终颜色了：

$
\begin{aligned}
Result &= (1, 0, 0, 0.6) * (0.6, 0.6, 0.6, 0.6)\\\ \\\  &+ (0,1,0, 1) * (0.4,0.4,0.4,0.4) \\\
\\\
&=(0.6,  0.4,  0, 0.76)
\end{aligned}
$

> 源颜色因子和目标颜色因子也都是 4 维向量，也就是(0.6, 0.6, 0.6, 0.6)和(0.4, 0.4, 0.4，0.4）

上面我们是将源颜色和目标颜色的RGBA 信息乘以一个固定的向量因子，事实上，WebGL 允许我们单独为 RGB 和 Alpha 设置对应的因子，使用 `gl.blendFuncSeparate`函数可完成该功能。

```javascript
gl.blendFuncSeparate(src_rgb_factor,  des_rgb_factor, src_alpha_factor,  des_alpha_factor)
```

其中：
* src_rgb_factor: 代表源颜色的 RGB 因子。
* des_rgb_factor: 代表目标颜色的RGB 因子。
* src_alpha_factor：代表源颜色的透明度部分的因子。
* des_alpha_factor：代表目标颜色的透明度部分的因子。

假设我们需要将源颜色的 RGB 因子设置为源颜色的透明度，源颜色的透明度因子采用自身的透明度，目标颜色的 RGB 因子设置为 1，目标颜色的透明度因子设置为 0，那么我们可以这样设置：

```javascript
gl.blendFuncSeparate(gl.SRC_ALPHA,  gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ZERO);
```

#### 混合公式设置
上面我们以源颜色和混合颜色的加法公式来计算，WebGL 还提供了减法、逻辑运算等方式来计算最终颜色。使用gl.blendEquation来指定运算规则，规则有以下几种：

* gl.FUNC_ADD：相加。
    * 源颜色 * 源因子 + 目标颜色 * 目标因子
* gl.FUNC_SUBTRACT：相减。
    * 源颜色 * 源因子 - 目标颜色 * 目标因子
* gl.FUNC_REVERSE_SUBTRACT：反减。
    * 目标颜色 - 源颜色。


## 混合实战
以上就是混合的理论，比较简单，主要是针对颜色和透明度的设置，接下来，我们就要进入实战阶段了。

### 混合前的注意事项

在写代码之前，我们再回顾一下深度测试的概念。

深度测试是这样的，GPU 绘制一个像素点的时候，会先检测当前位置是否存在片元，如果存在片元，则比较即将绘制的片元与已经存在的片元之间的 Z 值深度，距离屏幕远的片元会被舍弃，保留距离近的片元，同时将深度缓存值更新为最近保留的片元深度，如此循环测试，最终保留离屏幕最近的片元，完成遮挡效果。

在混合之前，我们需要考虑这个问题。因为场景中透明物体和不透明物体的顺序是不确定的，那如何绘制才能保证正确的混合和正确的遮挡呢？

记住下面这两个准则：

* 透明物体在不透明物体前面时，混合颜色。
* 透明物体在不透明物体后面时，不混合颜色，采用深度检测遮挡。


对应的策略是：

* 将透明物体和不透明物体区分开。
* 首先开启深度更新功能`gl.depthMask(true)`，关闭混合功能`gl.disable(gl.BLEND)`。绘制所有不透明物体，绘制完后，深度缓存里保留的是离屏幕最近的物体的深度信息。
* 对透明物体由远及近进行排序。
* 开启混合功能，关闭深度更新功能，按照顺序对透明物体绘制。




### 绘制两个物体

准备两个物体，第一个物体是一个红色玻璃，透明度为 0.5，第二个物体是一个不透明的绿色箱子，红色玻璃在前，绿色箱子在后面。

```javascript
//开启混合功能
gl.enable(gl.BLENDING);
let face1 = createFace(2, 3, 1, [255，0, 0, 125]);
let face2 = createFace(3, 2, 0, [0, 255, 0, 255]);
```

源透明因子采用源目标的透明度，目标透明因子用 1减去源透明因子。

```javascript
gl.blendFunc(gl.SRC_ALPHA,  gl.ONE_MINUS_SRC_ALPHA);
```

#### 混合相加

设置成混合相加，这也是默认的混合方式：

```javascript
gl.blendEquation(gl.FUNC_ADD);
```

效果如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/23/1673fdcfcc0079d5~tplv-t2oaga2asx-image.image)


#### 混合相减

```javascript
gl.blendEquation(gl.FUNC_SUBTRACT);
```

效果如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/23/1673fe5af8bbf2ce~tplv-t2oaga2asx-image.image)

可以看到，中间相交部分的颜色变成了黑色，大家用上面的公式算一下就会理解。

$
\begin{aligned}
C_{result} &= (1 * 0.5 - 0 * 0.5, 0 * 0.5 - 1 * 0.5, 0 * 0.5 - 0 * 0.5, 0.5 * 0.5 - 0.5 * 1 )
\\\
& = (0.5, -0.5, 0, -0.25) \\\
& = (0.5, 0, 0, 0)
\end{aligned}
$

透明度是 0  ，所以显示黑色。

#### 混合反减

```javascript
gl.blendEquation(gl.FUNC_SUBTRACT);
```



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/23/167413c1cafef45e~tplv-t2oaga2asx-image.image)


红色相间部分为半透明绿色，验证步骤如下：

$
\begin{aligned}
C_{result} &= ( 0 * 0.5  - 1 * 0.5 ,  1 * 0.5 -  0 * 0.5,   0 * 0.5 - 0 * 0.5,   0.5 * 1 - 0.5 * 0.5 )\\\
& = (-0.5, 0.5, 0, 0.25) \\\
& = (0, 0.5, 0, 0.25)
\end{aligned}
$

### 回顾

本节，我们讲述了混合的使用技巧，学习了透明颜色的计算方式，并进一步理解了深度测试与深度保持的意义。

下一节，我们学习 WebGL 的另一个重要技术：`帧缓冲`。


## 3.初级入门 --- 绘制三角形：学会使用缓冲区、了解 WebGL 中的基本图形元素

上节带领大家学习了`点图元`的绘制过程，内容涉及到着色器的语法部分以及 JavaScript 操作 WebGL 的步骤。如果大家能够按照例子多练习几遍的话，之后的学习会更容易一些。

本节带大家练习绘制三角形，三角形的绘制比较简单。 因为它是 WebGL 提供给我们的基本图元之一，我们只需要给着色器提供三角形的顶点数据，调用 WebGL 的绘制命令 `gl.drawArrays` 即可。

## 目标
本节通过实现利用鼠标动态绘制三角形的功能，学习使用缓冲区向 GPU 中传递数据。最终效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc46e5a511b~tplv-t2oaga2asx-image.image)

* [演示地址](http://ifanqi.top/webgl/pages/lesson2.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson2.html)。

通过本节学习，你将会掌握如下内容：

* 三角形图元的分类。
* 使用缓冲区传递数据。
* 类型化数组的作用。
* 动态绘制三角形。



## 三角形图元的分类
WebGL 的基本图元包含点、线段、三角形，而三角形又分为三类

* 基本三角形
* 三角带
* 三角扇

那么，他们之间有什么区别呢？

* 基本三角形（TRIANGLES）

基本三角形是一个个独立的三角形，假如我们提供给着色器六个顶点，那么 WebGL 会绘制两个三角形，前三个顶点绘制一个，后三个顶点绘制另一个，互不相干。
举个例子来说，假如我们有六个顶点【v1, v2, v3, v4, v5, v6】，采用基本三角形图元进行绘制，绘制完是这个样子：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc0abecae80~tplv-t2oaga2asx-image.image)

 【v1, v2, v3】为一个三角形，【v4, v5, v6】 为另一个三角形。

`绘制三角形的数量 = 顶点数 / 3`。

* 三角带（TRIANGLE_STRIP）

同样是这六个顶点，如果采用三角带的方式绘制的话，则会绘制 【v1, v2, v3】, 【v3, v2, v4】, 【v3, v4, v5】, 【v5, v4, v6】 共计 4 个三角形，如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/22/16875b8e51710e48~tplv-t2oaga2asx-image.image)

`绘制三角形的数量 = 顶点数 - 2`

* 三角扇（TRIANGLE_FAN）

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc2bb044266~tplv-t2oaga2asx-image.image)

可以看出，三角扇的绘制方式是以第一个顶点作为所有三角形的顶点进行绘制的。采用三角扇绘制方式所能绘制的三角形的数量和顶点个数的关系如下：

`绘制三角形的数量 = 顶点数 - 2`


本节我们主要学习基本三角形图元的绘制。

## 绘制基本三角形



我们的目标是在 canvas 上点击三个位置作为三角形的三个顶点，然后绘制一个红颜色的三角形，本节还是不涉及深度信息（Z值），所以每个顶点我们只传入【x, y】坐标即可。

我们从简单之处着手，首先实现一个固定顶点坐标的三角形。

按照惯例，我们先准备着色器程序：

### 顶点着色器

```glsl
//设置浮点数据类型为中级精度
precision mediump float;
//接收顶点坐标 (x, y)
attribute vec2 a_Position;

void main(){
   gl_Position = vec4(a_Position, 0, 1);
}
```

### 片元着色器

```glsl
//设置浮点数据类型为中级精度
precision mediump float;
//接收 JavaScript 传过来的颜色值（rgba）。
uniform vec4 u_Color;

void main(){
   vec4 color = u_Color / vec4(255, 255, 255, 1);
   gl_FragColor = color;
}

```

### HTML 部分
HTML 部分还是包含一个 `canvas` 标签，以及存储片元和顶点着色器源码的 `script` 标签，和之前绘制点的内容大致相同，仅着色器源码有所差异。
为了节省篇幅，我们不贴这部分的源码了。

### JavaScript 部分

首先，定义三角形的三个顶点：

```
var positions = [1,0, 0,1, 0,0];
```

给着色器传递顶点数据和上节采用的方式不同，区别在于如何将三角形的三个顶点数据传递到顶点着色器中。  
按照惯例，我们还是先找到 a_Position 变量：

```javascript
var a_Position = gl.getAttribLocation(program, 'a_Position')
```

找到了该变量，接下来我们该怎么传递数据呢？按照上节绘制点的方式传递数据肯定不行了，因为这次我们要传递多个顶点数据。这里我们借助一个强大的工具`缓冲区`，通过缓冲区我们可以向着色器传递多个顶点数据。

首先创建一个缓冲区：

```javascript
var buffer = gl.createBuffer();
```
缓冲区创建好了，我们绑定该缓冲区为 WebGL 当前缓冲区 `gl.ARRAY_BUFFER`，绑定之后，对缓冲区绑定点的的任何操作都会基于该缓冲区（即buffer） 进行。

```javascript
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
```

接下来往当前缓冲区（即上一步通过 bindBuffer 绑定的缓冲区）中写入数据。


```javascript
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
```

>注意，着色器程序中的变量需要强类型数据，所以我们在往缓冲区写数据的时候，JS 的弱类型数组一定要用类型化数组转化一下。上面的 `new Float32Array(positions)`，目的就是将 JavaScript 中的弱类型数组转化为强类型数组。

总结一下这一系列步骤：

* 首先，创建了一个保存顶点坐标的数组，保存了三角形的顶点信息。
* 然后我们使用`gl.createBuffer`创建了一个缓冲区，并通过`gl.bindBuffer(gl.ARRAY_BUFFER, buffer)`绑定 `buffer` 为当前缓冲区。
* 之后我们用`new Float32Array(positions)`将顶点数组转化为更严谨的类型化数组。
* 最后我们使用 `gl.bufferData` 将类型化后的数组复制到缓冲区中，最后一个参数 `gl.STATIC_DRAW` 提示 WebGL 我们不会频繁改变缓冲区中的数据，WebGL 会根据这个参数做一些优化处理。

>以上这些代码属于初始化过程，在渲染过程中一般不会再次调用。

接下来，我们演示如何把顶点组成的模型渲染到屏幕上。

我们需要告诉 WebGL 如何从之前创建的缓冲区中获取数据，并且传递给顶点着色器中的 `a_Position` 属性。 那么，首先启用对应属性 `a_Position`：

```javascript
gl.enableVertexAttribArray(a_Position);
```

接下来我们需要设置从缓冲区中取数据的方式：

```javascript
//每次取两个数据
var size = 2;
//每个数据的类型是32位浮点型
var type = gl.FLOAT;  
//不需要归一化数据
var normalize = false; 
// 每次迭代运行需要移动数据数 * 每个数据所占内存 到下一个数据开始点。
var stride = 0;   
// 从缓冲起始位置开始读取     
var offset = 0; 
// 将 a_Position 变量获取数据的缓冲区指向当前绑定的 buffer。
gl.vertexAttribPointer(
   a_Position, size, type, normalize, stride, offset)
```


>需要注意的是，我们通过 `gl.vertexAttribPointer` 将属性绑定到了当前的缓冲区，即使之后我们使用 `bindBuffer` 绑定到其他缓冲区时，`a_Position` 也依然会从 `buffer` 这个缓冲区中获取数据。



这个函数比较关键，它决定了目标属性(本例是 a_Position )如何从缓冲区中读取数据，在这里我解释一下：

* gl.vertexAttribPointer (target, size, type, normalize, stride, offset)。
   	* target： 允许哪个属性读取当前缓冲区的数据。
   	* size：一次取几个数据赋值给 `target` 指定的目标属性。在我们的示例中，顶点着色器中 a\_Position 是 vec2 类型，即每次接收两个数据，所以 `size` 设置为 2。以后我们绘制立体模型的时候，a\_Position 会接收三个数据，size 相应地也会设置成 3。
   	* type：数据类型，一般而言都是浮点型。
   	* normalize：是否需要将非浮点类型数据`单位化`到【-1, 1】区间。
   	* stride：步长，即每个顶点所包含数据的字节数，默认是 0 ，0 表示一个属性的数据是连续存放的。在我们的例子中，我们的一个顶点包含两个分量，X 坐标和 Y 坐标，每个分量都是一个 Float32 类型，占 4 个字节，所以，stride = 2 * 4 = 8 个字节。但我们的例子中，缓冲区只为一个属性`a_Position`服务，缓冲区的数据是连续存放的，因此我们可以使用默认值 0 来表示。但如果我们的缓冲区为多个属性所共用，那么 stride 就不能设置为 0 了，需要进行计算。
   	* offset：在每个步长的数据里，目标属性需要偏移多少字节开始读取。在我们的例子中，buffer 只为 a_Position 一个属性服务，所以 offset 为 0 * 4 = 0。

假如我们的顶点数组为【10, 20, 30, 30, 40, 50, 60, 70】，每两个相邻数字代表一个顶点的 X 坐标和 Y 坐标。由于我们使用的是 Float32Array 浮点数组，每个数字占 4 个字节。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/6/165adbb47096a00f~tplv-t2oaga2asx-image.image" width="70%" height="70%">

上面也介绍了，stride 代表每个顶点数据所占用字节数：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/6/165adbb5478cdcb9~tplv-t2oaga2asx-image.image" width="60%" height="60%">

>这两个图应该能让大家更容易理解 stride 的计算方式。关于 `gl.vertexAttribPointer` 的使用方式我们先告一段落，下节我们再介绍用一个缓冲区为多个属性传递数据时，stride 和 offset 该如何计算。



言归正传，设置完变量和缓冲区的绑定之后，我们接下来编写绘制代码：

```javascript
//绘制图元设置为三角形
var primitiveType = gl.TRIANGLES;
//从顶点数组的开始位置取顶点数据
var offset = 0;
//因为我们要绘制三个点，所以执行三次顶点绘制操作。
var count = 3;
gl.drawArrays(primitiveType, offset, count);
```

大功告成，我们看下效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc7174338aa~tplv-t2oaga2asx-image.image)

>可以看出，使用 WebGL 绘制一个简单的三角形就需要很多代码。但请大家不要担心，代码固然多，但是很容易理解，而且这部分代码我们完全可以通过封装，减少调用。

大家看代码注释就能明白对应的含义，而且 GLSL 的语法也能够让人见名知意。本节不对 GLSL 做过多介绍。我会在之后的中级进阶里专门开辟一个章节详细介绍 GLSL 的语法细节。

一张图演示上面这个例子的数据传输过程：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8f2f0f0caff2~tplv-t2oaga2asx-image.image)

## 动态绘制三角形
到目前为止，我们已经实现了在屏幕上绘制一个固定三角形的功能，接下来我们实现动态绘制三角形，大家回想一下上节动态绘制点的逻辑，动态三角形的绘制和它基本类似。

### 着色器部分

* 顶点着色器增加一个变量用来接收 canvas 的尺寸，将 canvas 坐标转化为 NDC 坐标。

```glsl
//设置浮点数精度为中等精度
precision mediump float;
// 接收顶点坐标 (x, y)
attribute vec2 a_Position;
// 接收 canvas 的尺寸(width, height)
attribute vec2 a_Screen_Size;
void main(){
    vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0;
    position = position * vec2(1.0,-1.0);
    gl_Position = vec4(position, 0, 1);
}

```

* 片元着色器部分没有改动。

### JavaScript 部分
在 JavaScript 代码部分，我们多了一些交互操作：

* 鼠标点击 canvas，存储点击位置的坐标。
* 每点击三次时，再执行绘制命令。因为三个顶点组成一个三角形，我们要保证当顶点个数是3的整数倍时，再执行绘制操作。

关键代码如下：

```javascript
canvas.addEventListener('mouseup', e => {
    var x = e.pageX;
    var y = e.pageY;
    positions.push(x, y);
    if (positions.length % 6 == 0) {
      //向缓冲区中复制新的顶点数据。
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
        //重新渲染
        render(gl);
    }
})

//渲染函数
function render(gl) {
    gl.clearColor(0, 0, 0, 1.0);
    //用上一步设置的清空画布颜色清空画布。
    gl.clear(gl.COLOR_BUFFER_BIT);
    //绘制图元设置为三角形
    var primitiveType = gl.TRIANGLES;
    //从顶点数组的开始位置取顶点数据
    var drawOffset = 0;
    //因为我们要绘制 N 个点，所以执行 N 次顶点绘制操作。
    gl.drawArrays(primitiveType, 0, positions.length / 2);
}
```

至此，我们完成了动态绘制三角形的功能，效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/5/165a8dc46e5a511b~tplv-t2oaga2asx-image.image)


## 回顾

回顾一下我们本节学到的内容：

* 三角形图元分类
	* gl.TRIANGLES：基本三角形。
	* gl.TRIANGLE_STRIP：三角带。
	* gl.TRIANGLE_FAN：三角扇。
* 类型化数组的作用。
	* Float32Array：32位浮点数组。
* 使用缓冲区传递数据。
	* gl.createBuffer：创建buffer。
	* gl.bindBuffer：绑定某个缓冲区对象为当前缓冲区。
	* gl.bufferData：往缓冲区中复制数据。
	* gl.enableVertexAttribArray：启用顶点属性。
	* gl.vertexAttribPointer：设置顶点属性从缓冲区中读取数据的方式。
* 动态绘制三角形。
	* 改变顶点信息，然后通过缓冲区将改变后的顶点信息传递到着色器，重新绘制三角形。
	
## 思考与作业
大家有没有发现一些问题：

* 为什么绘制的所有三角形颜色都是一样的？
* 能不能不同的三角形显示不同的颜色？
* 同一个三角形能不能做成渐变色？

仔细思考一下，动手试试看。

下一节我们学习第三种基本图元：`线段`。





## 30.深入研究 --- 帧缓冲

在之前的章节中，我们已经接触过缓冲的概念了，比如顶点的坐标、颜色、法向量、纹理坐标等，今天我们学习一个新的缓冲概念：帧缓冲。

## 概念


顾名思义，帧缓冲（Frame Buffer Object）也是一个缓冲对象，不同于之前的缓冲，它相当于一个存在于内存中的不可见画布，我们可以先将即将绘制的内容绘制到帧缓冲中，然后对其做一些处理，之后，再将其绘制到画布上，这种方式让我们能够针对场景进行后处理，实现一些场景特效。


在之前的绘制过程中，渲染操作也是有帧缓冲的，只不过使用的是系统默认的帧缓冲。


显然，帧缓冲既然也是一块画布，那么它经常要和颜色打交道。因此，帧缓冲通常至少包含一个颜色缓冲区，除此之外，我们还需要一个图像载体，将图像绘制到载体上，载体分为两种，`纹理`和`渲染缓冲对象`。

纹理的优势是，我们可以在着色器中使用这个纹理，然后对其像素做后期处理。

渲染缓冲对象不能在着色器中使用，但是它有纹理不支持的特性，最大优点就是渲染缓冲所包含的各种数据是已经优化过的。

简单来说，帧缓冲就像提供给我们一个渲染前的画板，我们先在该画板上画好要显示的图像，满意之后再将它输出到屏幕上。

## 实战
我们将一幅图像用 2D 纹理渲染到自定义帧缓冲，同时将该自定义缓冲渲染到一个2D纹理，接下来再将帧缓冲对象绑定到默认帧缓冲，在默认帧缓冲上将上一步的纹理映射到一个立方体上，并在屏幕显示出来。

### 创建帧缓冲对象

首先创建帧缓冲对象，然后将该对象设置为绑定到`帧缓冲绑定点`。

```javascript
let frameBuffer = gl.createFrameBuffer();
gl.bindFrameBuffer(gl.FRAMEBUFFER, frameBuffer);
```

### 创建帧缓冲图像的写入纹理

接下来，我们创建一个纹理对象，并设置帧缓冲向纹理写入数据时的参数，最后将帧缓冲和纹理进行关联。

创建帧缓冲纹理

```javascript
let frameTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, frameTexture);
```

设置帧缓冲向纹理写入数据时的参数：

```javascript
// 绑定到第一个颜色附加区。
let attachmentPoint = gl.COLOR_ATTACHMENT0;
// 写入数据，注意初始化时应为 null。
let data = null;
// 绑定帧缓冲纹理作为当前纹理操作对象。
gl.bindTexture(gl.TEXTURE_2D, frameTexture);
// 设置写入参数，256 代表纹理的宽和高。
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,256, 256, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);

// 设置放大或者缩小时的算法
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

// 设置超出边界时的算法
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// 将纹理和帧缓冲绑定。
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);
```

做完这几步，当我们执行完drawArrays等渲染操作之后，帧缓冲中的数据就渲染到该纹理对象上了。

### 绘制帧缓冲
接下来，我们创建一个专门向帧缓冲纹理进行绘制的方法，该方法将向自定义缓冲渲染两个立方体。

```javascript
function drawFrame(){
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.clearColor(1,1,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.viewport(0, 0, 256, 256);
    ...绘制立方体，此处略。
}
```

你会发现，我们的每一个操作步骤都是有目的的：

* 首先将自定义帧缓冲对象绑定到帧缓冲绑定点上。
* 之后设置清屏颜色，进行颜色和深度信息的清除处理，主要是为了和画布的绘制进行区分。
* 最后还需要重新设置绘图区域大小，这步也很关键，不然你会发现渲染到纹理上的图像和我们期待的不一样。

### 绘制到画布
我们在默认缓冲绘制一个立方体，立方体每个面使用的纹理采用自定义缓冲渲染到的纹理。

```javascript
 gl.bindFramebuffer(gl.FRAMEBUFFER,null);
gl.bindTexture(gl.TEXTURE_2D, frameTexture);
gl.uniform1i(useTexture, true);
gl.clearColor(1, 1, 0, 1); gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        
gl.uniform1i(u_Skybox, 0);
...绘制立方体，此处略
```

你会发现，我们的步骤和渲染到纹理步骤有所区别：

* 首先将帧缓冲绑定到默认缓冲上。
* 其次绑定纹理对象为帧缓冲纹理，因为我们要将自定义帧缓冲渲染到立方体的每一个面上。
* 接着设置常量useTexture 为true，设置它为true是时才使用纹理。
* 设置清屏颜色，并进行清屏。
* 重新设置绘图区域。
* 将零号纹理传到着色器里。


### 效果


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/30/1676035df672709d~tplv-t2oaga2asx-image.image)

这就是最终渲染的效果，立方体的每个面上被自定义帧缓冲上的对象所填充。

### 加入深度缓冲
上面的例子，我们只为帧缓冲附加了颜色缓冲信息，事实上，帧缓冲还可以附加深度缓冲、模板缓冲。接下来，我们为帧缓冲加入深度缓冲信息。
我们用渲染缓冲对象保存深度缓冲信息，那么首先要创建渲染缓冲对象。

```javascript
// 创建一个深度缓冲
const renderBuffer = gl.createRenderbuffer();
gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
```

接下来，设置渲染缓冲对象的大小，这里和前面创建的纹理大小保持一致。

```javascript
// 设置深度缓冲的大小和帧缓冲纹理一致。
gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 256, 256);

```

最后，将渲染缓冲对象和帧缓冲对象进行关联。

```javascript
gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderBuffer);
```

#### 效果


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/30/167603d58b51e1f8~tplv-t2oaga2asx-image.image)

可以看到，两个立方体的深度信息显现出来了。


## 应用
那么，帧缓冲有什么好处呢？做了这个例子，大家心里也许已经有一些想法了。

在做一些赛车游戏时，如果玩家想从反光镜中看车后面的景色，这时候，帧缓冲就派上用场了。

再有，当我们需要对场景进行后期处理时，我们就可以 用帧缓冲渲染到纹理的方式，对纹理像素进行处理，实现某些特效，比如反向、模糊、黑白处理等。

## 回顾

以上就是帧缓冲的内容，概念有些抽象，但是大家可以通过一些例子来感受它的存在。

至此，小册内容就结束了，下一节，我会对所学内容做一个总结。






## 31.高级应用 --- 3D模型的拾取原理与实现

实际应用中，场景里的模型会越来越多，这时我们不可避免地需要一些交互效果，比如当点击某一个模型的时候，做出一些反馈，这需要我们能够通过鼠标的点击位置推导出点击到的模型，即距离我们最近的模型，这种技术称为 `3D 拾取`。

## 3D 拾取原理
先透露一下 3D 拾取原理的关键点，其实是一个几何知识：
`求射线与三角形的交点。`

为什么这么说呢？要理解这一点，大家还需要理解`坐标变换流水线`。

让我们回顾下`坐标变换流水线`，看它是如何将一个点一步步地呈现在屏幕上的。

## 坐标变换流水线
让我们回顾一下坐标变换流水线，看一下模型空间中一点 P0 到屏幕空间的转换步骤。
### 从模型空间到屏幕空间
在第十七节，我为大家讲述了点从模型空间到屏幕空间的变换步骤，文章里有如下一张图：
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/22/1669b4e4af96327b~tplv-t2oaga2asx-image.image)

#### 1、模型空间坐标转换成世界空间坐标
模型空间经过平移、缩放、旋转后，来到世界空间，该点在世界空间中的坐标为P1。
假设模型空间到世界空间的变换矩阵为 M，则有：
$
P1 = M \times P0
$
#### 2、世界空间坐标转换成观察空间坐标
将摄像机放在世界空间中的某个位置，以摄像机为原点建立观察坐标系，P0 在该空间下的坐标为 P2。

假设世界空间到观察空间的变换矩阵为 V，则有：

$
P2 = V \times P1
$

#### 3、观察空间坐标转换到裁剪空间坐标
该阶段以透视投影为例，P0 在该空间下的坐标为 P3。
假设观察空间到裁剪空间的变换矩阵为 P，则有：
$
P3 = P \times  P2
$

#### MVP 的由来
以上三个空间变换矩阵一般情况都是在 CPU 中进行运算，通常我们将其按照顺序相乘得到一个混合变换矩阵 MVP。

$
MVP = P \times M \times V
$

然后将该矩阵传递到GPU 中的顶点着色器程序中，将其与模型空间坐标相乘，得到裁剪空间坐标 P3。
#### 4、裁剪空间坐标转换成 NDC 空间坐标
裁剪空间坐标 P3 是一个 4 维齐次坐标，GPU 会自动将各个分量同时除以齐次坐标 w，得到 NDC 空间下的坐标 P4，P4 此时处于边长为 2 的立方中。
#### 5、NDC 空间坐标转换成屏幕坐标
NDC 空间坐标处于边长为 2 的立方体中，它的坐标原点在屏幕正中央，Y 轴正向朝上，X 轴向右为正。这和屏幕坐标有所区别，屏幕坐标以屏幕左上角为原点，X 轴向右为正，Y 轴向下为正，所以此处仍然需要转换。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/27/169bcf47c921c68f~tplv-t2oaga2asx-image.image)

需要特别记住的是，坐标流水线的第一步到第三步，通常由开发者去运算得出。第四步到第五步，通常是由 GPU 自行运算，运算规则也比较简单。

接下来我们反向执行该流水线操作，将屏幕上一点，反推到模型空间。
### 屏幕空间到模型空间

当我们在屏幕上点击时，得到一个屏幕坐标系（视口）上的二维坐标 $P_5$，接下来，我们需要沿坐标变换流水线的逆序进行操作。
#### 1、屏幕空间到 NDC 空间。
屏幕坐标 P5 经过变换到达 NDC 空间 P4。假设 P5 坐标为 【Xp5，Yp5】，屏幕宽度为sWidth，高度为 sHeight，那么有如下等式：

$
\frac{Xp5  }{ sWidth}  =
 \frac{Xp4 + 1}{ 2}
$
$
\frac{Yp5}{sHeight} =  \frac{- (Yp4 - 1)} {2}
$

所以，可以推出 P4 坐标：

$
Xp4 = \frac{2 \times Xp5}{sWdith - 1}
$
$
Yp4 = \frac{1- (2 \times Yp5) }{ sHeight}
$

#### 2、NDC 空间坐标转换到投影空间坐标
我们在屏幕上点击的坐标位置，可以理解为在投影空间的近裁剪平面上的点 P3。假设近裁剪平面 X 轴最小坐标为 Pl，最大坐标为 Pr，Y 轴最大坐标为 Yt，最小坐标为 Yb，则有如下等式：

$
\frac{Xp4  - (-1)} { 1 - (-1)} = \frac{Xp3 - Pl} { (Pr - Pl)}
$

$
\frac{Yp4 - (-1)} { (1 - (-1)} = \frac{Yp3 - Pb} { (Pt - Pb)}
$

所以，可以推断NDC 空间坐标在投影面上的坐标为：

$
Xp3 = \frac{Xp4 + 1} { 2 \times (Pr - Pl)} + Pl
$

$
Yp3 = \frac{Yp4 + 1} { 2} \times (Pt - Pb) + Pb
$

推断出 NDC 空间坐标在投影面上的 X、Y 轴坐标之后，我们就开始考虑为其扩展 3D 坐标 Z 值了。

因为近裁剪平面，Z 值是我们做投影变换矩阵的运算时选取的，所以，我们可以采用近裁剪平面的 Z 值作为 P3 的 Z 轴坐标。

至此，我们得到了投影空间坐标，投影空间坐标转换到观察空间坐标，只需一步，将 Z 轴坐标反向即可。

#### 投影空间坐标到观察空间坐标
转换到投影空间坐标为 P2，那么P2与 P3 的关系如下：

$
Xp2 = Xp3
$
$
Yp2 = Yp3
$

$
Zp2 = - Zp3
$

$
Wp2 = 1;
$

#### 3、观察空间转换到模型空间
观察空间转到到模型空间只需要乘以观察矩阵的逆矩阵，以及世界矩阵的逆矩阵即可。

### 3D 拾取步骤
以上就是流水线的正向与逆向转换过程，那么，我们只能对屏幕上一点进行逆向变换，无法对拿到物体的 Z 轴信息，那么如何进行检测呢？

你或许会发现，我们将摄像机原点与近裁剪平面的一点连起来，形成一条射线，指向视椎体，射线如果穿过视椎体中的距离近裁剪屏幕最近的模型，那么代表鼠标点选了该模型。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/23/16ae55ed7c8154a6~tplv-t2oaga2asx-image.image)

所以，我们需要构造这么一条射线，射线和模型检测时，需要在同一个坐标系，为了计算方便，我们将射线选取在观察坐标系中。

#### 一、将选取射线与物体转换到同一个坐标系中
首先射线的起点 E 在观察坐标系中代表原点，即 E = （0，0，0）。所以，我们只需要求出点击位置在观察坐标系的坐标即可求出射线。

##### 首先我们算出点在canvas 画布上的坐标位置，这里以一个铺满屏幕的画布举例：
```javascript
var x = e.clientX;
var y = e.clientY;
```
#####  将屏幕坐标转化为NDC 坐标
```javascript
//屏幕坐标转换为 CVV 坐标
function getCVVFromScreen(mouse) {
    var viewWidth = canvas.width;
    var viewHeight = canvas.height;
    var x = mouse.x;
    var y = mouse.y;
    var cvv = {x: 0, y: 0};
    cvv.x = x / (viewWidth / 2) - 1;
    cvv.y = 1 - y / (viewHeight / 2);
    return cvv;
}
// 屏幕坐标转化为NDC坐标
var cvv = getCVVFromScreen({x: x, y: y});
```


##### 根据 NDC 坐标求出该点在投影平面上的坐标
```javascript
function getProFromCVV(cvv, near, viewRadians) {
    //投影盒上边坐标
    var top = near * Math.tan(Math.PI / 180) * 0.5 * viewRadians;
    //投影盒高度
    var height = 2 * top;
    //投影盒宽度
    var width = aspect * height;
    //投影盒左边界坐标
    var left = -0.5 * width;

    var pro = {x: 0, y: 0};
    pro.x = ((cvv.x + 1) / 2) * width + left;
    pro.y = ((cvv.y + 1) / 2) * height + top - height;
    return pro;
}
```

##### 求出该点在相机坐标系的坐标
投影面上的坐标仅仅是 2 维坐标，我们需要经 2 维转化为 3 维，还记得我们从相机坐标到投影坐标的转换步骤吗？首先是设定了一个近裁剪平面：
```javascript
var near = 0.5;
var projectionMatrix = matrix.perspective(
    fieldOfViewRadians,
    aspect,
    near,
    2000
);
```
perspective 方法中的第三个参数 `0.5` 就是近裁剪平面，在上一步中求得的投影平面坐标所在的投影面在相机坐标系中的 Z 轴坐标即为 `0.5`。所以，我们把 2维投影平面坐标转化为 3 维相机坐标，仅需要增加一个 Z 轴坐标即可，Z 轴坐标为近裁剪平面坐标 `0.5`。

大家不要忘记了，投影空间是左手坐标系，相机空间是右手坐标系，所以，近裁剪平面的 Z 轴坐标在相机空间下要取相反数，即为 `-0.5`。

因此，顶点在相机坐标系下的坐标可以通过如上方法求得：

```javascript
// 投影坐标转化为相机坐标
function getViewFromPro(pro,near) {
    var point = new Vector3(pro.x, pro.y, -near);
    return point;
}
```
以上就是将鼠标点击屏幕坐标转变到相机空间坐标的推导过程，代码如下：

```javascript
    canvas.addEventListener('click', function(e) {
        var x = e.clientX;
        var y = e.clientY;
        // 屏幕坐标转化为NDC坐标
        var cvv = getCVVFromScreen({x: x, y: y});
        // NDC 坐标转化为投影坐标
        cvv = getProFromCVV(cvv, 0.5, 60);
        // 投影坐标转化为观察坐标
        cvv = getViewFromPro(cvv);
        // 构造观察坐标系下的射线
        var newRay = new Ray(
          new Vector3(0, 0, 0),
          new Vector3(cvv.x, cvv.y, cvv.z)
        );
        // 求出三角形的顶点 A 在观察坐标系中的坐标
        var a = new Vector4(positions[0], positions[1], positions[2]);
        a = matrix.applyMatrix(a, viewMatrix);
        a = V4toV3(a);
        // 求出三角形的顶点 B 在观察坐标系中的坐标
        var b = new Vector4(positions[3], positions[4], positions[5]);
        b = matrix.applyMatrix(b, viewMatrix);
        b = V4toV3(b);
        // 求出三角形的顶点 C 在观察坐标系中的坐标
        var c = new Vector4(positions[6], positions[7], positions[8]);
        c = matrix.applyMatrix(c, viewMatrix);
        c = V4toV3(c);
        // 求出射线与三角形相交交点
        var result = newRay.intersectTriangle(a, b, c);
        
        positions1[0] = result.x;
        positions1[1] = result.y;
        positions1[2] = result.z + 0.1;
        render(gl);
        renderPoint(gl);
        return cvv;
      });
```

接下来，我们还需要将模型坐标也转变到相机空间下，只有在同一个空间下坐标才能得到统一。模型坐标转变到相机空间比较简单，只需要将模型顶点乘以世界变换矩阵和相机变换矩阵即可，此处就不贴代码了。

#### 二、求出射线与三角形的交点
上面代码中有一段是射线与三角形相交算法，该类算法比较多，我们采用的是效率相对高一些的`Möller–Trumbore_intersection_algorithm` 算法，感兴趣的同学可以[点此查看](https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm)。

算法实现可以参照 [ThreeJS 的实现](https://github.com/mrdoob/three.js/blob/dev/src/math/Ray.js)，此处就不贴了。



### 一些优化
以上就是最简单的拾取原理，但实际上，场景模型比较多的时候，我们需要考虑如何高效的实现选取操作，这里面涉及很多策略，比如射线与包围球/盒相交的检测，模型按深度排序，按区域划分屏幕等等，这些优化方式的本质都是避免一些不必要的检测，本文不再一一介绍这些内容，感兴趣的同学可以翻看 ThreeJS 的源码，其中有这些算法的实现。



## 32.高级应用 --- 魔法 Shader：火焰效果的原理与实现

前面的一系列学习中，我们用到的着色器（Shader） 程序，仅仅是一些简单的着色器使用。但其实，着色器程序是实现各种特效的秘密武器，那么本节我 将带领大家学习一下 Shader 的深入使用。


### 片元着色器
很多特效事实上都是基于片元着色器来实现，所以我们着重讲解一下片元着色器。

接下来我们先了解一下片元着色器中的常用内置变量以及内置函数。

#### 内置变量
* gl_FragColor
* gl_FragCoord


#### 内置函数
着色器中有很多内置数学和几何函数，有一些是很常见且易于理解的，譬如如下几种：
* abs(x)
    * 返回绝对值。
* sin(x)
    * 返回对应弧度值的正弦值。
* cos(x)
    * 返回对应弧度值的余弦值。 
* mod(x, y)
    * 求模计算，返回 x - y * floor(x / y)，其实就是我们小学学的取余数。
    * 比如：mod(5, 10)，返回的模是 5。
* min
    * 返回两个数之间的最小值。 
* max
    * 返回两个数之前的最大值

但是还有一些很常用但是我们不太熟悉的函数，比如下面的这些函数：

* fract
    * 返回一个数的小数部分。
* mix
    * 接收三个参数：x，y，a
    * 返回（
* smoothstep(edge0, edge1, x)
    * 这个函数也很常用，主要用于平滑取值，当 x 小于edge0 时，返回 edge0，当 x 大于edge1 时，返回 edge1。当 x 介于 edge0 和 edge1 时，返回该区间内的平滑过渡值，并非线性值哦。


### 着色器的优势
有些同学见到这些函数可能会有想法了：

```!
 这些类型的函数计算我们完全可以在应用层面完成，为什么着色器语言还要再设计这么一套函数呢？
```

这个问题其实比较关键，是图形学编程中性能优化的一个参考基点。

这里给大家普及下 GPU 与 CPU 的区别。

首先，着色器程序运行在 GPU 上。

我想大家都知道 GPU 擅长图形运算，但不知大家有没有想过，为什么是 GPU 擅长而不是 CPU 呢？

原理就在于 GPU 的硬件设计，GPU 内部存在数以千计的微处理器，这些微处理器可以并行地同时执行一类相似的任务。也就是说，如果我们要对屏幕图像进行像素处理，让图像的每一个像素都变成红色，每一个像素的处理可以看成一个微任务，微处理器会并行执行这些任务，如果是 CPU 的话，恐怕要针对每一个像素的任务进行串行处理，显而易见，在重复简单任务的执行效率上，GPU 更胜一筹。



常用的一些数学函数我们就先介绍到这里，接下来，我们使用这些函数做一些效果，在实践中加深对这些函数的理解。

### 对角线的画法
先来实现一个特别简单的效果，我们使用着色器程序在屏幕上绘制一个对角线。

####  原理
实现这个效果有很多种方式，本节主要使用着色器程序实现。
原理很简单。
* 首先，在片元着色器中，获取每一个像素在屏幕上的坐标。利用 gl_FragCoord 内置变量来获取。
* 判断 X 轴坐标。
* 使用 mix 线性函数，求得 Y 轴坐标。
* 将符合 X、Y 轴坐标的像素，涂抹成待绘制的线条颜色。


#### 实现
* 顶点着色器代码

```glsl
precision highp float;
attribute vec3 a_Position;

void main () {
    gl_Position = vec4(a_Position, 1.0);
}
```
* 片元着色器代码

```glsl
precision highp float;
uniform vec2 u_Screen;

void main() {
    float y = mix(0., u_Screen.y, gl_FragCoord.x/u_Screen.x);
    if(abs(y - gl_FragCoord.y) <= 1.){
        gl_FragColor = vec4(0, 1, 1, 1);
    } else {
        gl_FragColor = vec4(0, 0, 0, 1);
    }
    return;
}
```

实现效果如下图：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/10/16e54c9a1a80e414~tplv-t2oaga2asx-image.image)

可以看出，画一个对角线，我们主要使用了 gl_FragCoord 内置变量，该变量可以让我们在片元着色器中拿到当前像素在绘制屏幕的坐标值。

然后我们通过线性计算 mix，计算出对角线上的 Y 轴坐标，并将处于对角线上点的颜色设置成我们需要的颜色。

### 抛物线的画法

接下来，我们提升下难度，看一下抛物线的绘制方法。

#### 原理

利用抛物线公式:

$y = ax^2 + bx + c$

将坐标符合以上抛物线公式求得的点，渲染成我们需要的颜色，即可绘制出一条抛物线来。

#### 实现
* 顶点着色器代码

```glsl
precision highp float;
attribute vec3 a_Position;

void main () {
    gl_Position = vec4(a_Position, 1.0);
}

```
* 片元着色器代码

```glsl
precision highp float;
// canvas 尺寸
uniform vec2 u_Screen;

void main () {
    // 求得符合抛物线公式的 Y 轴坐标。
    float y = -6.0 * pow((gl_FragCoord.x-u_Screen.x/2.)/u_Screen.x ,2.) + 0.5;
    //  将距离求得的 Y 轴坐标不超过 0.005 的点涂抹成我们需要的颜色，0.28 是抛物线和 X 轴的焦点，也就是说我们将 X 轴以上的抛物线部分绘制出来。
    if(abs(gl_FragCoord.y / u_Screen.y - y) <=0.005 && abs((gl_FragCoord.x-u_Screen.x/2.)/u_Screen.x)<=0.28){
        gl_FragColor = vec4(0,1,1,1);
    } else {
        gl_FragColor = vec4(0,0,0,1);
    }
    return;
}
```

效果如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/11/16e593b76337eac8~tplv-t2oaga2asx-image.image)

### 正弦波的画法

从上面大家可以看出，当我们想绘制一些曲线的时候，我们只需要找到对应的公式就可以了。

接下来，我们再学习绘制一个动态曲线，正弦波。

#### 原理
* 首先，根据当前点的 X 轴坐标，算出对应 X 轴坐标的正弦值，以该正弦值作为 Y 轴坐标的参照。
* 然后将当前点的 Y 轴坐标和第一步计算出来的正弦值作比较，相差不超过0.005 时，将该点渲染成期望的颜色。
* 我们每次都往着色器中传递一个时间参数 u_Time，通过它让正弦波动起来。

#### 实现

* 顶点着色器

```glsl
precision highp float;
attribute vec3 a_Position;

void main () {
    gl_Position = vec4(a_Position, 1.0);
}
```
* 片元着色器

```glsl
precision highp float;
uniform vec2 u_Screen;
uniform float u_Time;
const float PI = 3.1415926;

void main () {
    float x = gl_FragCoord.x +(u_Screen.x / 8.) * u_Time;
    float y = sin(8.* PI * (x-u_Screen.x)/u_Screen.x)+ 2.;
    
    if(abs(4. * gl_FragCoord.y / u_Screen.y - y) <=0.01 ){
        gl_FragColor = vec4(0,1,1,1);
    } else {
        gl_FragColor = vec4(0,0,0,1);
    }
}
```

效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/11/16e599972435ed5b~tplv-t2oaga2asx-image.image)

很简单有木有。

### 火焰效果实现

最后我们综合运用以上的函数和内置变量，讲解一下火焰效果的实现。

#### 原理
* 首先根据当前点的 X 轴坐标，计算出符合火焰抛物线性质的 Y 轴坐标。
* 将当前点的 Y 轴坐标和第一步计算出的 Y 轴坐标点作比较，如果这两个点的距离小于某个阈值，则将该点的颜色置为火焰颜色，为了做出一种平滑渐变的感觉，使用 smooth_step 计算火焰颜色。
* 弱化绿色通道的颜色，使火焰颜色偏红。


#### 实现

* 顶点着色器
```glsl
precision highp float;
attribute vec3 a_Position;

void main () {
    gl_Position = vec4(a_Position, 1.0);
}
```
* 片元着色器
```glsl
precision highp float;
uniform vec2 u_Screen;
varying vec3 v_Position;
uniform float u_Time;
const float PI = 3.1415926;

void main () {
    // 将坐标系坐标范围约束在【-4，4】和【-5，3】之间。
    vec2 pos = ( gl_FragCoord.xy / u_Screen.xy )*8.-vec2(4., 5.);
    if(pos.y>-5.){
        pos.y += 0.1 * sin(u_Time * 3.) + 0.13 * cos(u_Time * 2. + 0.6) + .1 * sin(u_Time * 3. + 0.4) + 0.2 * fract(sin(u_Time * 400.));
    }
    vec3 color = vec3(0., 0., 0.0);
    float y = -pow(pos.x, 3.2)/(0.008) * 3.3;
    //计算当前点与抛物线点的距离，并缩小距离范围。
    float dir = length(pos-vec2(pos.x, y)) * sin(0.3);
    if(dir < 0.7){
        color.rg += smoothstep(0.0,1.,.75-dir);
        //弱化绿色通道颜色
        color.g /=2.4;
    }
    //强化红色通道颜色。
    color += pow(color.r,1.1);
    gl_FragColor = vec4(vec3(color) , 1.0 );
}
```

最终效果如下：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/11/16e59ba223e08828~tplv-t2oaga2asx-image.image)


> 注意：在用 GLSL 实现一些复杂效果的时候，需要有一定的耐心，去调配各种参数。

### 总结

以上就是 GLSL 一些基本函数的使用，通过这些函数，我们可以实现很多特效。当然，这其中离不开数学公式，大家还是要多温习一下初中高中学过的数学函数，这样才更容易发挥想象力，实现各种各样的特效。



## 33.结束了吗？一切刚刚开始

至此，我们对 WebGL 的学习就告一段落了，坦白的说，我们还有一些 WebGL 细节没有在本小册呈现。但我相信，拥有了3D 数学的相关功底，你已经不再惧怕那些函数式 API 了，毕竟你连那么复杂的数学公式的推导过程都已经经历了。

当你看到本节时，我假设你已经掌握了以下内容：

* WebGL 的开发要素。
* 光照、颜色相关知识。
* GLSL 语言。
* 3D 数学算法实现。


此时你再去看一些 3D 框架，会对其中的概念有一见如故的感觉。不仅如此，我相信你会更容易地读懂它的源码。



## 下一步如何走

有的读者会问了，学完这些技术，下一步我该怎么走呢？我不能只是为了学习而学习吧。

首先，我必须要表扬你，你是有思想的同学。

学以致用是我们学习的目的。如果只学不用，那岂不是浪费我们宝贵的青春。

### 如果你并不专职 WebGL 领域
如果不打算转向 WebGL 领域，那么建议你使用数学库配合 CSS3 中的 3D 属性，为自己的页面增加一些令人耳目一新的 3D 效果，比如 3D 照片墙， WebVR 等。

#### 使用 CSS 技术实现 3D 效果
如果你不想使用 webgl 技术，那你仍然可以使用 css3 中的 `transform` 和 `perspective` 等 3D 属性来实现三维效果。

还记得吗？transform 属性是用来对 dom 进行变换的。它接收两类值，分别是 matrix 和 matrix3d，其中 matrix 代表 2D 变换，是一个 3 阶矩阵，我们需要为其传入 9 个数字。
matrix3d 代表 3D 变换，是一个 4 阶矩阵，我们需要为其传入 16 个数字。


在中级进阶阶段，我们学习了变换矩阵的推导公式。大家只需利用这些推导算法，计算出变换矩阵，然后将其转化成 matrix 或者 matrix3d 所接收的字符串格式，赋值给 transform 即可。

> 但请注意， matrix中包含 6 个数字，而非 3 阶矩阵中的 9 个数字。

####  css 中的摄像机
perspective 属性用来设置摄像机和屏幕之间的远近，通常是在 Z 轴
上的距离，关于摄像机的原理，我们也在坐标系变换章节中也进行了详细的讲解，相信大家不会再惧怕这个概念了。

我们可以对父容器的 perspective 设置视距，transform-style:preserve-3d 设置成 3D 显示效果。



###  如果你打算踏入 WebGL 编程领域
如果你真的打算专职 WebGL 编程领域，建议你按照下面的步骤进行深入学习。

* 深入了解 OpenGL 的底层知识。
* 熟练掌握 ThreeJS、Babylon 等框架提供的 API，如果有多余精力，再去深入学习它们的底层实现，相信你会有更多收获。
* 学会使用框架提供的模型拾取、碰撞检测等交互相关的关键技术。
* 做实际项目，只有在实战中才能大幅提升自己的技术。

#### 3D 小游戏

每一个前端同学的心里都有过做一款属于自己的游戏的想法，只是苦于自己能力有限，只能望洋兴叹。

但是现在的你，是有能力实现一些 3D 小游戏了，只要有了创意，就去试试吧。

## 一些学习网站
另外，提供一些 3D 资源，供大家学习：

* 框架：
	* [ThreeJS](https://github.com/mrdoob/three.js)
	* [BabylonJs](https://www.babylonjs.com/)
* 技术网站
	* [数学乐](https://www.shuxuele.com/algebra/matrix-inverse-minors-cofactors-adjugate.html) 
	* [WebGL 规范](https://www.khronos.org/registry/webgl/specs/latest/2.0/)
    * [OpenGL ES 规范](https://www.khronos.org/files/opengles_shading_language.pdf)
	* [一个很好的日文 WebGL 学习网站](https://wgld.org/d/webgl/)





## 4.初级入门 --- 基本图元绘制：线段

上节我们通过三角形的绘制方式，了解到 WebGL 开发的基本要素，以及如何通过缓冲区向着色器传递数据。本节我们学习最后一种基本图元`线段`。

本节内容虽然简单，但是我仍然想向那些钟爱 WebGL 的新手同学们详细地讲解一下，毕竟这是 WebGL 知识体系中的一部分，有经验的同学可以略过哈~
## 目标
本节通过鼠标点击动态绘制线段的示例，学习线段图元的分类以及绘制特点，效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676ef8587bbdd52~tplv-t2oaga2asx-image.image)

* [演示地址](http://ifanqi.top/webgl/pages/lesson5.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson5.html)

## 线段图元的分类

线段图元分为三种：

* LINES：基本线段。
* LINE_STRIP：带状线段。
* LINE_LOOP：环状线段。

接下来我们还是以实战为主，练习线段图元的绘制，并介绍他们之间的区别。

## LINES 图元
LINES 图元称为基本线段图元，绘制每一条线段都需要明确指定构成线段的两个端点。

我们还是通过每次点击产生一个点，并将点击位置坐标放进 positions 数组中。

>注意，我们的坐标还是相对于屏幕坐标系，顶点着色器中会将屏幕坐标系转换到裁剪坐标系，也就是坐标区间在[-1, 1]之间。

```javascript
var positions = [];
canvas.addEventListener('mouseup', e => {
    var x = e.pageX;
    var y = e.pageY;
    positions.push(x);
    positions.push(y);
    if (positions.length > 0) {
        gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.DYNAMIC_DRAW
    );
        render(gl);
    }
});
```



之后进行绘制，注意执行 drawArrays 时，图元参数应该设置为 gl.LINES。

```javascript
gl.drawArrays(gl.LINES, 0, positions.length / 2);
```



![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676edc8253ea74e~tplv-t2oaga2asx-image.image)


可以看到，每次点击两次之后才能绘制一条新的线段，也就是说，采用 gl.LINES 进行绘制的话，必须制定两个端点坐标。

基本线段图元的绘制比较简单，我们看一下`带状线段`的绘制特点。

### LINE_STRIP

`LINE_STRIP` 图元的绘制特点和 `LINES` 的有所区别，在绘制线段时，它会采用前一个顶点作为当前线段的起始端点。我们还是通过一个例子理解一下。

依然采用上面的代码，只不过这次在绘制时，将图元设置为 LINE_STRIP：

```javascript
gl.drawArrays(gl.LINE_STRIP, 0, positions.length);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676ee17d48e6893~tplv-t2oaga2asx-image.image)

可以看到，除了第一条线段需要指定两个端点，之后每次点击一个新的点，都会自动绘制一条新线段，新线段的起点是上一个线段的终点。

LINE_STRIP 也比较简单，接下来看下环状线段`LINE_LOOP`的特点。

### LINE_LOOP

顾名思义，环状线段除了包含 LINE_STRIP 的绘制特性，还有一个特点就是将线段的终点和第一个线段的起点进行连接，形成一个线段闭环。

废话不多说，看下效果大家就明白了。

>注意，不要忘记将绘制图元更改为 `LINE_LOOP`。

```javascript
gl.drawArrays(gl.LINE_LOOP, 0, positions.length);
```


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676eeb846ebcef3~tplv-t2oaga2asx-image.image)




## 回顾

线段图元的绘制方式到此就结束了，比较简单。我们可以用线段做路线标注，也可以用它绘制一些线状图形，再加上一些动画做出有创意的效果。

>事实上，webgl 的知识是有限的，但是我们的创意是无限的，有的时候并不需要技术多牛逼，只要创意够好，简单的技术也能实现让人惊艳的效果。

题外话：我一直觉得我的想象力是很差的，有时候还不如自己三岁的女儿。在做这个 demo 的时候，我女儿的一次胡乱点击，让我大吃一惊，她的绘制路径像极了一个五角星，我在此大致还原了一下她的点击路径：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/2/1676ef8587bbdd52~tplv-t2oaga2asx-image.image)

一个胖胖、扁扁的的五角星，PS：偷笑。

下一节进入本节的一个重点，我会通过绘制`渐变三角形`来带大家深入学习`顶点缓冲区`的使用，并解答第三章节的三个遗留问题。

## 5.初级入门 --- 绘制渐变三角形：深入理解缓冲区

上节带领大家学习了基本三角形图元的绘制过程，以及如何使用`缓冲区`向着色器传递多个数据，但上节只演示了往着色器传递`坐标`这一种数据，本节通过绘制渐变三角形，讲解一下如何通过缓冲区向着色器传递多种数据。

## 目标
本节通过一个鼠标每点击三次便会绘制一个渐变三角形的示例，带大家深入理解缓冲区的用法，最终效果如下图所示：
![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/10/165c2d31ba262d95~tplv-t2oaga2asx-image.image)


* [演示地址](http://ifanqi.top/webgl/pages/lesson4.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson4.html)

通过本节学习，你将会掌握如下内容：

* 顶点数据在 `buffer` 中的排布方式。
* 切换 `buffer` 时，`bindBuffer` 的重要性。
* 使用多个 `buffer` 读取多种顶点数据。
* 使用单个 `buffer` 读取多种顶点数据。
* 如何实现渐变效果。



## 渐变三角形

上节我们实现的是单色三角形，通过在片元着色器中定义一个 `uniform` 变量，接收 JavaScript 传递过去的颜色值来实现。那渐变三角形的处理与单色三角形有何不同呢？

渐变三角形颜色不单一，在顶点与顶点之间进行颜色的渐变过渡，这就要求我们的顶点信息除了包含`坐标`，还要包含`颜色`。这样在顶点着色器之后，GPU 根据每个顶点的颜色对顶点与顶点之间的颜色进行插值，自动填补顶点之间像素的颜色，于是形成了渐变三角形。

那既然我们需要为每个顶点传递坐标信息和颜色信息，因此需要在顶点着色器中额外增加一个 `attribute` 变量`a_Color`，用来接收顶点的颜色，同时还需要在顶点着色器和片元着色器中定义一个 varying 类型的变量`v_Color`，用来传递顶点颜色信息。

### 着色器
* 依然从顶点着色器开始，顶点着色器新增一个 attribute 变量，用来接收顶点颜色。

```	glsl
    //设置浮点数精度为中等精度。
    precision mediump float;
    //接收顶点坐标 (x, y)
    attribute vec2 a_Position;
    //接收浏览器窗口尺寸(width, height)
    attribute vec2 a_Screen_Size;
    //接收 JavaScript 传递的顶点颜色
    attribute vec4 a_Color;
    //传往片元着色器的颜色。
    varying vec4 v_Color;
    void main(){
      vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0;
      position = position * vec2(1.0,-1.0);
      gl_Position = vec4(position, 0, 1);
      v_Color = a_Color;
    }

```

* 片元着色器

片元着色器新增一个 varying 变量 `v_Color`，用来接收插值后的颜色。

```glsl
    //设置浮点数精度为中等。
    precision mediump float;
    //接收 JavaScript 传过来的颜色值（rgba）。
    varying vec4 v_Color;
    void main(){
      vec4 color = v_Color / vec4(255, 255, 255, 1);
      gl_FragColor = color;
   }
```

我们的着色器部分还是和之前一样简单，只是在顶点着色器中增加了顶点颜色这一变量。

接下来我们用 JavaScript 向着色器传递数据。

### JavaScript 部分
用缓冲区向着色器传递数据有两种方式：

* 利用一个缓冲区传递多种数据。
* 另一种是利用多个缓冲区传递多个数据。

上节绘制三角形的时候我们给顶点着色器传递的只是坐标信息，并且只用了一个 `buffer`，本节示例，我们除了传递顶点的坐标数据，还要传递顶点颜色。
按照正常思路，我们可以创建两个 `buffer`，其中一个 `buffer` 传递坐标，另外一个 `buffer` 传递颜色。


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/10/165c29bb2b8976b7~tplv-t2oaga2asx-image.image)

创建两个 `buffer`，将 `a_Position` 和 `positionBuffer` 绑定，`a_Color` 和 `colorBuffer` 绑定，然后设置各自读取 `buffer` 的方式。

>请谨记：程序中如果有多个 `buffer` 的时候，在切换 `buffer` 进行操作时，一定要通过调用 `gl.bindBuffer` 将要操作的 `buffer` 绑定到 `gl.ARRAY_BUFFER` 上，这样才能正确地操作 `buffer` 。您可以将 `bindBuffer` 理解为一个状态机，`bindBuffer` 之后的对 `buffer` 的一些操作，都是基于最近一次绑定的 `buffer` 来进行的。

以下 `buffer` 的操作需要在绑定 `buffer` 之后进行：

>* gl.bufferData：传递数据。
>* gl.vertexAttribPointer：设置属性读取 buffer 的方式。


#### 方式一：多个 buffer 传递

* [示例代码](https://github.com/lucefer/webgl/blob/master/pages/lesson3.html)
* [演示地址](http://ifanqi.top/webgl/pages/lesson3.html)

我们使用一个 buffer 传递坐标信息，另一个 buffer 传递颜色信息。




```javascript
// 创建 坐标信息 buffer
var positionBuffer = gl.createBuffer();
// 将当前 buffer 设置为 postionBuffer，接下来对 buffer 的操作都是针对 positionBuffer 了。
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
// 设置 a_Position 变量读取 positionBuffer 缓冲区的方式。
var size = 2;
var type = gl.FLOAT;
var normalize = false;
var stride = 0;
var offset = 0;
gl.vertexAttribPointer(
      a_Position, size, type, normalize, stride, offset);
      
// 创建 颜色信息 buffer
var colorBuffer = gl.createBuffer();
// 将当前 buffer 设置为 postionBuffer，接下来对 buffer 的操作都是针对 positionBuffer 了。
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
// 设置 a_Position 变量读取 positionBuffer 缓冲区的方式。
var size = 4;
var type = gl.FLOAT;
var normalize = false;
var stride = 0;
var offset = 0;
gl.vertexAttribPointer(
      a_Color, size, type, normalize, stride, offset);

```

>gl.vertexAttribPointer(
      a_Color, size, type, normalize, stride, offset)。这个方法比较重要，上节已经向大家详细介绍了，如果还不太明白的，可以再次回顾下上节内容。
      
我们发现，上面代码对 `buffer` 的操作有些冗余，我们还是提取出一个方法 `createBuffer` 放到 `webgl-helper.js`，减少重复编码，之后我们对 `buffer` 的一系列调用只需要如下两句就可以了：


```javascript
var positionBuffer = createBuffer(gl, a_Position, { size: 2});
var colorBuffer = createBuffer(gl, a_Color, { size: 4});

```


假如我们顶点坐标数组中有四个顶点 8 个元素【30, 30, 30, 40, 40, 30, 20, 0】，顶点着色器中的 `a_Position` 属性在读取顶点坐标信息时，以 2 个元素为一组进行读取：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/10/165c2c5f0e0528c1~tplv-t2oaga2asx-image.image)



又假如我们顶点颜色数组中有两个顶点 8 个元素 【244, 230, 100, 1, 125, 30, 206, 1】，那么顶点着色器中的 `a_Color` 属性在读取顶点颜色信息时，以 4 个元素（r, g, b, a）为一组进行读取，如下图所示。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/10/165c2c5fe4a7d8cf~tplv-t2oaga2asx-image.image)

>以多少元素作为一个顶点信息进行读取的设置，是在调用 `gl.vertexAttribPointer` 时设置的 `size` 参数值。


言归正传，接下来我们为 `canvas` 添加点击事件：

```javascript
canvas.addEventListener('click', e => {
    var x = e.pageX;
    var y = e.pageY;
    positions.push(x, y);
    //随机一种颜色
    var color = randomColor();
    //将随机颜色的 rgba 值添加到顶点的颜色数组中。
    colors.push(color.r, color.g, color.b, color.a);
    //顶点的数量是 3 的整数倍时，执行绘制操作。
    if (positions.length % 6 == 0) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
        render(gl);
    }
})
```

万事俱备，只欠绘制：

```javascript
    function render(gl) {
      //用设置的清空画布颜色清空画布。
      gl.clear(gl.COLOR_BUFFER_BIT);
      if (positions.length <= 0) {
        return;
      }
      //绘制图元设置为三角形。
      var primitiveType = gl.TRIANGLES;
      //因为我们要绘制三个点，所以执行三次顶点绘制操作。
      gl.drawArrays(primitiveType, 0, positions.length / 2);
    }
```

至此，三角形的渐变效果就实现啦。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/10/165c2d31ba262d95~tplv-t2oaga2asx-image.image)

#### 另一种思路：使用 1 个 buffer 同时传递坐标和颜色信息

* [示例代码](https://github.com/lucefer/webgl/blob/master/pages/lesson4.html)
* [演示地址](http://ifanqi.top/webgl/pages/lesson4.html)

常规思路使用多个 `buffer` 传递多种数据（坐标和颜色），我们再演示另外一种思路：使用 1 个 `buffer` 同时传递多种数据。

着色器部分的代码和上面的一样，无需改动，改动的主要部分是 JavaScript 程序。

首先，我们依然是创建 `buffer`，只不过这次是创建一个 `buffer`。

```javascript
var buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
```

创建完 `buffer`，接下来设置读取 `buffer` 的方式，我们有两个属性 `a_Position`、`a_Color`，由于我们只有一个 `buffer`，该 `buffer` 中既存储坐标信息，又存储颜色信息，所以两个属性需要读取同一个 `buffer`：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/10/165c2e171e604257~tplv-t2oaga2asx-image.image)

我们可以看到，一个顶点信息占用 6  个元素，前两个元素代表坐标信息，后四个元素代表颜色信息，所以在下面设置属性读取 `buffer` 方式时，`a_Color` 和 `a_Position` 的设置会有不同：

* a_Position：坐标信息占用 2 个元素，故 size 设置为 2。
坐标信息是从第一个元素开始读取，偏移值为 0 ，所以 offset 设置为 0.
* a_Color：由于 color 信息占用 4 个元素，所以 size 设置为 4 。
color 信息是在坐标信息之后，偏移两个元素所占的字节（2 * 4 = 8）。所以，offset 设置为 8。

* stride：代表一个顶点信息所占用的字节数，我们的示例，一个顶点占用 6 个元素，每个元素占用 4 字节，所以，stride = 4 * 6 = 24 个字节。


```javascript
gl.vertexAttribPointer(
      a_Color, 4, gl.FLOAT, false, 24, 8);
      
gl.vertexAttribPointer(
      a_Position, 2, gl.FLOAT, false, 24, 0);

```

`canvas` 的点击事件也有所不同，一个顶点占用 6 个元素，三个顶点组成一个三角形，所以我们的 `positions` 的元素数量必须是 18 的整数倍，才能组成一个三角形：

```javascript
    canvas.addEventListener('click', e => {
      var x = e.pageX;
      var y = e.pageY;
      positions.push(x);
      positions.push(y);
      //随机出一种颜色
      var color = randomColor();
      //将随机颜色的 rgba 值添加到顶点的颜色数组中。
      positions.push(color.r, color.g, color.b, color.a);
      //顶点的数量是 18 的整数倍时，执行绘制操作。
      if (positions.length % 18 == 0) {
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        render(gl);
      }
    })
```

实现效果和上面操作多缓冲区的方式一样，但是单缓冲区不仅减少了缓冲区的数量，而且减少了传递数据的次数以及复杂度。



## 回顾
至此，我们对缓冲区的讲解就结束了，本节所讲知识点和上节基本类似，不同点在于用单个缓冲区传递多类数据时，`gl.vertexAttribPointer` 各个参数如何设置，理解这点对我们以后编程十分有用，希望大家课下多多练习，深刻理解它的用法。

到目前为止，我们掌握了三角形的绘制方法，接下来学习怎样用三角形构建其他图形。

下一节我们将从简单平面开始：先用三角形构建一个矩形。

## 6.初级入门 --- 画个矩形：用基本图形构建平面

上节带领大家学习了基本三角形图元的绘制方法，并讲解了如何使用缓冲区向着色器传递多种数据，本节我们开始学习如何使用三角形构建矩形。

## 目标

上节我们通过创建多个 `buffer` 实现渐变三角形的绘制，本节我们以矩形为例，掌握用三角形构建平面的方法。

>本节示例较多，因此将`演示地址`和`源码地址`放在相应段落中，此处暂不列举。

通过本节学习，你会掌握如下内容：

* 通过基本三角形绘制矩形的思路。
* 索引绘制的使用方法。
* 使用三角带绘制矩形。
* 使用三角扇绘制矩形。
* 绘制圆形。
* 绘制环形。
* 顶点顺序的不同有什么影响。

## 基本三角形构建矩形




我们知道，一个矩形其实可以由两个共线的三角形组成，即 `V0, V1, V2, V3`，其中 `V0 -> V1 -> V2` 代表三角形A，`V0 -> V2 -> V3`代表三角形B。


<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/11/165c77b134803832~tplv-t2oaga2asx-image.image" width="100%" />

>请谨记，组成三角形的顶点要按照一定的顺序绘制。默认情况下，WebGL 会认为顶点顺序为逆时针时代表正面，反之则是背面，区分正面、背面的目的在于，如果开启了背面剔除功能的话，背面是不会被绘制的。当我们绘制 3D 形体的时候，这个设置很重要。关于背面剔除功能，我们在[绘制立方体章节](https://juejin.cn/book/6844733755580481543/section/6844733755924414477)再进行讲解。

### 着色器

着色器部分和上节绘制三角形一样，没有变动。

* 顶点着色器
	* a_Position
	* a_Color
	* a\_Screen_Size
	* v_Color
* 片元着色器
	* v_Color

### JavaScript 部分

仍然从简单之处着手，绘制固定顶点的矩形。

首先准备组成矩形的三角形，每个三角形由三个顶点组成，两个矩形共需要六个顶点。

```javascript
var positions = [
	30, 30, 255, 0, 0, 1,    //V0
	30, 300, 255, 0, 0, 1,   //V1
	300, 300, 255, 0, 0, 1,  //V2
	30, 30, 0, 255, 0, 1,    //V0
	300, 300, 0, 255, 0, 1,  //V2
	300, 30, 0, 255, 0, 1    //V3
]
```

我们给两个三角形设置不同颜色，其中，`V0->V1->V2` 三角形设置为红色， `VO->V2->V3` 三角形设置为绿色。

> 本节我们依然用单 buffer 来处理数据传递过程。

代码和上节基本一致，只是我们的顶点数组 `positions` 不再是动态更新的，而是固定的。

我们看下效果：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/11/165c7aa32f1a98f9~tplv-t2oaga2asx-image.image" width="80%" />

很简单，我们用两个基本三角形就实现了矩形的绘制。

### 索引方式绘制

* [示例代码](https://github.com/lucefer/webgl/blob/master/pages/lesson7.html)
* [演示地址](http://ifanqi.top/webgl/pages/lesson7.html)

不知道大家有没有发现，我们在绘制一个矩形的时候，实际上只需要 `V0, V1, V2, V3` 四个顶点即可，可是我们却存储了六个顶点，每个顶点占据 4 * 6 = 24 个字节，绘制一个简单的矩形我们就浪费了 24 * 2 = 48 字节的空间，那真正的 WebGL 应用都是由成百上千个，甚至几十万、上百万个顶点组成，这个时候，重复的顶点信息所造成的内存浪费就不容小觑了。

那有没有其他的方式改进一下呢？

答案当然是肯定的，WebGL 除了提供 `gl.drawArrays` 按顶点绘制的方式以外，还提供了一种按照`顶点索引`进行绘制的方法：`gl.drawElements`，使用这种方式，可以避免重复定义顶点，进而节省存储空间。我们看下 gl.drawElements 的使用方法，详细解释参见[MDN](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements)。

>void gl.drawElements(mode, count, type, offset);

* mode：指定绘制图元的类型，是画点，还是画线，或者是画三角形。
* count：指定绘制图形的顶点个数。
* type：指定索引缓冲区中的值的类型,常用的两个值：`gl.UNSIGNED_BYTE`和`gl.UNSIGNED_SHORT`，前者为无符号8位整数值，后者为无符号16位整数。
* offset：指定索引数组中开始绘制的位置，以字节为单位。 

举例来说：

```javascript
gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_BYTE, 0);
```

这段代码的意思是：采用`三角形图元`进行绘制，共绘制 `3` 个顶点，顶点索引类型是 `gl.UNSIGNED_BYTE`，从`顶点索引数组的开始位置`绘制。


### 使用 drawElements 绘制矩形

纸上得来终觉浅，绝知此事要躬行，我们改进下绘制矩形的例子，来学习 drawElements 的用法。



#### 着色器

着色器部分依然不需要改动。

#### JavaScript部分

我们的 JavaScript 部分要有所改变了，采用索引绘制方式，我们除了准备存储顶点信息的数组，还要准备存储顶点索引的数组。

```javascript
//存储顶点信息的数组
var positions = [
    30, 30, 255, 0, 0, 1,    //V0
    30, 300, 255, 0, 0, 1,   //V1
    300, 300, 255, 0, 0, 1,  //V2
    300, 30, 0, 255, 0, 1    //V3
];
//存储顶点索引的数组
var indices = [
    0, 1, 2, //第一个三角形
    0, 2, 3  //第二个三角形
];
```

除了多准备一个数组容器存储顶点索引以外，我们还需要将索引传递给 GPU，所以，仍然需要创建一个索引 `buffer`.

```javascript
var indicesBuffer = gl.createBuffer();
```

按照惯例，创建完 buffer，我们需要绑定，这里要和 `ARRAY_BUFFER` 区分开来，索引 buffer 的绑定点是`gl.ELEMENT_ARRAY_BUFFER`。

```javascript
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);
```

接下来，我们就可以往 indicesBuffer 中传入顶点索引了：

```javascript
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
```

之后执行绘制操作：

```javascript
gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
```


我们看下效果：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/11/165c817552d7e47b~tplv-t2oaga2asx-image.image" width="80%" />

矩形能够绘制出来，但是颜色和我们之前的矩形有些不同，第二个三角形从红到绿渐变。

仔细回顾一下，我们用 drawArrays 进行绘制的时候，使用了六个顶点，每个三角形的顶点颜色一致，所以两个三角形的颜色都是单一的。
当采用 `drawElements` 方法进行绘制的时候，使用了四个顶点，第二个三角形的两个顶点 V0、V2 是红色的，第三个顶点 V3 是绿色的，所以造成了从 V0、V2 向 V3 的红绿渐变。

如果我们必须要实现两个不同颜色的单色三角形，还是应该用六个顶点来绘制，这时，使用 drawArrays 的方式更优一些。毕竟，不用创建索引数组和索引缓冲。

## 使用三角带构建矩形


* [演示地址](http://ifanqi.top/webgl/pages/lesson8.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson8.html)

我们学习了使用基本三角形绘制矩形的方法，接下来我们尝试一下使用三角带绘制矩形。




前面我们讲过，三角带的绘制特点是前后两个三角形是共线的，并且我们知道顶点数量与绘制的三角形的数量之间的关系是：

>顶点数或者索引数 = 三角形数量 + 2

仍然以绘制矩形为目标，如果采用基本三角形进行绘制的话，需要准备六个顶点，即两个三角形。那如果采用三角带进行绘制的话，利用三角带的特性，我们实际需要的顶点数为 2 + 2 = 4，即矩形的四个顶点位置。

>切记，顶点顺序不能乱哦。

画图看下组成矩形的三角形顶点的顺序

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/12/165cc89ab4b4a667~tplv-t2oaga2asx-image.image" width="100%" />

由上图可以看出，绘制三角带图元的时候，V0->V1->V2 组成第一个三角形，V2->V1->V3 组成第二个三角形。

三角带与基本三角形绘制在代码上的区别有两点：

* 顶点数组的数据不同。
* drawArrays 的第一个参数代表的图元类型不同。
	* 基本三角形：TRIANGLES。
	* 三角带：TRIANGLE_STRIP。
	* 三角扇：TRIANGLE_FAN。

#### 关键代码

先看顶点数组：

```javascript
var positions = [
    30, 300, 255, 0, 0, 1,   //V0  
    300, 300, 255, 0, 0, 1,  //V1
    30, 30, 255, 0, 0, 1,    //V2
    300, 30, 0, 255, 0, 1    //V3
]

```

再看绘制方法：

```javascript
gl.drawArrays(gl.TRIANGLE_STRIP, 0, );
```

绘制方法改动不大，我们看下效果：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/12/165ccbd7f9d1c5ea~tplv-t2oaga2asx-image.image" width = "80%" />



读者可能会问了，我能不能用 `V1->V2->V0` 绘制第一个三角形，`V0->V2->V3`绘制第二个三角形呢？

如果按照这个顺序绘制的话，按照三角带的绘制特点，`V0->V2` 这条线段是第二个三角形和第一个三角形的共线。

先不急着编码验证，我们画图看下效果：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/12/165ccc64b99747b5~tplv-t2oaga2asx-image.image" width ="100%" />

如果你太确定，我们验证一下：

```javascript
var positions = [
   300, 300, 255, 0, 0, 1,  //V1
   30, 30, 255, 0, 0, 1,    //V2
   30, 300, 255, 0, 0, 1,   //V0
   300, 30, 0, 255, 0, 1    //V3
]

```

我们把 V0 移到第三个位置，看下效果：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/12/165ccc8edafdb9fa~tplv-t2oaga2asx-image.image" width="80%" />

这和我们推演的效果相同，可以看出，使用三角带进行绘制时，一定要注意顶点的顺序，顶点顺序稍有差错，绘制出来的效果就与实际期待的大不相同。


## 三角扇绘制矩形

* [演示地址](http://ifanqi.top/webgl/pages/lesson9.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson9.html)

基本三角形和三角带绘制矩形的原理讲完了，还有一种图元方式：三角扇，它是否也能绘制矩形？

我们在`绘制三角形`章节讲到，三角扇是围绕着第一个顶点作为公共顶点绘制三角形的，并且使用`三角扇`绘制出来的三角形的数量和顶点数量之间的关系和`三角带`一样：

>顶点数或者索引数 = 三角形数量 + 2



我们看下三角扇绘制矩形时的顶点分布以及顺序：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/12/165cce3f472a4f47~tplv-t2oaga2asx-image.image" width="100%" />

可以看出，使用三角扇需要绘制 4 个三角形，相应地顶点数量为 6 个：

 
| 三角形            | 顶点组成             |
| ---------------- | -------------       | 
| 左边三角形         |  V0 -> V1 -> V2    | 
| 上边三角形         |  V0 -> V2 -> V3    | 
| 右边三角形      	  |  V0 -> V3 -> V4     |
| 下边三角形        |  V0 -> V4 -> V1     | 

需要的顶点数组为

```javascript
var positions = [
    165, 165, 255, 255, 0, 1, //V0
    30, 30, 255, 0, 0, 1,    //V1
    30, 300, 255, 0, 0, 1,   //V2
    300, 300, 255, 0, 0, 1,  //V3
    300, 30, 0, 255, 0, 1,   //V4
    30, 30, 255, 0, 0, 1,    //V1
]
```
 
绘制方式改为三角扇：

```javascript
gl.drawArrays(gl.TRIANGLE_FAN, 0, positions.length / 6);
```

效果如下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/12/165cce8c33f5df5e~tplv-t2oaga2asx-image.image" width = "80%" />

>可以很明显的看出四个三角形都以中心点为顶点。

#### 顶点顺序
其实不管是使用三角扇还是基本三角形，又或者是三角带绘制的时候，一定要保证顶点顺序是逆时针。如果三角形的顶点顺序不是逆时针，在开启背面剔除功能后，不是逆时针顺序的三角形是不会被绘制的。

我们不妨试一下，改变顶点顺序，将他们之间的关系从逆时针改为顺时针：

```javascript
var positions = [
    165, 165, 255, 255, 0, 1, //V0
    30, 300, 255, 0, 0, 1,   //V2
    30, 30, 255, 0, 0, 1,    //V1
]
```

如果不开启背面提剔除功能，会发现三角形依然能够绘制，不受顺序的影响。

开启背面剔除功能：

```javascript
gl.enable(gl.CULL_FACE);
```

开启后，可以发现页面空空如也，三角形没有被绘制。


当然，我们也可以更改面的显示方式，默认显示正面，我们可以通过如下方式，剔除正面，只显示背面：

```javascript
gl.cullFace(gl.FRONT);
```

## 绘制圆形



* [演示地址](http://ifanqi.top/webgl/pages/lesson10.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson10.html)


矩形比较简单，两个三角形拼接起来就可以了。那常见的圆形该如何绘制呢？聪明的同学可能已经想到了：将圆形分割成以圆心为共同顶点的若干个三角形，三角形数越多，圆形越平滑。

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fb3037eeca21b~tplv-t2oaga2asx-image.image" width="80%" />

如上图所示，我们将圆形划分成 12 个三角形，13 个顶点，我们需要计算每个顶点的坐标，我们定义一个生成圆顶点的函数：

 * x：圆心的 x 坐标
 * y：圆心的 y 坐标
 * radius：半径
 * n：三角形的数量

```javascript
    var sin = Math.sin;
    var cos = Math.cos;
    function createCircleVertex(x, y, radius, n) {
      var positions = [x, y, 255, 0, 0, 1];
      for (let i = 0; i <= n; i++) {
        var angle = i * Math.PI * 2 / n;
        positions.push(x + radius * sin(angle), y + radius * cos(angle), 255, 0, 0, 1);
      }
      return positions;
    }
   var positions = createCircleVertex(100, 100, 50,  12);
```

将圆划分成 12 个三角形的效果：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fb489231ea726~tplv-t2oaga2asx-image.image" width="80%" />

有棱有角，不太自然，我们将圆切分成 50 个三角形试试：

```javascript
var positions = createCircleVertex(100, 100, 50,  50);
```

效果如下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fb48a1462aded~tplv-t2oaga2asx-image.image" width="80%" />

可以看出， 50 个三角形组成的圆更加自然一些，三角形面数越多，画出的图形越自然越平滑，但是我们也不能无限划分，毕竟三角形的数量越多，顶点数量相应的变多，内存占用会变大。在绘制规则图形的时候，我们需要在图形显示效果与顶点数量之间做一个权衡。

## 绘制环形


* [演示地址](http://ifanqi.top/webgl/pages/lesson11.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson11.html)

再深入一下，我们看看环形如何绘制，动手画画图，应该能想到：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/27/167ed9b3702ca350~tplv-t2oaga2asx-image.image" width="80%" />


建立两个圆，一个内圆，一个外圆，划分n个近似于扇形的三角形，每个三角形的两条边都会和内圆和外圆相交，产生四个交点，这四个交点组成一个近似矩形，然后将近似矩形划分成两个三角形：

```javascript
function createRingVertex(x, y, innerRadius, outerRadius, n) {
    var positions = [];
    var color = randomColor();
    for (var i = 0; i <= n; i++) {
        if (i % 2 == 0) {
            color = randomColor();
        }
        var angle = i * Math.PI * 2 / n;
        positions.push(x + innerRadius * sin(angle), y + innerRadius * cos(angle), color.r, color.g, color.b, color.a);
        positions.push(x + outerRadius * sin(angle), y + outerRadius * cos(angle), color.r, color.g, color.b, color.a);
    }
    var indices = [];
    for (var i = 0; i < n; i++) {
        var p0 = i * 2;
        var p1 = i * 2 + 1;
        var p2 = (i + 1) * 2 + 1;
        var p3 = (i + 1) * 2;
        if (i == n - 1) {
          p2 = 1;
          p3 = 0;
        }
        indices.push(p0, p1, p2, p2, p3, p0);
    }
    return { 
        positions: positions, 
        indices: indices 
    };
}
```

上面这个方法能够根据内圆半径和外圆半径以及三角形的数量返回顶点数组和索引数组，我们生成 100 个三角形的信息。

```javascript
var geo = createRingVertex(100, 100, 20, 50, 100);
```

为了节省空间，我们采用索引绘制：

```javascript
gl.drawElements(gl[currentType], indices.length, gl.UNSIGNED_SHORT, 0);
```

效果如下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/21/165fbbed2908c8cf~tplv-t2oaga2asx-image.image" width="60%" />

## 回顾

我们清楚了各种形状的平面其实都可以通过三角形图元组装而成，大家或许会说了，这样岂不是很累啊？确实很累，只不过实际应用中，我们往往都是通过 3D 建模软件为我们生成顶点、索引、颜色等信息。本节通过代码来生成模型顶点信息，是为了培养大家在绘制复杂图形时用三角形进行拆分的意识。

本节我们学习了使用基本三角形、三角带、三角扇绘制矩形、圆形、环形的方法，以及它们之间的使用区别，同时还学习了使用索引绘制的技巧，了解了顶点顺序的重要性。

下一节，我为大家介绍纹理贴图，学习如何将图片应用到平面上。

## 7.初级入门 --- 纹理贴图：为形体穿上外衣

之前章节我们学习了绘制单一和渐变颜色的三角形，但是在实际的建模中（游戏居多），模型表面往往都是丰富生动的图片。这就需要有一种机制，能够让我们把图片素材渲染到模型的一个或者多个表面上，这种机制叫做`纹理贴图`，本节我们学习如何使用 WebGL 进行纹理贴图。

## 目标

本节我们的目标是要学会纹理贴图的步骤以及注意事项。

* [演示地址](http://ifanqi.top/webgl/pages/lesson13.html)
* [源码地址](https://github.com/lucefer/webgl/blob/master/pages/lesson13.html)

通过本节学习，你将掌握如下内容：

* 为什么需要贴图？
* 贴图的步骤？
* 注意事项。

## 为什么我们需要贴图？

之前章节的示例中，为图形增加色彩仅仅是用了简单的单色和渐变色，但是实际应用中往往需要一些丰富多彩的图案，我们不可能用代码来生成这些图案，费时费力，效果也不好。通常我们会借助一些图形软硬件（比如照相机、手机、PS等）准备好图片素材，然后在 WebGL 中把图片应用到图形表面。

## 纹理图片格式
WebGL 对图片素材是有严格要求的，图片的宽度和高度必须是 2 的 N 次幂，比如 16 x 16，32 x 32，64 x 64 等。实际上，不是这个尺寸的图片也能进行贴图，但是这样会使得贴图过程更复杂，从而影响性能，所以我们在提供图片素材的时候最好参照这个规范。


## 纹理坐标系统

纹理也有一套自己的坐标系统，为了和顶点坐标加以区分，通常把纹理坐标称为 `UV`，`U` 代表横轴坐标，`V` 代表纵轴坐标。

* 图片坐标系统的特点是：
    * 左上角为原点(0, 0)。
    * 向右为横轴正方向，横轴最大值为 1，即横轴坐标范围【1，0】。
    * 向下为纵轴正方向，纵轴最大值为 1，即纵轴坐标范围【0，1】。


* 纹理坐标系统不同于图片坐标系统，它的特点是：
    * 左下角为原点(0, 0)。
    * 向右为横轴正方向，横轴最大值为 1，即横轴坐标范围【1，0】。
    * 向上为纵轴正方向，纵轴最大值为 1，即纵轴坐标范围【0，1】。

如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/25/1688415c89af299b~tplv-t2oaga2asx-image.image)

纹理坐标系统可以理解为一个边长为 1 的正方形。

### 贴图练习

接下来，我们学习一下贴图过程。

#### 准备图片

按照规范所讲，我们首先准备一张符合要求的图片，这里自己制作一个尺寸为宽高分别是 2 的 7 次方，即 128 x 128 的图片。

#### 着色器

本节片元着色器中，不再是接收单纯的颜色了，而是接收纹理图片对应坐标的颜色值，所以我们的着色器要能够做到如下几点：

* 顶点着色器接收顶点的 `UV` 坐标，并将`UV`坐标传递给片元着色器。
* 片元着色器要能够接收顶点插值后的`UV`坐标，同时能够在纹理资源找到对应坐标的颜色值。

我们看下如何修改才能满足这两点：

* 顶点着色器    

首先，增加一个名为 v\_Uv 的 attribute 变量，接收 JavaScript 传递过来的 UV 坐标。  
其次，增加一个 varying 变量 v\_Uv，将 UV 坐标插值化，并传递给片元着色器。

```glsl
    precision mediump float;
   // 接收顶点坐标 (x, y)
   attribute vec2 a_Position;
   // 接收 canvas 尺寸(width, height)
   attribute vec2 a_Screen_Size;
   // 接收JavaScript传递过来的顶点 uv 坐标。
   attribute vec2 a_Uv;
   // 将接收的uv坐标传递给片元着色器
   varying vec2 v_Uv;
   void main(){
     vec2 position = (a_Position / a_Screen_Size) * 2.0 - 1.0;
     position = position * vec2(1.0,-1.0);
     gl_Position = vec4(position, 0, 1);
     // 将接收到的uv坐标传递给片元着色器
     v_Uv = a_Uv;
   }
```

* 片元着色器
首先，增加一个 `varying` 变量 `v_Uv`，接收顶点着色器插值过来的 `UV` 坐标。  
其次，增加一个 `sampler2D` 类型的全局变量 `texture`，用来接收 JavaScript 传递过来的纹理资源（图片数据）。

```glsl
	precision mediump float;
	// 接收顶点着色器传递过来的 uv 值。
	varying vec2 v_Uv;
	// 接收 JavaScript 传递过来的纹理
	uniform sampler2D texture;
	void main(){
		// 提取纹理对应uv坐标上的颜色，赋值给当前片元（像素）。
  		gl_FragColor = texture2D(texture, vec2(v_Uv.x, v_Uv.y));
	}
```

#### JavaScript 部分

我们首先要将纹理图片加载到内存中：

```javascript
    var img = new Image();
    img.onload = textureLoadedCallback;
    img.src = "";
```

图片加载完成之后才能执行纹理的操作，我们将纹理操作放在图片加载完成后的回调函数中，即`textureLoadedCallback`。

需要注意的是，我们使用 canvas 读取图片数据是受浏览器跨域限制的，所以首先要解决跨域问题。

那么，针对图片跨域问题我们可以采用三种方式来解决：

**第一种方法：设置允许 Chrome 跨域加载资源**

在本地开发阶段，我们可以设置 Chrome 浏览器允许加载跨域资源，这样就可以使用磁盘地址来访问页面了。

mac 设置方法如下：

```bash
open -n /Applications/Google\ Chrome.app/ --args --disable-web-security --user-data-dir(指定目录,例如 = /user/Documents)
```


**第二种方法：图片资源和页面资源放在同一个域名下**

除了设置 Chrome，我们还可以将图片资源和页面资源部署在同一域名下，这样就不存在跨域问题了。

**第三种方法：为图片资源设置跨域响应头**

实际生产环境中，图片资源往往部署在 CDN 上，图片和页面分属不同域，这种情况的跨域访问我们就需要正面解决了。

假设我们的图片资源所属域名为：`https://cdn-pic.com`，页面所属域名为 `https://test.com`。

解决方法如下：

* 首先：为图片资源设置跨域响应头：
```glsl
Access-Control-Allow-Origin：`https://test.com`
```

* 其次：在图片加载时，为 img 设置 crossOrigin 属性。

```javascript
var img = new Image();
img.crossOrigin = '';
img.src = 'https://cdn-pic.com/test.jpg'
```

做完这两步，我们就可以真正的加载跨域图片了。
解决了图片加载跨域问题，我们就可以开始纹理贴图了。


我们定义六个顶点，这六个顶点能够组成一个矩形，并为顶点指定纹理坐标。

```javascript
    var positions = [
      30, 30, 0, 0,    //V0
      30, 300, 0, 1,   //V1
      300, 300, 1, 1,  //V2
      30, 30, 0, 0,    //V0
      300, 300, 1, 1,  //V2
      300, 30, 1, 0    //V3
    ]
```

按照惯例，我们该为着色器传递数据了。

>经历过前面几个小节的练习，相信大家对操作 WebGL 的代码已经很熟悉了。

加载图片

```javascript
	var img  = new Image();
	img.onload = textureLoadedCallback;
	img.src="";
```

>您或许看到我并没有为 img 设置 `crossOrigin` 属性，原因是在我本地，图片和页面在同一个域名下，所以不需要额外设置。

图片加载完成后，我们进行如下操作：

首先：激活 0 号纹理通道`gl.TEXTURE0`，0 号纹理通道是默认值，本例也可以不设置。

```javascript
	gl.activeTexture(gl.TEXTURE0);
```

然后创建一个纹理对象：

```javascript
	var texture = gl.createTexture();
```

之后将创建好的纹理对象`texture`绑定 到`当前纹理绑定点`上，即 `gl.TEXTURE_2D`。绑定完之后对当前纹理对象的所有操作，都将基于 `texture` 对象，直到重新绑定。

```javascript
	gl.bindTexture(gl.TEXTURE_2D, texture);
```
为片元着色器传递图片数据：

```javascript
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
```

gl.texImage2D 方法是一个重载方法，其中有一些参数可以省略：  

>glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, glsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);  

|参数|含义|
|-----|----|
|target| 纹理类型，TEXTURE_2D代表2维纹理|
| level| 表示多级分辨率的纹理图像的级数，若只有一种分辨率，则 level 设为 0，通常我们使用一种分辨率|
| components | 纹理通道数，通常我们使用 RGBA 和 RGB 两种通道|
| width| 纹理宽度，可省略|
|height| 纹理高度，可省略|
| border| 边框，通常设置为0，可省略|
| format | 纹理映射的格式 |
|type|纹理映射的数据类型|
|pixels| 纹理图像的数据|

上面这段代码的意思是，我们将 img 变量指向的图片数据传递给片元着色器，取对应纹理坐标的 RGBA 四个通道值，赋给片元，每个通道的数据格式是无符号单字节整数。

接下来，我们设置图片在放大或者缩小时采用的算法`gl.LINEAR`。
>gl.LINEAR 代表采用最靠近象素中心的四个象素的加权平均值，这种效果表现的更加平滑自然。
>gl.NEAREST 采用最靠近象素中心的纹素，该算法可能使图像走样，但是执行效率高，不需要额外的计算。

```javascript
gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
```

之后为片元着色器传递 0 号纹理单元：

```javascript
gl.uniform1i(uniformTexture, 0);
```
> 这里，我们为片元着色器的 texture 属性传递 0，此处应该与激活纹理时的通道值保持一致。

图片作为纹理的渲染效果如下：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/25/1688422a4034bef1~tplv-t2oaga2asx-image.image" width="80%" />

可以看到，我们绘制的矩形表面贴上了纹理。

您或许有疑问，为什么我只是指定了三角形的顶点对应的 UV 坐标，GPU 就能够将纹理图片的其他坐标的颜色贴到三角形表面呢？

这其实，就回归到了`渲染管线`这个概念上，在第一节我画了个图，大致阐述了渲染管线的工作方式，但其实在光栅化环节上有些细节没有说到。
在光栅化阶段，GPU 处理两件事情：

* 计算图元覆盖了哪些像素。
* 根据顶点着色器的顶点位置计算每个像素的纹理坐标的插值。

> 注：片元可以理解为像素。

光栅化结束后，来到片元着色器，片元着色器此时知道每个像素对应的 `UV` 坐标，根据当前像素的 `UV` 坐标，找到纹理资源对应坐标的颜色信息，赋值给当前像素，从而能够为图元表面的每个像素贴上正确的纹理颜色。


## 注意事项

我们总结一下贴图的注意点：

* 图片最好满足 2^m x 2^n 的尺寸要求。
* 图片数据首先加载到内存中，才能够在纹理中使用。
* 图片资源加载前要先解决跨域问题。



## 回顾
至此，我们使用 WebGL 绘制平面的课程就结束了，总结一下之前章节所学的知识点：

* GLSL：着色器
	* 数据类型
		* vec2：2 维向量容器。
		* vec4：4 维向量容器。
		* 运算法则：向量与向量、向量与浮点数的运算法则。
	* 修饰符
		* attribute：属性修饰符。
		* uniform：全局变量修饰符。
		* varying：顶点着色器传递给片元着色器的属性修饰符。
	* precision：设置精度
		* highp：高精度。
		* mediump：中等精度。
		* lowp：低精度。
	* 内置变量
		* gl_Position：顶点坐标。
		* gl_FragColor：片元颜色。
		* gl_PointSize：顶点大小。
	* 屏幕坐标系到设备坐标系的转换。
		* 屏幕坐标系左上角为原点，X 轴坐标向右为正，Y 轴坐标向下为正。
		* 坐标范围：
			*  X轴：【0, canvas.width】
			*  Y轴：【0, canvas.height】
		* 设备坐标系以屏幕中心为原点，X 轴坐标向右为正，Y 轴向上为正。
		* 坐标范围是
			* X轴：【-1, 1】。
			* Y轴：【-1, 1】。
* WebGL API
	* shader：着色器对象
		* gl.createShader：创建着色器。
		* gl.shaderSource：指定着色器源码。
		* gl.compileShader：编译着色器。
	* program：着色器程序
		* gl.createProgram：创建着色器程序。
		* gl.attachShader：链接着色器对象。
		* gl.linkProgram：链接着色器程序。
		* gl.useProgram：使用着色器程序。
	* attribute：着色器属性
		* gl.getAttribLocation：获取顶点着色器中的属性位置。
		* gl.enableVertexAttribArray：启用着色器属性。
		* gl.vertexAttribPointer：设置着色器属性读取 buffer 的方式。
		* gl.vertexAttrib2f：给着色器属性赋值，值为两个浮点数。
		* gl.vertexAttrib3f：给着色器属性赋值，值为三个浮点数。
	* uniform：着色器全局属性
		* gl.getUniformLocation：获取全局变量位置。
		* gl.uniform4f：给全局变量赋值 4 个浮点数。
		* gl.uniform1i：给全局变量赋值 1 个整数。
	* buffer：缓冲区
		* gl.createBuffer：创建缓冲区对象。
		* gl.bindBuffer：将缓冲区对象设置为当前缓冲。
		* gl.bufferData：向当前缓冲对象复制数据。
 	* clear：清屏
 		* gl.clearColor：设置清除屏幕的背景色。
 		* gl.clear：清除屏幕。
 	* draw：绘制
 		* gl.drawArrays：数组绘制方式。
 		* gl.drawElements：索引绘制方式。
 	* 图元
 		* gl.POINTS：点。
 		* gl.LINE：基本线段。
 		* gl.LINE_STRIP：连续线段。
 		* gl.LINE_LOOP：闭合线段。
 		* gl.TRIANGLES：基本三角形。
 		* gl.TRIANGLE_STRIP：三角带。
 		* gl.TRIANGLE_FAN：三角扇。
 	* 纹理
 		* gl.createTexture：创建纹理对象。
 		* gl.activeTexture：激活纹理单元。
 		* gl.bindTexture：绑定纹理对象到当前纹理。
 		* gl.texImage2D：将图片数据传递给 GPU。
 		* gl.texParameterf：设置图片放大缩小时的过滤算法。
 	
以上是截止到目前所涉及的知识点，大家可以按照自己的想法做些小例子，熟练掌握它们。

接下来我们开始学习如何使用基本图元构建 3D 模型。

## 8.初级入门 --- 绘制立方体、球体、椎体：如何用基本图形构建规则形体

从本节开始，我们学习绘制 3D 形体，仍然是从简单模型入手，我们首先学习绘制一个立方体。

## 目标
本节通过绘制常见的立方体、球体、椎体来学习如何使用基本图形构建规则的形体。

通过本节学习，你将掌握如下内容：
* WebGL 坐标系。
    * 裁剪坐标系。
    * NDC 坐标系。
* 坐标系变换。
    * 模型变换。
    * 投影变换。
* 立方体、球体、椎体是如何用三角面组成的。
* 背面剔除的作用。

## WebGL 坐标系
本节开始学习 3D
形体的绘制，与之前几个章节绘制点和面不同，3D 形体的顶点坐标需要包含深度信息 Z 轴 坐标。所以我们先了解一下 WebGL `坐标系` 的概念。
> 后续章节有关于[WebGL 坐标系](https://juejin.cn/book/6844733755580481543/section/6844733755937013773)和[坐标系基本变换原理与算法实现](https://juejin.cn/book/6844733755580481543/section/6844733755937030157)的深入讲解，但是为了本节学习的方便，还是要在此介绍一下坐标系的相关知识。

WebGL 采用左手坐标系，X 轴向右为正，Y 轴向上为正，Z 轴沿着屏幕往里为正，如下图：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/29/16624dfadfcfef91~tplv-t2oaga2asx-image.image)

```!
讲到这里，我想有很多同学会质疑了：WebGL 不是遵循右手坐标系吗，这里怎么成左手坐标系了？
```

没错，WebGL 是`遵循`右手坐标系，但仅仅是遵循，是期望大家遵守的规范。其实 WebGL 内部 (裁剪坐标系) 是基于左手坐标系的，Z 轴沿屏幕向里为正方向。如果您迫切想知道为什么？请点击[WebGL坐标系章节](https://juejin.cn/book/6844733755580481543/section/6844733755937013773)，该章节会有示例来证明。


WebGL 坐标系 X、Y、Z 三个坐标分量的的范围是【-1，1】，即一个边长为 2 的正方体，原点在正方体中心。这点在之前的章节有介绍，我们也称这个坐标系为标准设备坐标系，简称 `NDC 坐标系`。

大家应该还记得，前面章节我们经常在顶点着色器中使用内置属性 `gl_Position`，并且在为 `gl_Position` 赋值之前做了一些坐标系转换（屏幕坐标系转换到裁剪坐标系）操作。

```!
为了理解 gl_Position 接收坐标前所做的变换目的，这就需要理解 `gl_Position` 接收什么样的坐标。
```

`gl_Position` 接收一个 4 维浮点向量，该向量代表的是`裁剪坐标系`的坐标。读者可能会问了，`裁剪坐标系`又是怎么冒出来的？这里先不细说，大家只需要记住，gl_Position 接收的坐标范围是顶点在裁剪坐标系中的坐标就可以了。

裁剪坐标系中的坐标通常由四个分量表示：(x, y, z, w)。请注意，w 分量代表`齐次坐标分量`，在之前的例子中，w 都是设置成 `1` ，这样做的目的是让裁剪坐标系和 NDC 坐标系就保持一致，省去裁剪坐标到 NDC 坐标的转换过程。

gl_Position 接收到裁剪坐标之后，顶点着色器会对坐标进行`透视除法`，透视除法的公式是 `(x/w, y/w, z/w, w/w)` ，透视除法过后，顶点在`裁剪坐标系`中的坐标就会变成 `NDC 坐标系`中的坐标，各个坐标的取值范围将被限制在【-1，1】之间，如果某个坐标超出这个范围，将会被 GPU 丢弃。


>透视除法这个步骤是顶点着色器程序黑盒执行的，对开发者来说是透明的，无法通过编程手段干预。但是我们需要明白有这么一个过程存在。

在之前章节的例子中，我们给出的顶点坐标都是基于屏幕坐标系，然后在顶点着色器中对顶点作简单转换处理，转变成 NDC 坐标。

本节我们不着重讲解坐标系变换，而是为了讲解物体如何由三角形组成，所以会忽略`裁剪坐标系`之前的一些坐标变换，在 JavaScript 中直接采用`裁剪坐标系坐标`来表示顶点位置。


## 如何用三角形构建正方体

一个只包含坐标信息的立方体实际上是由 6 个正方形，每个正方形由两个三角形组成，每个三角形由三个顶点组成，所以一个立方体由 6 个正方形 * 2 个三角形 * 3 个顶点 = 36 个顶点组成，但是这 36个顶点中有很多是重复的，我们很容易发现：一个纯色立方体实际上由 6 个矩形面，或者 8 个不重复的顶点组成。

请谨记，顶点的`重复与否`，不只取决于顶点的坐标信息一致，还取决于该顶点所包含的其他信息是否一致。比如顶点纹理坐标 uv、顶点法线，顶点颜色等。一旦有一个信息不同，就必须用两个顶点来表示。

仍然以矩形举例，每个顶点只包含`坐标`和`颜色`两类信息。如果我们的矩形是纯色的，假设是红色。

```javascript
//顶点信息
var positions = [
    30, 30, 1, 0, 0, 1,    //V0
    30, 300, 1, 0, 0, 1,   //V1
    300, 300, 1, 0, 0, 1,  //V2
    30, 30, 1, 0, 0, 1,    //V0
    300, 300, 1, 0, 0, 1,  //V2
    300, 30, 1, 0, 0, 1    //V3
]
```
很明显，V0 和 V2 这两个顶点坐标和颜色完全一致，所以，该顶点是重复的，我们可以忽略重复的顶点。

同样地，还是这样一个矩形，每个顶点还是只包含坐标和颜色两类信息，我们想实现一个渐变矩形，从 `V0 -> V1V2` 为红绿渐变，从`V1V2 -> V3` 为黄蓝渐变。
如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/28/1661ee227cedb437~tplv-t2oaga2asx-image.image)
我们看一下顶点数组：

```javascript
//顶点信息
var positions = [
    30, 30, 1, 0, 0, 1,    //V0，红色
    30, 300, 0, 1, 0, 1,   //V1，绿色
    300, 300, 0, 1, 0, 1,  //V2，绿色
    30, 30, 1, 1, 0, 1,  //V4，黄色
    300, 300, 1, 1, 0, 1,//V5，黄色
    300, 30, 0, 0, 1, 1    //V3，蓝色
]
```
可以看到，虽然 V0 和 V4，V2 和 V5 的顶点坐标一致，但是顶点颜色不一样，所以我们只能把他们当做不同的顶点处理，否则达不到我们想要的效果。

>一定要理解`重复顶点`的定义：两个顶点必须是所有信息一致，才可以称之为重复顶点。

## 彩色立方体

为了在视觉层面区分出立方体的各个面，接下来我们绘制一个彩色立方体。

立方体是 3 维形体，所以它们的顶点坐标需要从 2 维扩展成 3 维，除了 `x、y` 坐标，还需要深度值： `z` 轴坐标。



### 代码调整
本节代码组织上和之前章节有所不同，主要有以下两点：

* 顶点属性不再使用一个 buffer 混合存储，改为每个属性对应一个 buffer，便于维护。  
* 顶点坐标我们不再使用屏幕坐标系，而是采用 NDC 坐标系。如果使用屏幕坐标系，会涉及到相对复杂的坐标系变换，大家可能不容易理解。

我们还是按照之前的套路：
* 定义顶点
* 传递数据
* 执行绘制。

首先定义顶点，由于立方体包含六个面，每个面采用同一个颜色，所以我们需要定义 6 个矩形面 * 4 个顶点 = 24 个不重复的顶点。


```javascript
    //正方体 8 个顶点的坐标信息
let zeroX = 0.5;
let zeroY = 0.5;
let zeroZ = 0.5;
let positions = [
    [-zeroX, -zeroY, zeroZ],  //V0
    [zeroX, -zeroY, zeroZ],  //V1
    [zeroX, zeroY, zeroZ],   //V2
    [-zeroX, zeroY, zeroZ],  //V3
    [-zeroX, -zeroY, -zeroZ],//V4
    [-zeroX, zeroY, -zeroZ], //V5
    [zeroX, zeroY, -zeroZ],  //V6
    [zeroX, -zeroY, -zeroZ]  //V7
]
```
接下来定义六个面包含的顶点索引：

```javascript
const CUBE_FACE_INDICES = [
  [0, 1, 2, 3], //前面
  [4, 5, 6, 7], //后面
  [0, 3, 5, 4], //左面
  [1, 7, 6, 2], //右面
  [3, 2, 6, 5], //上面
  [0, 4, 7, 1] // 下面
];
```

定义六个面的颜色信息：

```javascript
const FACE_COLORS = [
    [1, 0, 0, 1], // 前面，红色
    [0, 1, 0, 1], // 后面，绿色
    [0, 0, 1, 1], // 左面，蓝色
    [1, 1, 0, 1], // 右面，黄色
    [1, 0, 1, 1], // 上面，品色
    [0, 1, 1, 1]  // 下面，青色
]
```
有了顶点坐标和颜色信息，接下来我们写一个方法生成立方体的顶点属性。
该方法接收三个参数：宽度、高度、深度，返回一个包含组成立方体的顶点坐标、颜色、索引的对象。

```javascript
function createCube(width, height, depth) {
  let zeroX = width / 2;
  let zeroY = height / 2;
  let zeroZ = depth / 2;

  let cornerPositions = [
    [-zeroX, -zeroY, -zeroZ],
    [zeroX, -zeroY, -zeroZ],
    [zeroX, zeroY, -zeroZ],
    [-zeroX, zeroY, -zeroZ],
    [-zeroX, -zeroY, zeroZ],
    [-zeroX, zeroY, zeroZ],
    [zeroX, zeroY, zeroZ],
    [zeroX, -zeroY, zeroZ]
  ];
  let colorInput = [
    [255, 0, 0, 1],
    [0, 255, 0, 1],
    [0, 0, 255, 1],
    [255, 255, 0, 1],
    [0, 255, 255, 1],
    [255, 0, 255, 1]
  ];

  let colors = [];
  let positions = [];
  var indices = [];

  for (let f = 0; f < 6; ++f) {
    let faceIndices = CUBE_FACE_INDICES[f];
    let color = colorInput[f];
    for (let v = 0; v < 4; ++v) {
      let position = cornerPositions[faceIndices[v]];
      positions = positions.concat(position);
      colors = colors.concat(color);
    }
    let offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }
  indices = new Uint16Array(indices);
  positions = new Float32Array(positions);
  colors = new Float32Array(colors);
  return {
    positions: positions,
    indices: indices,
    colors: colors
  };
} 

```

有了生成立方体顶点的方法，我们生成一个边长为 1 的正方体：

```javascript
var cube = createCube(1, 1, 1);
```

拿到了顶点的信息，就可以用我们熟悉的索引绘制方法来进行绘制了，这部分代码和之前一样，我们就不写了，看下效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/30/16629a1a1667d97c~tplv-t2oaga2asx-image.image)

看到这个红色矩形，有的同学或许有疑问了：

* 我们定义的立方体的边长都是 1 ，也就是一个正方体，每个面应该是正方形，为什么渲染到屏幕后就成长方形了？ 

* 如何才能看到立方体的其他表面？

#### 第一个问题的答案
这是因为，我们给 gl_Position 赋的坐标，在 渲染到屏幕之前，GPU 还会对其做一次坐标变换：`视口变换`。该变换会将 NDC 坐标转换成对应设备的视口坐标。

假设有一顶点 P（0.5，0.5，0.5，1）， gl_Position 接收到坐标后，会经历如下阶段：

* 首先执行透视除法，将顶点 P 的坐标从裁剪坐标系转换到 NDC 坐标系，转换后的坐标为： `P1（0.5 / 1, 0.5 / 1, 0.5 / 1, 1 / 1）`。由于 w 分量是 1， 所以 P1 和 P 的坐标一致。

* 接着，GPU 将顶点渲染到屏幕之前，对顶点坐标执行视口变换。假设我们的 canvas 视口宽度 300，高度 400，顶点坐标在 canvas 中心。那么 3D 坐标转换成 canvas 坐标的算法是:
* canvas 坐标系 X 轴坐标 = NDC 坐标系下 X 轴坐标 * 300 / 2 = 0.5 * 150 = 75  
* canvas 坐标系 Y 轴坐标 = NDC 坐标系下 Y 轴坐标 * 400 / 2 = 0.5 * 200 = 100

所以会有一个问题，立方体的每个面宽度和高度虽然都是 1 ，但是渲染效果会随着显示设备的尺寸不同而不同。

这个问题该如何解决呢？这就引出了 WebGL 坐标系的一个重要变换：`投影变换`。

#### 第二个问题的答案

因为我们绘制的是立方体，没有施加动画效果，所以我们只能看到立方体前表面，那如何看到其他表面呢？大家稍微一想就能知道，我们可以让立方体转动起来，转起来之后我们就能看到其他表面了。
那如何让立方体转动起来呢？
这就引出了 WebGL 坐标系的另一个重要变换：`模型变换`。

针对这两个问题的解决方案是对顶点施加投影和模型变换，本节我们采用业界常用的变换算法，暂时不做算法原理的讲解，只讲如何使用，让我们的正方体可以正常渲染并且能转动起来。

> 请谨记：每个转换可以用一个矩阵来表示，转换矩阵相乘，得出的最终矩阵用来表示组合变换。大家先记住这点，在中级进阶中的数学矩阵及运算中我会详细讲解。




### 让立方体转动起来。

* 引入`模型变换`让立方体可以转动，以便我们能观察其他表面。
* 引入`投影变换`让我们的正方体能够以正常比例渲染到目标设备，不再随视口的变化而拉伸失真。

为了引入这两个变换，我们需要引入`矩阵乘法`、`绕 X 轴旋转`、`绕 Y 轴旋转`、`正交投影`四个方法，如下：

```javascript
//返回一个单位矩阵
function identity() {}
//计算两个矩阵的乘积，返回新的矩阵。
function multiply(matrixLeft, matrixRight){}
//绕 X 轴旋转一定角度，返回新的矩阵。
function rotationX(angle) {}
//绕 Y 轴旋转一定角度，返回新的矩阵。
function rotateY(m, angle) {}
//正交投影，返回新的矩阵
function ortho(left, right, bottom, top, near, far, target) {}
```


在顶点着色器中定义一个变换矩阵，用来接收 JavaScript 中传过来的模型投影变换矩阵，同时将变换矩阵左乘顶点坐标。

```glsl
    // 接收顶点坐标 (x, y, z)
    precision mediump float;
    attribute vec3 a_Position;
    attribute vec4 a_Color;
    varying vec4 v_Color;
    uniform mat4 u_Matrix;
    void main(){
      gl_Position =  u_Matrix * vec4(a_Position, 1);
      v_Color = a_Color;
    }
```

增加旋转动画效果：每隔 50 ms 分别绕 X 轴和 Y 轴转动 1 度，然后将旋转对应的矩阵传给顶点着色器。

```javascript
//生成单位矩阵
var initMatrix = matrix.identify();
var currentMatrix = null;
var xAngle = 0;
var yAngle = 0;
var deg = Math.PI / 180;
function animate(e) {
      if (timer) {
        clearInterval(timer);
        timer = null;
      } else {
        timer = setInterval(() => {
          xAngle += 1;
          yAngle += 1;
          
          currentMatrix = matrix.rotationX(deg * xAngle);
          currentMatrix = matrix.rotateY(currentMatrix, deg * yAngle);
          gl.uniformMatrix4fv(u_Matrix, false, currentMatrix);
          render(gl);
        }, 50);
      }
    }

```

我们看下效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/9/16656d1a4ae38334~tplv-t2oaga2asx-image.image)

可以看到，渲染画面不再只是一幅静态的平面了，而是一个能够自由转动的立方体。

立方体的构建比较简单，我们看下如何使用三角面构建球体。

## 如何用三角面构建球体

```!
我们学会了使用三角面构建立方体，那么球体该如何用三角面组成呢？
```

我们可以将球体按照纬度等分成 n 份，形成 n 个圆面，每个圆面的 Y 坐标都相同，然后将每个圆面按照经度划分成 m 份，形成 m 个顶点，这 m 个顶点的 Y 坐标也都相同。按照这个逻辑，我们思考下球体的顶点生成过程：

```javascript
function createSphere(radius, divideByYAxis, divideByCircle) {
  let yUnitAngle = Math.PI / divideByYAxis;
  let circleUnitAngle = (Math.PI * 2) / divideByCircle;
  let positions = [];
  for (let i = 0; i <= divideByYAxis; i++) {
    let yValue = radius * Math.cos(yUnitAngle * i);
    let yCurrentRadius = radius * Math.sin(yUnitAngle * i);

    for (let j = 0; j <= divideByCircle; j++) {
      let xValue = yCurrentRadius * Math.cos(circleUnitAngle * j);
      let zValue = yCurrentRadius * Math.sin(circleUnitAngle * j);
      positions.push(xValue, yValue, zValue);
    }
  }

  let indices = [];
  let circleCount = divideByCircle + 1;
  for (let j = 0; j < divideByCircle; j++) {
    for (let i = 0; i < divideByYAxis; i++) {
      indices.push(i * circleCount + j);
      indices.push(i * circleCount + j + 1);
      indices.push((i + 1) * circleCount + j);

      indices.push((i + 1) * circleCount + j);
      indices.push(i * circleCount + j + 1);
      indices.push((i + 1) * circleCount + j + 1);
    }
  }
  return {
    positions: new Float32Array(positions),
    indices: new Uint16Array(indices)
  };
}
```

通过这个函数，我们得到了一个顶点对象，该对象包含所有顶点的坐标信息和索引信息。接下来我们为球体的每个三角面增加颜色信息。

我们知道，如果一个顶点的坐标相同，颜色不同的话，也必须视为两个顶点，否则会产生渐变颜色。因此，我们目前得到的球体的顶点仅仅坐标相同，如果我们要为每一个三角面绘制一种颜色的话，需要额外增加顶点，且不再使用`索引绘制`，而是采用`顶点数组绘制`。

```javascript
function transformIndicesToUnIndices(vertex) {
  let indices = vertex.indices;
  let vertexsCount = indices.length;
  let destVertex = {};

  Object.keys(vertex).forEach(function(attribute) {
    if (attribute == 'indices') {
      return;
    }
    let src = vertex[attribute];
    let elementsPerVertex = getElementsCountPerVertex(attribute);
    let dest = [];
    let index = 0;
    for (let i = 0; i < indices.length; i++) {
      for (let j = 0; j < elementsPerVertex; j++) {
        dest[index] = src[indices[i] * elementsPerVertex + j];
        index++;
      }
    }
    let type = getArrayTypeByAttribName();
    destVertex[attribute] = new type(dest);
  });
  return destVertex;
}
```

该方法将我们第一步获取的球体顶点数组展开，得到所有三角形的顶点对象。

接着，我们可以为顶点施加颜色了。

```javascript
function createColorForVertex(vertex) {
  let vertexNums = vertex.positions;
  let colors = [];
  let color = {
    r: 255,
    g: 0,
    b: 0
  };

  for (let i = 0; i < vertexNums.length; i++) {
    if (i % 36 == 0) {
      color = randomColor();
    }
    colors.push(color.r, color.g, color.b, 255);
  }

  vertex.colors = new Uint8Array(colors);
  return vertex;
}
```

生成球体顶点、增加三角面颜色这两个关键步骤做完之后，我们就可以执行绘制操作了，看下绘制后的效果：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/9/16656b7d844aaaeb~tplv-t2oaga2asx-image.image)

## 构建椎体、柱体、台体
椎体、柱体、台体可以归为一类构建方法，因为他们都受上表面、下表面、高度这三个因素的影响。
按照这种思路，我们再思考下它们的构建方法：

* 定义上表面的半径：topRadius。
* 定义下表面的半径：bottomRadius。
* 定义高度：height。
* 定义横截面的切分数量：bottomDivide。
* 定义垂直方向的切分数量：verticalDivide。

生成算法如下：

```javascript
function createCone(
  topRadius,
  bottomRadius,
  height,
  bottomDivide,
  verticalDivide
) {
    
  let vertex = {};
  let positions = [];
  let indices = [];

  for (let i = -1; i <= verticalDivide + 1; i++) {
    let currentRadius = 0;
    if (i > verticalDivide) {
      currentRadius = topRadius;
    } else if (i < 0) {
      currentRadius = bottomRadius;
    } else {
      currentRadius =
        bottomRadius + (topRadius - bottomRadius) * (i / verticalDivide);
    }
    let yValue = (height * i) / verticalDivide - height / 2;
    if (i == -1 || i == verticalDivide + 1) {
      currentRadius = 0;
      if (i == -1) {
        yValue = -height / 2;
      } else {
        yValue = height / 2;
      }
    }

    for (let j = 0; j <= bottomDivide; j++) {
      let xValue = currentRadius * Math.sin((j * Math.PI * 2) / bottomDivide);
      var zValue = currentRadius * Math.cos((j * Math.PI * 2) / bottomDivide);
      positions.push(xValue, yValue, zValue);
    }
  }

  // indices
  let vertexCountPerRadius = bottomDivide + 1;
  for (let i = 0; i < verticalDivide + 2; i++) {
    for (let j = 0; j < bottomDivide; j++) {
      indices.push(i * vertexCountPerRadius + j);
      indices.push(i * vertexCountPerRadius + j + 1);
      indices.push((i + 1) * vertexCountPerRadius + j + 1);

      indices.push(
        vertexCountPerRadius * (i + 0) + j,
        vertexCountPerRadius * (i + 1) + j + 1,
        vertexCountPerRadius * (i + 1) + j
      );
    }
  }

  vertex.positions = new Float32Array(positions);
  vertex.indices = new Uint16Array(indices);
  return vertex;
}
```

当我们定义上表面的半径为 0 时，得出的形体是椎体：

```javascript
let coneVertex = createCone(6, 0, 12, 12, 12);
```

效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/9/166576e23515ef1b~tplv-t2oaga2asx-image.image)

当我们定义上表面和下表面的半径相同，且都不为 0  时，得出的形体是柱体：

```javascript
let coneVertex = createCone(4, 4, 12, 12, 12);
```
效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/9/166576e460720c50~tplv-t2oaga2asx-image.image)

当我们定义上表面和下表面的半径不同，且都不为 0  时，得出的形体是台体（也可以称为棱锥体）：

```javascript
let coneVertex = createCone(6, 3, 12, 12, 12);
```
效果如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/10/9/166576e5afce7b89~tplv-t2oaga2asx-image.image)



## 回顾

本节主要教大家掌握使用普通三角面构建复杂形体的思路，顺便让大家简单了解`投影变换`和`模型变换`的用法（详细的变换我们在中级进阶深入讲解）。

下一节，我们将绘制方法封装一下，练习绘制多个模型。

## 9.初级入门 --- 绘制多个物体：进一步封装绘制方法

截止到目前，我们已经熟悉了 WebGL 的开发步骤：

* 初始化阶段
    * 创建所有着色器程序。
    * 寻找全部 attribute 参数位置。
    * 寻找全部 uniforms 参数位置。
    * 创建缓冲区，并向缓冲区上传顶点数据。
    * 创建纹理，并上传纹理数据。
* 首次渲染阶段
    * 为 uniforms 变量赋值。
    * 处理 attribute 变量
        * 使用 gl.bindBuffer 重新绑定模型的 attribute 变量。
        * 使用 gl.enableVertexAttribArray 启用 attribute 变量。
        * 使用 gl.vertexAttribPointer设置 attribute变量从缓冲区中读取数据的方式。 
        * 使用 gl.bufferData 将数据传送到缓冲区中。
    * 使用 gl.drawArrays 执行绘制。
* 后续渲染阶段
    * 对发生变化的 uniforms 变量重新赋值。
    * 每个模型的 attribute 变量。
        * 使用 gl.bindBuffer 重新绑定模型的 attribute 变量。
        * 使用 gl.bufferData 重新向缓冲区上传模型的 attribute 数据。
    * 使用 gl.drawArrays 执行绘制。

这就是 WebGL 的基本绘制流程，但是这些只是在绘制单个模型时的步骤。思考一下，如果我们有多个模型，会碰到哪些问题？如何进行优化？

> 这里提到了模型的概念，3D 中的模型是由顶点`vertex`组成，顶点之间连成三角形，多个三角形就能够组成复杂的立体模型。简单模型诸如立方体、球体等，复杂模型诸如汽车、茶壶等。类比到现实世界中，模型可以理解为现实生活中看得见摸得着的物体。

## 创建模型类

每个模型都有对应的顶点数据，包含顶点位置、颜色、法向量、纹理坐标等，我们将这些数据用一个顶点缓冲对象来表示，每个属性对应一个 `attribute` 变量。除了顶点数据，还需要有众多 `uniforms` 变量，uniforms 变量存储和顶点无关的属性，比如`模型变换矩阵`、模型视图投影矩阵`MVP`，（后续我们用 `MVP` 指代模型视图投影矩阵），法向量矩阵，光照等。既然模型有这么多共同的属性，那么我们把模型抽象出来。

定义一个模型类，模型类自身属性有模型矩阵`u_ModelMatrix`，MVP 矩阵`u_Matrix`，以及所有的 uniforms 变量，顶点缓冲数据。

```javascript
//模型类
function Model(bufferInfo, uniforms ){
    this.uniforms = uniforms || {};
    this.u_Matrix = matrix.identity();
    this.bufferInfo = bufferInfo || {};
    
    // 偏移
    this.translation = [0, 0, 0];
    // 旋转角度
    this.rotation = [0, 0, 0];
    // 缩放
    this.scalation = [1, 1, 1];
}
```

> matrix.identity 方法生成一个单位矩阵。

### 设置顶点对象

提供一个为模型提供顶点数据的方法，顶点数据用一个对象表示，对象的属性用着色器中属性名称来 表示，对应顶点属性。一个完整的 `bufferInfo` 包含如下内容：


```javascript
bufferInfo = {
    attributes:{
        a_Positions: {
            buffer: buffer,
            type: gl.FLOAT,
            normalize: false,
            numsPerElement: 4,
        },
        a_Colors:{
            buffer:buffer,
            type: gl.UNSIGNED_BYTE,
            normalize: true,
            numsPerElement: 4
        },
        a_Normals:{
            buffer:buffer,
            type: gl.FLOAT,
            normalize: false,
            numsPerElement: 3
        },
        a_Texcoords:{
            buffer:buffer,
            type: gl.FLOAT,
            normalize: false,
            numsPerElement: 2
        }
    },
    indices:[],
    elementsCount: 30
}
```
`indices` 代表顶点的索引数组， `elementsCount` 表示顶点的个数。buffer 代表 WebGL 创建的 buffer 对象，里面存储着对应的顶点数据。

顶点数据对象除了可以在初始化时为 model 设置以外，还需要为 model 提供一个单独设置方法：

```javascript
Model.prototype.setBufferInfo = function(bufferInfo){
    this.bufferInfo = bufferInfo || {};
}
```

我们最初得到的顶点模型数据一般是这种格式的：

```javascript
let vertexObject = {
    positions: [],
    normals: [],
    texcoords: [],
    indices: [],
    colors: []
}
```

这和我们上面设置的字段格式都不同，所以我们要添加一个适配器转换一下。


### 设置模型状态

我们需要一些方法能够随时对模型对象的信息进行修改，比如位移，旋转角度，缩放比例等，最后还需要增加一个 preRender 预渲染方法，在绘制之前更新矩阵。

#### 设置模型位移。
位移的设置包含同时对三个分量设置以及对每个分量单独设置：

* translate：对模型设置 X 轴、Y 轴、Z 轴方向的偏移。
* translateX：对模型设置 X 轴偏移。
* translateY：对模型设置 Y 轴偏移。
* translateZ：对模型设置 Z 轴偏移。

```javascript
Model.prototype.translate = function(tx, ty, tz){
    this.translateX(tx);
    this.translateY(ty);
    this.translateZ(tz);
}
Model.prototype.translateX = function(tx){
    this.translation[0] = tx || 0;
}
Model.prototype.translateY = function(ty){
    this.translation[1] = ty || 0;
}
Model.prototype.translateZ = function(tz){
    this.translation[2] = tz || 0;
}
```

#### 设置模型缩放比例。
缩放比例的设置包含同时对三个分量设置以及对每个分量单独设置：

* scale：对模型设置 X 轴、Y 轴、Z 轴上的缩放比例。
* scaleX：对模型设置 X 轴缩放比例。
* scaleY：对模型设置 Y 轴缩放比例。
* scaleZ：对模型设置 Z 轴缩放比例。

```javascript
Model.prototype.scale = function(sx, sy, sz){
    this.scaleX(sx);
    this.scaleY(sy);
    this.scaleZ(sz);
}
Model.prototype.scaleX = function(sx){
    this.scalation[0] = sx || 1;
}
Model.prototype.scaleY = function(sy){
    this.scalation[1] = sy || 1;
}
Model.prototype.scaleZ = function(sz){
    this.scalation[2] = sz || 1;
}
```



#### 设置模型旋转角度。
模型旋转角度的设置包含同时对三个分量设置以及对每个分量单独设置：

* rotate：对模型设置 X轴、Y轴、Z 轴上的旋转角度。
* rotateX：对模型设置 X 轴旋转角度。
* rotateY：对模型设置 Y 轴旋转角度。
* rotateZ：对模型设置 Z 轴旋转角度。

```javascript
Model.prototype.rotate = function(rx, ry, rz){
    this.rotateX(rx);
    this.rotateY(ry);
    this.rotateZ(rz);
}
Model.prototype.rotateX = function(rx){
    this.rotation[0] = rx || 0;
}
Model.prototype.rotateY = function(ry){
    this.rotation[1] = ry || 0;
}
Model.prototype.rotateZ = function(rz){
    this.rotation[2] = rz || 0;
}
```

#### 预渲染。
在将模型矩阵以及模型的 MVP 矩阵传递给 GPU 之前，我们对模型矩阵以及 MVP 矩阵重新计算。

* rotate：对模型设置 X 轴、Y 轴、Z 轴上的旋转角度。
* rotateX：对模型设置 X 轴旋转角度。
* rotateY：对模型设置 Y 轴旋转角度。
* rotateZ：对模型设置 Z 轴旋转角度。

```javascript
Model.prototype.preRender =  function( viewMatrix, projectionMatrix){
    let modelMatrix = matrix.identity();
  if (this.translation) {
    modelMatrix = matrix.translate(
      modelMatrix,
      this.translation[0],
      this.translation[1],
      this.translation[2]
    );
  }
  if (this.rotation) {
    if (this.rotation[0] !== undefined)
      modelMatrix = matrix.rotateX(modelMatrix, degToRadians(this.rotation[0]));
    if (this.rotation[1] !== undefined)
      modelMatrix = matrix.rotateY(modelMatrix, degToRadians(this.rotation[1]));
    if (this.rotation[2] !== undefined)
      modelMatrix = matrix.rotateZ(modelMatrix, degToRadians(this.rotation[2]));
  }
  if (this.scalation) {
    modelMatrix = matrix.scale(
      modelMatrix,
      this.scalation[0],
      this.scalation[1],
      this.scalation[2]
    );
  }

  this.u_ModelMatrix = modelMatrix;

  //重新计算 MVP 矩阵

  this.u_Matrix = matrix.multiply(viewMatrix, this.u_ModelMatrix);
  this.u_Matrix = matrix.multiply(projectionMatrix, this.u_Matrix);
}
```

### 封装顶点数据的操作
最为重要的是顶点数据，它们是模型的基本组成元素，顶点数据一般包含如下几个属性：

* 颜色信息
* 位置信息
* 法向量信息
* 索引信息
* 纹理坐标

```javascript
bufferInfo = {
    colors: [],
    positions: [],
    normals: [],
    indices: [],
    texcoords: []
}
```

我们有了这些顶点信息，还需要通过 attribute 变量传递给 GPU，所以，我们还需要找到对应的 attribute 变量。

在着色器中命名 attribute 变量时，我们通常使用 `a_` 开头，后面跟着顶点属性名称，按照这种规范命名也方便我们在 JavaScript 中对变量进行赋值。


```javascript
attribute vec4 a_Positions;
attribute vec3 a_Normals;
attribute vec2 a_Texcoords;
attribute vec4 a_Colors;
```

那么我们查找变量时，可以这样查找：


```javascript
let attributesCount = gl.getProgramParameter(program, param);
```

当 pname 为 gl.ACTIVE_ATTRIBUTES时，返回program绑定的顶点着色器中 attribute 变量的数量 attributesCount。

有了变量数量，我们就可以对变量进行遍历了。


```javascript
for(let i = 0; i< attributesCount; i++){
    let attributeInfo = gl.getActiveAttrib(program, i);
}

```


attributeInfo 对象包含 attribute 的变量名称 name，有了`name`我们就能够用 JavaScript 查找该 attribute 变量了：


```javascript
let attributeIndex = gl.getAttribLocation(program, attributeInfo.name);
```

接着是熟悉的对变量的启用、读取缓冲区方式的设置了，我们将这些操作封装到一个方法中。


```javascript
function createAttributeSetter(attributeIndex){
    return function(bufferInfo){
        gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.buffer);
        gl.enableVertexAttribArray(attributeIndex);
        gl.vertexAttribPointer(
          attributeIndex,
          bufferInfo.numsPerElement || bufferInfo.size,
          bufferInfo.type || gl.FLOAT,
          bufferInfo.normalize || false,
          bufferInfo.stride || 0,
          bufferInfo.offset || 0
        );
    }
}

```

定义一个 attribute 变量设置对象，对每个 attribute 绑定上面实现的设置方法`createAttributeSetter`。

```javascript
let attributeSetter = {};
for(let i = 0; i< attributesCount; i++){
    let attributeInfo = gl.getActiveAttrib(program, i);
    let attributeIndex = gl.getAttribLocation(program, attributeInfo.name);
    attributeSetter[attributeInfo.name] = createAttributeSetter(attributeIndex);
}
return attributeSetter;
```

以上是对着色器的各个attribute变量初始化操作，那么当我们需要对这些变量赋值时，就可以调用attribute 变量对应的 setter 函数对 attribute 进行设置了。


### 封装 uniforms 变量操作。
那么，除了 attribute 变量，程序中还充斥着很多 uniforms 变量，uniforms 变量是与顶点无关的，即不管执行多少遍顶点操作， uniforms 变量始终保持不变。

像 attribute 变量一样，我们仍然需要先找到所有 uniforms 变量：

```javascript
let uniformsCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
```

之后，遍历所有 uniforms 变量，根据 uniforms 变量名称，生成 uniforms 赋值函数。

```javascript
let uniformsSetters = {};
for(let i = 0; i< uniformsCount; i++){
    let uniformInfo = gl.getActiveUniform(program, i);
      if (!uniformInfo) {
        break;
      }
      let name = uniformInfo.name;
      if (name.substr(-3) === '[0]') {
        name = name.substr(0, name.length - 3);
      }
      var setter = createUniformSetter(program, uniformInfo);
      uniformSetters[name] = setter;
}
```

uniforms 赋值函数比较繁琐一些，只因 uniforms 变量类型比较多，我们需要针对 uniforms 变量类型，编写对应的赋值函数。

```javascript
let enums = {
        FLOAT_VEC2: {
            value: 0x8B50,
            setter: function(location, v){
                gl.uniform2fv(location, v);
            }
        },
        FLOAT_VEC3: {
            value: 0x8B51,
            setter: function(location, v){
                gl.uniform3fv(location, v);
            }
        }
        FLOAT_VEC4: {
            value: 0x8B52,
            setter: function(location, v){
                gl.uniform3fv(location, v);
            }
        },
        INT_VEC2: {
            value: 0x8B53,
            setter: function(location, v){
                gl.uniform2iv(location, v);
            }
        },
        INT_VEC3: {
            value: 0x8B54,
            setter: function(location, v){
                gl.uniform3iv(location, v);
            }
        },
        INT_VEC4: {
            value: 0x8B55,
            setter: function(location, v){
                gl.uniform4iv(location, v);
            }
        },
        BOOL: {
            value: 0x8B56,
            setter: function(location, v){
                gl.uniform1iv(location, v);
            }
        },
        BOOL_VEC2: {
            value: 0x8B57,
            setter: function(location, v){
                gl.uniform2iv(location, v);
            }
        },
        BOOL_VEC3: {
            value: 0x8B58,
            setter: function(location, v){
                gl.uniform3iv(location, v);
            }
        },
        BOOL_VEC4: {
            value: 0x8B59,
            setter: function(location, v){
                gl.uniform4iv(location, v);
            }
        },
        FLOAT_MAT2: {
            value: 0x8B5A,
            setter: function(location, v){
                gl.uniformMatrix2fv(location, false, v);
            }
        },
        FLOAT_MAT3: {
            value: 0x8B5B,
            setter: function(location, v){
                gl.uniformMatrix3fv(location, false, v);
            }
        },
        FLOAT_MAT4: {
            value: 0x8B5C,
            setter: function(location, v){
                gl.uniformMatrix4fv(location, false, v);
            }
        },
        SAMPLER_2D: {
            value: 0x8B5E,
            setter: function(location, texture){
            gl.uniform1i(location, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
          }
        },
        SAMPLER_CUBE: {
            value: 0x8B60,
            setter: function(location, texture){
                gl.uniform1i(location, 0);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
            }
        },
        
        INT: {
            value: 0x1404,
            setter: function(location, v){
                gl.uniform1i(location, v);
            }
        },
        
        FLOAT: {
            value: 0x1406,
            setter: function(location, v){
                gl.uniform1f(location, v);
            }
        }
};
```

enums 是所有的变量类型，但没有包含普通数组，所以我们还需要通过 uniformInfo.size 属性判断该 uniform 变量是否是数组，uniform 变量的 size 大于 1  并且该变量名称的最后三个字符是`[0]`，说明该 uniform 变量是数组类型，大家可以尝试一下。

> 有两点需要大家注意：  
> 1、如果 uniform 或者 attribute 变量只是在着色器中进行了定义，但没有被使用，那么它将被编译器抛弃，我们通过`gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS)`这种方式获取不到该变量。  
> 2、uniform 和 attribute 变量的数量并不是可以无限定义的，而是有一定上限，不同平台数量不同，一般 windows 平台 256 个，mac 和 linux 平台一般为 1024 个，如果定义数量超过这个上限，着色器程序会报编译错误。


```javascript
function createUniformSetter(gl, program, uniformInfo) {
    let uniformLocation = gl.getUniformLocation(program, uniformInfo.name);
    let type = uniformInfo.type;
    let isArray = uniformInfo.size > 1 && uniformInfo.name.substr(-3) === '[0]';
    
    if(isArray && type == enums.INT.value){
        return function(v) {
          gl.uniform1iv(location, v);
        };
    }
    if(isArray && type == enums.FLOAT.value){
        return function(v) {
          gl.uniform1fv(location, v);
        };
    }
    return function createSetter(v){
        return enums[getKeyFromType(type)].setter(location, v)
    }
}
```

以上就是 uniforms 变量的初始化过程，相对繁琐，但比较简单，容易理解。

## 绘制多个物体
既然有了模型类、uniforms 和 attribute 变量的赋值函数，接下来我们就可以创建一个模型列表和一个渲染列表，模型列表中存放所有模型对象，渲染列表中存放着待渲染的对象。

```javascript
// 渲染列表
let renderList = new List();
// 模型列表
let modelList = new list();

// 列表类
function List(list){
    this.list = list || [];
    this.uuid = list.length;
}
// 添加对象
List.prototype.add = function(object){
    object.uuid = this.uuid;
    this.list.push(object);
    this.uuid++;
}
// 删除对象
List.prototype.remove = function(object){
    this.list.splice(object.uuid, 1);
}
// 查找对象
List.prototype.get = function(index){
    return this.list[index];
}
// 遍历列表
List.prototype.forEach = function(callback){
    return this.list.forEach(callback);
}
```

模型列表和渲染列表的区别在于，渲染列表只存储和渲染相关的数据，比如着色器程序，模型的顶点缓冲数据，uniforms 数据等。

一个完整的模型对象有如下内容：

```javascript
let modelObject={
    // 偏移状态
    translation:[0, 0, 0],
    // 缩放状态
    scalation:[1, 1, 3],
    // 旋转状态
    rotation:[30, 60, 100],
    bufferInfo:{
        // 顶点属性
        attributes:{
            // 顶点坐标
            a_Position: {
                buffer: [],
                type: gl.FLOAT,
                normalize: false,
                numsPerElement: 4
            },
            ...
        },
        // 顶点索引
        indices: [],
        // 顶点数量
        elementsCount: 30
    },
    uniforms: {
        // MVP 矩阵
        u_Matrix: ...,
        // 模型矩阵
        u_ModelMatrix: ...,
        // 法向量矩阵
        u_NormalMatrix: ...,
        // 全局光照
        u_LightColor: ...,
        ...
    }
}
```

而一个渲染对象通常包含对应模型的几个属性：

```javascript
let renderObject = {
    // 模型
    bufferInfo: modelObject.bufferInfo,
    program: program,
    uniforms: modelObject.uniforms,
}
```

添加一个新模型时，我们只需要初始化模型对象，添加到 objectList 中，同时往 renderList 中添加渲染对象。

```javascript
let cube = createCube(5, 5, 5);
let cubeModel = new Model(cube);
objectList.add(cubeModel);
let renderObject= {
    program: program,
    model: cubeModel,
    primitive: 'TRIANGLES',
    renderType: 'drawArrays'
}
renderList.add(renderObject);
```


每次渲染时，首先遍历 objectList 中的模型对象，计算模型的 uniforms 变量，比如代表模型状态的 MVP 矩阵，模型矩阵，法向量矩阵等，以及顶点数据 bufferInfo，然后遍历 renderList 中的渲染对象，设置对应的 bufferInfo 和 uniforms 变量 ，执行绘制即可。


```javascript
objectList.forEach(function(modelObject){
    // 计算相关 uniforms 属性。
    modelObject.preRender();
})
renderList.forEach(function(renderObject){
    let bufferInfo = renderObject.model.bufferInfo;
    let uniforms = renderObject.model.uniforms;
    let program = renderObject.program;
    // 往顶点缓冲区传递数据
    setBufferInfos(gl, program, bufferInfo);
    // 设置 uniforms 变量。
    setUniforms(gl, program, uniforms);
    // 绘制
    if (renderObject.renderType === 'drawElements') {
        if (bufferInfo.indices) {
            gl.drawElements(object.primitive, bufferInfo.indices.length, gl.UNSIGNED_SHORT, 0);
            return;
        } else {
            console.warn('model buffer does not support indices to draw');
            return;
        }
    } else {
          gl.drawArrays(gl[object.primitive], 0, bufferInfo.elementsCount);
    }
})
```

## 演示

接下来我们用上面的代码演示一下绘制多个模型的场景，利用之前写好的立方体和球体生成函数，我们生成 200 个模型，随机分配颜色，请注意由于目前强制要求一个模型的顶点必须包含`颜色`、`坐标`、`纹理坐标`、`法向量`的，所以我们的模型生成函数必须要有能力生成这些属性。

```javascript
let cube = createCube(2, 2, 2);
// 将带索引的立方体顶点数据转化成无索引的顶点数据
cube = transformIndicesToUnIndices(cube);
// 为顶点数据添加颜色信息
createColorForVertex(cube);
let sphere = createSphere(1, 10, 10);
// 将带索引的球体顶点数据转化成无索引的顶点数据
sphere = transformIndicesToUnIndices(sphere);
// 为顶点数据添加颜色信息
createColorForVertex(sphere);
```


根据上面的顶点数据生成模型缓冲对象：


```javascript
// 生成立方体的顶点缓冲对象
let cubeBufferInfo = createBufferInfoFromObject(gl, cube);
// 生成球体的顶点缓冲对象
let sphereBufferInfo = createBufferInfoFromObject(gl, sphere);
```


创建模型列表和渲染列表,这里我们选择创建 100 个模型


```javascript
let modelList = new List();
let renderList = new List();
for (var i = 0; i < 100; ++i) {
    var object = new Model();
    if (i % 2 == 0) {
        object.setBufferInfo(bufferInfo);
    } else {
        object.setBufferInfo(sphereBufferInfo);
    }
    // 设置模型的位置
    object.translate(rand(-10, 10), rand(-10, 10), rand(-10, 10));
    // 设置模型的旋转角度
    object.rotate(rand(0, 90));
    // 预渲染
    object.preRender(viewMatrix, projectionMatrix);
    // 设置模型的 uniforms 属性。
    object.setUniforms({
        u_ModelMatrix: object.u_ModelMatrix,
        u_Matrix: object.u_Matrix,
        u_ColorFactor: new Float32Array([rand(0.5, 0.75), rand(0.5, 0.75), rand(0.25, 0.5)])
    })

    objectList.add(object);
    // 根据模型对象创建渲染对象，并将渲染对象添加到渲染列表中
    renderList.add({
        programInfo: program,
        model: object,
        primitive: gl.TRIANGLES,
        renderType: 'drawArrays'
    });
}
```

有了模型列表和渲染列表，接下来我们就可以执行渲染操作了，渲染操作是遍历渲染列表，重新设置模型的 bufferInfo 和 uniforms 属性，然后执行绘制。


```javascript
function render() {
    if (!playing) {
        requestAnimationFrame(render);
        return;
    }
    // 重新设置模型的状态
    objectList.forEach(function (object) {
        object.rotateX(object.rotation[0] + rand(0.2, 0.5));
        object.rotateY(object.rotation[1] + rand(0.2, 0.5));
        object.rotateZ(object.rotation[1] + rand(0.2, 0.5));
        object.preRender(viewMatrix, projectionMatrix);
        object.setUniforms({
            u_ModelMatrix: object.u_ModelMatrix,
            u_Matrix: object.u_Matrix,
        })
    })
    // 执行渲染
    let lastProgram;
    let lastBufferInfo;
    renderList.forEach(function (object) {
        let programInfo = object.programInfo;
        let bufferInfo = object.model.bufferInfo;
        let uniforms = object.model.uniforms;
        let bindBuffers = false;
        if (programInfo !== lastProgram) {
          lastProgram = programInfo;
          gl.useProgram(programInfo.program);
          bindBuffers = true;
        }

        if (bindBuffers || bufferInfo !== lastBufferInfo) {
          lastBufferInfo = bufferInfo;
          setBufferInfos(gl, programInfo, bufferInfo);
        }
        setUniforms(programInfo, uniforms);

        // 绘制
        if (object.renderType === 'drawElements') {
          if (bufferInfo.indices) {
            gl.drawElements(object.primitive, bufferInfo.indices.length, gl.UNSIGNED_SHORT, 0);
            return;
          } else {
            console.warn('model buffer does not support indices to draw');
            return;
          }
        } else {
          gl.drawArrays(gl[object.primitive], 0, bufferInfo.elementsCount);
        }
      });
      requestAnimationFrame(render);
    }
```


上面这些就是重构后的调用代码，是不是很简洁了很多？我们看下效果：


![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/11/6/166e7faf5af2477e~tplv-t2oaga2asx-image.image)

## 回顾
本节将之前的代码进行重构优化，大家可以看到一些前面用到的、没有用到的函数，比如 `uniforms` 属性赋值函数，虽然种类很多，但是很容易就能够见名知意。之前代码有用到 `gl.uniform1f` 给变量赋值单个 `float` 类型的数字，其他类似的函数也是为了给 uniform 变量赋值，只是赋值类型不同。


通过对重用代码进行封装，我们能够以很少的代码绘制多个模型，并且不用再去编写繁琐的`buffer` 和 `uniform` 的赋值代码，我们把精力放在编写模型的状态逻辑上，这大大地提高了我们的开发效率。

下一节我们开始学习光照效果，光照效果涉及到一些物理学知识，大家先别急着看代码，先理解下物理知识，然后多做实践，相信大家很快就能掌握。


