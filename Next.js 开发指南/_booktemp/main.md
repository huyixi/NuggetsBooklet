---
title: Next.js 开发指南
author: Next.js 开发指南
date: 2025-02-14
lang: zh-CN
---

## 1.答疑篇 | 学习路线与答疑

## 学习路线

感谢购买小册!

这本小册由基础篇、实战篇、源码篇、面试篇四大篇章组成，预计 70 篇左右。

对于初学者，建议：

1.  看完基础篇前 20 篇，了解如何使用脚手架、如何定义路由、如何获取数据、如何定义样式等写 Next.js 项目最基本的知识

2.  基础篇后 16 篇作为开发手册使用，可以 10 分钟看完一篇，了解大致有哪些内容就行，用到时再查

3.  进入实战篇，至少写出第一个实战项目 React Notes，在实战中体会 Next.js 的用法
4.  进入源码篇，了解实现原理，知其然，知其所以然

## 常见问题

**Q：学习 Next.js 需要 React 基础吗？**

A：需要一点，但不多。如果你用过 React 做过项目，或是看过文档、写过 Demo，那够了，有遇到 React 问题不会的再去查就行。

<br/>

**Q: 学习 Next.js 需要 Node.js 基础吗？**

A: 需要一点，但不多，比 React 还少。如果你给自己制定先系统学习 React，再学习 Node，最后学习 Next.js 这种看似“完美”的学习路线，我建议你尽早放弃。能不能完成这么漫长的学习周期，心里没点b数吗？

学习一定不能讲究“延迟满足”。整个过程时间周期太长，如果中间看不到任何反馈，你很容易就放弃。就算过程中实现了某个小目标，虽然感受到了自己的优秀和成长，但这种反馈往往又比较温和。一个东西花时间久又看不到什么大的成效，出于人趋利避害的本性，人自然就会选择逃避、放弃。

正是因为学习本身就是要克服痛苦的，所以学习更要讲究“及时反馈、及时满足”。 简单来说，不要磨磨唧唧，没那么难，直接上 Next.js，学完基础知识就做项目，过程虽痛苦但高效。做项目和解决实际问题才是最真实、有效、直接的反馈。

PS：其实“学习”这件事情也是需要学习的，可以听听冴羽长达 3 小时的关于[《如何高效学习》](https://www.yuque.com/yayu/blog/grow#TdtOC)的絮叨。

<br/>

**Q：Next.js、Nuxt.js、Nest.js 傻傻分不清楚**

A：简单的说，Next 是 React 全栈框架，Nuxt 是 Vue 全栈框架，Nest 是后端框架。也就说，Next.js 适合用来做全栈项目，在 Next.js 中既可以写页面，又可以写接口，一个项目全部搞定。

而且 Next.js 内置了各种方便开发的 API 和工具，所以要快速创建一个性能还不错的全栈项目，那就用 Next.js。

Nuxt.js 对标 Next.js，可以放在一起讲，但其实也没有什么放在一起讲的必要，这更多是技术选型问题，会 React 用 Next.js ，会 Vue 用 Nuxt.js。而 Nest.js 是纯后端框架，也就是用来纯写后端服务。简单来说，写全栈项目用 Next 和 Nuxt，纯写后端服务，用 Nest。三者解决的是不同的场景问题，根据自己的需要选择即可。

<br/>

**Q：学习 Next.js 有前途吗？**

A：目前 Next.js Npm 周均下载量 634W 左右，是国外主流的技术选型。React 首推的生产框架也是 Next.js。

而且 Next.js 背靠 Vercel，挖了不少业界大佬，比如 Sebastian Markbage（原 React 团队 Tech Lead）、Rich Harries（Svelte 作者）、Donny（SWC 作者）、Tobias Koppers（Webpack 作者）、Jared Palme（Turborepo 创始人）等等，全明星的开发团队，未来可期。

PS：至于人的前途，终归是要靠自己去创造的……

<br/>

**Q：为什么推荐买这本小册？**

A：因为我写的小册我自然是要推荐的……开个玩笑，尽管 Next.js 是一个非常受欢迎的框架，但 Next.js 在中文文档汉化方面十分落后，能搜到的中文文档基本都停留在非常老的版本上且处于无人维护状态。Next.js 于 2022 年底推出了基于 RSC 的 v13 版本，提供了全新的开发方式，文档也早已重写，然而这些内容在国内却没有系统完整的介绍，能搜到的更多是单篇的粗略介绍，技术细节寥寥。

这就导致大家在使用 Next.js 的时候也许可以快速上手，但对于高阶的 API 却知之甚少。有更简单、便捷的实现方案却不知道，对于细枝末节上的问题需要多次深入英文文档翻找，对于一些没有过多解释的地方更需要自己反复测试和理解，这无疑增大了使用 Next.js 的成本。

我写的这本小册，也许不一定够好，但内容至少是新的、完整的、有体系的、有细致讲解的。与其自己费力的阅读英文文档，搜一堆细节问题的答案，踩一堆坑，不如跟着这本小册的内容循序渐进，肯定也会遇到一些问题，但一定比自己学省时省力。节省出的时间，请去创造自己的产品，去优化自己的业务，去找对象吧！

<br/>

**Q：如何加入学习群？**

A：小册购买后，小册主页有个 “+学习群” 按钮，添加好友后回复特殊口令即会邀请你加入学习群。

PS：因为最近机器人被封，所以可以直接扫码入群。

<br/>

**Q：还有什么建议？**

A: 费曼学习法是一个非常知名、备受推崇的学习法。它的核心是 —— 当你准备学习一门新知识时，必须站在传授者的立场，假设自己要向别人讲解这门知识。那么你一定要用最简洁、清晰和易于理解的语言表达出来，才能让行外的人也能听懂。

简单的来说就是确定要学习的目标，进行主题学习，然后以教为学，在输出的过程中不断重新学习、回顾和反思。

输出其实是一种对学习者更高的要求。因为在输出知识时你就不能简单地复制粘贴，而是既能总结出知识的精华，又能加上自己深刻的理解，还要用大家都能看懂、听懂的语言往外传播。

希望大家在阅读此本小册的过程中，能够持续输出，你学习时遇到的那些问题一定还会有其他小伙伴会遇到，将其解决方法和实现思路写出来，勇敢的分享出来吧！

PS：欢迎将自己原创的 Next.js 相关文章分享到此篇评论区中，至少我看到一定会给你点赞的！


## 10.渲染篇 | Suspense 与 Streaming

## 前言

Suspense 是 Next.js 项目中常用的一个组件，了解其原理和背景有助于我们正确使用 Suspense 组件。

## 传统 SSR

在最近的两篇文章里，我们已经介绍了 SSR 的原理和缺陷。简单来说，使用 SSR，需要经过一系列的步骤，用户才能查看页面、与之交互。具体这些步骤是：

1.  服务端获取所有数据
2.  服务端渲染 HTML
3.  将页面的 HTML、CSS、JavaScript 发送到客户端
4.  使用 HTML 和 CSS 生成不可交互的用户界面（non-interactive UI）
5.  React 对用户界面进行水合（hydrate），使其可交互（interactive UI）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ca67632f94426e92512ed318259736~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=612\&s=307750\&e=png\&b=161616)

这些步骤是连续的、阻塞的。这意味着服务端只能在获取所有数据后渲染 HTML，React 只能在下载了所有组件代码后才能进行水合：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fec73cefc3924b47bf4a112919bb72d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=748\&s=373884\&e=png\&b=141414)

还记得上篇总结的 SSR 的几个缺点吗？

1.  SSR 的数据获取必须在组件渲染之前
2.  组件的 JavaScript 必须先加载到客户端，才能开始水合
3.  所有组件必须先水合，然后才能跟其中任意一个组件交互

## Suspense

为了解决这些问题，React 18 引入了 [\<Suspense\>](https://react.dev/reference/react/Suspense) 组件。我们来介绍下这个组件：

`<Suspense>` 允许你推迟渲染某些内容，直到满足某些条件（例如数据加载完毕）。

你可以将动态组件包装在 Suspense 中，然后向其传递一个 fallback UI，以便在动态组件加载时显示。如果数据请求缓慢，使用 Suspense 流式渲染该组件，不会影响页面其他部分的渲染，更不会阻塞整个页面。

让我们来写一个例子，新建 `app/dashboard/page.js`，代码如下：

```jsx
import { Suspense } from 'react'

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function PostFeed() {
  await sleep(2000)
  return <h1>Hello PostFeed</h1>
}

async function Weather() {
  await sleep(8000)
  return <h1>Hello Weather</h1>
}

async function Recommend() {
  await sleep(5000)
  return <h1>Hello Recommend</h1>
}

export default function Dashboard() {
  return (
    <section style={{padding: '20px'}}>
      <Suspense fallback={<p>Loading PostFeed Component</p>}>
        <PostFeed />
      </Suspense>
      <Suspense fallback={<p>Loading Weather Component</p>}>
        <Weather />
      </Suspense>
      <Suspense fallback={<p>Loading Recommend Component</p>}>
        <Recommend />
      </Suspense>
    </section>
  )
}
```

在这个例子中，我们用 Suspense 包装了三个组件，并通过 sleep 函数模拟了数据请求耗费的时长。加载效果如下：

![suspense.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60be4c9076614e16934f26215a242841~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1449\&h=507\&s=269182\&e=gif\&f=26\&b=1a1a1a)

可是 Next.js 是怎么实现的呢？

让我们观察下 dashboard 这个 HTML 文件的加载情况，你会发现它一开始是 2.03s，然后变成了 5.03s，最后变成了 8.04s，这不就正是我们设置的 sleep 时间吗？

查看 dashboard 请求的响应头：

![截屏2024-03-04 22.47.51.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0d2d120619c4c74a494805105f1c717~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1866\&h=956\&s=245353\&e=png\&b=292929)

`Transfer-Encoding` 标头的值为 `chunked`，表示数据将以一系列分块的形式进行发送。

> 分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许 HTTP由网页服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在 HTTP 协议1.1版本（HTTP/1.1）中提供。

再查看 dashboard 返回的数据（这里我们做了简化）：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        // ...
    </head>
    <body class="__className_aaf875">
        <section style="padding:20px">
            <!--$?-->
            <template id="B:0"></template>
            <p>Loading PostFeed Component</p>
            <!--/$-->
            <!--$?-->
            <template id="B:1"></template>
            <p>Loading Weather Component</p>
            <!--/$-->
            <!--$?-->
            <template id="B:2"></template>
            <p>Loading Recommend Component</p>
            <!--/$-->
        </section>
        // ...
        <div hidden id="S:0">
            <h1>Hello PostFeed</h1>
        </div>
        <script>
            // 交换位置
            $RC = function(b, c, e) {
                // ...
            };
            $RC("B:0", "S:0")
        </script>
        <div hidden id="S:2">
            <h1>Hello Recommend</h1>
        </div>
        <script>
            $RC("B:2", "S:2")
        </script>
        <div hidden id="S:1">
            <h1>Hello Weather</h1>
        </div>
        <script>
            $RC("B:1", "S:1")
        </script>
    </body>
</html>

```

可以看到使用 Suspense 组件的 fallback UI 和渲染后的内容都会出现在该 HTML 文件中，说明该请求持续与服务端保持连接，服务端在组件渲染完后会将渲染后的内容追加传给客户端，客户端收到新的内容后进行解析，执行类似于 `$RC("B:2", "S:2")`这样的函数交换 DOM 内容，使 fallback UI 替换为渲染后的内容。

这个过程被称之为 Streaming Server Rendering（流式渲染），它解决了上节说的传统 SSR 的第一个问题，那就是数据获取必须在组件渲染之前。使用 Suspense，先渲染 Fallback UI，等数据返回再渲染具体的组件内容。

使用 Suspense 还有一个好处就是 Selective Hydration（选择性水合）。简单的来说，当多个组件等待水合的时候，React 可以根据用户交互决定组件水合的优先级。比如 Sidebar 和 MainContent 组件都在等待水合，快要到 Sidebar 了，但此时用户点击了 MainContent 组件，React 会在单击事件的捕获阶段同步水合 MainContent 组件以保证立即响应，Sidebar 稍后水合。

总结一下，使用 Suspense，可以解锁两个主要的好处，使得 SSR 的功能更加强大：

1.  Streaming Server Rendering（流式渲染）：从服务器到客户端渐进式渲染 HTML
2.  Selective Hydration（选择性水合）：React 根据用户交互决定水合的优先级

### Suspense 会影响 SEO 吗？

首先，Next.js 会等待 [generateMetadata](https://juejin.cn/book/7307859898316881957/section/7309079119902277669#heading-3) 内的数据请求完毕后，再将 UI 流式传输到客户端，这保证了响应的第一部分就会包含 `<head>` 标签。

其次，因为 Streaming 是流式渲染，HTML 中会包含最终渲染的内容，所以它不会影响 SEO。

### Suspense 如何控制渲染顺序？

在刚才的例子中，我们是将三个组件同时进行渲染，哪个组件的数据先返回，就先渲染哪个组件。

但有的时候，希望按照某种顺序展示组件，比如先展示 `PostFeed`，再展示`Weather`，最后展示`Recommend`，此时你可以将 Suspense 组件进行嵌套：

```javascript
import { Suspense } from 'react'

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function PostFeed() {
  await sleep(2000)
  return <h1>Hello PostFeed</h1>
}

async function Weather() {
  await sleep(8000)
  return <h1>Hello Weather</h1>
}

async function Recommend() {
  await sleep(5000)
  return <h1>Hello Recommend</h1>
}

export default function Dashboard() {
  return (
    <section style={{padding: '20px'}}>
      <Suspense fallback={<p>Loading PostFeed Component</p>}>
        <PostFeed />
        <Suspense fallback={<p>Loading Weather Component</p>}>
          <Weather />
          <Suspense fallback={<p>Loading Recommend Component</p>}>
            <Recommend />
          </Suspense>
        </Suspense>
      </Suspense>
    </section>
  )
}
```

那么问题来了，此时页面的最终加载时间是多少秒？是请求花费时间最长的 8s 还是 2 + 8 + 5 = 15s 呢？让我们看下效果：

![suspense1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00bcbba3b76e48728dc4958076e82257~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1462\&h=509\&s=222364\&e=gif\&f=13\&b=fcfcfc)

答案是 8s，这些数据请求是同时发送的，所以当 Weather 组件返回的时候，Recommend 组件立刻就展示了出来。

注意：这也是因为这里的数据请求并没有前后依赖关系，如果有那就另讲了。

## Streaming

### 介绍

Suspense 背后的这种技术称之为 Streaming。将页面的 HTML 拆分成多个 chunks，然后逐步将这些块从服务端发送到客户端。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dbd0db15ec434ce7bd32db7f7a0adcc0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3200\&h=1236\&s=842460\&e=png\&b=141414)

这样就可以更快的展现出页面的某些内容，而无需在渲染 UI 之前等待加载所有数据。提前发送的组件可以提前开始水合，这样当其他部分还在加载的时候，用户可以和已完成水合的组件进行交互，有效改善用户体验。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c889efc33d504902adfcc0c43e64502b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3200\&h=900\&s=604411\&e=png\&b=161616)

Streaming 可以有效的阻止耗时长的数据请求阻塞整个页面加载的情况。它还可以减少加载[第一个字节所需时间（TTFB）](https://web.dev/articles/ttfb?hl=zh-cn)和[首次内容绘制（FCP）](https://developer.chrome.com/docs/lighthouse/performance/first-contentful-paint/)，有助于缩短[可交互时间（TTI）](https://developer.chrome.com/en/docs/lighthouse/performance/interactive/)，尤其在速度慢的设备上。

传统 SSR：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c85db6b77c54d56b1b104cb96edc17b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=612\&s=307750\&e=png\&b=161616)

使用 Streaming 后：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e3a28d086c44749a89daf69e7d34374~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=730\&s=373563\&e=png\&b=171717)

### 使用

在 Next.js 中有两种实现 Streaming 的方法：

1.  页面级别，使用 `loading.jsx`
2.  特定组件，使用 `<Suspense>`

`<Suspense>` 上节已经介绍过，`loading.jsx` 在 [《路由篇 | App Router》](https://juejin.cn/book/7307859898316881957/section/7308681814742417434#heading-11)也介绍过。这里分享一个使用 `loading.jsx` 的小技巧，那就是当多个页面复用一个 loading.jsx 效果的时候可以借助路由组来实现。

目录结构如下：

```javascript
app                  
├─ (dashboard)       
│  ├─ about          
│  │  └─ page.js     
│  ├─ settings       
│  │  └─ page.js     
│  ├─ team           
│  │  └─ page.js     
│  ├─ layout.js      
│  └─ loading.js         

```

其中 `app/(dashboard)/layout.js`代码如下：

```javascript
import Link from 'next/link'

export default function DashboardLayout({
  children,
}) {
  return (
    <section>
        <nav className="flex items-center justify-center gap-10 text-blue-600 mb-6">
          <Link href="/about">About</Link>
          <Link href="/settings">Settings</Link>
          <Link href="/team">Team</Link>
        </nav>
      {children}
    </section>
  )
}
```

`app/(dashboard)/loading.js`代码如下：

```javascript
export default function DashboardLoading() {
  return  <div className="h-60 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">Loading</div>
}
```

`app/(dashboard)/about/page.js`代码如下：

```javascript
const sleep = ms => new Promise(r => setTimeout(r, ms));

export default async function About() {
  await sleep(2000)
  return (
    <div className="h-60 flex-1 rounded-xl bg-teal-400 text-white flex items-center justify-center">Hello, About!</div>
  )
}
```

剩余两个组件代码与 About 组件类似。最终的效果如下：

![suspense2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2871317841224854bb18e2b0f1a4fe96~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=874\&h=538\&s=105637\&e=gif\&f=60\&b=6ad1bc)

在线查看效果和代码：[CodeSandbox Loading](https://codesandbox.io/p/devbox/loading-jsx-zx4mfy?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cltdu2u3z00073b6i08865iv9%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cltdu2u3z00023b6ijugbhpax%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cltdu2u3z00043b6i2wg1p3h8%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cltdu2u3z00063b6ig9e8y777%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cltdu2u3z00023b6ijugbhpax%2522%253A%257B%2522id%2522%253A%2522cltdu2u3z00023b6ijugbhpax%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cltdu2u3z00063b6ig9e8y777%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltdu2u3z00053b6i3v1assnv%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fabout%2522%257D%255D%252C%2522id%2522%253A%2522cltdu2u3z00063b6ig9e8y777%2522%252C%2522activeTabId%2522%253A%2522cltdu2u3z00053b6i3v1assnv%2522%257D%252C%2522cltdu2u3z00043b6i2wg1p3h8%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltdu2u3z00033b6i19ll8rh0%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522cltdu2u3z00043b6i2wg1p3h8%2522%252C%2522activeTabId%2522%253A%2522cltdu2u3z00033b6i19ll8rh0%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

### 缺点

Suspense 和 Streaming 确实很好，将原本只能先获取数据、再渲染水合的传统 SSR 改为渐进式渲染水合，但还有一些问题没有解决。就比如用户下载的 JavaScript 代码，该下载的代码还是没有少，可是用户真的需要下载那么多的 Javascript 代码吗？又比如所有的组件都必须在客户端进行水合，对于不需要交互性的组件其实没有必要进行水合。

为了解决这些问题，目前的最终方案就是上一篇介绍的 RSC：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e78230237ee74eb4bf31fba92be6ebf6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920\&h=1080\&s=619076\&e=png\&b=020a0b)

当然这并不是说 RSC 可以替代 Suspense，实际上两者可以组合使用，带来更好的性能体验。我们会在实战篇的项目中慢慢体会。

## 参考链接

1.  <https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming>
2.  <https://vercel.com/blog/how-streaming-helps-build-faster-web-applications>
3.  <https://www.builder.io/blog/why-react-server-components#suspense-for-server-side-rendering>


## 11.渲染篇 | 服务端组件和客户端组件

## 前言

服务端组件和客户端组件是 Next.js 中非常重要的概念。如果没有细致的了解过，你可能会简单的以为所谓服务端组件就是 SSR，客户端组件就是 CSR，服务端组件在服务端进行渲染，客户端组件在客户端进行渲染等等，实际上并非如此。本篇就让我们深入学习和探究 Next.js 的双组件模型吧！

## 服务端组件

### 1. 介绍

在 Next.js 中，组件默认就是服务端组件。

举个例子，新建 `app/todo/page.js`，代码如下：

```javascript
export default async function Page() {
  const res = await fetch('https://jsonplaceholder.typicode.com/todos')
  const data = (await res.json()).slice(0, 10)
  console.log(data)
  return <ul>
    {data.map(({ title, id }) => {
      return <li key={id}>{title}</li>
    })}
  </ul>
}
```

请求会在服务端执行，并将渲染后的 HTML 发送给客户端：

![截屏2024-03-05 15.59.27.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f949a6245142c686aceed30a4ca9d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3708\&h=1778\&s=775078\&e=png\&b=fefefe)

因为在服务端执行，`console` 打印的结果也只可能会出现在命令行中，而非客户端浏览器中。

### 2. 优势

使用服务端渲染有很多好处：

1.  数据获取：通常服务端环境（网络、性能等）更好，离数据源更近，在服务端获取数据会更快。通过减少数据加载时间以及客户端发出的请求数量来提高性能
2.  安全：在服务端保留敏感数据和逻辑，不用担心暴露给客户端
3.  缓存：服务端渲染的结果可以在后续的请求中复用，提高性能
4.  bundle 大小：服务端组件的代码不会打包到 bundle 中，减少了 bundle 包的大小
5.  初始页面加载和 FCP：服务端渲染生成 HTML，快速展示 UI
6.  Streaming：服务端组件可以将渲染工作拆分为 chunks，并在准备就绪时将它们流式传输到客户端。用户可以更早看到页面的部分内容，而不必等待整个页面渲染完毕

因为服务端组件的诸多好处，**在实际项目开发的时候，能使用服务端组件就尽可能使用服务端组件**。

### 3. 限制

虽然使用服务端组件有很多好处，但使用服务端组件也有一些限制，比如不能使用 useState 管理状态，不能使用浏览器的 API 等等。如果我们使用了 Next.js 会报错，比如我们将代码修改为：

```javascript
import { useState } from 'react';

export default async function Page() {

  const [title, setTitle] = useState('');

  const res = await fetch('https://jsonplaceholder.typicode.com/todos')
  const data = (await res.json()).slice(0, 10)
  console.log(data)
  return <ul>
    {data.map(({ title, id }) => {
      return <li key={id}>{title}</li>
    })}
  </ul>
}
```

此时浏览器会报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba27110eabb549e4a4f23d7c57da386d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1648\&h=676\&s=128433\&e=png\&b=1a1a1a)

报错提示我们此时需要使用客户端组件。那么又该如何使用客户端组件呢？

## 客户端组件

### 1. 介绍

使用客户端组件，你需要在文件顶部添加一个 `"use client"` 声明，修改 `app/todo/page.js`，代码如下：

```javascript
'use client'

import { useEffect, useState } from 'react';

function getRandomInt(min, max) {
  const minCeiled = Math.ceil(min);
  const maxFloored = Math.floor(max);
  return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
}

export default function Page() {

  const [list, setList] = useState([]);

  const fetchData = async () => {
    const res = await fetch('https://jsonplaceholder.typicode.com/todos')
    const data = (await res.json()).slice(0, getRandomInt(1, 10))
    setList(data)
  }

  useEffect(() => {
    fetchData()
  }, [])

  return (
    <>
      <ul>
        {list.map(({ title, id }) => {
          return <li key={id}>{title}</li>
        })}
      </ul>
      <button onClick={() => {
        location.reload()
      }}>换一批</button>
    </>
  )
}
```

在这个例子中，我们使用了 useEffect、useState 等 React API，也给按钮添加了点击事件、使用了浏览器的 API。无论使用哪个都需要先声明为客户端组件。

**注意：`"use client"`用于声明服务端和客户端组件模块之间的边界。当你在文件中定义了一个 `"use client"`，导入的其他模块包括子组件，都会被视为客户端 bundle 的一部分。**

### 2. 优势

1.  交互性：客户端组件可以使用 state、effects 和事件监听器，意味着用户可以与之交互
2.  浏览器 API：客户端组件可以使用浏览器 API 如地理位置、localStorage 等

## 服务端组件 VS 客户端组件

### 1. 如何选择使用？

| 如果你需要……                                           | 服务端组件 | 客户端组件 |
| ------------------------------------------------- | ----- | ----- |
| 获取数据                                              | ✅     | ❌     |
| 访问后端资源（直接）                                        | ✅     | ❌     |
| 在服务端上保留敏感信息（访问令牌、API 密钥等）                         | ✅     | ❌     |
| 在服务端使用依赖包，从而减少客户端 JavaScript 大小                   | ✅     | ❌     |
| 添加交互和事件侦听器（onClick(), onChange() 等）               | ❌     | ✅     |
| 使用状态和生命周期（useState(), useReducer(), useEffect()等） | ❌     | ✅     |
| 使用仅限浏览器的 API                                      | ❌     | ✅     |
| 使用依赖于状态、效果或仅限浏览器的 API 的自定义 hook                   | ❌     | ✅     |
| 使用 React 类组件                                      | ❌     | ✅     |

### 2. 渲染环境

**服务端组件只会在服务端渲染，但客户端组件会在服务端渲染一次，然后在客户端渲染。**

这是什么意思呢？让我们写个例子，新建 `app/client/page.js`，代码如下：

```javascript
'use client'

import { useState } from 'react';

console.log('client')

export default function Page() {

  console.log('client Page')

  const [text, setText] = useState('init text');

  return (
    <button onClick={() => {
      setText('change text')
    }}>{text}</button>
  )
}
```

新建 `app/server/page.js`，代码如下：

```javascript
console.log('server')

export default function Page() {

  console.log('server Page')

  return (
    <button>button</button>
  )
}
```

现在运行 `npm run build`，会打印哪些数据呢？

答案是无论客户端组件还是服务端组件，都会打印：

![截屏2024-03-05 21.46.46.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e339f9ee0ff4ba9a2d6d306696350dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1066\&h=1102\&s=946992\&e=png\&b=070314)

而且根据输出的结果，无论是 `/client`还是 `/server`走的都是静态渲染。

当运行 `npm run start`的时候，又会打印哪些数据呢？

答案是命令行中并不会有输出，访问 `/client`的时候，浏览器会有打印：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bd886475c77487e9bc07cc5d4513388~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920\&h=688\&s=110247\&e=png\&b=1a1a1a)

访问 `/server`的时候，浏览器不会有任何打印：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6384d18a64504b839039aa6bfd4f0c07~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1914\&h=486\&s=76742\&e=png\&b=1c1c1c)

客户端组件在浏览器中打印，这可以理解，毕竟它是客户端组件，当然要在客户端运行。可是客户端组件为什么在编译的时候会运行一次呢？让我们看下 `/client` 的返回：

![截屏2024-03-05 22.00.58.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c81815267654e849a40023b5df41838~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2458\&h=968\&s=373493\&e=png\&b=1d1d1d)

你会发现 `init text`其实是来自于 useState 中的值，但是却依然输出在 HTML 中。这就是编译客户端组件的作用，为了第一次加载的时候能更快的展示出内容。

所以其实所谓服务端组件、客户端组件并不直接对应于物理上的服务器和客户端。服务端组件运行在构建时和服务端，客户端组件运行在构建时、服务端（生成初始 HTML）和客户端（管理 DOM）。

### 3. 交替使用服务端组件和客户端组件

实际开发的时候，不可能纯用服务端组件或者客户端组件，当交替使用的时候，一定要注意一点，那就是：

**服务端组件可以直接导入客户端组件，但客户端组件并不能导入服务端组件**

```javascript
'use client'
 
// 这是不可以的
import ServerComponent from './Server-Component'
 
export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)
 
  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
 
      <ServerComponent />
    </>
  )
}

```

但同时正如介绍客户端组件时所说：

> "use client"用于声明服务端和客户端组件模块之间的边界。当你在文件中定义了一个 "use client"，导入的其他模块包括子组件，都会被视为客户端 bundle 的一部分。

组件默认是服务端组件，但当组件导入到客户端组件中会被认为是客户端组件。客户端组件不能导入服务端组件，其实是在告诉你，如果你在服务端组件中使用了诸如 Node API 等，该组件可千万不要导入到客户端组件中。

但你可以将服务端组件以 props 的形式传给客户端组件：

```javascript
'use client'
 
import { useState } from 'react'
 
export default function ClientComponent({ children }) {
  const [count, setCount] = useState(0)
 
  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  )
}
```

```javascript
import ClientComponent from './client-component'
import ServerComponent from './server-component'
 
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```

使用这种方式，`<ClientComponent>` 和 `<ServerComponent>` 代码解耦且独立渲染。

注：你可能会想为什么要这么麻烦的非要使用 ServerComponent 呢？这是因为 ServerComponent 有很多好处比如代码不会打包到 bundle 中。而为什么以 props 的形式就可以传递呢？在 [《实战篇 | React Notes | 笔记搜索》](https://juejin.cn/book/7307859898316881957/section/7309111974141362202)中，我们会结合实战项目更具体的讲解。

### 4. 组件渲染原理

在服务端：

Next.js 使用 React API 编排渲染，渲染工作会根据路由和 Suspense 拆分成多个块（chunks），每个块分两步进行渲染：

1.  React 将服务端组件渲染成一个特殊的数据格式称为 **React Server Component Payload (RSC Payload)**
2.  Next.js 使用 RSC Payload 和客户端组件代码在服务端渲染 HTML

> RSC payload 中包含如下这些信息：
>
> 1.  服务端组件的渲染结果
> 2.  客户端组件占位符和引用文件
> 3.  从服务端组件传给客户端组件的数据

在客户端：

1.  加载渲染的 HTML 快速展示一个非交互界面（Non-interactive UI）
2.  RSC Payload 会被用于协调（reconcile）客户端和服务端组件树，并更新 DOM
3.  JavaScript 代码被用于水合客户端组件，使应用程序具有交互性（Interactive UI）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8e343dc5c2c455596a8c3bd00e569cf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1570\&h=854\&s=820753\&e=png\&b=111415)

注意：上图描述的是页面初始加载的过程。其中 SC 表示 Server Components 服务端组件，CC 表示 Client Components 客户端组件。

我们在上节[《渲染篇 | Suspense 与 Streaming》](https://juejin.cn/book/7307859898316881957/section/7342436717142409242#heading-8)讲到 Suspense 和 Streaming 也有一些问题没有解决，比如该加载的 JavaScript 代码没有少、所有组件都必须水合，即使组件不需要水合。

使用服务端组件和客户端组件就可以解决这个问题，服务端组件的代码不会打包到客户端 bundle 中。渲染的时候，只有客户端组件需要进行水合，服务端组件无须水合。

而在后续导航的时候：

1.  客户端组件完全在客户端进行渲染
2.  React 使用 RSC Payload 来协调客户端和服务端组件树，并更新 DOM

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65f99b5002114436b5b0d3250c270a71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1586\&h=844\&s=758469\&e=png\&b=111415)

线上查看代码和效果：[CodeSandbox Server Components And Client Components](https://codesandbox.io/p/devbox/team-pm7qsz?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522cltfm0thd00073b6ihtzhdp7h%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522cltfm0thd00023b6iy9zjtjt7%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522cltfm0thd00043b6iv1i7b4xt%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522cltfm0thd00063b6iygu09302%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522cltfm0thd00023b6iy9zjtjt7%2522%253A%257B%2522id%2522%253A%2522cltfm0thd00023b6iy9zjtjt7%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522cltfm0thd00063b6iygu09302%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltfm0thd00053b6i9mstj5l7%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fteam%2522%257D%255D%252C%2522id%2522%253A%2522cltfm0thd00063b6iygu09302%2522%252C%2522activeTabId%2522%253A%2522cltfm0thd00053b6i9mstj5l7%2522%257D%252C%2522cltfm0thd00043b6iv1i7b4xt%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522cltfm0thd00033b6ii38rpxll%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522cltfm0thd00043b6iv1i7b4xt%2522%252C%2522activeTabId%2522%253A%2522cltfm0thd00033b6ii38rpxll%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

## 最佳实践：使用服务端组件

### 1. 共享数据

当在服务端获取数据的时候，有可能出现多个组件共用一个数据的情况。

面对这种情况，你不需要使用 React Context（当然服务端也用不了），也不需要通过 props 传递数据，直接在需要的组件中请求数据即可。这是因为 React 拓展了 fetch 的功能，添加了记忆缓存功能，相同的请求和参数，返回的数据会做缓存。

```javascript
async function getItem() {
  const res = await fetch('https://.../item/1')
  return res.json()
}
 
// 函数被调用了两次，但只有第一次才执行
const item = await getItem() // cache MISS
 
// 第二次使用了缓存
const item = await getItem() // cache HIT
```

当然这个缓存也是有一定条件限制的，比如只能在 GET 请求中，具体的限制和原理我们会在缓存篇中具体讲解。

### 2. 组件只在服务端使用

由于 JavaScript 模块可以在服务器和客户端组件模块之间共享，所以如果你希望一个模块只用于服务端，就比如这段代码：

```javascript
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })
 
  return res.json()
}
```

这个函数使用了 API\_KEY，所以它应该是只用在服务端的。如果用在客户端，为了防止泄露，Next.js 会将私有环境变量替换为空字符串，所以这段代码可以在客户端导入并执行，但并不会如期运行。

为了防止客户端意外使用服务器代码，我们可以借助 `server-only`包，这样在客户端意外使用的时候，会抛出构建错误。

使用 `server-only`，首先安装该包：

```bash
npm install server-only
```

其次将该包导入只用在服务端的组件代码中：

```javascript
import 'server-only'
 
export async function getData() {
  const res = await fetch('https://external-service.com/data', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })
 
  return res.json()
}
```

现在，任何导入 `getData`的客户端组件都会在构建的时候抛出错误，以保证该模块只能在服务端使用。

### 3. 使用三方包

毕竟 React Server Component 是一个新特性， React 生态里的很多包可能还没有跟上，这样就可能会导致一些问题。

比如你使用了一个导出 `<Carousel />`组件的 `acme-carousel`包。这个组件使用了 useState，但是它并没有 `"use client"` 声明。

当你在客户端组件中使用的时候，它能正常工作：

```javascript
'use client'
 
import { useState } from 'react'
import { Carousel } from 'acme-carousel'
 
export default function Gallery() {
  let [isOpen, setIsOpen] = useState(false)
 
  return (
    <div>
      <button onClick={() => setIsOpen(true)}>View pictures</button>
 
      {/* Works, since Carousel is used within a Client Component */}
      {isOpen && <Carousel />}
    </div>
  )
}
```

然而如果你在服务端组件中使用，它会报错：

```javascript
import { Carousel } from 'acme-carousel'
 
export default function Page() {
  return (
    <div>
      <p>View pictures</p>
 
      {/* Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

这是因为 Next.js 并不知道 `<Carousel />`是一个只能用在客户端的组件，毕竟它是三方的，你也无法修改它的代码，为它添加 `"use client"` 声明，Next.js 于是就按照服务端组件进行处理，结果它使用了客户端组件的特性 `useState`，于是便有了报错。

为了解决这个问题，你可以自己包一层，将该三方组件包在自己的客户端组件中，比如：

```javascript
'use client'
 
import { Carousel } from 'acme-carousel'
 
export default Carousel
```

现在，你就可以在服务端组件中使用 `<Carousel />`了：

```javascript
import Carousel from './carousel'
 
export default function Page() {
  return (
    <div>
      <p>View pictures</p>
      <Carousel />
    </div>
  )
}
```

注：有的时候改为使用客户端组件也不能解决问题，如果遇到 document is not defined、window is not defined 这种报错，可以参考 [《Next.js v14 报 document is not defined 这种错怎么办？》](https://juejin.cn/post/7352342892785352755) 解决

### 4. 使用 Context Provider

上下文是一个典型的用于节点的特性，主要是为了共享一些全局状态，就比如当前的主题（实现换肤功能）。但服务端组件不支持 React context，如果你直接创建会报错：

```javascript
import { createContext } from 'react'
 
//  服务端组件并不支持 createContext
export const ThemeContext = createContext({})
 
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

为了解决这个问题，你需要在客户端组件中进行创建和渲染：

```javascript
'use client'
 
import { createContext } from 'react'
 
export const ThemeContext = createContext({})
 
export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

然后再在根节点使用：

```javascript
import ThemeProvider from './theme-provider'
 
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

这样应用里的其他客户端组件就可以使用这个上下文。

## 最佳实践：使用客户端组件

### 1. 客户端组件尽可能下移

为了尽可能减少客户端 JavaScript 包的大小，尽可能将客户端组件在组件树中下移。

举个例子，当你有一个包含一些静态元素和一个交互式的使用状态的搜索栏的布局，没有必要让整个布局都成为客户端组件，将交互的逻辑部分抽离成一个客户端组件（比如`<SearchBar />`），让布局成为一个服务端组件：

```javascript
// SearchBar 客户端组件
import SearchBar from './searchbar'
// Logo 服务端组件
import Logo from './logo'
 
// Layout 依然作为服务端组件
export default function Layout({ children }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

注：这点我们还会在实战篇的第一个项目[《实战篇 | React Notes | 侧边栏笔记列表》](https://juejin.cn/book/7307859898316881957/section/7309114608562733107#heading-5)讲解演示。

### 2. 从服务端组件到客户端组件传递的数据需要序列化

当你在服务端组件中获取的数据，需要以 props 的形式向下传给客户端组件，这个数据需要做序列化。

这是因为 React 需要先在服务端将组件树先序列化传给客户端，再在客户端反序列化构建出组件树。如果你传递了不能序列化的数据，这就会导致错误。

如果你不能序列化，那就改为在客户端使用三方包获取数据吧。

注：这点我们还会在实战篇的第一个项目[《实战篇 | React Notes | 侧边栏笔记列表》](https://juejin.cn/book/7307859898316881957/section/7309114608562733107#heading-2)讲解演示。

## 参考链接

1.  [Introducing Zero-Bundle-Size React Server Components – React Blog](https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html)
2.  [How React server components work: an in-depth guide](https://www.plasmic.app/blog/how-react-server-components-work)
3.  [Rendering: Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components)
4.  [Rendering: Client Components](https://nextjs.org/docs/app/building-your-application/rendering/client-components)
5.  [Rendering: Composition Patterns](https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns)
6.  <https://github.com/reactwg/server-components/discussions/4>
7.  <https://news.ycombinator.com/item?id=25499171>
8.  <https://betterprogramming.pub/the-future-of-react-server-components-90f6e3e97c8a>
9.  <https://twitter.com/dan_abramov/status/1342264337478660096>
10. <https://www.builder.io/blog/why-react-server-components#suspense-for-server-side-rendering>


## 12.渲染篇 | 服务端渲染策略

## 前言

现在让我们新建一个 `app/server/page.js`，代码如下：

```javascript
export default async function Page() {
  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search')).json())[0].url
  
  return (
    <img src={url} width="300" alt="cat" />
  )
}
```

其中，<https://api.thecatapi.com/v1/images/search> 是一个返回猫猫图片的接口，每次调用都会返回一张随机的猫猫图片数据。

现在让我们运行 `npm run dev`，开发模式下，每次刷新都会返回一张新的图片：

![strage.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fba1c5eb0f7454ab5b312ec673efa81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=595\&h=336\&s=257512\&e=gif\&f=44\&b=f8f4f3)

现在让我们运行 `npm run build && npm run start`，然而此时每次刷新都还是这张 emo 的猫猫：

![strage-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5c24ed8d2c34d3792833ca6d874162c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=595\&h=336\&s=99356\&e=gif\&f=42\&b=fefefe)

这是为什么呢？

让我们看下构建时的输出结果：

![截屏2024-03-06 18.18.43.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37a2df3490d44761857bf0c83999db0c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=922\&h=424\&s=280422\&e=png\&b=070212)

`/server` 被标记为 `Static`，表示被预渲染为静态内容。也就是说，`/server`的返回内容其实在构建的时候就已经决定了。页面返回的图片正是构建时调用猫猫接口返回的那张图片。

那么问题来了，如何让 `/server` 每次都返回新的图片呢？

这就要说到 Next.js 的服务端渲染策略了。

## 服务端渲染策略

Next.js 存在三种不同的服务端渲染策略：

*   静态渲染
*   动态渲染
*   Streaming

我们来一一介绍。

### 1. 静态渲染（Static Rendering）

**这是默认渲染策略**，**路由在构建时渲染，或者在重新验证后后台渲染**，其结果会被缓存并且可以推送到 CDN。适用于未针对用户个性化且数据已知的情况，比如静态博客文章、产品介绍页面等。

开头中的例子就是构建时渲染。那么如何在重新验证后后台渲染呢？

具体重新验证的方法我们会在[《缓存篇 | Caching》](https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-9)中详细介绍。这里为了举例说一种 —— 使用路由段配置项 `revalidate`。

修改 `app/server/page.js`，代码如下：

```javascript
export const revalidate = 10

export default async function Page() {

  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search')).json())[0].url
  
  return (
    <img src={url} width="300" alt="cat" />
  )
}
```

此时虽然在 `npm run build`的输出中，`/server`依然是标记为静态渲染，但图片已经可以更新了，虽然每隔一段时间才更新：

![strage-3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8beca518ecaf43649191f3b0b438a3ee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=595\&h=336\&s=229929\&e=gif\&f=77\&b=ebe3df)

其中 `revalidate=10`表示设置重新验证频率为 10s，但是要注意：

这句代码的效果并不是设置服务器每 10s 会自动更新一次 `/server`。而是至少 10s 后进行重新验证。

举个例子，假设你现在访问了 `/server`，此时时间设为 0s，10s 内持续访问，`/server` 返回的都是之前缓存的结果。当 10s 过后，假设你第 12s 又访问了一次 `/server`，此时虽然超过了 10s，但依然会返回之前缓存的结果，但同时会触发服务器更新缓存，当你第 13s 再次访问的时候，就是更新后的结果。

简单来说，超过 revalidate 设置时间的首次访问会触发缓存更新，如果更新成功，后续的返回就都是新的内容，直到下一次触发缓存更新。

### 2. 动态渲染（Dynamic Rendering）

路由在请求时渲染，适用于针对用户个性化或依赖请求中的信息（如 cookie、URL 参数）的情况。

在渲染过程中，**如果使用了动态函数（Dynamic functions）或者未缓存的数据请求（uncached data request），Next.js 就会切换为动态渲染**：

| 动态函数 | 数据缓存 | 渲染策略 |
| ---- | ---- | ---- |
| 否    | 缓存   | 静态渲染 |
| 是    | 缓存   | 动态渲染 |
| 否    | 未缓存  | 动态渲染 |
| 是    | 未缓存  | 动态渲染 |

注意：作为开发者，无须选择静态还是动态渲染，Next.js 会自动根据使用的功能和 API 为每个路由选择最佳的渲染策略

#### 2.1. 使用动态函数（Dynamic functions）

**动态函数指的是获取只有在请求时才能得到信息（如 cookie、请求头、URL 参数）的函数**。

在 Next.js 中这些动态函数是：

*   [cookies()](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-7) 和 [headers()](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-20) ：获取 cookie 和 header
*   `searchParams`：页面查询参数

使用这些函数的任意一个，都会导致路由转为动态渲染。

第一个例子，修改 `app/server/page.js`，代码如下：

```javascript
import { cookies } from 'next/headers'

export default async function Page() {

  const cookieStore = cookies()
  const theme = cookieStore.get('theme')

  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search')).json())[0].url
  
  return (
    <img src={url} width="300" alt="cat" />
  )
}
```

运行 `npm run build && npm run start`，此时 `/server`显示为动态渲染：

![截屏2024-03-06 19.09.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b723f4fb30d4ecc871352bf0715b852~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=934\&h=464\&s=318531\&e=png\&b=070212)

访问效果如下：

![strage-4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/794a5a74b1204ea39837622d456bff6a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=618\&h=362\&s=279634\&e=gif\&f=41\&b=0b0b0b)

第二个例子，使用 searchParams，修改 `app/server/page.js`，代码如下：

```javascript
export default async function Page({ searchParams }) {
  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search')).json())[0].url
  return (
    <>
      <img src={url} width="300" alt="cat" />
      {new Date().toLocaleTimeString()}
      {JSON.stringify(searchParams)}
    </>
  )
}
```

运行 `npm run build && npm run start`，此时 `/server`显示为动态渲染：

![截屏2024-03-06 20.57.25.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f1cfdbb34147f194421c070e1dab37~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=932\&h=454\&s=309475\&e=png\&b=070212)

但是图片却没有在页面刷新的时候改变（此时又是一只 emo 的猫猫）：

![strage-5.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4be4e8d67c24801983537cb8d2e3110~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=571\&h=426\&s=247454\&e=gif\&f=21\&b=0c0c0c)

页面确实是动态渲染，因为每次刷新时间都发生了改变。但为什么图片没有更新呢？

这是因为动态渲染和数据请求缓存是两件事情，页面动态渲染并不代表页面涉及的请求一定不被缓存。正是因为 fetch 接口的返回数据被缓存了，这才导致了图片每次都是这一张。

修改 `app/server/page.js`，代码如下：

```javascript
export default async function Page({ searchParams }) {
  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search', { cache: 'no-store' })).json())[0].url
  return (
    <>
      <img src={url} width="300" alt="cat" />
      {new Date().toLocaleTimeString()}
      {JSON.stringify(searchParams)}
    </>
  )
}
```

我们为 fetch 请求添加了 `{ cache: 'no-store' }`，使 fetch 请求退出了缓存。此时运行生产版本，图片和时间在刷新的时候都会改变：

![strage-6.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfc16461522f44b795577e668c4b392d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=598\&h=455\&s=529824\&e=gif\&f=52\&b=080808)

注：同样是转为动态渲染，为什么使用 cookies 的时候，fetch 请求没有被缓存呢？这就是接下来要讲的内容。

当你在 `headers` 或 `cookies` 方法之后使用 fetch 请求会导致请求退出缓存，这是 Next.js 的自动逻辑，但还有哪些情况导致 fetch 请求自动退出缓存呢？让我们往下看。

#### 2.2. 使用未缓存的数据请求（uncached data request）

在 Next.js 中，fetch 请求的结果默认会被缓存，但你可以设置退出缓存，一旦你设置了退出缓存，就意味着使用了未缓存的数据请求（uncached data request），会导致路由进入动态渲染，如：

*   `fetch` 请求添加了 `cache: 'no-store'`选项
*   `fetch` 请求添加了 `revalidate: 0`选项
*   `fetch` 请求在路由处理程序中并使用了 `POST` 方法
*   在`headers` 或 `cookies` 方法之后使用 `fetch`请求
*   配置了路由段选项 `const dynamic = 'force-dynamic'`
*   配置了路由段选项`fetchCache` ，默认会跳过缓存
*   `fetch` 请求使用了 `Authorization`或者 `Cookie`请求头，并且在组件树中其上方还有一个未缓存的请求

注：关于数据请求，具体我们还会在[《数据获取篇 | 数据获取、缓存与重新验证》](https://juejin.cn/book/7307859898316881957/section/7309076949182709811)中详细介绍。

举个例子，修改 `app/server/page.js`，代码如下：

```javascript
export default async function Page() {
  const url = (await (await fetch('https://api.thecatapi.com/v1/images/search', { cache: 'no-store' })).json())[0].url
  return (
    <>
      <img src={url} width="300" alt="cat" />
      {new Date().toLocaleTimeString()}
    </>
  )
}
```

此时页面会转为动态渲染，每次刷新页面都会出现新的图片。

关于动态渲染再重申一遍：数据缓存和渲染策略是分开的。假如你选择了动态渲染，Next.js 会在请求的时候再渲染 RSC Payload 和 HTML，但其中涉及的数据请求，依然是可以从缓存中获取的。

### 3. Streaming

使用 `loading.js` 或者 React Suspense 组件会开启 Streaming。具体参考小册[《渲染篇 | Suspense 与 Streaming》](https://juejin.cn/book/7307859898316881957/section/7342436717142409242)

## 其他术语防混淆

除了静态渲染、动态渲染、动态函数、未缓存数据请求等术语，阅读官方文档的时候，你还可能遇到局部渲染、动态路由等这些与“渲染”、“动态”、“静态”有关的词，所以我们在这里列出来帮助大家区分。

### 1. 局部渲染（Partial rendering）

局部渲染指的是仅在客户端重新渲染导航时更改的路由段，共享段的内容的继续保留。举个例子，当在两个相邻的路由间导航的时候, `/dashboard/settings` 和 `/dashboard/analytics`，`settings` 和 `analytics` 页面会重新渲染，共享的 `dashboard` 布局会保留。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc25dbf75a2a44c69d23ff8ac41bc076~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=945\&s=464860\&e=png\&b=1b1b1b)

局部渲染的目的也是为了减少路由切换时的传输数据量和执行时间，从而提高性能。

### 2. 动态路由（Dynamic Routes）

动态路由我们在小册[《路由篇 | 动态路由、路由组、平行路由和拦截路由》](https://juejin.cn/book/7307859898316881957/section/7308693561648611379)中讲过：

```javascript
export default function Page({ params }) {
  return <div>My Post: {params.slug}</div>
}
```

动态路由并不一定是动态渲染，你也可以用 `generateStaticParams`静态生成路由。

但有的时候，动态路由（Dynamic Routes）会用来表达“动态渲染的路由”（dynamically rendered routes）这个意思。在官网中，很少用到静态路由（Static Routes）这个词，用到的时候是用来表达“静态渲染的路由”（statically rendered routes）。

### 3. 动态段（Dynamic Segment）

路由中的动态段，举个例子，`app/blog/[slug]/page.js`中 `[slug]`就是动态段。

## 小结

恭喜你，完成了本篇内容的学习！

这篇我们介绍了服务端渲染的三种策略。至此，渲染篇基本介绍完毕，我们开始进入数据获取篇！


## 13.数据获取篇 | 数据获取、缓存与重新验证

## 前言

在 Next.js 中如何获取数据呢？

Next.js 优先推荐使用原生的 fetch 方法，因为 Next.js 拓展了原生的 fetch 方法，为其添加了缓存和更新缓存(重新验证)的机制。

这样做的好处在于可以自动复用请求数据，提高性能。坏处在于如果你不熟悉，经常会有一些“莫名奇妙”的状况出现……

让我们来看看具体如何使用吧。

## 1. 服务端使用 fetch

### 1.1. 基本用法

Next.js 拓展了原生的 [fetch Web API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)，可以为**服务端的每个请求**配置缓存（caching）和重新验证（ revalidating）行为。

你可以在**服务端组件、路由处理程序、Server Actions** 中搭配 `async`/`await` 语法使用 fetch。

举个例子：

```javascript
// app/page.js
async function getData() {
  const res = await fetch('https://jsonplaceholder.typicode.com/todos')
  if (!res.ok) {
    // 由最近的 error.js 处理
    throw new Error('Failed to fetch data')
  }
  return res.json()
}

export default async function Page() {
  const data = await getData()
  return <main>{JSON.stringify(data)}</main>
}
```

### 1.2.  默认缓存

默认情况下，Next.js 会自动缓存服务端 `fetch` 请求的返回值（背后用的是[数据缓存（Data Cache）](https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-6)）。

```javascript
// fetch 的 cache 选项用于控制该请求的缓存行为
// 默认就是 'force-cache', 平时写的时候可以省略
fetch('https://...', { cache: 'force-cache' })
```

但这些情况默认不会自动缓存：

1. 在 Server Action 中使用的时候
2. 在定义了非 GET 方法的路由处理程序中使用的时候

**简单的来说，在服务端组件和只有 GET 方法的路由处理程序中使用 fetch，返回结果会自动缓存。**

#### 1.2.1. logging 配置项

让我们分别举个例子演示下。但在写代码之前，先让我们修改下 `next.config.mjs` 的配置：

```js
const nextConfig = {
  logging: {
    fetches: {
      fullUrl: true
    }
  }
};

export default nextConfig;
```

目前 logging 只有这一个配置，用于**在开发模式下**显示 fetch 请求和缓存日志：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76fca0ddd8f54a12bae3b9a0f6487f90~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078&h=78&s=71180&e=png&b=070314)

上图日志的意思是：

访问 `/api/cache` 路由，其中 GET 请求了 https://dog.ceo/api/breeds/image/random 这个接口，接口 20ms 返回，状态码 200，此次请求命中了缓存（HIT）。

这个日志会帮助我们查看缓存情况（实际用的时候有的日志结果不是很准，还有待改进）。

#### 1.2.2. 服务端组件

第一种在服务端组件中使用，修改 `app/page.js`，代码如下：

```js
async function getData() {
  // 接口每次调用都会返回一个随机的猫猫图片数据
  const res = await fetch('https://api.thecatapi.com/v1/images/search')
  if (!res.ok) {
    throw new Error('Failed to fetch data')
  }
 
  return res.json()
}

export default async function Page() {
  const data = await getData()
  
  return <img src={data[0].url} width="300" />
}
```
运行 `npm run dev`，开启开发模式：

![cache-4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09ea27349964498e81fc2a196ae174c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1436&h=459&s=466881&e=gif&f=39&b=180831)

在开发模式下，为了方便调试，可以使用浏览器的硬刷新（Command + Shift + R）清除缓存，此时数据会发生更改（cache: SKIP）。普通刷新时因为会命中缓存（cache: HIT），数据会保持不变。

运行 `npm run build && npm run start` 开启生产版本：

![cache.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e26d6e09a5e04b99bba03a8a1f9d8141~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=439&h=353&s=136348&e=gif&f=33&b=efedec)

因为 fetch 请求的返回结果被缓存了，无论是否硬刷新，图片数据都会保持不变。

#### 1.2.3. 路由处理程序 GET 请求

第二种在路由处理程序中使用，新建 `app/api/cache/route.js`，代码如下：

```js
export async function GET() {
  const res = await fetch('https://dog.ceo/api/breeds/image/random')
  
  const data = await res.json()
  return Response.json({ data })
}
```

运行 `npm run dev`，开启开发模式：

![cache-5.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c844d6e5ce04083b81e5797241b7494~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1436&h=459&s=293876&e=gif&f=40&b=141414)

开发模式下，浏览器硬刷新的时候会跳过缓存，普通刷新的时候则会命中缓存。可以看到第一次硬刷新的时候，请求接口时间为 912ms，后面普通刷新的时候，因为使用缓存中的数据，数据返回时间都是 1ms 左右。

运行 `npm run build && npm run start` 开启生产版本：

![cache-6.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5d4476224694a73a8f631359cd2ead6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1036&h=192&s=53493&e=gif&f=31&b=191919)

因为 fetch 请求的返回结果被缓存了，无论是否硬刷新，接口数据都会保持不变。

### 1.3. 重新验证

**在 Next.js 中，清除数据缓存并重新获取最新数据的过程就叫做重新验证（Revalidation）。**

Next.js 提供了两种方式重新验证：

一种是**基于时间的重新验证（Time-based revalidation）**，即经过一定时间并有新请求产生后重新验证数据，适用于不经常更改且新鲜度不那么重要的数据。

一种是**按需重新验证（On-demand revalidation）**，根据事件手动重新验证数据。按需重新验证又可以使用基于标签（tag-based）和基于路径（path-based）两种方法重新验证数据。适用于需要尽快展示最新数据的场景。

#### 基于时间的重新验证

使用基于时间的重新验证，你需要在使用 fetch 的时候设置 `next.revalidate` 选项（以秒为单位）：

```javascript
fetch('https://...', { next: { revalidate: 3600 } })
```

或者通过[路由段配置项](https://juejin.cn/book/7307859898316881957/section/7309079033223446554)进行配置，使用这种方法，它会重新验证该路由段所有的 `fetch` 请求。

```javascript
// layout.jsx | page.jsx | route.js
export const revalidate = 3600
```

注：在一个静态渲染的路由中，如果你有多个请求，每个请求设置了不同的重新验证时间，将会使用最短的时间用于所有的请求。而对于动态渲染的路由，每一个 `fetch`请求都将独立重新验证。

#### 按需重新验证

使用按需重新验证，在**路由处理程序或者 Server Action** 中通过路径（ [revalidatePath](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-12)） 或缓存标签 [revalidateTag](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-23) 实现。

##### revalidatePath

新建 `app/api/revalidatePath/route.js`，代码如下：

```js
import { revalidatePath } from 'next/cache'
 
export async function GET(request) {
  const path = request.nextUrl.searchParams.get('path')
 
  if (path) {
    revalidatePath(path)
    return Response.json({ revalidated: true, now: Date.now() })
  }
 
  return Response.json({
    revalidated: false,
    now: Date.now(),
    message: 'Missing path to revalidate',
  })
}
```

此时访问 `/api/revalidatePath?path=/` 就会更新 `/` 的 fetch 请求返回数据，交互效果如下：


![cache-7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0fbd05293b4b58bc8d5dee6b8182b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=913&h=380&s=533495&e=gif&f=141&b=f7f4f3)

此时访问 `/api/revalidatePath?path=/api/cache` 就会更新 `/api/cache` 的 fetch 请求返回数据，交互效果如下：

![cache-8.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ae60a8b621644c9a45ea99378260a89~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1035&h=370&s=305075&e=gif&f=108&b=171717)

注意：这两张图演示的是开发模式下的情况，用 revalidatePath 确实更新了对应路径上的 fetch 缓存结果。但如果大家部署到生产版本，你是发现 revalidatePath 只对页面生效，对路由处理程序并不生效。

这是因为 `/api/cache` 被静态渲染了，首先你要将 `/api/cache` 转为动态渲染，然后才能测试 revalidatePath 的效果。但是转为动态渲染，比如使用 cookies 等函数，又会触发 Next.js 的自动逻辑，让 fetch 请求退出缓存。

简而言之，如果你想在生产环境测试 revalidatePath 对路由处理程序的影响，你需要多做一些配置：

```js
// 路由动态渲染
export const revalidate = 0
// fetch 强制缓存
export const fetchCache = 'force-cache'
export async function GET() {
  const res = await fetch('https://dog.ceo/api/breeds/image/random')
  
  const data = await res.json()
  return Response.json({ data, now: Date.now() })
}
```

这样的代码在生产环境下，是可以被 revalidatePath 重新验证的。效果同开发模式下的截图。

##### revalidateTag

Next.js 有一个路由标签系统，可以跨路由实现多个 fetch 请求重新验证。具体这个过程为：

1.  使用 fetch 的时候，设置一个或者多个标签标记请求
2.  调用 revalidateTag 方法重新验证该标签对应的所有请求

举个例子：

```javascript
// app/page.js
export default async function Page() {
  const res = await fetch('https://...', { next: { tags: ['collection'] } })
  const data = await res.json()
  // ...
}
```

在这个例子中，为 `fetch` 请求添加了一个 `collection`标签。在 Server Action 中调用 `revalidateTag`，就可以让所有带 `collection` 标签的 fetch 请求重新验证。

```javascript
// app/actions.js
'use server'
 
import { revalidateTag } from 'next/cache'
 
export default async function action() {
  revalidateTag('collection')
}
```

让我们真的写个例子。修改 `app/page.js` 代码如下：

```js
async function getData() {
  const res = await fetch('https://api.thecatapi.com/v1/images/search', { next: { tags: ['collection'] } })
  if (!res.ok) {
    throw new Error('Failed to fetch data')
  }
 
  return res.json()
}

export default async function Page() {
  const data = await getData()
  
  return <img src={data[0].url} width="300" />
}
```

修改 `app/api/cache/route.js`，代码如下：

```js
export const revalidate = 0
export const fetchCache = 'force-cache'

export async function GET() {
  const res = await fetch('https://dog.ceo/api/breeds/image/random', { next: { tags: ['collection'] } })
  
  const data = await res.json()
  return Response.json({ data, now: Date.now() })
}
```

新建 `app/api/revalidateTag/route.js`，代码如下：

```js
import { revalidateTag } from 'next/cache'
 
export async function GET(request) {
  const tag = request.nextUrl.searchParams.get('tag')
  revalidateTag(tag)
  return Response.json({ revalidated: true, now: Date.now() })
}
```

此时访问 `/api/revalidateTag?tag=collection` 就会让 `/` 页面和 `/api/cache` 接口的数据都重新验证：


![cache-9.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86ff118bb5034674a986d2acc03e9c57~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042&h=493&s=552326&e=gif&f=126&b=fbf8f8)

#### 错误处理和重新验证

如果在尝试重新验证的过程中出现错误，缓存会继续提供上一个重新生成的数据，而在下一个后续请求中，Next.js 会尝试再次重新验证数据。

### 1.4. 退出数据缓存

当 `fetch` 请求满足这些条件时都会退出数据缓存：

*   `fetch` 请求添加了 `cache: 'no-store'` 选项
*   `fetch` 请求添加了 `revalidate: 0` 选项
*   `fetch` 请求在路由处理程序中并使用了 `POST` 方法
*   使用`headers` 或 `cookies` 的方法之后使用 `fetch`请求
*   配置了路由段选项 `const dynamic = 'force-dynamic'`
*   配置了路由段选项 `fetchCache` ，默认会跳过缓存
*   `fetch` 请求使用了 `Authorization`或者 `Cookie`请求头，并且在组件树中其上方还有一个未缓存的请求


在具体使用的时候，如果你不想缓存某个单独请求：

```javascript
// layout.js | page.js
fetch('https://...', { cache: 'no-store' })
```

不缓存多个请求，可以借助[路由段配置项](https://juejin.cn/book/7307859898316881957/section/7309079033223446554)：

```javascript
// layout.js | page.js
export const dynamic = 'force-dynamic'
```

**Next.js 推荐单独配置每个请求的缓存行为，这可以让你更精细化的控制缓存行为。**

## 2.服务端使用三方请求库

也不是所有时候都能使用 fetch 请求，如果你使用了不支持或者暴露 fetch 方法的三方库（如数据库、CMS 或 ORM 客户端），但又想实现数据缓存机制，那你可以使用 React 的 `cache` 函数和路由段配置项来实现请求的缓存和重新验证。


举个例子：

```javascript
// app/utils.js
import { cache } from 'react'
 
export const getItem = cache(async (id) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

现在我们调用两次 `getItem` ：

```javascript
// app/item/[id]/layout.js
import { getItem } from '@/utils/get-item'
 
export const revalidate = 3600
 
export default async function Layout({ params: { id } }) {
  const item = await getItem(id)
  // ...
}
```

```javascript
// app/item/[id]/page.js
import { getItem } from '@/utils/get-item'
 
export const revalidate = 3600
 
export default async function Page({ params: { id } }) {
  const item = await getItem(id)
  // ...
}
```

在这个例子中，尽管 `getItem` 被调用两次，但只会产生一次数据库查询。

注：这里的代码并不是完整可运行的，如果想要细致了解 React Cache 函数的特性，可以查看： [（技巧）当 Next.js 遇到频繁重复的数据库操作时，记住使用 React 的 cache 函数](https://juejin.cn/post/7348643498117038099#heading-5)

## 3. 客户端使用路由处理程序

如果你需要在客户端组件中获取数据，可以在客户端调用路由处理程序。路由处理程序会在服务端被执行，然后将数据返回给客户端，适用于不想暴露敏感信息给客户端（比如 API tokens）的场景。

如果你使用的是服务端组件，无须借助路由处理程序，直接获取数据即可。

## 4. 客户端使用三方请求库

你也可以在客户端使用三方的库如 [SWR](https://swr.vercel.app/) 或 [React Query](https://tanstack.com/query/latest) 来获取数据。这些库都有提供自己的 API 实现记忆请求、缓存、重新验证和更改数据。

## 5. 建议与最佳实践

有一些在 React 和 Next.js 中获取数据的建议和最佳实践，本节来介绍一下：

### 5.1. 尽可能在服务端获取数据

尽可能在服务端获取数据，这样做有很多好处，比如：

1.  可以直接访问后端资源（如数据库）
2.  防止敏感信息泄漏
3.  减少客户端和服务端之间的来回通信，加快响应时间
4.  ...

### 5.2. 在需要的地方就地获取数据

如果组件树中的多个组件使用相同的数据，无须先全局获取，再通过 props 传递，你可以直接在需要的地方使用 `fetch` 或者 React `cache` 获取数据，不用担心多次请求造成的性能问题，因为 `fetch` 请求会自动被记忆化。这也同样适用于布局，毕竟本来父子布局之间也不能传递数据。

### 5.3. 适当的时候使用 Streaming

Streaming 和 `Suspense`都是 React 的功能，允许你增量传输内容以及渐进式渲染 UI 单元。页面可以直接渲染部分内容，剩余获取数据的部分会展示加载态，这也意味着用户不需要等到页面完全加载完才能与其交互。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0271e01ad344ceeaa4059be34513311~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=785\&s=475591\&e=png\&b=151515)

注：关于 Suspense 和 Streaming，我们会在 [《渲染篇 | Suspense 与 Streaming》](https://juejin.cn/book/7307859898316881957/section/7342436717142409242) 中详细讲解。

### 5.4. 串行获取数据

在 React 组件内获取数据时，有两种数据获取模式，并行和串行。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1731c628568e4746957939c94929c309~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=525\&s=338982\&e=png\&b=141414)

所谓串行数据获取，数据请求相互依赖，形成瀑布结构，这种行为有的时候是必要的，但也会导致加载时间更长。

所谓并行数据获取，请求同时发生并加载数据，这会减少加载数据所需的总时间。

我们先说说串行数据获取，直接举个例子：

```javascript
// app/artist/page.js
// ...
 
async function Playlists({ artistID }) {
  // 等待 playlists 数据
  const playlists = await getArtistPlaylists(artistID)
 
  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  )
}
 
export default async function Page({ params: { username } }) {
  // 等待 artist 数据
  const artist = await getArtist(username)
 
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  )
}
```

在这个例子中，`Playlists` 组件只有当 `Artist` 组件获得数据才会开始获取数据，因为 `Playlists` 组件依赖 `artistId` 这个 prop。这也很容易理解，毕竟只有先知道了是哪位艺术家，才能获取这位艺术家对应的曲目。

在这种情况下，你可以使用 `loading.js` 或者 React 的 `<Suspense>` 组件，展示一个即时加载状态，防止整个路由被数据请求阻塞，而且用户还可以与未被阻塞的部分进行交互。

关于阻塞数据请求：

*   一种防止出现串行数据请求的方法是在应用程序根部全局获取数据，但这会阻塞其下所有路由段的渲染，直到数据加载完毕。
*   任何使用 `await` 的 `fetch` 请求都会阻塞渲染和下方所有组件的数据请求，除非它们使用了 `<Suspense>` 或者 `loading.js`。另一种替代方式就是使用并行数据请求或者预加载模式。

### 5.5. 并行数据请求

要实现并行请求数据，你可以在使用数据的组件外定义请求，然后在组件内部调用，举个例子：

```javascript
import Albums from './albums'

// 组件外定义
async function getArtist(username) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}
 
async function getArtistAlbums(username) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}
 
export default async function Page({ params: { username } }) {
  // 组件内调用，这里是并行的
  const artistData = getArtist(username)
  const albumsData = getArtistAlbums(username)
 
  // 等待 promise resolve
  const [artist, albums] = await Promise.all([artistData, albumsData])
 
  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums}></Albums>
    </>
  )
}
```

在这个例子中，`getArtist` 和 `getArtistAlbums` 函数都是在 `Page` 组件外定义，然后在 `Page` 组件内部调用。用户需要等待两个 promise 都 resolve 后才能看到结果。

为了提升用户体验，可以使用 Suspense 组件来分解渲染工作，尽快展示出部分结果。

### 5.6. 预加载数据

防止出现串行请求的另外一种方式是使用预加载。举个例子：

```javascript
// app/article/[id]/page.js
import Article, { preload, checkIsAvailable } from './components/Article'
 
export default async function Page({ params: { id } }) {
  // 获取文章数据
  preload(id)
  // 执行另一个异步任务，这里是伪代码，比如判断文章是否有权限访问
  const isAvailable = await checkIsAvailable()
 
  return isAvailable ? <Article id={id} /> : null
}
```

而在具体的 preload 函数中，则要搭配 React 的 cache 函数一起使用：

```javascript
// components/Article.js
import { getArticle } from '@/utils/get-article'
import { cache } from 'react'

export const getArticle = cache(async (id) => {
  // ...
})

export const preload = (id) => {
	void getArticle(id)
}

export const checkIsAvailable = (id) => {
	// ...
}

export default async function Article({ id }) {
  const result = await getArticle(id)
  // ...
}
```

### 5.7. 使用 React `cache` `server-only` 和预加载模式

你可以将 `cache` 函数，`preload` 模式和 [server-only](https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-15) 包一起使用，创建一个可在整个应用使用的数据请求工具函数。

```javascript
// utils/get-article.js
import { cache } from 'react'
import 'server-only'
 
export const preloadArticle = (id) => {
  void getArticle(id)
}
 
export const getArticle = cache(async (id) => {
  // ...
})
```

现在，你可以提前获取数据、缓存返回结果，并保证数据获取只发生在服务端。此外，布局、页面、组件都可以使用 `utils/get-article.js`

注：如果想要细致了解 preload 函数和 server-only 以及 cache 的特性，可以查看： [（技巧）当 Next.js 遇到频繁重复的数据库操作时，记住使用 React 的 cache 函数](https://juejin.cn/post/7348643498117038099#heading-5)

## 小结

恭喜你，完成了本篇内容的学习！

这一节我们介绍了请求数据的四种方式，重点介绍了服务端使用 fetch 的方式，这是因为 Next.js 拓展了原生的 fetch，增加了数据缓存和重新验证的逻辑。在 Next.js 中，为了提高性能，应该尽可能的使用缓存，但为了保证数据的时效性，也应该设置合理的重新验证逻辑。Next.js 推荐单独配置每个请求的缓存行为，这可以让你更精细化的控制缓存行为。

介绍完四种数据请求方式后，Next.js 提供了一些获取数据的建议和最佳实践，正是因为有了强大的缓存功能，所以在书写代码的时候可以就地获取数据，而不用担心相同请求多次发送造成的性能影响。

## 参考链接

1.  [Data Fetching: Fetching, Caching, and Revalidating | Next.js](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)
2.  [Data Fetching: Data Fetching Patterns | Next.js](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns)


## 14.缓存篇 | Caching（上）

## 前言

本章我们将介绍 Next.js 的缓存机制。

Next.js 的缓存功能非常强大，以至于让人又爱又恨。一方面，缓存的重要性不言而喻，可以优化应用性能和降低开销。另一方面，写 Next.js 项目的时候常会遇到数据没有更新的问题，多半都是缓存搞得鬼……

理论上，缓存不是使用 Next.js 的必要知识。因为 Next.js 会自动根据你使用的 API 做好缓存管理。但实际上，你还是要认真学习下缓存，至少要清楚知道 Next.js 的缓存机制有哪些，大致的工作原理，以及如何退出缓存，否则遇到缓存问题的时候你甚至不知道如何解决……

现在就让我们认真学习下缓存吧。

## 概览

Next.js 中有四种缓存机制：

| 机制                        | 缓存内容               | 存储地方 | 目的               | 期间        |
| ------------------------- | ------------------ | ---- | ---------------- | --------- |
| 请求记忆（Request Memoization） | 函数返回值              | 服务端  | 在 React 组件树中复用数据 | 每个请求的生命周期 |
| 数据缓存（Data Cache ）         | 数据                 | 服务端  | 跨用户请求和部署复用数据     | 持久（可重新验证） |
| 完整路由缓存（Full Route Cache）  | HTML 和 RSC payload | 服务端  | 降低渲染成本、提高性能      | 持久（可重新验证） |
| 路由缓存（Router Cache）        | RSC payload        | 客户端  | 减少导航时的服务端请求      | 用户会话或基于时间 |

默认情况下，Next.js 会尽可能多的使用缓存以提高性能和降低成本。像路由默认会采用静态渲染，数据请求的结果默认会被缓存。下图是构建时静态路由渲染以及首次访问静态路由的原理图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e176beb2d77848f88f7790d9eb7ab720~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=1179\&s=418691\&e=png\&b=0d0d0d)

在这张图中：

打包构建 `/a`时（BUILD TIME），因为路由中的请求是首次，所以都会 `MISS`，从数据源获取数据后，将数据在**请求记忆**和**数据缓存**中都保存了一份（`SET`），并将生成的 RSC Payload 和 HTML 也在服务端保存了一份（**完整路由缓存**）。

当客户端访问 `/a` 的时候，命中服务端缓存的 RSC Payload 和 HTML，并将 RSC Payload 在客户端保存一份（**路由缓存**）。

缓存行为是会发生变化的，具体取决的因素有很多，比如路由是动态渲染还是静态渲染，数据是缓存还是未缓存，请求是在初始化访问中还是后续导航中。

是不是有点懵？没有关系，随着内容的展开，我们会有更加深入的了解。

## 1. 请求记忆（Request Memoization）

### 1.1. 工作原理

React 拓展了 [fetch API](https://nextjs.org/docs/app/building-your-application/caching#fetch)，当有相同的 URL 和参数的时候，React 会自动将请求结果缓存。也就是说，即时你在组件树中的多个位置请求一份相同的数据，但数据获取只会执行一次。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd22d593060474fa2a7437337469aa0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=857\&s=666460\&e=png\&b=141414)

这样当你跨路由（比如跨布局、页面、组件）时，你不需要在顶层请求数据，然后将返回结果通过 props 转发，直接在需要数据的组件中请求数据即可，不用担心对同一数据发出多次请求造成的性能影响。

```javascript
// app/page.js
async function getItem() {
  // 自动缓存结果
  const res = await fetch('https://.../item/1')
  return res.json()
}
 
// 函数调用两次，但只会执行一次请求
const item = await getItem() // cache MISS
 
const item = await getItem() // cache HIT
```

这是请求记忆的工作原理图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b9746cb977d49888c846ea230f99fa1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=800\&s=149814\&e=png\&b=0e0e0e)

在这种图中，当渲染 `/a` 路由的时候，由于是第一次请求，会触发缓存 `MISS`，函数被执行，请求结果会被存储到内存中（缓存`SET`），当下一次相同的调用发生时，会触发缓存 `HIT`，数据直接从内存中取出。

它背后的原理想必大家也想到了，就是[函数记忆](https://juejin.cn/post/6844903494256705543)，《JavaScript 权威指南》中就有类似的函数：

```javascript
function memoize(f) {
    var cache = {};
    return function(){
        var key = arguments.length + Array.prototype.join.call(arguments, ",");
        if (key in cache) {
            return cache[key]
        }
        else return cache[key] = f.apply(this, arguments)
    }
}
```

关于请求记忆，要注意：

*   请求记忆是 React 的特性，并非 Next.js 的特性。 React 和 Next.js 都做了请求缓存，React 的方案叫做“请求记忆”，Next.js 的方案叫做“数据缓存”，两者有很多不同
*   请求记忆只适合用于用 `GET` 方法的 `fetch` 请求
*   请求记忆只应用于 React 组件树，也就是说你在 `generateMetadata`、`generateStaticParams`、布局、页面和其他服务端组件中使用 fetch 会触发请求记忆，但是在路由处理程序中使用则不会触发，因为这就不在 React 组件树中了

### 1.2. 持续时间

缓存会持续在服务端请求的生命周期中，直到 React 组件树渲染完毕。它的存在是为了避免组件树渲染的时候多次请求同一数据造成的性能影响。

### 1.3. 重新验证

由于请求记忆只会在渲染期间使用，因此也无须重新验证。

### 1.4. 退出方式

这个行为是 React 的默认优化。不建议退出。

如果你不希望 fetch 请求被记忆，可以借助 [AbortController](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController) 这个 Web API，具体使用方式如下（虽然这个 API 本来的作用是用来中止请求）：

```javascript
const { signal } = new AbortController()
fetch(url, { signal })
```

### 1.5. React Cache

如果你不能使用 fetch 请求，但是又想实现记忆，可以借助 React 的 cache 函数：

```javascript
// utils/get-item.ts
import { cache } from 'react'
import db from '@/lib/db'
 
export const getItem = cache(async (id: string) => {
  const item = await db.item.findUnique({ id })
  return item
})
```

注：为了让大家更好的理解**请求记忆**和**数据缓存**，实战例子我们会放到本篇最后。

## 2. 数据缓存（Data Cache）

### 2.1. 工作原理

Next.js 有自己的数据缓存方案，可以跨服务端请求和构建部署存储数据。之所以能够实现，是因为 Next.js 拓展了 fetch API，在 Next.js 中，每个请求都可以设置自己的缓存方式。

不过与 React 的请求记忆不同的是，请求记忆因为只用于组件树渲染的时候，所以不用考虑数据缓存更新的情况，但 Next.js 的数据缓存方案更为持久，则需要考虑这个问题。

默认情况下，使用 `fetch` 的数据请求都会被缓存，这个缓存是持久的，它不会自动被重置。你可以使用 `fetch` 的 `cache` 和 `next.revalidate` 选项来配置缓存行为：

```javascript
fetch(`https://...`, { cache: 'force-cache' | 'no-store' })
```

```javascript
fetch(`https://...`, { next: { revalidate: 3600 } })
```

这是 Next.js 数据缓存的工作原理图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1fe452584b349bd94efe4cf658c729f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=661\&s=138430\&e=png\&b=101010)

让我们解释一下：当渲染的时候首次调用，请求记忆和数据缓存都会 MISS，从而执行请求，返回的结果在请求记忆和数据缓存中都会存储一份。

当再次调用的时候，因为添加了 `{cache: 'no-store'}`参数，请求参数不同，请求记忆会  MISS，而这个参数会导致数据缓存跳过，所以依然是执行请求，因为配置了 no-store，所以数据缓存也不会缓存返回的结果，请求记忆则会正常做缓存处理。

### 2.2. 持续时间

数据缓存在传入请求和部署中都保持不变，除非重新验证或者选择退出。

### 2.3. 重新验证

Next.js 提供了两种方式更新缓存：

一种是**基于时间的重新验证（Time-based revalidation）**，即经过一定时间并有新请求产生后重新验证数据，适用于不经常更改且新鲜度不那么重要的数据。

一种是**按需重新验证（On-demand revalidation）**，根据事件手动重新验证数据。按需重新验证又可以使用基于标签（tag-based）和基于路径（path-based）两种方法重新验证数据。适用于需要尽快展示最新数据的场景。

#### 基于时间

基于时间的重新验证，需要使用 `fetch` 的 `next.revalidate` 选项设置缓存的时间（注意它是以秒为单位）。

```javascript
// 每小时重新验证
fetch('https://...', { next: { revalidate: 3600 } })
```

可以借助路由段配置项来配置该路由所有的 fetch 请求：

```javascript
// layout.jsx / page.jsx / route.js
export const revalidate = 3600
```

这是基于时间的重新验证原理图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c2a97c76ad24bfe98708d452cd27211~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=1252\&s=260753\&e=png\&b=0e0e0e)

通过这种图，你可以发现：并不是 60s 后该请求会自动更新，而是 60s 后再有请求的时候，会进行重新验证，60s 后的第一次请求依然会返回之前的缓存值，但 Next.js 将使用新数据更新缓存。60s 后的第二次请求会使用新的数据。

#### 按需更新

使用按需重新验证，数据可以根据路径（`revalidatePath`）和 缓存标签（`revalidateTag`） 按需更新。

`revalidatePath` 用在路由处理程序或 Server Actions 中，用于手动清除特定路径中的缓存数据：

```javascript
revalidatePath('/')
```

`revalidateTag` 依赖的是 Next.js 的缓存标签系统，当使用 fetch 请求的时候，声明一个标签，然后在路由处理程序或是 Server Actions 中重新验证具有某一标签的请求：

```javascript
// 使用标签
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

```javascript
// 重新验证具有某一标签的请求
revalidateTag('a')
```

这是按需更新的原理图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cac0e8d8c8854c9586c72dbd7981169a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=1082\&s=189982\&e=png\&b=0e0e0e)

你会发现，这跟基于时间的重新验证有所不同。第一次调用请求的时候，正常缓存数据。当触发按需重新验证的时候，将会从缓存中删除相应的缓存条目。下次请求的时候，又相当于第一次调用请求，正常缓存数据。

### 2.4. 退出方式

如果你想要退出数据缓存，有两种方式：

一种是将 `fetch` 的 `cache` 选项设置为 `no-store`，示例如下，每次调用的时候都会重新获取数据：

```javascript
fetch(`https://...`, { cache: 'no-store' })
```

一种是使用[路由段配置项](https://juejin.cn/book/7307859898316881957/section/7309079033223446554)，它会影响该路由段中的所有数据请求：

```javascript
export const dynamic = 'force-dynamic'
```

## 3. 实战体会

修改 `app/page.js`，代码如下：

```js
async function getData() {
  // 接口每次调用都会返回一个随机的猫猫图片数据
  const res = await fetch('https://api.thecatapi.com/v1/images/search') 
  return res.json()
}

export async function generateMetadata() {
  const data = await getData()
  return {
    title: data[0].id
  }
}

export default async function Page() {
  const data = await getData()
  return (
    <>
      <h1>图片 ID：{data[0].id}</h1>
      <img src={data[0].url} width="300" />
      <CatDetail />
    </>
  )
}

async function CatDetail() {
  const data = await getData()
  return (
    <>
      <h1>图片 ID：{data[0].id}</h1>
      <img src={data[0].url} width="300" />
    </>
  )
}
```

代码的逻辑很简单，访问 `/` 会在 generateMetadata 函数、页面、子组件中调用 3 次接口，接口每次调用都会返回一张随机的猫猫图片数据，请问此时运行**生产版本**，3 次返回的数据是一致的吗？

让我们实际运行一下，效果如下：


![cache-10.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d95cede0ec354239b1b26da95a46a070~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1187&h=680&s=400357&e=gif&f=31&b=f8f4f4)

无论是普通刷新还是硬刷新，图片都会保持不遍，且 3 次接口调用数据返回一致。

原因也很简单，首先是静态渲染，页面在构建的时候进行渲染，其次虽然调用了 3 次接口，但因为有请求记忆、数据缓存，3 次调用接口数据返回一致。

现在我们关掉数据缓存，在 `app/page.js` 中添加代码：

```js
// 强制 fetch 不缓存
export const fetchCache = 'force-no-store'
```

运行生产版本，此时交互效果如下：


![cache-11.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95da27f365964fdcb2e1dbf9810c1a53~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1182&h=705&s=412571&e=gif&f=42&b=f9f6f6)

因为设置了 fetch 不缓存，页面自动从静态渲染转为动态渲染，所以每次刷新，接口都会返回新的图片。但因为有请求记忆，3 次接口调用都是返回一样的图片。

此时我们再关闭请求记忆，修改 `app/page.js`：

```js
async function getData() {
  const { signal } = new AbortController()
  const res = await fetch('https://api.thecatapi.com/v1/images/search', { signal }) 
  return res.json()
}
```

运行生产版本，此时交互效果如下：


![cache-12.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9342b86709649be94e47a67752ebeb3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1182&h=705&s=564105&e=gif&f=56&b=fdfdfd)

此时页面动态渲染，数据缓存和请求记忆都已关闭，所以每次请求都会返回不同的图片数据。

## 总结

最后让我们比较一下请求记忆和数据缓存：

请求记忆是 React 的数据缓存方案，它只持续在组件树渲染期间，目的是为了避免组件树渲染的时候多次请求同一数据造成的性能影响。

数据缓存是 Next.js 的数据缓存方案，它可以跨部署和请求缓存，缓存数据不会失效，除非重新验证或者主动退出。目的在于优化应用性能。

实际项目开发的时候，请求记忆和数据缓存往往同时存在，共同作用。


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b148832e89c44f77a00c9d4edaa67b42~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=661&s=124915&e=png&b=101010)

## 参考链接

1.  [Building Your Application: Caching | Next.js](https://nextjs.org/docs/app/building-your-application/caching)


## 15.缓存篇 | Caching（下）

## 前言

本篇我们继续讲 Next.js 的缓存机制。今天介绍的是完整路由缓存和路由缓存。

## 1. 完整路由缓存（Full Route Cache）

### 1.1. 工作原理

Next.js 在**构建的时候**会自动渲染和缓存路由，这样当访问路由的时候，可以直接使用缓存中的路由而不用从零开始在服务端渲染，从而加快页面加载速度。

那你可能要问，缓存路由是个什么鬼？我听过缓存数据，但是路由怎么缓存呢？让我们复习下 Next.js 的渲染原理：

Next.js 使用 React 的 API 来编排渲染。当渲染的时候，渲染工作会根据路由和 Suspense 拆分成多个 chunk，每个 chunk 分为两步进行渲染：

1.  React 会将服务端组件渲染成一种特殊的数据格式，我们称之为 React Server Component Payload，简写为 RSC payload。比如一个服务端组件的代码为：

```javascript
<div>
  Don’t give up and don’t give in.
  <ClientComponent />
</div>
```

React 会将其转换为如下的 Payload：

```javascript
["$","div",null,{"children":["Don’t give up and don’t give in.", ["$","$L1",null,{}]]}]
1:I{"id":123,"chunks":["chunk/[hash].js"],"name":"ClientComponent","async":false}
```

这个格式针对流做了优化，它们可以以流的形式逐行从服务端发送给客户端，客户端可以逐行解析 RSC Payload，渐进式渲染页面。

当然这个 RSC payload 代码肯定是不能直接执行的，它包含的更多是信息：

1.  服务端组件的渲染结果
2.  客户端组件的占位和引用文件
3.  从服务端组件传给客户端组件的数据

比如这个 RSC Payload 中的 `$L1` 表示的就是 ClientComponent，客户端会在收到 RSC Payload 后，解析下载 ClientComponent 对应的 bundle 地址，然后将执行的结果渲染到 `$L1` 占位的位置上。

2.  Next.js 会用 RSC payload 和客户端组件代码在服务端渲染 HTML

这张图生动的描述了这个过程：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb119007336543c288845f29c425e014~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=888\&s=171366\&e=png\&b=0d0d0d)

简单来说，路由渲染的产物有两个，一个是 RSC Payload，一个是 HTML。完整路由缓存，缓存的就是这两个产物。

不过路由在构建的时候是否会被缓存取决于它是静态渲染还是动态渲染。静态路由默认都是会被缓存的，动态路由因为只能在请求的时候被渲染，所以不会被缓存。这张图展示了静态渲染和动态渲染的差异：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1e45c1c5849d2892dfad986832acc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=1314\&s=351817\&e=png\&b=0c0c0c)

在这种图中，静态路由 `/a` 因为有完整路由缓存，所以不会重新渲染一遍。动态路由 `/b` 没有完整路由缓存，所以会重新执行一遍渲染。但这并不影响客户端的路由缓存，所以在后续的请求中都命中了路由缓存。

### 1.2. 持续时间

完整路由缓存默认是持久的，这意味着可以跨用户请求复用。

### 1.3. 失效方式

有两种方式可以使完整路由缓存失效：

*   重新验证数据：重新验证数据缓存会使完整路由缓存失效，毕竟渲染输出依赖于数据
*   重新部署：数据缓存是可以跨部署的，但完整路由缓存会在重新部署中被清除

### 1.4. 退出方式

退出完整路由缓存的方式就是将其改为动态渲染：

*   使用动态函数：使用动态函数后会改为动态渲染，此时数据缓存依然可以用
*   使用路由段配置项：`dynamic = 'force-dynamic'`或 `revalidate = 0` 这会跳过完整路由缓存和数据缓存，也就是说，每次请求时都会重新获取数据并渲染组件。此时路由缓存依然可以用，毕竟它是客户端缓存
*   退出数据缓存：如果路由中有一个 fetch 请求退出了缓存，则会退出完整路由缓存。这个特定的 fetch 请求会在每次请求时重新获取，其他 fetch 请求依然会使用数据缓存。Next.js 允许这种缓存和未缓存数据的混合

简单来说，完整路由缓存只适用于静态渲染，在服务端保留静态渲染的产物 RSC Payload 和 HTML。

使用动态渲染则会退出完整路由缓存。如何让路由从静态渲染转为动态渲染，也可以参考 [《渲染篇 | 服务端渲染策略》](https://juejin.cn/book/7307859898316881957/section/7342031804771565619#heading-2)。

## 2. 路由缓存（Router Cache）

### 2.1. 工作原理

Next.js 有一个存放在内存中的客户端缓存，它会在用户会话期间按路由段存储 RSC Payload。这就是路由缓存。

工作原理图如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8964c9aa0318409db0dd74ed86d18dd6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=1375\&s=312833\&e=png\&b=0b0b0b)

原理图很好理解，当访问 `/a`的时候，因为是首次访问（`MISS`），将 `/（layout）`和 `/a(page)`放在路由缓存中（`SET`），当访问与 `/a`共享布局的 `/b`的时候，使用路由缓存中的 `/（layout）`，然后将 `/b(page)`放在路由缓存中（`SET`）。再次访问 `/a`的时候，直接使用路由缓存中（`HIT`）的 `/(layout)`和 `/b(page)`。

不止如此，当用户在路由之间导航，Next.js 会缓存访问过的路由段并预获取用户可能导航的路由（基于视口内的 `<Link>` 组件）。这会为用户带来更好的导航体验：

1.  即时前进和后退导航，因为访问过的路由已经被缓存，并且预获取了新路由
2.  导航不会导致页面重载，并且会保留 React 的状态和浏览器状态

让我们根据原理图写个 demo 验证一下：

```javascript
// app/layout.js
import Link from "next/link";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <div>
          <Link href="/a">Link to /a</Link>
          <br />
          <Link href="/b">Link to /b</Link>
        </div>
        {children}
      </body>
    </html>
  )
}
```

两个路由的代码类似：

```javascript
// app/a/page.js | app/b/page.js
export default function Page() {
  return (
    <h1>Component X</h1>
  )
}
```

当首次访问 `/a`的时候，因为 Link 组件的 `/a` 和 `/b` 都在视口内，所以会预加载 `/a` 和  `/b` 的 RSC Payload：

![截屏2023-11-28 上午11.13.19.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73175e3be51847c7bfb65e00c32da591~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1298\&h=1028\&s=150651\&e=png\&b=ffffff)

得益于预加载和缓存，无论是导航还是前进后退都非常顺滑：

![1114.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a18d51d4ff7448d81b2e883b223b73f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=927\&h=570\&s=131584\&e=gif\&f=32\&b=fefefe)

### 2.2. 持续时间

路由缓存存放在浏览器的临时缓存中，有两个因素决定了路由缓存的持续时间：

*   Session，缓存在导航时持续存在，当页面刷新的时候会被清除
*   自动失效期：单个路由段会在特定时长后自动失效
    * **如果路由是静态渲染，持续 5 分钟**
    * **如果路由是动态渲染，持续 30s**

比如上面的 demo 中如果等 5 分钟后再去点击，就会重新获取新的 RSC Payload

通过添加 `prefetch={true}`（Link 组件的 prefetch 默认就为 true）或者在动态渲染路由中调用 `router.prefetch`，可以进入缓存 5 分钟。

### 2.3. 失效方式

**有两种方法可以让路由缓存失效：**

*   在 Server Action 中
    *   通过 `revalidatePath` 或 `revalidateTag` 重新验证数据 
    *   使用  `cookies.set` 或者 `cookies.delete` 会使路由缓存失效，这是为了防止使用 cookie 的路由过时（如身份验证）
*   调用 `router.refresh` 会使路由缓存失效并发起一个重新获取当前路由的请求

### 2.4. 退出方式

**无法退出路由缓存**。你可以通过给 `<Link>` 组件的 `prefetch` 传递 `false` 来退出预获取，但依然会临时存储路由段 30s，这是为了实现嵌套路由段之间的即时导航。此外访问过的路由也会被缓存。

### 2.5. 实战体会

这个时候你可能觉得路由缓存还蛮不错，但是让我们写个项目，在实战中感受下路由缓存有的时候让人多头疼吧！

目录结构如下：

```
app                  
├─ (cache)       
│  ├─ about          
│  │  └─ page.js     
│  ├─ settings       
│  │  └─ page.js     
│  ├─ layout.js      
│  └─ loading.js         
```

其中 `app/(cache)/layout.js`，代码如下：

```js
import Link from 'next/link'

export const dynamic = 'force-dynamic'

export default function CacheLayout({
  children,
}) {
  return (
    <section className="p-5">
        <nav className="flex items-center justify-center gap-10 text-blue-600 mb-6">
          <Link href="/about">About</Link>
          <Link href="/settings">Settings</Link>
        </nav>
      {children}
    </section>
  )
}
```

`app/(cache)/loading.js`，代码如下：

```js
export default function DashboardLoading() {
  return  <div className="h-60 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">Loading</div>
}
```

`app/(cache)/about/page.js`，代码如下：

```js
const sleep = ms => new Promise(r => setTimeout(r, ms));

export default async function About() {
  await sleep(2000)
  return (
    <div className="h-60 flex-1 rounded-xl bg-teal-400 text-white flex items-center justify-center">Hello, About! {new Date().toLocaleString()}</div>
  )
}
```

`app/(cache)/settings/page.js`，代码如下：

```js
const sleep = ms => new Promise(r => setTimeout(r, ms));

export default async function Settings() {
  await sleep(2000)
  return (
    <div className="h-60 flex-1 rounded-xl bg-teal-400 text-white flex items-center justify-center">Hello, Settings! {new Date().toLocaleString()}</div>
  )
}
```

运行生产版本，交互效果如下：


![cache-13.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ca548ee77b444eb96e34b8d868d3738~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1235&h=800&s=1605366&e=gif&f=66&b=262829)

交互效果看起来很正常是不是？但是注意：

当我们刷新页面的时候，`/about` 出现了 loading 加载，当我们首次点击 Settings 导航至 `/settings` 的时候，也出现了 loading 加载。然而当我们再点击 About、Settings 的时候就没有 loading 加载效果了，不仅如此，查看网络请求，甚至都没有发送网络请求。

这就是客户端路由缓存的功效。尤其是搭配 `<Link>` 标签导航的时候，会直接从路由缓存中获取 RSC，所以当导航的时候，连时间都没有改变。

如果我希望每次点击的时候都重新加载页面呢？

你可能会想，那就给 About、Settings 这两个页面加上 `dynamic`、`revalidate` 等路由段配置项，让静态渲染转为动态渲染。但其实我们已经在布局中配置了 `const dynamic = 'force-dynamic'`，现在就是动态渲染，动态渲染只能让页面刷新或者初次请求的时候时间是准确的，但是导航的时候，因为客户端缓存的缘故，依然不会更新。

那么我们该怎么办呢？

第一种方式是等。客户端缓存是有自动失效期的，动态渲染 30s，静态渲染 5 分钟。现在是动态渲染，等待 30s 后再点击 About、Settings 就会重新发送请求，显示正确的时间。

第二种方式是不用 Link 标签，改用原生的 `<a>` 标签。不过这种方式会导致页面刷新。

修改 `app/(cache)/layout.js`，代码如下：

```js
import Link from 'next/link'

export const dynamic = 'force-dynamic'

export default function CacheLayout({
  children,
}) {
  return (
    <section className="p-5">
        <nav className="flex items-center justify-center gap-10 text-blue-600 mb-6">
          <a href="/about">About</a>
          <a href="/settings">Settings</a>
        </nav>
      {children}
    </section>
  )
}
```

运行生产版本，交互效果如下：

![cache-14.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/caeac218e1314bdf86c464f6534eecfb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1235&h=800&s=650141&e=gif&f=46&b=292929)

第三种方式是参照让路由缓存失效的方式：一种是使用 Server Actions，不过这里我们用不到 Server Actions。一种是调用 router.refresh，但是使用 router 需要声明为客户端组件，这就需要将布局改为客户端组件，虽然有点糟糕，但是也能用。

修改 `app/(cache)/layout.js`，代码如下：

```js
'use client'

import { useRouter } from 'next/navigation'

export default function CacheLayout({
  children,
}) {
  const router = useRouter()
  return (
    <section className="p-5">
        <nav className="flex items-center justify-center gap-10 text-blue-600 mb-6">
          <button onClick={() => {
            router.push('/about')
            router.refresh()
          }}>About</button>
          <button onClick={() => {
            router.push('/settings')
            router.refresh()
          }}>Settings</button>
        </nav>
      {children}
    </section>
  )
}
```

然后给 `app/(cache)/about/page.js` 和 `app/(cache)/about/page.js` 添加代码：

```js
export const dynamic = 'force-dynamic'
```

目的将其转为动态渲染。运行生产版本，效果如下：

![cache-16.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/282410b6f48443218699d266c1328161~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1235&h=800&s=751814&e=gif&f=53&b=2a2a2a)

第四种方式跟第三种方式都是用 router.refresh，不过实现方式不同。示例代码如下：

新建 `app/(cache)/navigation-events.js`，代码如下：

```js
'use client'
 
import { useEffect } from 'react'
import { usePathname, useSearchParams } from 'next/navigation'
import { useRouter } from 'next/navigation'

export function NavigationEvents() {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  const router = useRouter()
  
  useEffect(() => {
    router.refresh()
  }, [pathname, searchParams])
 
  return null
}
```

修改 `app/(cache)/layout.js`，代码如下：

```js
import Link from 'next/link'
import { Suspense } from 'react'
import { NavigationEvents } from './navigation-events'

export const dynamic = 'force-dynamic'

export default function CacheLayout({
  children,
}) {
  return (
    <section className="p-5">
        <nav className="flex items-center justify-center gap-10 text-blue-600 mb-6">
          <Link href={`/about`}>About</Link>
          <Link href={`/settings`}>Settings</Link>
        </nav>
      {children}
      <Suspense fallback={null}>
        <NavigationEvents />
      </Suspense>
    </section>
  )
}
```

运行生产版本，交互效果如下：

![cache-15.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52a49095ee07425ba2eeb47f66ab2349~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1235&h=800&s=1232048&e=gif&f=47&b=2a2a2a)

## 总结

路由缓存和完整路由缓存的区别：

1.  路由缓存发生在用户访问期间，将 RSC Payload 暂时存储在浏览器，导航期间都会持续存在，页面刷新的时候会被清除。而完整路由缓存则会持久的将 RSC Payload 和 HTML 缓存在服务器上
2.  完整路由缓存仅缓存静态渲染的路由，路由缓存可以应用于静态和动态渲染的路由

在实际项目开发中，路由缓存可能是一个让人头疼的问题。因为它经常使用，但又无法退出，为此有的时候需要特殊处理，所以关于路由缓存可以多关注一下。我们在实战篇的第一个项目[《实战篇 | React Notes | 笔记预览界面》](https://juejin.cn/book/7307859898316881957/section/7309112043122196490#heading-4)还会遇到路由缓存。

之前说过 Next.js 会自动根据你使用的 API 做好缓存管理，具体 API 跟四种缓存的关系表为：

API                                                                                                                                  | 路由缓存               | 完整路由缓存      | 数据缓存            | 请求记忆 |
| ------------------------------------------------------------------------------------------------------------------------------------ | -------------------------- | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](https://nextjs.org/docs/app/building-your-application/caching#link)                                              | Cache                      |                       |                       |             |
| [`router.prefetch`](https://nextjs.org/docs/app/building-your-application/caching#routerprefetch)                                    | Cache                      |                       |                       |             |
| [`router.refresh`](https://nextjs.org/docs/app/building-your-application/caching#routerrefresh)                                      | Revalidate                 |                       |                       |             |
| [`fetch`](https://nextjs.org/docs/app/building-your-application/caching#fetch)                                                       |                            |                       | Cache                 | Cache       |
| [`fetch` `options.cache`](https://nextjs.org/docs/app/building-your-application/caching#fetch-optionscache)                          |                            |                       | Cache or Opt out      |             |
| [`fetch` `options.next.revalidate`](https://nextjs.org/docs/app/building-your-application/caching#fetch-optionsnextrevalidate)       |                            | Revalidate            | Revalidate            |             |
| [`fetch` `options.next.tags`](https://nextjs.org/docs/app/building-your-application/caching#fetch-optionsnexttags-and-revalidatetag) |                            | Cache                 | Cache                 |             |
| [`revalidateTag`](https://nextjs.org/docs/app/building-your-application/caching#fetch-optionsnexttags-and-revalidatetag)             | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`revalidatePath`](https://nextjs.org/docs/app/building-your-application/caching#revalidatepath)                                     | Revalidate (Server Action) | Revalidate            | Revalidate            |             |
| [`const revalidate`](https://nextjs.org/docs/app/building-your-application/caching#segment-config-options)                           |                            | Revalidate or Opt out | Revalidate or Opt out |             |
| [`const dynamic`](https://nextjs.org/docs/app/building-your-application/caching#segment-config-options)                              |                            | Cache or Opt out      | Cache or Opt out      |             |
| [`cookies`](https://nextjs.org/docs/app/building-your-application/caching#cookies)                                                   | Revalidate (Server Action) | Opt out               |                       |             |
| [`headers`, `searchParams`](https://nextjs.org/docs/app/building-your-application/caching#dynamic-functions)                         |                            | Opt out               |                       |             |
| [`generateStaticParams`](https://nextjs.org/docs/app/building-your-application/caching#generatestaticparams)                         |                            | Cache                 |                       |             |
| [`React.cache`](https://nextjs.org/docs/app/building-your-application/caching#react-cache-function)                                  |                            |                       |                       | Cache       |

注：Cache 表示触发缓存，Revalidate 表示触发重新验证，Opt out 表示触发退出缓存

在开发项目中遇到缓存问题的时候，可以先根据使用的 API 判断涉及的缓存类型，然后再选择合适的方式重新验证或者退出缓存。

## 参考链接

1.  [Building Your Application: Caching | Next.js](https://nextjs.org/docs/app/building-your-application/caching)


## 16.数据获取篇 | Server Actions（上）

## 前言

**Server Actions 是指在服务端执行的异步函数，它们可以在服务端和客户端组件中使用，以处理 Next.js 应用中的数据提交和更改。**

注：如果大家看英文文档，“数据更改”更专业的说法叫做 Data Mutations，中文译为“数据突变”。简单来说，数据查询（Data Queries）指读取数据，数据突变（Data Mutations）指更改数据。突变可以是新增、更新、删除字段或对象。“数据突变”初听可能有些奇怪，习惯就好。

## 基本用法

定义一个 Server Action 需要使用 React 的 ["use server"](https://react.dev/reference/react/use-server) 指令。按指令的定义位置分为两种用法：

1.  将 "use server" 放到一个 async 函数的顶部表示该函数为 Server Action（函数级别）
2.  将 "use server" 放到一个单独文件的顶部表示该文件导出的所有函数都是 Server Actions（模块级别）

**Server Actions 可以在服务端组件使用，也可以在客户端组件使用。**

当在服务端组件中使用的时候，两种级别都可以使用：

```javascript
// app/page.jsx
export default function Page() {
  // Server Action
  async function create() {
    'use server'
 
    // ...
  }
 
  return (
    // ...
  )
}
```

而在客户端组件中使用的时候，只支持模块级别。需要先创建一个文件（文件名无约定，很多开发者常命名为 "actions"），在顶部添加 "use server" 指令：

```javascript
'use server'

// app/actions.js
export async function create() {
  // ...
}
```

当需要使用的时候，导入该文件：

```javascript
import { create } from '@/app/actions'
 
export function Button() {
  return (
    // ...
  )
}
```

也可以将 Server Action 作为 props 传给客户端组件：

```javascript
<ClientComponent updateItem={updateItem} />
```

```javascript
'use client'
 
export default function ClientComponent({ updateItem }) {
  return <form action={updateItem}>{/* ... */}</form>
}
```

## 使用场景

在 Pages Router 下，如果要进行前后端交互，需要先定义一个接口，然后前端调用接口完整前后端交互。而在 App Router 下，这种操作都可以简化为 Server Actions。

也就是说，如果你要实现一个功能，按照传统前后端分离的架构，需要自己先写一个接口，用于前后端交互，那就都可以尝试使用 Server Actions，除非你就是需要写接口方便外部调用。

**而在具体使用上，虽然 Server Actions 常与 `<form>` 一起使用，但其实还可以在事件处理程序、useEffect、三方库、其他表单元素（如 `<button>`）中调用。**

## 实战体会

了解了基本用法，还是让我们在实战中具体体会吧！

我们的目标是写一个简单的 ToDoList：

![actions-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6aac0ba6aab452eab1ea2bddbed0a97~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918\&h=711\&s=72795\&e=gif\&f=26\&b=f5f5f5)

写之前我们先用传统的 Pages Router 来实现一遍，通过对比来感受传统的使用 API 开发和使用 Server Actions 开发之间的区别。

### Pages Router  - API

实现一个 ToDoList，我们需要先创建一个 `/api/todo`接口。新建 `app/api/todos/route.js`，代码如下：

```javascript
import { NextResponse } from 'next/server'

const data = ['阅读', '写作', '冥想']
 
export async function GET() {
  return NextResponse.json({ data })
}

export async function POST(request) {
  const formData = await request.formData()
  const todo = formData.get('todo')
  data.push(todo)
  return NextResponse.json({ data })
}
```

此时访问 `/api/todos`，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bae3ba7e1e4d4a289b9f0deee7d4df47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1840\&h=250\&s=42777\&e=png\&b=fefefe)
现在我们开始写页面，在项目根目录新建 `pages`目录（用了 src，就放到 src 下），新建 `pages/form.js`，代码如下：

```javascript
import { useEffect, useState } from "react"

export default function Page() {

  const [todos, setTodos] = useState([])

  useEffect(() => {
    const fetchData = async () => {
      const { data } = await (await fetch('/api/todos')).json()
      setTodos(data)
    }
    fetchData()
  }, [])

  async function onSubmit(event) {
    event.preventDefault()
    const response = await fetch('/api/todos', {
      method: 'POST',
      body: new FormData(event.currentTarget),
    })

    const {data} = await response.json()
    setTodos(data)
  }
  return (
    <>
      <form onSubmit={onSubmit}>
        <input type="text" name="todo" />
        <button type="submit">Submit</button>
      </form>
      <ul>
        {todos.map((todo, i) => <li key={i}>{todo}</li>)}
      </ul>
    </>
  )
}
```

代码很简单，页面加载的时候 GET 请求 `/api/todos` 渲染待办事项，表单提交的时候 POST 请求 `/api/todos`修改数据，然后渲染最新的待办事项。交互效果如下：

![actions-2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98a2e2e47a1d4627999d34701d2df82b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918\&h=689\&s=98362\&e=gif\&f=51\&b=fefefe)

### App Router - Server Actions

那么用 Server Actions 该怎么实现呢？

新建 `app/form2/page.js`，代码如下：

```javascript
import { findToDos, createToDo } from './actions';

export default async function Page() {
  const todos = await findToDos();
  return (
    <>
      <form action={createToDo}>
        <input type="text" name="todo" />
        <button type="submit">Submit</button>
      </form>
      <ul>
        {todos.map((todo, i) => <li key={i}>{todo}</li>)}
      </ul>
    </>
  )
}
```

新建 `app/form2/actions.js`，代码如下：

```javascript
'use server'

import { revalidatePath } from "next/cache";

const data = ['阅读', '写作', '冥想']
 
export async function findToDos() {
  return data
}

export async function createToDo(formData) {
  const todo = formData.get('todo')
  data.push(todo)
  revalidatePath("/form2");
  return data
}
```

交互效果如下（其实效果跟 Pages Router 下相同）：

![actions-3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66da4e1806d84a9fac84b2771e78dcd5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918\&h=689\&s=67987\&e=gif\&f=34\&b=fefefe)

## Server Actions

就让我们以这个简单的 Server Actions Demo 为例来分析下 Server Actions。
### 基本原理
首先是原理，Server Actions 是怎么实现的呢？让我们看下表单对应的 HTML 元素：

![截屏2024-03-12 22.51.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9709525ade5d4bebbeb29a1200471320~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2742\&h=610\&s=203100\&e=png\&b=2c2c2c)

Next.js 会自动插入一个 `<input type="hidden">`，其值为 `$ACTION_ID_xxxxxxxx`，用于让服务端区分 Action（因为一个页面可能使用多个 Server Actions）。

当点击 Submit 的时候，触发表单提交，会发送一个 POST 请求到当前页面地址：

![截屏2024-03-12 22.54.44.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e25b5b096dd748b795649d40ef78a165~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2858\&h=1478\&s=431607\&e=png\&b=2b2b2b)

请求会携带表单中的值，以及 \$ACTION\_ID：

![截屏2024-03-12 22.55.57.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7354fd9c235c4dc9a92d0e50ea679b5e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2854\&h=1028\&s=305594\&e=png\&b=2b2b2b)

接口返回 RSC Payload，用于渲染更新后的数据：

![截屏2024-03-12 23.05.05.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d841770d3ca4697be42a7e9f3d7c100~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3154\&h=1040\&s=396005\&e=png\&b=2c2c2c)

其中，中文在 Chrome 显示乱码了（火狐可以正常查看）。RSC Payload 中包含最新的数据（返回最新的数据是因为我们调用了 revalidatePath）：

![截屏2024-03-12 23.06.33.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de99e77ca7534f68b45a20ccd3510e38~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3456\&h=436\&s=243070\&e=png\&b=1f1f1f)

简而言之：

1.  **Server Actions 背后使用的是 POST 请求方法**，请求当前页面地址，根据 \$ACTION\_ID 区分
2.  **Server Actions 与 Next.js 的缓存和重新验证架构集成**。调用 Action 时，Next.js 可以一次性返回更新的 UI 和新数据
### 使用好处
其次我们说说使用 Server Actions 的好处：

1.  代码更简洁。你也不需要手动创建接口，而且 Server Actions 是函数，这意味着它们可以在应用程序的任意位置中复用。
2.  当结合 form 使用的时候，支持渐进式增强。也就是说，即使禁用 JavaScript，表单也可以正常提交：

![actions-4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ca8470e248d43f49db3ae7d44295f8c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1078\&h=571\&s=105914\&e=gif\&f=43\&b=292929)

如果使用 Pages Router 下的监听事件的方式，表单就无法正常工作了。但是 Server Actions 即使禁用 JS，也可以正常工作。

使用 Server Actions 禁用和不禁用 JS 的差别是，**不禁用的时候提交表单，页面不会刷新**。禁用的时候提交表单页面会刷新（仔细看上图提交“早起”这项任务的时候，刷新按钮有变化）
### 注意要点
最后讲讲使用 Server Actions 的注意要点。

1.  **Server Actions 的参数和返回值都必须是可序列化的**，简单的说，JSON.stringfiy 这个值不出错
2.  Server Actions 会继承使用的页面或者布局的运行时和路由段配置项，包括像 maxDuration 等字段

### 支持事件

前面也说过：

> **而在具体使用上，虽然 Server Actions 常与 `<form>` 一起使用，但其实还可以在事件处理程序、useEffect、三方库、其他表单元素（如 `<button>`）中调用。**


如果是在事件处理程序中，该怎么使用呢？

我们为刚才的 ToDoList 增加一个 “添加运动” 的按钮。当点击的时候，将运动添加到 TODO 中：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80e49e5847d84e7c99af97a722592f77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1148&h=566&s=49790&e=png&b=fefefe)

修改 `app/form2/page.js`，代码如下：

```js
import { findToDos, createToDo } from './actions';
import Button from './button';

export default async function Page() {
  const todos = await findToDos();
  return (
    <>
      <form action={createToDo}>
        <input type="text" name="todo" />
        <button type="submit">Submit</button>
      </form>
      <Button>添加运动</Button>
      <ul>
        {todos.map((todo, i) => <li key={i}>{todo}</li>)}
      </ul>
    </>
  )
}
```

新建 `app/form2/button.js`，代码如下：

```js
'use client'

import { createToDoDirectly } from './actions';

export default function Button({children}) {
  return <button onClick={async () => {
    const data = await createToDoDirectly('运动')
    alert(JSON.stringify(data))
  }}>{children}</button>
}
```

修改 `app/form2/actions.js`，添加代码：

```js
export async function createToDoDirectly(value) {
  const form = new FormData()
  form.append("todo", value);
  return createToDo(form)
}
```

交互效果如下：


![actions-5.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/561fa0b46ab241f9be6b03ec45622244~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=847&h=558&s=55228&e=gif&f=32&b=fefefe)

这里的 Server Actions 是怎么实现的呢？

其实还是发送了一个 POST 请求到当前地址：


![截屏2024-03-13 10.50.23.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99ed678d82c34f4c8e8b981110e3ea50~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2770&h=1668&s=523309&e=png&b=fefefe)

返回的依然是 RSC Payload：


![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d78ded7ca837448d96ac6e5cbbcd3939~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2770&h=1098&s=444743&e=png&b=fefefe)

## 总结

想必大家已经熟悉了 Server Actions 的基本用法，Server Actions 自 Next.js v14 起进入稳定阶段，以后应该会是 Next.js 开发全栈项目时获取数据的主要方式，一定要熟练掌握。

其实使用 Server Actions 还有很多细节，比如如何获取表单提交时的等待状态？服务端如何验证字段？如何进行乐观更新？如何进行错误处理？如何获取 Cookies、Headers 等数据？如何重定向？……

这些也都是开发中常遇到的问题，我们下篇继续讲 Server Actions。


## 17.数据获取篇 | Server Actions（下）

## 前言

上篇我们讲了 Server Actions 的基本用法，本篇我们讲讲 Server Actions 的“标准”用法。比如哪些 API 和库是常搭配 Server Actions 使用的？写一个 Server Actions 要注意哪些地方？

我们还会介绍开发 Server Actions 时常遇到的一些问题，比如如何进行乐观更新？如何进行错误处理？如何获取 Cookies、Headers 等数据？如何重定向？等等

让我们开始吧。

## Form

我们先讲讲 Server Actions 处理表单提交时常搭配使用的一些 API。

### 1. useFormStatus

首先是 [useFormStatus](https://react.dev/reference/react-dom/hooks/useFormStatus)，这是 React 的官方 hook，用于返回表单提交的状态信息。示例代码如下：

```javascript
'use client'
// app/submit-button.jsx
import { useFormStatus } from 'react-dom'
 
export function SubmitButton() {
  const { pending } = useFormStatus()
 
  return (
    <button type="submit" aria-disabled={pending}>
      {pending ? 'Adding' : 'Add'}
    </button>
  )
}
```

```javascript
// app/page.jsx
import { SubmitButton } from '@/app/submit-button'
 
export default async function Home() {
  return (
    <form action={...}>
      <input type="text" name="field-name" />
      <SubmitButton />
    </form>
  )
}
```

使用的时候要注意：useFormStatus 必须用在 `<form>` 下的组件内部，就像这段示例代码一样。先建立一个按钮组件，在组件内部调用 useFormStatus，然后 `<form>` 下引用该组件。不能完全写到一个组件中，像这样写就是错误的：

```javascript
function Form() {
  // 🚩 `pending` will never be true
  // useFormStatus does not track the form rendered in this component
  const { pending } = useFormStatus();
  return <form action={submit}></form>;
}
```

### 2. useFormState

然后是 [useFormState](https://react.dev/reference/react-dom/hooks/useFormState)，这也是 React 官方 hook，根据表单 action 的结果更新状态。

用在 React 时示例代码如下：

```javascript
import { useFormState } from "react-dom";

async function increment(previousState, formData) {
  return previousState + 1;
}

function StatefulForm({}) {
  const [state, formAction] = useFormState(increment, 0);
  return (
    <form>
      {state}
      <button formAction={formAction}>Increment</button>
    </form>
  )
}
```

用在 Next.js，结合 Server Actions 时，示例代码如下：

```javascript
'use client'

import { useFormState } from 'react-dom'

export default function Home() {

  async function createTodo(prevState, formData) {
    return prevState.concat(formData.get('todo'));
  }

  const [state, formAction] = useFormState(createTodo, [])

  return (
    <form action={formAction}>
      <input type="text" name="todo" />
      <button type="submit">Submit</button>
      <p>{state.join(',')}</p>
    </form>
  ) 
}
```

### 3. 实战体会

现在让我们结合 useFormStatus 和 useFormState，讲解使用 Server Actions 如何处理 form 提交。涉及的目录和文件如下：

```javascript
app                 
└─ form3           
   ├─ actions.js   
   ├─ form.js      
   └─ page.js            
```

其中 `app/form3/page.js` 代码如下：

```javascript
import { findToDos } from './actions';
import AddToDoForm from './form';

export default async function Page() {
  const todos = await findToDos();
  return (
    <>
      <AddToDoForm />
      <ul>
        {todos.map((todo, i) => <li key={i}>{todo}</li>)}
      </ul>
    </>
  )
}
```

`app/form3/form.js`，代码如下：

```javascript
'use client'
 
import { useFormState, useFormStatus } from 'react-dom'
import { createToDo } from './actions';

const initialState = {
  message: '',
}
 
function SubmitButton() {
  const { pending } = useFormStatus()
  return (
    <button type="submit" aria-disabled={pending}>
      {pending ? 'Adding' : 'Add'}
    </button>
  )
}

export default function AddToDoForm() {
  const [state, formAction] = useFormState(createToDo, initialState)
 
  return (
    <form action={formAction}>
      <input type="text" name="todo" />
      <SubmitButton />
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
    </form>
  )
}
```

`app/form3/actions.js`，代码如下：

```javascript
'use server'

import { revalidatePath } from "next/cache";

const sleep = ms => new Promise(r => setTimeout(r, ms));

let data = ['阅读', '写作', '冥想']
 
export async function findToDos() {
  return data
}

export async function createToDo(prevState, formData) {
  await sleep(500)
  const todo = formData.get('todo')
  data.push(todo)
  revalidatePath("/form3");
  return {
    message: `add ${todo} success!`
  }
}
```

交互效果如下：

![actions-6.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9b1592d85124e03a2cd6d927ea6686b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=847\&h=558\&s=81417\&e=gif\&f=37\&b=fefefe)
注意：当使用 useFormState 的时候，对应 Server Action 函数的参数，第一个参数是 prevState，第二个参数是 formData。当使用 useFormStatus 的时候，要写在 form 下的单独的组件中。使用的时候，注意这两点就行。

值得一提的是：

```javascript
<p aria-live="polite" className="sr-only">
  {state?.message}
</p>
```

`aria-live`表示这是一个 ARIA 标签，用于礼貌通知用户发生了变更。`"sr-only"`表示这是一个只用于 screen reader 的内容。因为我们并没有设置 sr-only 的样式，所以在页面中显露了出来，按理说要加一个如下的样式：

```css
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
```

简单的来说，这段内容在屏幕上并不应该显示出来。返回这个信息是用于通知不能像正常人看到屏幕内容、需要借助屏幕阅读器工具的人，任务创建成功。

## Server Actions

接下来讲讲写 Server Actions 有哪些注意要点。简单来说，要注意：

1.  获取提交的数据
2.  进行数据校验和错误处理
3.  重新验证数据
4.  错误处理

### 1. 获取数据

如果使用 form action 这种最基本的形式，Server Action 函数第一个参数就是 formData：

```javascript
export default function Page() {
  async function createInvoice(formData) {
    'use server'
 
    const rawFormData = {
      customerId: formData.get('customerId')
    }
 
    // mutate data
    // revalidate cache
  }
 
  return <form action={createInvoice}>...</form>
}
```

如果使用 form action + useFormState 这种形式，Server Actions 函数第一个参数是 prevState，第二个参数是 formData：

```javascript
'use client'

import { useFormState } from 'react-dom'

export default function Home() {

  async function createTodo(prevState, formData) {
    return prevState.concat(formData.get('todo'));
  }

  const [state, formAction] = useFormState(createTodo, [])

  return (
    <form action={formAction}>
      <input type="text" name="todo" />
      <button type="submit">Submit</button>
      <p>{state.join(',')}</p>
    </form>
  ) 
}
```

如果是直接调用，那看调用的时候是怎么传入的，比如上篇举的事件调用的例子：

```javascript
'use client'

import { createToDoDirectly } from './actions';

export default function Button({children}) {
  return <button onClick={async () => {
    const data = await createToDoDirectly('运动')
    alert(JSON.stringify(data))
  }}>{children}</button>
}
```

```javascript
'use server'

export async function createToDoDirectly(value) {
  const form = new FormData()
  form.append("todo", value);
  return createToDo(form)
}
```

### 2. 表单验证

Next.js 推荐基本的表单验证使用 HTML 元素自带的验证如 `required`、`type="email"`等。

对于更高阶的服务端数据验证，可以使用 [zod](https://zod.dev/) 这样的 schema 验证库来验证表单数据的结构：

```javascript
'use server'
 
import { z } from 'zod'
 
const schema = z.object({
  email: z.string({
    invalid_type_error: 'Invalid Email',
  }),
})
 
export default async function createsUser(formData) {
  const validatedFields = schema.safeParse({
    email: formData.get('email'),
  })
 
  // Return early if the form data is invalid
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
    }
  }
 
  // Mutate data
}
```

### 3. 重新验证数据

Server Action 修改数据后，一定要注意重新验证数据，否则数据不会及时更新。

使用 revalidatePath：

```javascript
'use server'
 
import { revalidatePath } from 'next/cache'
 
export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }
 
  revalidatePath('/posts')
}
```

使用 revalidateTag：

```javascript
'use server'
 
import { revalidateTag } from 'next/cache'
 
export async function createPost() {
  try {
    // ...
  } catch (error) {
    // ...
  }
 
  revalidateTag('posts')
}
```

### 4. 错误处理

一种是返回错误信息。举个例子，当一个条目创建失败，返回错误信息：

```javascript
'use server'
// app/actions.js
export async function createTodo(prevState, formData) {
  try {
    await createItem(formData.get('todo'))
    return revalidatePath('/')
  } catch (e) {
    return { message: 'Failed to create' }
  }
}
```

在客户端组件中，读取这个值并显示错误信息：

```javascript
'use client'
// app/add-form.jsx
import { useFormState, useFormStatus } from 'react-dom'
import { createTodo } from '@/app/actions'
 
const initialState = {
  message: null,
}
 
function SubmitButton() {
  const { pending } = useFormStatus()
 
  return (
    <button type="submit" aria-disabled={pending}>
      Add
    </button>
  )
}
 
export function AddForm() {
  const [state, formAction] = useFormState(createTodo, initialState)
 
  return (
    <form action={formAction}>
      <label htmlFor="todo">Enter Task</label>
      <input type="text" id="todo" name="todo" required />
      <SubmitButton />
      <p aria-live="polite" className="sr-only">
        {state?.message}
      </p>
    </form>
  )
}
```

一种是抛出错误，会由最近的 error.js 捕获：

```javascript
'use client'
// error.js
export default function Error() {
  return (
    <h2>error</h2>
  )
}
```

```javascript
// page.js
import { useFormState } from 'react-dom'

function AddForm() {
  async function serverActionWithError() {
    'use server';   
    throw new Error(`This is error is in the Server Action`);
  }

  return (
    <form action={serverActionWithError}>
      <button type="submit">Submit</button>
    </form>
  ) 
}

export default AddForm
```

这样当 Server Action 发生错误的时候，就会展示错误 UI。

## 乐观更新

### 1. useOptimistic

所谓乐观更新，举个例子，当用户点击一个点赞按钮的时候，传统的做法是等待接口返回成功时再更新 UI。乐观更新是先更新 UI，同时发送数据请求，至于数据请求后的错误处理，则根据自己的需要自定义实现。

React 提供了 [useOptimistic](https://react.dev/reference/react/useOptimistic) hook，这也是官方 hook，基本用法如下：

```javascript
import { useOptimistic } from 'react';

function AppContainer() {
  const [optimisticState, addOptimistic] = useOptimistic(
    state,
    // updateFn
    (currentState, optimisticValue) => {
      // merge and return new state
      // with optimistic value
    }
  );
}
```

结合 Server Actions 使用的示例代码如下：

```javascript
'use client'
 
import { useOptimistic } from 'react'
import { send } from './actions'
 
export function Thread({ messages }) {
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [...state, { message: newMessage }]
  )
 
  return (
    <div>
      {optimisticMessages.map((m) => (
        <div>{m.message}</div>
      ))}
      <form
        action={async (formData) => {
          const message = formData.get('message')
          addOptimisticMessage(message)
          await send(message)
        }}
      >
        <input type="text" name="message" />
        <button type="submit">Send</button>
      </form>
    </div>
  )
}
```

### 2. 实战体会

为了加深对乐观更新的理解，我们来写一个例子。项目目录和文件如下：

```javascript
app                 
└─ form4           
   ├─ actions.js   
   ├─ form.js      
   └─ page.js            
```

其中 `app/form4/page.js` 代码如下：

```javascript
import { findToDos } from './actions';
import Form from './form';

export default async function Page() {
  const todos = await findToDos();
  return (
    <Form todos={todos} />
  )
}
```

`app/form4/form.js`，代码如下：

```javascript
'use client'

import { useOptimistic } from 'react'
import { useFormState } from 'react-dom'
import { createToDo } from './actions';

export default function Form({ todos }) {
  const [state, sendFormAction] = useFormState(createToDo, { message: '' })

  const [optimistiToDos, addOptimisticTodo] = useOptimistic(
    todos.map((i) => ({text: i})),
    (state, newTodo) => [
      ...state,
      {
        text: newTodo,
        sending: true
      }
    ]
  );

  async function formAction(formData) {
    addOptimisticTodo(formData.get("todo"));
    await sendFormAction(formData);
  }

  console.log(optimistiToDos)

  return (
    <>
      <form action={formAction}>
        <input type="text" name="todo" />
        <button type="submit"> Add </button>
        <p aria-live="polite" className="sr-only">
          {state?.message}
        </p>
      </form>
      <ul>
        {optimistiToDos.map(({text, sending}, i) => <li key={i}>{text}{!!sending && <small> (Sending...)</small>}</li>)}
      </ul>
    </>
  )
}
```

`app/form4/actions.js`，代码如下：

```javascript
'use server'

import { revalidatePath } from "next/cache";

const sleep = ms => new Promise(r => setTimeout(r, ms));

let data = ['阅读', '写作', '冥想']
 
export async function findToDos() {
  return data
}

export async function createToDo(prevState, formData) {
  await sleep(2500)
  const todo = formData.get('todo')
  data.push(todo)
  revalidatePath("/form4");
  return {
    message: `add ${todo} success!`
  }
}
```

交互效果如下：

![actions-7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a786cb80a2ea4a4eb0e4a9060ccf7d4d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1124\&h=529\&s=247810\&e=gif\&f=65\&b=fefefe)

注：乐观更新是一种面向未来的 UI 更新方式。如何在接口错误的时候撤回数据？如果接口实在是太慢了，乐观更新的时候，用户要离开该怎么办？

关于这些更细节的实现问题，欢迎参考 [《Next.js v14 实现乐观更新，面向未来的 UI 更新方式，你可以不去做，但你不应该不了解》](https://juejin.cn/post/7347957960884355113)

## 常见问题

### 1. 如何处理 Cookies ?

```javascript
'use server'
 
import { cookies } from 'next/headers'
 
export async function exampleAction() {
  // Get cookie
  const value = cookies().get('name')?.value
 
  // Set cookie
  cookies().set('name', 'Delba')
 
  // Delete cookie
  cookies().delete('name')
}
```

### 2. 如何重定向？

```javascript
'use server'
 
import { redirect } from 'next/navigation'
import { revalidateTag } from 'next/cache'
 
export async function createPost(id) {
  try {
    // ...
  } catch (error) {
    // ...
  }
 
  revalidateTag('posts') // Update cached posts
  redirect(`/post/${id}`) // Navigate to the new post page
}
```

## 参考链接

1.  [Data Fetching: Fetching, Caching, and Revalidating](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)
2.  [Data Fetching: Data Fetching Patterns](https://nextjs.org/docs/app/building-your-application/data-fetching/patterns)
3.  [Data Fetching: Forms and Mutations](https://nextjs.org/docs/app/building-your-application/data-fetching/forms-and-mutations)
4.  [Functions: Server Actions](https://nextjs.org/docs/app/api-reference/functions/server-actions)
5.  <https://makerkit.dev/blog/tutorials/nextjs-server-actions>


## 18.样式篇 | Tailwind CSS、CSS-in-JS 与 Sass

## 前言

Next.js 支持多种方式添加样式：

1.  内联 CSS
2.  CSS 模块：创建局部 CSS 避免命名冲突，提升可维护性
3.  全局 CSS
4.  外部样式表
5.  Tailwind CSS：一个 CSS 框架，通过组合的方式声明样式
6.  CSS-in-JS：将 CSS 直接嵌入到 JavaScript 组件中，实现动态和局部样式
7.  Sass：最流行的 CSS 预处理器

让我们来一一讲解。

## 1. 内联 CSS

最基础的添加样式的方式便是使用内联 CSS，举个例子：

```javascript
// app/about/page.js
export default function About() {
  return (
    <h1 style={{
      color: red;
    }}>Hello About!</h1>
  )
}
```

## 2. CSS 模块

Next.js 内置了对 CSS 模块的支持。使用 CSS 模块，你只需要使用 `.module.css`作为文件后缀名，Next.js 就会自动进行处理。

CSS 模块的作用在于实现局部 CSS，本质是创建一个不会重复的类名。这样你就可以在不同的文件里使用相同的类名，而不用担心发生样式冲突。这是最理想的实现组件级别 CSS 的方式。

让我们举个例子：

首先，创建一个 `styles.module.css`文件，样式书写方式如同正常的 CSS 文件：

```javascript
// app/dashboard/styles.module.css
.dashboard {
  padding: 24px;
}
```

然后，CSS 模块可以被导入到 `app` 目录下的任意文件，让我们导入并使用该样式：

```javascript
// app/dashboard/layout.js
import styles from './styles.module.css'
 
export default function DashboardLayout({ children }) {
  return <section className={styles.dashboard}>{children}</section>
}
```

## 3. 全局样式

全局样式，顾名思义，应用到所有路由的样式，像我们传统写页面 CSS 的时候，都会引入 `normalize.css` 或者 `reset.css`等，这种场景就适合使用全局样式。

全局样式可以被导入 `app` 目录下的任意 layout、page 或者组件中。（为什么总是强调任意呢？因为在 `pages` 目录下，也就是之前的 Pages Router 模式，全局样式只能被导入到 `_app.js` 文件，这是一个新的改变。）

具体怎么使用呢？让我们举个例子：

首先，创建一个 `app/global.css`  样式文件：

```javascript
body {
  padding: 20px 20px 60px;
  max-width: 680px;
  margin: 0 auto;
}
```

然后，在根布局（`app/layout.js`）导入 `global.css`，该样式会被应用于应用里的每个路由：

```javascript
// app/layout.js
import './global.css'
 
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

## 4. 外部样式表

你也可以通过导入外部包的方式添加样式，举个例子：

```javascript
// app/layout.js
import 'bootstrap/dist/css/bootstrap.css'
 
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className="container">{children}</body>
    </html>
  )
}
```

不过要注意，该外部包必须是从 npm 包直接导入或者下载完和你的代码放在一起。

如果我想引用外部 CDN CSS 文件呢？就比如https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css 这种文件？

那你可以使用 `<link>` 标签添加在 Root Layout 中，就像这样：

```jsx
// app/layout.js
import "./globals.css";

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
      </head>
      <body>{ children }</body>
    </html>
  );
}
```

使用样式的时候要注意：

**即时刷新：** 在本地使用`next dev` 运行项目的时候，本地样式（无论是全局样式还是 CSS 模块），都会在你保存更改后立刻刷新，你可以即时看到样式变化。

**打包构建** ：当使用 `next build` 的时候，CSS 文件会被打包成更少的压缩 `.css` 文件，这是为了减少网络请求，从而提高加载速度，所以不用担心创建多个 css 文件而影响了性能。

**禁用 JS：** 当你禁用 JavaScript 的时候，在生产版本（`next start`），样式依然会被加载。也就是说，打包构建后的代码中的 CSS 并不是通过 JS 注入的。但是开发的时候（`next dev`），为了开启快速刷新，JavaScript 依然是有必要的。

## 5. Tailwind CSS

[Tailwind CSS](https://tailwindcss.com/) 是一个非常知名的 CSS 框架，本质是一个工具集，包含了大量比如 `flex`、`pt-4`、`text-center`、`rotate-90`等工具类，可以组合使用并直接在 HTML 代码上实现任何 UI 设计。与 Next.js 搭配使用非常顺手。Next.js 官方便是用的 Tailwind CSS。

在使用 `create-next-app`创建项目的时候，如果你在命令行中选择了使用 Tailwind CSS，则相关配置都会自动生成，可以直接使用。如果没有选择，希望引入 Tailwind CSS，可以参考此步骤。其实 Tailwind CSS 官方也提供了针对各个框架的[使用指南：](https://tailwindcss.com/docs/installation/framework-guides)

### 5.1. 安装

在项目根目录执行以下命令：

```javascript
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

会同时生成 `tailwind.config.js`和 `postcss.config.js`文件。

### 5.2. 配置 Tailwind

`postcss.config.js` 不需要修改。在 `tailwind.config.js` 中添加使用 Tailwind CSS 类名的文件路径：

```javascript
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
 
    // 嫌麻烦，你也可以直接使用 `src` 目录
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
```

### 5.3. 导入样式

添加 Tailwind CSS 指令，将 Tailwind 的样式注入到全局样式中。使用方式如下：

```javascript
// app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

在根布局（`app/layout.tsx`），导入 `globals.css` ：

```javascript
// app/layout.js 
import './globals.css'
 
export const metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}
 
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

### 5.4. 使用类名

然后你就可以在应用里使用 Tailwind 的工具类名：

```javascript
// app/page.js
export default function Page() {
  return <h1 className="text-3xl font-bold underline">Hello, Next.js!</h1>
}
```

### 5.5. 辅助使用

在 VSCode 中使用的时候，可以安装 [Tailwind CSS IntelliSense ](https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss)这个插件，提供自动功能、语法校验、悬停预览等功能。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad65001bb64441018aa46bc84fe6c6bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2080\&h=1170\&s=249225\&e=png\&b=1a1b26)

Tailwind CSS 中的工具类众多，记不清的时候也可以查询这个[速查表](https://tailwindcomponents.com/cheatsheet/)。

## 6. CSS-in-JS

### 6.1. 介绍

CSS-in-JS，顾名思义，将 CSS 写在 JS 文件里，而不是单独新建如 `.css`、`.scss`等文件。这样就可以在 CSS 中使用 JS 的变量定义、函数调用、条件判断等功能。

之所以能够流行，也跟 React、Vue 等框架的流行有关，“组件”的概念开始深入人心。因为 Vue 本身有自己的 CSS 方案，React 没有，所以 CSS-in-JS 也多在 React 社区中讨论。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a97658e259b4859859e32caa0c15c70~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1762\&h=1560\&s=483187\&e=png\&b=252325)

实现 CSS-in-JS 的库有很多，每个库的实现、使用方式、语法也不尽相同。目前 Next.js 客户端组件中支持使用的库有：

*   [kuma-ui](https://kuma-ui.com/)
*   [@mui/material](https://mui.com/material-ui/guides/next-js-app-router/)
*   [pandacss](https://panda-css.com/)
*   [styled-jsx](https://nextjs.org/docs/app/building-your-application/styling/css-in-js#styled-jsx)
*   [styled-components](https://nextjs.org/docs/app/building-your-application/styling/css-in-js#styled-components)
*   [style9](https://github.com/johanholmerin/style9)
*   [tamagui](https://tamagui.dev/docs/guides/next-js#server-components)
*   [tss-react](https://tss-react.dev/)
*   [vanilla-extract](https://github.com/vercel/next.js/tree/canary/examples/with-vanilla-extract)

[emotion](https://github.com/emotion-js/emotion/issues/2928) 正在支持中……

如果你希望设置服务端组件的样式，推荐使用 CSS 模块或者其他输出 CSS 文件的解决方案比如 PostCSS 或者 Tailwind CSS。

### 6.2. 配置方式

在 Next.js 中配置 CSS-in-JS 的基本原理分为三步：

1.  在渲染的时候有一个包含所有 CSS 规则的样式注册表
2.  使用 `useServerInsertedHTML`hook 在内容被使用前注入样式规则
3.  使用包含样式注册表的客户端组件包裹应用

### 6.3. styled-jsx

这三步听起来有些复杂，让我们以 `styled-jsx` 为例进行讲解。注意在客户端组件使用 `styled-jsx`至少需要使用 `v5.1.0`版本。

首先创建一个新的注册表：

```javascript
'use client'
// app/registry.js
import React, { useState } from 'react'
import { useServerInsertedHTML } from 'next/navigation'
import { StyleRegistry, createStyleRegistry } from 'styled-jsx'
 
export default function StyledJsxRegistry({ children }) {
  const [jsxStyleRegistry] = useState(() => createStyleRegistry())
 
  useServerInsertedHTML(() => {
    const styles = jsxStyleRegistry.styles()
    jsxStyleRegistry.flush()
    return <>{styles}</>
  })
 
  return <StyleRegistry registry={jsxStyleRegistry}>{children}</StyleRegistry>
}
```

然后用此包含注册表的组件包裹根组件的 `children`：

```javascript
// app/layout.js
import StyledJsxRegistry from './registry'
 
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <StyledJsxRegistry>{children}</StyledJsxRegistry>
      </body>
    </html>
  )
}
```

然后你就可以在 `page.js` 中使用：

```jsx
export default function Page() {
  return (
    <div>
      <div className="container">text
      </div>

      <style jsx>{`
        .container {
          display: grid;
          grid-template-columns: repeat(1, minmax(0, 1fr));
          gap: 1.5rem /* 24px */;
        }

        @media (min-width: 1024px) {
          .container {
            grid-template-columns: repeat(3, minmax(0, 1fr));
          }
        }
      `}</style>
    </div>
  );
}
```

示例代码地址：<https://github.com/vercel/app-playground/tree/main/app/styling/styled-jsx>

### 6.4. Styled Components

Styled Components 的配置也大致如此，注意使用 `styled-components@6` 或者更高版本。

首先，创建一个全局注册表：

```javascript
'use client'
// lib/registry.js
import React, { useState } from 'react'
import { useServerInsertedHTML } from 'next/navigation'
import { ServerStyleSheet, StyleSheetManager } from 'styled-components'
 
export default function StyledComponentsRegistry({ children }) {
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet())
 
  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement()
    styledComponentsStyleSheet.instance.clearTag()
    return <>{styles}</>
  })
 
  if (typeof window !== 'undefined') return <>{children}</>
 
  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  )
}
```

然后用此包含注册表的组件包裹根组件的 `children`：

```javascript
// app/layout.js
import StyledComponentsRegistry from './lib/registry'
 
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <StyledComponentsRegistry>{children}</StyledComponentsRegistry>
      </body>
    </html>
  )
}
```

然后你就可以在 page.js 中使用：

```javascript
'use client';

import styled from 'styled-components';

const Container = styled.div`
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 1.5rem /* 24px */;
`;

const SkeletonInner = styled.div`
  padding: 1rem /* 16px */;
  background-color: rgb(24 24 27 / 0.8);
  border-radius: 1rem /* 16px */;
`;

const SkeletonImg = styled.div`
  height: 3.5rem /* 56px */;
  border-radius: 0.5rem /* 8px */;
  background-color: rgb(63 63 70 / 1);
`;

const SkeletonBtn = styled.div`
  margin-top: 0.75rem /* 12px */;
  width: 25%;
  height: 0.75rem /* 12px */;
  border-radius: 0.5rem /* 8px */;
  background-color: rgb(255 0 128 / 1);
`;

const Skeleton = () => (
  <SkeletonInner>
    <SkeletonImg />
    <SkeletonBtn />
  </SkeletonInner>
);

export default function Page() {
  return (
    <div className="space-y-4">
      <h1 className="text-xl font-medium text-gray-400/80">
        Styled with Styled Components
      </h1>
      <Container>
        <Skeleton />
        <Skeleton />
        <Skeleton />
      </Container>
    </div>
  );
}
```

示例代码地址：<https://github.com/vercel/app-playground/tree/main/app/styling/styled-components>

## 7. Sass

### 7.1. Sass 使用

Sass 作为知名的 CSS 预处理器已无须过多介绍。Next.js 内置了对 Sass 文件的支持，你需要使用 `.scss`和 `.sass`作为文件后缀。

你也可以结合 CSS 模块使用组件级别的 Sass， 你需要使用`.module.scss`或者 `.module.sass`作为文件后缀。

使用 sass，你需要首先安装 [sass](https://github.com/sass/sass)：

```javascript
npm install --save-dev sass
```

### 7.2. 自定义配置

如果你希望配置 Sass 编译器，使用 `next.config.js` 的 `sassOptions`选项：

```javascript
// next.config.js
const path = require('path')
 
module.exports = {
  sassOptions: {
    includePaths: [path.join(__dirname, 'styles')],
  },
}
```

### 7.3 Sass 变量

Next.js 支持从 CSS 模块文件导出 Sass 变量。这是一个示例代码：

```javascript
// app/variables.module.scss
$primary-color: #64ff00;
 
:export {
  primaryColor: $primary-color;
}
```

```javascript
// app/page.js
// maps to root `/` URL
 
import variables from './variables.module.scss'
 
export default function Page() {
  return <h1 style={{ color: variables.primaryColor }}>Hello, Next.js!</h1>
}
```

## 参考链接

1.  [Styling: CSS Modules](https://nextjs.org/docs/app/building-your-application/styling/css-modules)
2.  [Styling: Tailwind CSS](https://nextjs.org/docs/app/building-your-application/styling/tailwind-css)
3.  [Styling: CSS-in-JS](https://nextjs.org/docs/app/building-your-application/styling/css-in-js)
4.  [Styling: Sass](https://nextjs.org/docs/app/building-your-application/styling/sass)
5.  [State of CSS 2023: CSS-in-JS](https://2023.stateofcss.com/zh-Hans/css-in-js/)


## 19.配置篇 | 环境变量、路径别名与 src 目录

## 前言

本篇介绍**环境变量**、**路径别名**、**src 目录**三大块内容，主要是介绍环境变量的使用。Next.js 提供了更为强大便捷的环境变量使用方式，让我们来看看吧。

## 1. 环境变量

### 1.1 概念介绍

所谓环境变量（environment variables），引用[百度百科的解释](https://baike.baidu.com/item/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1730949)：

> 环境变量一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。
>
> 环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用程序所将使用到的信息。例如 Windows 和 DOS 操作系统中的 path 环境变量，当要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下面寻找此程序外，还应到 path 中指定的路径去找。用户通过设置环境变量，来更好的运行进程。

简单的来说，如果我们把操作系统想象成一门语言，就比如 JavaScript，各种程序对应的就是声明的各种函数，而环境变量对应的就是 JavaScript 中的全局变量。各个函数（各个程序）都可以使用这些变量。

#### 相关命令

我们常见的 `PATH` 只是其中一个环境变量。以 MacOS 系统为例的话（以下命令都是在 MacOS，Windows 中会有差别），我们可以在命令行中输入 `printenv` 查看所有环境变量：

```bash
printenv
```

输出结果如下：

![还有很多，就不一一描述了](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc1710b7fbfd4cfe89e208529c99d649~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=782\&h=250\&s=43040\&e=png\&b=0a0a0a "还有很多，就不一一描述了")

可以看出，环境变量的命名一般是全部大写。

如果要查看某个特定环境变量，可以使用 `printenv`，也可以使用 `echo`：

```bash
// 方式 1
printenv PATH

// 方式 2
echo $PATH
```

如果你要添加或者修改某个环境变量，可以使用 `export`命令：

```bash
// 1. 设置
export YAYUCUSTOM=yayu
// 2. 打印
echo $YAYUCUSTOM
```

不过使用这种方式，效果是临时的，只会在本次登录生效，关掉命令行再重启就失效了，不过有的时候，这也够了。比如我们在 `package.json` 中看到这样的配置：

```javascript
"scripts": {
    "dev": "export NODE_ENV=development && node index.js",
    "prod": "export NODE_ENV=production && node index.js"
}
```

`index.js`中就可以通过 `process.env.NODE_ENV` 获取到设置的 `NODE_ENV` 的值：

```javascript
// 打印的结果根据设置的值不同而不同
console.log(process.env.NODE_ENV)
```

那如何长久的修改某个环境变量呢？这个就稍微有点复杂了，有很多文件都可以修改环境变量，根据系统以及系统版本的不同会有所不同。以 mac 的 bash 为例的话，文件的顺序为：

```javascript
/etc/profile
/etc/paths 
/etc/paths.d/
~/.bash_profile 
~/.bash_login
~/.profile
~/.bashrc
```

其中，以 `/etc`开头的目录是系统级别的环境变量定义，其他则是用户级别的环境变量定义。一般来说，使用 `bash` 建议修改 `~/.bash_profile`，使用 `zsh` 建议修改 `~/.zshrc`。

Mac 使用 `zsh` 或 `bash` 作为登录 Shell 和交互式 Shell 的命令行解释器。从 macOS Catalina 开始，Mac 使用 `zsh` 作为默认登录 Shell 和交互式 Shell。`bash` 是 macOS Mojave 及更早版本中的默认 Shell。

使用 `bash`：

```bash
// 1. 修改文件
vim ~/.bash_profile
// 2. 添加内容
export YAYU_CUSOTM=yayu
// 3. 使用 wq 命令退出保存后执行使其生效
source  ~/.bash_profile
// 4. 查看生效
echo $YAYU_CUSOTM
```

使用 `zsh`：

```bash
// 1. 修改文件
vim  ~/.zshrc
// 2. 添加内容
export YAYU_CUSOTM=yayu
// 3. 使用 :wq 命令退出保存后执行使其生效
source  ~/.zshrc
// 4. 查看生效
echo $YAYU_CUSOTM
```

如果你遇到设置完后，当时有效，重启终端后就会失效，可能是你使用的 shell 有问题，查看当前使用的 Shell：

```bash
echo $SHELL
```

切换成 `zsh` 或 `bash` （执行命令后重启终端）：

```bash
// 切换成 zsh
chsh -s /bin/zsh
// 切换成 bash
chsh -s /bin/bash
```

#### process.env

Nodejs 提供了 `process.env` API 返回包含用户环境的对象，简单的来说，这是 Nodejs 提供的在 node 中获取环境变量的方法。此对象示例如下所示：

```javascript
{
  TERM: 'xterm-256color',
  SHELL: '/usr/local/bin/bash',
  USER: 'maciej',
  PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
  PWD: '/Users/maciej',
  EDITOR: 'vim',
  SHLVL: '1',
  HOME: '/Users/maciej',
  LOGNAME: 'maciej',
  _: '/usr/local/bin/node'
}
```

### 1.2 Next.js 实现

在 Next.js 中添加环境变量会更加方便，因为 Next.js 内置了对环境变量的支持，使用环境变量有两种方式：

1.  通过 `.env.local` 加载环境变量
2.  通过 `NEXT_PUBLIC_`前缀在浏览器中获取环境变量

#### .env.local 加载环境变量

Next.js 支持从 `.env.local`中加载环境变量到 `process.env`。现在我们在项目根目录下建立一个 `.env.local`文件（注意是根目录，不是 `/src`目录）

```javascript
DB_HOST=localhost
DB_USER=myuser
DB_PASS=mypassword
```

现在我们就可以服务端组件或者路由处理程序中通过 `process.env`获取到该值：

```javascript
// app/page.js
export default function Page() {
  console.log(process.env.DB_HOST)
  return <h1>Hello World!</h1>
}
```

```javascript
// app/api/route.js
export async function GET() {
  const db = await myDB.connect({
    host: process.env.DB_HOST,
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
  })
  // ...
}
```

使用起来就是这么方便。Next.js 也支持多行变量，示例代码如下：

```javascript
# .env.local
 
# 直接换行
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----
...
Kh9NV...
...
-----END DSA PRIVATE KEY-----"
 
# 也可以使用 `\n`
PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\nKh9NV...\n-----END DSA PRIVATE KEY-----\n"
```

Nxt.js 也支持使用 `$`引用其他变量，举个例子：

```javascript
TWITTER_USER=nextjs
TWITTER_URL=https://twitter.com/$TWITTER_USER
```

在这个例子中，`process.env.TWITTER_URL` 的值为 `https://twitter.com/nextjs`。

如果你本来就要用带 `$`的值，使用 `\$`这种方式进行转义即可。

#### 浏览器中获取环境变量

前面我们讲到，`process.env` 是 Nodejs 提供的用于获取用户环境变量对象的 API。也就是说，正常在 `.env.local` 中设置的变量，是无法在浏览器端获取的。

为了让浏览器也可以获取环境变量中的值，Next.js 可以在构建的时候，将值内联到客户端的 js bundle 中，替换掉所有硬编码使用 `process.env.[variable]`的地方。不过为了告诉 Next.js 哪些值是可以让浏览器访问的，你需要在变量前添加 `NEXT_PUBLIC_`前缀，比如：

```bash
NEXT_PUBLIC_ANALYTICS_ID=abcdefghijk
```

现在我们再通过 `process.env.NEXT_PUBLIC_ANALYTICS_ID` 获取：

```javascript
'use client';
// app/page.js
export default function Page() {
  return <h1 onClick={() => {
    console.log(process.env.NEXT_PUBLIC_ANALYTICS_ID)
  }}>Hello World!</h1>
}
```

如果没有 `NEXT_PUBLIC_`前缀，正常点击的时候获取的值会是 `undefined` ，添加 `NEXT_PUBLIC_`前缀后即可获取到正确的值。不过你要记得这里的原理，其实是在构建的时候，将所有 `NEXT_PUBLIC_`前缀的值做了替换，也就是在代码中，点击事件的代码就已经变成了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3754960b8c1b4627b52b863003af5d47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=640\&h=252\&s=38114\&e=png\&b=282828)

此外要注意，动态查找的值不会被内联，比如：

```javascript
// 使用了变量，不会被内联，不会生效
const varName = 'NEXT_PUBLIC_ANALYTICS_ID'
setupAnalyticsService(process.env[varName])
 
// 使用了变量，不会被内联，不会生效
const env = process.env
setupAnalyticsService(env.NEXT_PUBLIC_ANALYTICS_ID)
```

#### 默认环境变量

通常一个 `.env.local`文件就够用了，但有的时候，你也许会希望在 `development`（`next dev`）或 `production`（`next start`）环境中添加一些默认值。

Next.js 支持在 `.env`（所有环境）、`.env.development`（开发环境）、`.env.production`（生产环境）中设置默认的值。

`.env.local`会覆盖这些默认值。

注意：`.env`、`.env.development`、`.env.production` 用来设置默认的值，所有这些文件可以放到仓库中，但 `.env*.local`应该添加到 `.gitignore`，因为可能涉及到一些机密的信息。

此外，如果环境变量 NODE\_ENV 未设置，当执行 `next dev`的时候，Next.js 会自动给 `NODE_DEV`赋值 `development`，其他命令则会赋值 `production`。也就是说，当执行 `next dev`或者其他命令的时候，获取`process.env.NODE_ENV`是有值的，这是 Next.js 自动赋值的，为了帮助开发者区分开发环境。

#### 测试环境变量

除了 `development`环境和 `production`环境，还有第三个选项，那就是 `test`环境。这是当使用测试工具如 `jest`或 `cypress`时，出于测试目的而设置特定的环境变量。

用法跟开发环境、生产环境类似，建立一个 `.env.test`文件用于测试环境，但是跟开发环境、生产环境不同的是，测试环境不会加载 `.env.local`中的值，这是为了让每个人都产生相同的测试结果。这些默认值会在 `NODE_DEV`设置成 `test`的时候用到。

#### 环境变量加载顺序

环境变量的查找也是有顺序的，一旦找到，就会终止查找，不会再往下查找，这个顺序是：

1.  `process.env`
2.  `.env.$(NODE_ENV).local`
3.  `.env.local` (当 `NODE_ENV` 是 `test` 的时候不会查找)
4.  `.env.$(NODE_ENV)`
5.  `.env`

举个例子，如果你在 `.env.development.local` 和 `.env`中设置了 `NODE_ENV` 为 `development`，按照这个顺序，最终会使用 `.env.development.local`中的值。

## 2. 绝对地址导入和模块路径别名

Next.js 的 `tsconfig.json`和`jsconfig.json`文件支持设置 `"paths"`和 `"baseUrl"`选项。

这些配置会帮助你更方便的导入模块，举个例子：

```javascript
// before
import { Button } from '../../../components/button'
 
// after
import { Button } from '@/components/button'
```

### 2.1. 绝对地址导入

`baseUrl`配置项可以让你从项目根目录中直接导入。使用示例如下：

```javascript
// tsconfig.json or jsconfig.json
{
  "compilerOptions": {
    "baseUrl": "."
  }
}
```

我们声明 `baseUrl`为 `"."`，也就是项目根目录。现在我们在根目录下的 `components`文件夹下新建一个组件：

```javascript
// components/button.js
export default function Button() {
  return <button>Click me</button>
}
```

现在我们导入该组件，不需要再使用相对地址，当嵌套多层引入组件时候就会很方便：

```javascript
// app/page.js
import Button from '/components/button'
 
export default function HomePage() {
  return (
    <>
      <h1>Hello World</h1>
      <Button />
    </>
  )
}
```

### 2.2. 模块别名

除了配置 `baseUrl` 路径之外，你也可以设置 `"paths"` 选项实现路径别名。举个例子：

```javascript
// tsconfig.json or jsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/components/*": ["components/*"]
    }
  }
}
```

在这个例子中，我们设置了一个路径映射，`@/components/*` 到 `"components/*`。

```javascript
// components/button.js
export default function Button() {
  return <button>Click me</button>
}
```

现在我们不需要使用相对地址，使用设置的路径别名即可：

```javascript
// app/page.js
import Button from '@/components/button'
 
export default function HomePage() {
  return (
    <>
      <h1>Hello World</h1>
      <Button />
    </>
  )
}
```

那 `baseUrl`和 `paths:`是什么关系呢？事实上，`paths` 中的地址是相对于 `baseUrl` 的，举个例子：

```javascript
// tsconfig.json or jsconfig.json
{
  "compilerOptions": {
    "baseUrl": "src/",
    "paths": {
      "@/styles/*": ["styles/*"],
      "@/components/*": ["components/*"]
    }
  }
}
```

```javascript
// pages/index.js
import Button from '@/components/button'
import '@/styles/styles.css'
import Helper from 'utils/helper'
 
export default function HomePage() {
  return (
    <Helper>
      <h1>Hello World</h1>
      <Button />
    </Helper>
  )
}
```

`@/components/button`最终的地址其实是 `src/components/button`，其他地址同理。

## 3. src 目录

至今我们都是把代码放在根目录下的`app` 或 `pages` 目录下，但 Next.js 也支持 `src` 目录，将代码放在  `src` 目录下有助于实现应用程序代码和项目配置文件（多在项目根目录）分离。

使用 `src` 目录，将 `app` 下或者 `pages` 下的文件移动到 `src/app` 或 `src/pages` 即可：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ec8ac3a6b964518bf7a4919305f9b38~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=687\&s=330812\&e=png\&b=161616)

调整的时候注意：

*   `/public`目录继续放在项目根目录
*   `package.json`、`next.config.js`、`tsconfig.json` 等配置文件继续放在项目根目录
*   `.env.*` 文件继续放在项目根目录
*   如果 `app` 或者 `pages` 在根目录下存在，`src/app` 或 `src/pages` 会被忽略。
*   如果你正在使用 `src`，你可能还需要移动其他应用文件夹，如 `/components` 或 `/lib`
*   如果你正在使用中间件，确保它放在 `src` 目录下
*   如果你正在使用 Tailwind CSS，别忘了修改 `tailwind.config.js` 中的 `content` 配置项：

```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/**/*.{html,js}',
  ],
  // ...
}
```

## 参考链接

1.  [在 Mac 上将 zsh 用作默认 Shell](https://support.apple.com/zh-cn/HT208050)
2.  [Configuring: Environment Variables](https://nextjs.org/docs/app/building-your-application/configuring/environment-variables)
3.  [Configuring: Absolute Imports and Module Path Aliases](https://nextjs.org/docs/app/building-your-application/configuring/absolute-imports-and-module-aliases)


## 2.初始篇 | Next.js CLI

## 前言

欢迎学习 Next.js！在学习具体的知识点之前，我们先来创建一个 Next.js 项目。创建了可运行的项目，才能在学习的时候边调试边理解，从而达到事半功倍的效果。

幸运的是，Next.js 提供了开箱即用的 `create-next-app`脚手架，内置支持 TypeScript、ESLint 等功能，零配置即可实现自动编译和打包。

本篇我们会讲解创建项目的两种方式：自动创建项目和手动创建项目，以及开发项目时常用的脚本命令。同时我们会对脚本背后的 `next` 命令进行详解，帮助大家了解每个命令实现的功能和可选参数。

## 1. 自动创建项目

### 1.1. 环境要求

此本小册基于的是目前最新版本的 v14 版本，需要 [Node.js 18.17](https://nodejs.org/en) 及以后版本，支持 macOS、Windows、Linux 系统。

### 1.2. 创建项目

最快捷的创建 Next.js 项目的方式是使用 `create-next-app`脚手架，你只需要运行：

```bash
npx create-next-app@latest
```

接下来会有一系列的操作提示，比如设置项目名称、是否使用 TypeScript、是否开启 ESLint、是否使用 Tailwind CSS 等，根据自己的实际情况进行选择即可。如果刚开始你不知道如何选择，遵循默认选择即可，这些选择的作用我们会随着小册的学习逐渐了解。

注：为了减少学习成本，此本小册的示例代码就不使用 TypeScript 了。（想学习 TypeScript 的同学可以看我翻译的最新的[ TypeScript 官方文档](https://juejin.cn/column/7029490086710345742)）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec2fc0641cf1438cafdf1197b2f58771~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1098\&h=320\&s=611781\&e=png\&b=03090e)

完成选择之后，`create-next-app` 会自动创建项目文件并安装依赖，创建安装完的项目目录和文件如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76e218812d164d8a98212ac18342c56c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1228\&h=592\&s=117964\&e=png\&b=1d1e20)

如果你不使用 `npx`，也支持使用 `yarn`、`pnpm`、`bunx`：

```javascript
yarn create next-app
```

```javascript
pnpm create next-app
```

```javascript
bunx create-next-app
```

### 1.3. 运行项目

查看项目根目录 `package.json` 文件的代码：

```javascript
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
```

我们可以看到脚本命令有 `dev`、`build`、`start`、`lint`，分别对应开发、构建、运行、代码检查。

开发的时候使用  `npm run dev`。部署的时候先使用 `npm run build` 构建生产代码，再执行 `npm run start` 运行生产项目。运行 `npm run lint` 则会执行 ESLint 语法检查。

现在我们执行 `npm run dev` 运行项目吧！

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02fe813e102e4adf98f1c3e30b3d7e82~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=700\&h=410\&s=379156\&e=png\&b=02060a)

命令行会提示运行在 `3000` 端口，我们在浏览器打开页面 [http://localhost:3000/](http://localhost:3000/)，看到如下内容即表示项目成功运行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e8626c484a0463ab08325e411647e56~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3038\&h=2558\&s=516125\&e=png\&b=000000)

**注：学习的时候为了避免浏览器插件带来的影响，建议在无痕模式下测试。**

### 1.4. 示例代码

Next.js 提供了丰富的示例代码，比如 `with-redux`、`api-routes-cors`、`with-electron`、`with-jest`、`with-markdown`、`with-material-ui`、`with-mobx`，从这些名字中也可以看出，这些示例代码演示了 Next.js 的各种使用场景，比如 `with-redux`就演示了 Next.js 如何与 redux 搭配使用。

你可以访问 <https://github.com/vercel/next.js/tree/canary/examples> 查看有哪些示例代码。如果你想直接使用某个示例代码，就比如 `with-redux`，无须手动 clone 代码，在创建项目的时候使用 `--example` 参数即可直接创建：

```bash
npx create-next-app --example with-redux your-app-name
```

注：使用示例代码的时候，并不会像执行 `npx create-next-app`时提示是否使用 TypeScript、ESLint 等，而是会直接进入项目创建和依赖安装阶段。

## 2. 手动创建项目

大部分时候我们并不需要手动创建 Next.js 项目，但了解这个过程有助于我们认识到一个最基础的 Next.js 项目依赖哪些东西。

### 2.1. 创建文件夹并安装依赖

现在，创建一个文件夹，假设名为 `next-app-manual`，`cd` 进入该目录，安装依赖：

```bash
npm install next@latest react@latest react-dom@latest
```

npm 会自动创建 `package.json` 并安装依赖项。

### 2.2. 添加 scripts

打开 `package.json`，添加以下内容：

```javascript
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  }
}
```

### 2.3. 创建目录

在 `next-app-manual`下新建 `app` 文件夹，`app` 下新建 `layout.js` 和 `page.js`文件，代码如下：

```javascript
// app/layout.js
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
```

```javascript
// app/page.js
export default function Page() {
  return <h1>Hello, Next.js!</h1>
}
```

### 2.4. 运行项目

现在运行 `npm run dev`，正常渲染则表示运行成功：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f15914cd6c544635ab145cc001d06345~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1564\&h=268\&s=35009\&e=png\&b=ffffff)

## 3. Next.js CLI

通过 `package.json` 中的代码我们知道：当我们运行 `npm run dev` 的时候，其实执行的是 `next dev`。`next` 命令就是来自于 Next.js CLI。Next.js CLI 可以帮助你启动、构建和导出项目。

完整的 CLI 命令，你可以执行 `npx next -h` 查看（`-h` 是 `--help` 的简写）。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cf4b85fa2194c9ea26bb20e9d29008c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1328\&h=626\&s=1246629\&e=png\&b=03080d)

从上图可以看到，`next` 可以执行的命令有多个，我们介绍下最常用的一些。

注：因为我们是使用 `npx`创建的项目，这种方式下避免了全局安装 `create-next-app`，所以我们本地全局并无 `next` 命令。如果你要执行 `next` 命令，可以在 `next`前加一个 `npx`，就比如这次用到的 `npx next -h`

### 3.1. next build

执行 `next build` 将会创建项目的生产优化版本：

```bash
npx next build
```

构建输出如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4f2e351301d45699599287c0c86f779~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1016\&h=760\&s=1040533\&e=png\&b=02070b)

从上图可以看出，构建时会输出每条路由的信息，比如 Size 和 First Load JS。注意这些值指的都是 gzip 压缩后的大小。其中 First Load JS 会用绿色、黄色、红色表示，绿色表示高性能，黄色或红色表示需要优化。

这里要解释一下 Size 和 First Load JS 的含义。正常我们开发的 Next.js 项目，其页面表现类似于单页应用，即路由跳转（我们称之为“导航”）的时候，页面不会刷新，而会加载目标路由所需的资源然后展示，所以：

```md
加载目标路由一共所需的 JS 大小 = 每个路由都需要依赖的 JS 大小 + 目标路由单独依赖的 JS 大小
```

其中：
* 加载目标路由一共所需的 JS 大小就是 `First Load JS`
* 目标路由单独依赖的 JS 大小就是 `Size`
* 每个路由都需要依赖的 JS 大小就是图中单独列出来的 `First load JS shared by all`

也就是说：

```md
First Load JS = Size + First load JS shared by all
```

以上图中的 `/` 路由地址为例，89 kB（First Load JS）= 5.16 kB（Size） + 83.9 kB（First load JS shared by all）

使用官方文档中的介绍就是：

*   `Size`：导航到该路由时下载的资源大小，每个路由的大小只包括它自己的依赖项
*   `First Load JS`：加载该页面时下载的资源大小
*   `First load JS shared by all`：所有路由共享的 JS 大小会被单独列出来

现在我们访问生产版本的 [http://localhost:3000/](http://localhost:3000/)：

![截屏2023-12-04 下午3.38.18.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b4152d5a7a84af3be6d5d248fd2528f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2524\&h=1004\&s=469048\&e=png\&b=242424)

上图中红色框住的 JS 是每个页面都要加载的 JS，根据命令行中的输出，总共大小为 `83.9` kB，`413-dd2d1e77cac135ea.js` 和 `page-9a9638f75b922b0c.js` 是这个页面单独的 JS，总共大小为 `5.16` kB，所有JS 资源大小为 `89 kB`。（注：跟图中的数字没有完全一致是因为没有开启 gzip 压缩）

#### next build --profile

该命令参数用于开启 React 的生产性能分析（需要 Next.js v9.5 以上）。

```bash
npx next build --profile
```

然后你就可以像在开发环境中使用 React 的 `profiler` 功能。

> 注：这里我们执行的命令是 `npx next build --profile`，而不是 `npm run build --profile`。实际上有三种方式可以开启：
> 1. 运行 `npx next build --profile`
> 2. 先修改 `package.json` 中的 `build` 脚本命令为：
> ```json
> {
>  "scripts": {
>     "build": "next build --profile"
>   }
> }
> ```
> 然后再运行 `npm run build`
> 
> 3. 运行 `npm run build -- --profile`，将 `--profile` 添加到 `--` 分隔符后，会将 `--profile` 作为参数传递给实际执行的命令，最终的命令还是 `next build --profile`
> 
> 下节的 `--debug` 参数使用也是同理

如果你想测验这个功能，首先你的[浏览器要装有 React 插件](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)，然后你要对 React 的 [Profiler API](https://legacy.reactjs.org/docs/profiler.html) 有一定了解（其实就是测量组件渲染性能）。比如现在我们把 `page.js` 的代码改为：

```jsx
// app/page.js
import React from 'react'

export default function Page() {
  return (
    <React.Profiler id="hello">
      <p>hello app server</p>
    </React.Profiler>
  )
}
```

执行 `npm run dev`，你在控制台里可以看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25804df079cd4dd6ab34370bebdecfd5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2268\&h=726\&s=150520\&e=png\&b=292c32)

通常执行 `npm run build` 和 `npm run start`后，你再打开控制台，会发现在生产环境中不支持性能测量：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ed96ece5ba946e0a1f80894f29c10be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1984\&h=754\&s=133752\&e=png\&b=292b31)

但如果你执行 `npx next build --profile` 再执行 `npm run start`，尽管 React 插件会显示当前在生产环境，但 Profiler 是可以使用的：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c55d230e2aa147da831e019724815d93~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1694\&h=258\&s=64096\&e=png\&b=010101)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6de7b36eb2c4a85bd22eae7deb10aff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2290\&h=1006\&s=150923\&e=png\&b=292b31)

**这个功能可以帮助大家排查线上的性能问题。**

#### next build --debug

该命令参数用于开启更详细的构建输出：

```bash
npx next build --debug
```

开启后，将输出额外的构建输出信息如 `rewrites`、`redirects`、`headers`。

举个例子，我们修改下 `next.config.js`文件：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  async redirects() {
    return [
      {
        source: '/index',
        destination: '/',
        permanent: true,
      },
    ]
  },
  async rewrites() {
    return [
      {
        source: '/about',
        destination: '/',
      },
    ]
  }
}

module.exports = nextConfig

```

再执行 `npx next build --debug`，输出结果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44e90f70c6654a3b9a8d0016a9fd1ea0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1106\&h=1512\&s=2430158\&e=png\&b=03070c)

你可以看到相比之前的构建输出信息，多了 `rewrites`、`redirects` 等信息。关于 rewrites、redirects 的具体用法，我们会在后续的内容中介绍。

### 3.2. next dev

开发模式下，使用 `next dev` 运行程序，会自动具有热加载、错误报告等功能。默认情况下，程序将在 `http://localhost:3000` 开启。如果你想更改端口号：

```bash
npx next dev -p 4000
```

如果你想更改主机名（hostname）：（以便其他主机访问）

```bash
npx next dev -H 192.168.1.2
```

### 3.3. next start

生产模式下，使用 `next start`运行程序。不过要先执行 `next build`构建出生产代码。运行的时候，跟开发模式相同，程序默认开启在 `http://localhost:3000`。如果你想更改端口号：

```bash
npx next start -p 4000
```

### 3.4. next lint

执行 `next lint`会为 `pages/`、`app/`、`components/`、`lib/`、`src/`目录下的所有文件执行 ESLint 语法检查。如果你没有安装 ESLint，该命令会提供一个安装指导。如果你想要指定检查的目录：

```bash
npx next lint --dir utils
```

### 3.5. next info

`next info`会打印当前系统相关的信息，可用于报告 Next.js 程序的 bug。在项目的根目录中执行：

```bash
npx next info
```

打印信息类似于：

```bash
Operating System:
  Platform: linux
  Arch: x64
  Version: #22-Ubuntu SMP Fri Nov 5 13:21:36 UTC 2021
Binaries:
  Node: 16.13.0
  npm: 8.1.0
  Yarn: 1.22.17
  pnpm: 6.24.2
Relevant packages:
  next: 12.0.8
  react: 17.0.2
  react-dom: 17.0.2
```

这些信息可以贴到 GitHub Issues 中方便 Next.js 官方人员排查问题。

## 小结

恭喜你，完成本篇内容的学习！

这一节我们讲解了**自动创建项目**和**手动创建项目**两种创建项目的方式，如果是全新的项目，推荐使用自动创建方式。如果是项目中引入 Next.js，可以参考手动创建项目的方式。

Next.js 项目常用的脚本有三个：
1. `npm run dev`用于开发时使用
2. `npm run build`用于构建生产版本
3. `npm run start`用于运行生产版本

从 `package.json`中，我们得知这些脚本背后用的其实是 Next.js CLI 的 `next` 命令，然后我们对常用的 `next` 命令和相关参数进行了介绍。在必要的时候，可以使用这些命令和参数自定义 npm 脚本。

靡不有初，鲜克有终。恭喜你迈出第一步！接下来我们将进入路由篇，带大家了解 Next.js v13 带来颠覆式更新的的 App Route 功能。在学习的过程中，如果遇到有疑问的地方，一定要多写 demo 测试哦！


## 参考链接

1.  [Getting Started: Installation](https://nextjs.org/docs/getting-started/installation)
2.  [API Reference: create-next-app](https://nextjs.org/docs/app/api-reference/create-next-app)
3.  [API Reference: Next.js CLI](https://nextjs.org/docs/pages/api-reference/next-cli#next-info)
4.  [npm-run-script](https://docs.npmjs.com/cli/v10/commands/npm-run-script)


## 20.配置篇 | 路由段配置项

## 前言

之前的文章中已经多次提到了路由段配置项，路由段配置选项可以配置页面、布局、路由处理程序的行为，本篇我们会详细介绍其中的配置内容。

## 1. 段（Segment）

如果大家翻阅 Next.js 的官方文档（英文），会经常发现 Segment 这个单词，其释义为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1795b49110b1459081bb3672aeb4bd31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=992\&h=848\&s=193982\&e=png\&b=1c1e20)

为了简单起见，我翻译成“段”。Segment 放到 URL 这个场景时：

**URL Segment** 指的是由斜杠分隔的 URL Path 的一部分
**URL Path** 指的则是域名后面的 URL 部分（URL Path 由 URL Segment 组成）

用这张图表示更清晰一些：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b20bb421ef334b9699bc7773c6f67fa7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=371\&s=223859\&e=png\&b=131313)

Segment 放到 Route 这个场景时：

**Router Segment**，我翻译为“路由段”，路由中的每个文件夹都代表一个路由段。每个路由段都映射一个对应的 URL Segment：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83ecaf2828ef4e668a4146812ff7c9f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=594\&s=339521\&e=png\&b=141414)

在这张图中，`/dashboard/settings`由三段组成：

*   `/`：根段（Root Segment）
*   `dashboard`：段（Segment）
*   `settings`：叶段（Leaf Segment）

PS：叶段指的是没有子节点的段。

## 2. 路由段配置（Route Segment Config）

接下来我们来到本章的正题——路由段配置。

路由段配置选项可以配置页面、布局、路由处理程序的行为。比如我们使用 fetch 的时候可以单独配置某个请求的 `revalidate` ，借助路由段配置，我们可以配置这个路由下所有 fetch 请求的 `revalidate`。

路由段配置的使用方式也很简单，导出一个约定变量名即可，比如：

```javascript
// layout.js | page.js | route.js
export const dynamic = 'auto'
export const dynamicParams = true
export const revalidate = false
export const fetchCache = 'auto'
export const runtime = 'nodejs'
export const preferredRegion = 'auto'
export const maxDuration = 5
 
export default function MyComponent() {}
```

具体这些变量名和值的类型为：

| **变量名**                                                                                                            | **类型**                                                                                                                                            | **默认值**    |
| ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| [dynamic](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic)                 | `'auto' \| 'force-dynamic' \| 'error' \| 'force-static'`                                                                              | `'auto'`   |
| [dynamicParams](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamicparams)     | `boolean`                                                                                                                                         | `true`     |
| [revalidate](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#revalidate)           | `false \| 'force-cache' \| 0 \| number`                                                                                               | `false`    |
| [fetchCache](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#fetchcache)           | `'auto' \| 'default-cache' \| 'only-cache' \| 'force-cache' \| 'force-no-store' \| 'default-no-store' \| 'only-no-store'` | `'auto'`   |
| [runtime](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#runtime)                 | `'nodejs' \| 'edge'`                                                                                                                          | `'nodejs'` |
| [preferredRegion](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#preferredregion) | `'auto' \| 'global' \| 'home' \| string \| string[]`                                                                              | `'auto'`   |
| [maxDuration](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#maxduration)         | `number`                                                                                                                                          | 部署平台设置     |

注意配置选项的值目前是静态分析的，也就是说，配置`revalidate = 600`是有效的，但是 `revalidate = 60 * 10`是无效的。

我们来一一讲解这些配置选项的作用。

### 2.1. dynamic

更改布局或者页面的动态行为，用例如下：

```javascript
// layout.js | page.js | route.js
export const dynamic = 'auto'
// 'auto' | 'force-dynamic' | 'error' | 'force-static'
```

为了讲解 dynamic 参数的选项，我们先复习下基础知识：

所谓**静态渲染（Static Rendering）**，指的是路由在构建时渲染，或者在重新验证后后台渲染，其结果会被缓存并可以推送到 CDN。适用于未针对用户个性化且数据已知的情况，比如静态博客文章、产品介绍页面等。

所谓**动态渲染（Dynamic Rendering）**，指的是路由在请求时渲染，适用于针对用户个性化或依赖请求中的信息（如 cookie、URL 参数）的情况。

因为渲染模式和数据缓存是相互独立的，所以在动态渲染下，数据请求也分为缓存和不缓存（[uncached data request](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching)）的。默认是缓存，这样做的好处在于，即便选择了动态渲染，也不用担心渲染时获取所有数据对性能造成影响。

`dynamic` 影响的不仅是渲染模式，也会影响数据缓存的方式。

还有一个名词叫**动态函数（Dynamic Functions）**，指的是获取只能在请求时才能得到的信息（如 cookie、请求头、URL 参数）的函数，在 Next.js 中，对应的就是 `cookies()`、`headers()`、`useSearchParams()`、`searchParams()` 这些函数。如果使用了这些函数的任意一个，都会导致路由进行动态渲染。

接下来我们讲解 `dynamic` 的值都有哪些作用：

*   `'auto'`（默认）：自动判断
*   `'force-dynamic'`，强制动态渲染和退出所有 fetch 请求缓存，相当于：
    *   Page Router 下使用了 `getServerSideProps()`
    *   将布局或页面中每个 `fetch()` 请求都设置为 `{ cache: 'no-store', next: { revalidate: 0 } }`
    *   设置了路由段配置 `export const fetchCache = 'force-no-store'`
*   `'error'`强制静态渲染并缓存数据，如果有组件使用了动态函数或不缓存数据请求（[uncached data request](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching)），就会导致错误，相当于：
    *   Page Router 下使用了`getStaticProps()`
    *   将布局或页面中每个 `fetch()` 请求都设置为 `{ cache: 'force-cache' }`
    *   设置了路由段配置 `fetchCache = 'only-cache', dynamicParams = false`
    *   设置`dynamic = 'error'` 会更改 `dynamicParams` 的默认值 `true` 为 `false`
*   `'force-static'` 强制静态渲染并缓存数据，强制 `cookies()`、`headers()`、`useSearchParams()` 返回空值。

### 2.2. dynamicParams

控制当访问不是由 `generateStaticParams` 生成的动态路由段的时候发生什么。

```javascript
// layout.jsx | page.jsx
export const dynamicParams = true // true | false,
```

*   `true`（默认）：按需生成
*   false：返回 404

这个选项对应 Page Router 下的 `getStaticPaths` 的 `fallback: true | false | blocking`选项。

如果使用了 `dynamic = 'error'` 和 `dynamic = 'force-static'`，它会更改 `dynamicParams` 的默认值为 `false`。

### 2.3. revalidate

设置布局或者页面的默认验证时间。此设置不会覆盖单个 `fetch` 请求设置的 `revalidate` 的值。注意 `revalidate` 选项只能用于 Nodejs Runtime，不能用于 Edge Runtime。

```javascript
// layout.jsx | page.jsx | route.js
export const revalidate = false
// false | 'force-cache' | 0 | number
```

*   `false`（默认），语义上相当于 `revalidate: Infinity`，资源无限期缓存。
*   `0`，页面或布局总是动态渲染，即使没有使用动态函数或者不缓存数据请求（[uncached data request](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#opting-out-of-data-caching)）。
*   `number` ：设置布局或页面的默认重新验证频率，以秒为单位。

关于重新验证频率，一个路由可能有多个布局和一个页面，此时会选择最低的 `revalidate` 值作为路由的重新验证频率。这是为了确保子路由的重新验证时间频率和父布局保持一致。此外，单个 fetch 请求可以设置比路由默认的 `revalidate` 值更低的 `revalidate` 值，这会增加整个路由的重新验证频率。这允许你根据某些动态条件进行更频繁的重新验证。

### 2.4. fetchCache

这是一个高级选项，仅当你特别需要覆盖默认行为时才应该使用。为了解释这个选项，我们先复习下 fetch 请求的 `options.cache` 选项：

```javascript
fetch(`https://...`, { cache: 'force-cache' | 'no-store' })
```

其中 `force-cache`是默认值，表示优先从缓存中查找匹配请求，当没有匹配项或者匹配项过时时，才从服务器上获取资源并更新缓存。`no-store`表示每次请求都从服务器上获取资源，不从缓存中查，也不更新缓存。

回到 Next.js，默认情况下，Next.js 会缓存在动态函数使用之前的 `fetch` 请求，不会缓存任何动态函数之后的`fetch` 请求。而 `fetchCache` 允许你覆盖布局或者页面中所有的 `fetch`请求的默认 `cache`选项。

```javascript
// layout.jsx | page.jsx | route.js
export const fetchCache = 'auto'
// 'auto' | 'default-cache' | 'only-cache'
// 'force-cache' | 'force-no-store' | 'default-no-store' | 'only-no-store'
```

*   `'auto'`（默认）：动态函数之前按照开发者设置的 `cache` 选项进行缓存，动态函数之后不缓存请求
*   `'default-cache'`：开发者可以自由设置 `cache` 选项，但如果开发者未设置 `cache` 选项，默认设置为 `force-cache`，这意味着即使是在动态函数之后的请求，也会被视为静态
*   `'only-cache'`：如果开发者未设置 `cache` 选项，默认设置为 `force-cache`，如果有请求设置成 `cache: 'no-store'`，则会导致报错
*   `'force-cache'`：将所有请求的 `cache` 选项设置为 `force-cache` 。
*   `'default-no-store'`：开发者可以自由设置 `cache` 选项，但如果开发者未设置 `cache` 选项，默认设置为 `no-store`，这意味着即使是在动态函数之前的请求，也会被视为动态。
*   `'only-no-store'`：如果开发者未设置 `cache` 选项，默认设置为 `no-store`，如果有请求设置成 `cache: 'force-cache'`，则会导致报错
*   `'force-no-store'`：将所有请求的 `cache` 选项设置为 `no-store` 。

一个路由可能有多个布局和一个页面，此时选项应该相互兼容：

*   如何 `'only-cache'` 和 `'force-cache'` 同时提供，`'force-cache'` 获胜。如果 `'only-no-store'` 和 `'force-no-store'`同时提供，`'force-no-store'`获胜。带 `force` 的选项会更改整个路由的行为，并会阻止 `'only-*'` 引发的错误。
*   `'only-*'` 和 `force-*'`选项的作用就是确保整个路由要么是完全静态要么是完全动态，这意味着：
    *   在单个路由中不允许同时使用 `'only-cache'`和 `'only-no-store'`
    *   在单个路由中不允许同时使用 `'force-cache'`和 `'force-no-store'`
*   如果子级提供了 `'auto'`或  `'*-cache'`，父级无法使用 `'default-no-store'`，因为这会导致请求有不同的行为。

Next.js 建议共享的父布局使用 `'auto'`，在子级中自定义不同的选项。

### 2.5. runtime

设置运行时环境，具体参考小册[《渲染篇 | Streaming 和 Edge Runtime》](https://juejin.cn/book/7307859898316881957/section/7309076865732640818)

```javascript
// layout.jsx | page.jsx | route.js
export const runtime = 'nodejs'
// 'edge' | 'nodejs'
```

*   `nodejs`（默认）
*   `edge`

### 2.6. preferredRegion

在 [Vercel Serverless Functions](https://vercel.com/docs/functions/serverless-functions) 中使用，搭配 `export const runtime = 'edge'; `，用于设置 [Edge Functions](https://vercel.com/docs/functions/configuring-functions/region) 执行的区域，默认情况下，Edge Functions 在最接近传入请求的区域中执行，但如果你的函数比较依赖数据源，你会更希望它靠近数据源所在的位置以实现快速响应，那就可以设置 preferredRegion 指定一系列首选区域。

指定区域的时候，传入的是区域 ID，区域列表参考 [Vercel 的 Region List 文档](https://vercel.com/docs/edge-network/regions)，其中 iad1 表示美国东部区域，参考位置美国华盛顿地区，sfo1 表示美国西部，参考位置美国旧金山。

```javascript
// layout.jsx | page.jsx | route.js
export const preferredRegion = 'auto'
// 'auto' | 'global' | 'home' | ['iad1', 'sfo1']
```

### 2.7. maxDuration

在 [Vercel Serverless Functions](https://vercel.com/docs/functions/serverless-functions) 中使用，用于配置 [Vercel 函数](https://vercel.com/docs/functions/configuring-functions/duration)的最大持续时间，所谓 Max duration，指的是函数在响应之前可以处理 HTTP 请求的最长时间。如果持续时间内没有响应，则会返回错误码。如果没有指定，根据不同的部署平台，默认时间会不同。

```javascript
export const maxDuration = 5
```

### 2.8 generateStaticParams

与动态路由搭配使用，用于定义静态生成的路由段参数。具体内容参考小册[《API 篇 | 路由相关的常用方法》](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-1)

## 参考链接

1.  <https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config>
2.  <https://vercel.com/docs/functions/configuring-functions/region>


## 21.组件篇 | Images

## 前言
本篇开始我们进入组件篇，为大家详细介绍 Next.js 内置的四个组件，分别是：`<Image>`、`Font`、`<Link>`、`<Script>`，它们都是 Next.js 基于原生 HTML 标签做了诸多优化而专门抽象的组件，在开发的时候尽可能的使用这些组件。

其中 `<Image>` 组件实现了懒加载和根据设备尺寸自动调整图片大小，`<Link> `组件实现了后台预获取资源，从而让页面转换更快更平滑，`<Script>` 组件使得你可以控制加载和执行第三方脚本等等……具体的功能和 API 我们会在组件篇中详细介绍。

本篇将介绍 `<Image>` 组件，因为图片往往占据了网页大小很大一部分，图片的优化可谓是重中之重。`Image` 组件也提供了非常多的 prop 和配置项，了解这些 prop 以及背后的原理有助于我们更加深入的使用 `Image` 组件，带来更好的用户体验。
## 图片与 LCP
### 1. 图片占比
根据 [Web Almanac](https://almanac.httparchive.org/en/2022/media) 中的介绍，图片大小占典型网站页面大小的很大一部分。根据统计，2021 年 6 月网站的总大小中位数是 2019 KB（移动端），其中 881 KB 是图像。这比 HTML（30 KB），CSS（72 KB），JavaScript（461 KB）和字体（97 KB）的总和还要多。

在绝大多数页面上（70% 移动设备，80% 桌面），最有影响的就是图片。Largest Contentful Paint（最大内容绘制，简写：[LCP](https://web.dev/articles/lcp?hl=zh-cn)） 是一种 Web 性能指标，可以标识首屏中最大的内容元素。大部分时候，该元素都有图片。
### 2. LCP 背景
考虑到 LCP 并不算是一个常为大家熟知的概念，所以我们单独介绍下 LCP。

对于 Web 开发者而言，衡量网页主要内容的加载速度一直是一个挑战。

传统我们会使用 load、DOMContentLoaded 等方法，但它们并不表示用户在屏幕上看到的内容的时间。

而像首次内容渲染（FCP），如果页面有 loading 效果，那获取的时间也是不准确的。

当然也有首次有效绘制（FMP）等指标，但是这些指标非常复杂，往往是错误的。所以也不能用来确定主要内容的加载时间。

根据 W3C Web 性能工作组中的讨论和 Google 的研究，要衡量网页主要内容的加载时间，更为准确的方法是查看最大元素的呈现时间。这就是 LCP。
### 3. LCP 概念与标准
Largest Contentful Paint (LCP) 指标会报告视口内可见的最大图片或文本块的呈现时间（相对于网页首次开始加载的时间）。

为了提供良好的用户体验，网站应尽力将 Largest Contentful Paint 设置为 **2.5 秒**或更短。

让我们看一些  LCP 的例子：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdad5f872000436386d02af3b2b22ab6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=621&s=344333&e=png&b=faf4f4)

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d45d5ac94a014e66a4b791e61e2a41dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=621&s=397379&e=png&b=fbfbfb)

那么问题来了，页面往往是分阶段加载的，网页中最大元素可能是在不断变化的，LCP 是怎么计算出来的呢？

首先，浏览器会将 LCP 的元素限定在一些特定的元素类型内，比如`<img>` 元素、包含文本节点或其他内嵌级别文本元素的子项的块级元素、为自动播放 `<video>` 元素而绘制的第一帧、动画图片格式（例如 GIF 动画）的第一帧等等（这是为了简化这个问题，如果什么元素都计算一遍大小，就太复杂了而且没必要）。

然后浏览器在绘制完第一帧后，就会立即分派 largest-contentful-paint 类型的 PerformanceEntry，用于标识最大的内容元素。在渲染后续帧后，只要最大内容元素发生变化，该 API 就会再分派另一个 PerformanceEntry。简单的来说，每一帧绘制的时候，浏览器都会标示出最大内容元素。

当用户与页面发生交互（通过点按、滚动或按键），浏览器就会停止报告新条目。（因为用户交互通常会改变向用户显示的内容，就比如滚动操作）。一般来说，发出的最后一个条目的 startTime 值是 LCP 值。
## `<Image>`
### 1. 功能特性
讲解 LCP，只是为了帮助大家认识到图片优化的重要性（毕竟最大内容元素往往是图片）。回到 `<Image>` 组件上，Next.js 基于原生的 HTML `<img>` 元素，实现了这些优化功能：

1. 尺寸优化：自动为每个设备提供正确尺寸的图片，也会使用现代图片格式如 WebP 和 AVIF。
2. 视觉稳定性：防止图片加载时发生布局偏移（Layout Shift）
3. 更快的页面加载：图片只有在进入视口的时候才会加载，使用懒加载功能，并可选使用模糊占位符
4. 灵活配置：按需进行图片调整，远程服务器上的图片也可以

这些功能我们会在讲解组件 API 的时候一一涉及。
### 2. 基础使用
这是 `<Image>` 组件的使用示例，看起来如同使用正常的 img 元素一样：

```javascript
// app/page.js
import Image from 'next/image'
 
export default function Page() {
  return (
    <Image
      src="/profile.png"
      width={500}
      height={500}
      alt="Picture of the author"
    />
  )
}
```
### 3. 支持的 props
 `<Image>` 组件支持传入这些 props：

| **Prop** | **示例** | **类型** | **是否必须** |
| --- | --- | --- | --- |
| [src](https://nextjs.org/docs/app/api-reference/components/image#src) | `src="/profile.png"` | String | 是 |
| [width](https://nextjs.org/docs/app/api-reference/components/image#width) | `width={500}` | Integer (px) | 是 |
| [height](https://nextjs.org/docs/app/api-reference/components/image#height) | `height={500}` | Integer (px) | 是 |
| [alt](https://nextjs.org/docs/app/api-reference/components/image#alt) | `alt="Picture of the author"` | String | 是 |
| [loader](https://nextjs.org/docs/app/api-reference/components/image#loader) | `loader={imageLoader}` | Function | - |
| [fill](https://nextjs.org/docs/app/api-reference/components/image#fill) | `fill={true}` | Boolean | - |
| [sizes](https://nextjs.org/docs/app/api-reference/components/image#sizes) | `sizes="(max-width: 768px) 100vw"` | String | - |
| [quality](https://nextjs.org/docs/app/api-reference/components/image#quality) | `quality={80}` | Integer (1-100) | - |
| [priority](https://nextjs.org/docs/app/api-reference/components/image#priority) | `priority={true}` | Boolean | - |
| [placeholder](https://nextjs.org/docs/app/api-reference/components/image#placeholder) | `placeholder="blur"` | String | - |
| [style](https://nextjs.org/docs/app/api-reference/components/image#style) | `style={{objectFit: "contain"}}` | Object | - |
| [onLoadingComplete](https://nextjs.org/docs/app/api-reference/components/image#onloadingcomplete) | `onLoadingComplete={img => done())}` | Function | - |
| [onLoad](https://nextjs.org/docs/app/api-reference/components/image#onload) | `onLoad={event => done())}` | Function | - |
| [onError](https://nextjs.org/docs/app/api-reference/components/image#onerror) | `onError(event => fail()}` | Function | - |
| [loading](https://nextjs.org/docs/app/api-reference/components/image#loading) | `loading="lazy"` | String | - |
| [blurDataURL](https://nextjs.org/docs/app/api-reference/components/image#blurdataurl) | `blurDataURL="data:image/jpeg..."` | String | - |

其中，`src`、`width` 、`height`  和 `alt` 是必须的，其他是可选的。让我们逐一讲解。
### 4. src-必须
src 支持传入一个静态导入图片文件，也支持传入一个路径字符串。

使用本地图片的时候，就可以采用静态导入图片文件的方式。通过 `import` 导入 `.jpg`、`.png` 或者 `.webp` 格式的文件。使用示例如下：

```javascript
// app/page.js
import Image from 'next/image'
import profilePic from './me.png'
 
export default function Page() {
  return (
    <Image
      src={profilePic}
      alt="Picture of the author"
      // width={500} automatically provided
      // height={500} automatically provided
      // blurDataURL="data:..." automatically provided
      // placeholder="blur" // Optional blur-up while loading
    />
  )
}
```
使用静态文件导入的方式，`width` 和 `height` 不需要传入，Next.js 会自动提供。

注意：动态的 `await import()` 或者 `require() `是不支持的。`import` 必须是静态的，才可以在构建的时候进行分析。

使用远程图片的时候，src 可以传入一个 URL 字符串。

由于 Next.js 在构建的时候无法获取远程文件，你需要手动提供 `width`、`height` 和可选的 `blurDataURL` props。

`width` 和 `heigth` 属性用于推断图像正确的宽高比（Aspect ratio，也称为纵横比）以及避免图片加载的时候发生布局偏移。但 `width` 和`height`并不决定图片最终的渲染尺寸，这也很好理解，因为你也可能设置拉伸模式等。

```javascript
// app/page.js
import Image from 'next/image'
 
export default function Page() {
  return (
    <Image
      src="https://s3.amazonaws.com/my-bucket/profile.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
```

注意使用远程地址的时候，Next.js 要求在 `next.config.js`文件中定义支持的远程图片地址，这是为了防止一些恶意使用。配置方法如下：

```javascript
// next.config.js
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 's3.amazonaws.com',
        port: '',
        pathname: '/my-bucket/**',
      },
    ],
  },
}
```

关于配置文件中的 `remotePatterns`，本篇后面我们会详细讲解。
### 5. width-必须
`width` 属性表示图片渲染的宽度，它以像素为单位，影响图片的显示大小。

该属性必须，除非是静态导入图片或者图片有 `fill` 属性。
### 6. height-必须
`height` 属性表示图片渲染的高度，它以像素为单位，影响图片的显示大小。

属性必须，除非是静态导入图片或者图片有 `fill` 属性。
### 7. alt
`alt` 属性用于描述图片，提供给屏幕阅读器和搜索引擎使用。如果图片被禁用或者加载图片时出现错误，它会作为降级的文本提示。

`alt` 属性应该使用在不改变页面含义的情况下替代图片的文本描述，不应该重复图片上方或下方标题中提供的信息。

如果图片纯粹是装饰或者不是给用户使用，那 `alt` 属性应该用一个空字符串表示（`alt=""`）。
### 8. loader
 `loader` 表示解析图片地址的自定义函数。让我们看段示例代码：

```javascript
'use client'
 
import Image from 'next/image'
 
const imageLoader = ({ src, width, quality }) => {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
 
export default function Page() {
  return (
    <Image
      loader={imageLoader}
      src="me.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
```

函数接受 `src`、`width`、`quality`作为参数，返回图片的 URL 字符串。

注意：由于 `loader` prop 传入的是一个函数，所以需要使用客户端组件，在这个例子中，顶部也是用的 `'use client'`。

每一个图片都添加一个 loader 非常麻烦，你也可以使用 `next.config.js` 中的 `loaderFile` 配置项来配置应用里的每个 `next/image` 实例，而无需传递 `loader` prop。这个配置项本篇后面会讲解。
### 9. fill
```javascript
fill={true} // {true} | {false}
```

`fill`表示是否将图片填充父元素。默认值为 `false`。当图片的 `width` 和 `height` 未知的时候很有用。

但是要注意：使用 `fill`，父元素必须指定为 `position: "relative"`或`position: "fixed"`或`position: "absolute"`。而 img 元素会默认自动指定为 `position: "absolute"`。

如果图片没有应用其他样式，图片会被拉伸以填充容器。

当然填充容器有很多方式，CSS 属性里的 `object-fit: "container"` 和 `object-fit: "cover"` 也都可以用来填充图像。

让我们简单看下区别：

```javascript
// app/page.js
import Image from 'next/image'
import profilePic from './image.png'
 
export default function Page() {
  return (
    <div style={{
      width: '200px',
      height: '200px',
      backgroundColor: "#ccc",
      position: 'relative'
    }}>
     <Image
        src={profilePic}
        alt="Picture of the author"
      />
    </div>
  )
}
```

正常显示如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea029d04ff6748d297390b2d5a4fbcc9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=856&h=642&s=500317&e=png&b=2d2a27)
     
如果添加 fill 属性后：

```javascript
<Image
  src={profilePic}
  alt="Picture of the author"
  fill={true}
/>
```

效果如下，图片会被拉伸以适应容器：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23133468308c414d8b153bd6689a8495~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=578&h=538&s=265329&e=png&b=302d2b)

如果使用 `object-fit: "contain"`：

```javascript
<Image
  src={profilePic}
  alt="Picture of the author"
  fill={true}
  style={{objectFit: "contain"}}
/>
```

效果如下，图片在保持其宽高比的同时填充元素的整个内容框：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b375639f2e14d59923b2cd89440bd6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=562&h=518&s=174623&e=png&b=ebebeb)
如果使用 `object-fit: "cover"`：

```javascript
<Image
  src={profilePic}
  alt="Picture of the author"
  fill={true}
  style={{objectFit: "cover"}}
/>
```

效果如下，图片在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e02b46bc02941b6b9cf78e584e0578e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=624&h=532&s=232733&e=png&b=282523)
     
### 10. sizes
HTML 5.1 新增加了 img 元素的 `srcset`、`sizes` 属性，用于设置响应式图像。

当我们需要不同的设备展示不同的图片的时候，就需要用到 `srcset`。这里具体又分为两种情况，一种是图片是相同的尺寸，但是不同的分辨率对应不同的图片，即高分辨率下对应高倍图。一种是相同的图片内容，但依据设备显示的更大或者更小。这分别对应着 srcset 的两种语法。

先说第一种，根据分辨率不同展示不同的图片，使用示例如下：

```javascript
<img
  srcset="elva-fairy-320w.jpg, elva-fairy-480w.jpg 1.5x, elva-fairy-640w.jpg 2x"
  src="elva-fairy-640w.jpg"
  alt="Elva dressed as a fairy" />
```
效果如下：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a316177c7f664b9ab520736e62d054d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=480&h=425&s=130728&e=png&a=1&b=f4f1f0)

srcset 是由逗号分隔的一个或多个字符串组成，每段字符串由以下组成：

1. 指向图像的 URL
2. 一个空格（可选）
3. 一个像素密度描述符（一个正浮点数，后面紧跟 x 符号）

如果我们给图片应用一个 CSS 样式：

```css
img {
  width: 320px;
}
```

它的宽度在屏幕上就是 320 像素（CSS 像素）。浏览器会计算出正在显示的显示器的分辨率，然后显示 srcset 引用的最适合的图片。如果是普通的分辨率，一个设备像素表示一个 CSS 像素，那就会加载 `elva-fairy-320w.jpg`，它的大小是 39KB，如果设备是高像素，用两个或者更多的设备像素表示一个 CSS 像素，那就会加载 `elva-fairy-640w.jpg`，它的大小是 93KB。

再说第二种情况，相同的图片内容，但依据设备显示的更大或者更小。使用示例代码如下：

```javascript
<img
  srcset="elva-fairy-small.jpg 480w, elva-fairy-large.jpg 800w"
  src="elva-fairy-large.jpg"
  alt="Elva dressed as a fairy" />
```

srcset 的语法与刚才略有不同，它定义了浏览器可选择的图片设置以及每个图片的大小。分析它的语法，依然是由逗号分隔的一个或多个字符串组成，每段字符串由以下部分组成：

1. 指向图像的 URL
2. 一个空格
3. 图片的固有宽度（以像素为单位）。注意，这里使用宽度描述符 w，而非 px。但一个 w 对应 1 个像素。图片的固有宽度是指它的真实大小。

此时我们就告诉了浏览器，这张图片有两种备选图片可以显示，一张是 `elva-fairy-small.jpg`，这张图片的宽度是 480px，一张是 `elva-fairy-large.jpg`，它的宽度是 800px。

那浏览器怎么知道用哪张图片呢？比如当前设备视口宽度是 640px，是选择 480px 的图片还是选择 800px 的图片呢？

为了帮助浏览器判断，你就需要写 sizes 属性。sizes 属性就是一组媒体查询条件，告诉浏览器，什么样的条件使用什么样的图片。一个使用示例如下：

```javascript
<img
  srcset="elva-fairy-small.jpg 480w, elva-fairy-large.jpg 800w"
  sizes="(max-width: 600px) 480px,
         800px"
  src="elva-fairy-large.jpg"
  alt="Elva dressed as a fairy" />
```

sizes 也是由逗号分隔的一个或多个字符串组成，每段字符串由以下组成：

1. 一个媒体条件，例子中为 `(max-width:600px)`，它表示当视口的宽度小于等于 600px 时
2. 一个空格
3. 当媒体条件为真时，图片将填充的宽度，这个宽度可以是固定值，比如这个例子中的 480px，也可以是一个相对于视口的宽度（如 50vw），但不能是百分比。如果没有媒体条件，表示是默认生效。当浏览器成功匹配第一个媒体条件的时候，剩下所有的条件都会被忽略。所以顺序很重要。

有了这些属性后，浏览器会：

1. 检查设备宽度
2. 检查 sizes 列表中哪个媒体条件是第一个为真
3. 查看给予该媒体查询的槽大小
4. 加载 srcset 列表中引用的最接近所选的槽大小的图像

比如在这个例子中，如果浏览器的视口是 480px，那么 sizes 中的第一个条件 (max-width: 600px) 就为真，所以选择 480px 大小，因为 480px 与固有宽度 480w 最接近，所以加载 elva-fairy-small.jpg。通过这种方式就可以实现移动端加载小图片，从而加快移动端的加载速度。

讲完 img 元素的 `srcset` 和 `sizes` 属性，回到 `<Image>` 组件上，使用 Next.js，你并不需要设置 `srcset`，Next.js 会自动为你生成。设置 sizes 属性会影响生成的 `srcset` 的值。

如果你不设置组件的 sizes 属性，Next.js 会用 1x、2x 这种像素密度描述符，而如果你设置了 sizes 属性，Next.js 会用 640w、750w 这种固有宽度描述符。

设置前：
     
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ca8290c0b4849e6a4c936c1398140c9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1182&h=124&s=69379&e=png&b=282828)
     
设置后：
     
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/031333cd47564ad399e819642ae912f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=436&s=253485&e=png&b=282828)
### 11. quality
表示优化图片的质量，值为 1 到 100 之间的整数，100 表示最好的品质，也是最大的文件大小。默认是 75。

```javascript
quality={75} // {number 1-100}
```
### 12. priority
表示图片加载优先级，布尔类型，默认值为 false。当值为 true 时表示高优先级并预加载。使用 `priority` 的图片会自动禁用懒加载。

```javascript
priority={false} // {false} | {true}
```

使用该属性有两个建议：

1. 在首屏可见的图片上使用
2. 在 LCP 图片元素上使用，考虑到不同的视口宽度可能有不同的 LCP 图片，可以设置多个

运行 `next dev` 的时候，如果 LCP 元素是一个图片，但没有设置 priority 属性，控制台里会有警告：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5a914226438476ca76d26e481b6a6c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1398&h=104&s=54212&e=png&b=3f3a2e)

使用示例代码：

```javascript
// app/page.js
import Image from 'next/image'
import profilePic from '../public/me.png'
 
export default function Page() {
  return <Image src={profilePic} alt="Picture of the author" priority />
}
```
### 13. placeholder
表示加载图片时的占位符。可选值为 `blur`、`empty`、 `data:image/... `，默认值是 `empty`。

```javascript
placeholder = 'empty' // "empty" | "blur" | "data:image/..."
```

当值为 `empty` 的时候，加载不会有占位符，只有空白区域。

当值为 `data:image/...`的时候，使用 [Data URL](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) 作为图片加载时的占位图片。Data URL，即前缀为 `data:` 协议的 URL，允许内容创建者向文档中嵌入小文件。比如  base64 图片就是 Data URL。

当值为`blur`的时候，`blurDataURL`属性的值会被用于作为占位符图片。如果图片是静态导入的，并且导入的图片为 `.jpg`、`.png`、`.webp`或 `.avif` ，blurDataURL 会自动生成，但动态图片除外。如果是动态图片，必须提供 `blurDataURL`属性。

这是一个默认的 [blur 效果演示](https://image-component.nextjs.gallery/placeholder)：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74b6fe2095ec48e8ba8748518f50ee4b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=803&h=575&s=123548&e=gif&f=6&b=66868d)
### 14. blurDataURL
只有当你设置了 `placeholder="blur"`，该属性值才会生效。

必须是 base64 编码的图片。图片会被放大并模糊，建议使用一个非常小的图片（10px 或者更小）。

可以借助 blurDataURI 实现这种[色彩效果](https://image-component.nextjs.gallery/placeholder)：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aa039c8c7034d3b9a38a67de8c28126~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750&h=1020&s=326943&e=gif&f=8&b=e4b23f)

可以借助 [https://png-pixel.com/](https://png-pixel.com/) 快速获得一个纯色图片的 Data URL。
### 15. style
设置图片的样式

```javascript
// components/ProfileImage.js
const imageStyle = {
  borderRadius: '50%',
  border: '1px solid #fff',
}
 
export default function ProfileImage() {
  return <Image src="..." style={imageStyle} />
}
```

当你使用 style 修改了图片宽度的时候，注意设置 `height` 为 `auto` 以保持宽高比，否则图片会被扭曲。这是因为 Next.js 会自动为图片添加 `width` 和 `height` 属性，通过 style 样式只修改宽度，加上原本添加的 `height` 属性，就会导致图片变形。
### 16. onLoadingComplete
```javascript
'use client'
 
<Image onLoadingComplete={(img) => console.log(img.naturalWidth)} />
```

当图片加载完毕的时候，会执行该回调函数，同时占位符图片会被删除。回调函数调用的时候会传入一个参数，该参数是对底层 <img> 元素的引用。

注意：因为组件接收一个函数作为参数，需要使用客户端组件。
### 17. onLoad
```javascript
'use client'
  
<Image onLoad={(e) => console.log(e.target.naturalWidth)} />
```

同样是图片加载完的时候执行，该回调函数可能会在占位符被删除以及图片被完全解码前执行。所以如果你想等到图片完全加载完毕，使用 onLoadingComplete。

注意：因为组件接收一个函数作为参数，需要使用客户端组件。
### 18. onError
```javascript
'use client'
  
<Image onError={(e) => console.error(e.target.id)} />
```

图片加载失败时执行的回调函数。

注意：因为组件接收一个函数作为参数，需要使用客户端组件。
### 19. loading
```javascript
loading = 'lazy' // {lazy} | {eager}
```

设置图片的加载行为，默认值为 `lazy`。

当值为 `lazy` 的时候，图片会延迟加载，直到图片接近视口。

当值为 `eager` 的时候，图片会被立即加载。

使用 `eager` 通常会损害性能。Next.js 推荐使用 `priority` 属性代替。
### 20. unoptimized

取消优化。当值为 `true` 的时候，使用源图片，不会更改质量、大小、格式。默认值是 `false`。示例如下：

```javascript
import Image from 'next/image'
 
const UnoptimizedImage = (props) => {
  return <Image {...props} unoptimized />
}
```

从 Next.js 12.3.0 起，可以通过 `next.config.js` 设置所有的图片取消优化：

```javascript
// next.config.js
module.exports = {
  images: {
    unoptimized: true,
  },
}
```
### 21. 其他 props
其他传给 `<Image />` 组件的属性都会传给底层的 img 元素。但以下属性除外：

1. `srcSet`，Next.js 会自动生成，如果你想更改，使用配置项里的 deviceSizes，下一节会讲到。
2. `decoding`，它的值总是 `"async"`
## 配置选项
除了通过 props，你也可以在 `next.config.js` 中配置图片组件。
### 1. remotePatterns

为保护应用远离恶意用户，当使用外部图片的时候需要配置 `remotePatterns`：

```javascript
// next.config.js
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'example.com',
        port: '',
        pathname: '/account123/**',
      },
    ],
  },
}
```

这个示例的意思是，`next/image` 的 `src` 属性的值必须是以 `https://example.com/account123/` 为开头。其他的协议、主机名、端口或者不匹配的路径都会返回 400 错误。

这是另外一个例子，在此例子中使用了通配符：

```javascript
// next.config.js
module.exports = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: '**.example.com',
      },
    ],
  },
}
```

这个示例的意思是，`next/image` 的 `src` 属性的值必须是以 `https://xxx.example.com`、`https://xxx.xxx.example.com`、`https://xxx.xxx.xxx.example.com`……开头。

`pathname` 和 `hostname` 都可以使用通配符，其中：

1. `*` 表示匹配单个路由段或者子域
2. `**` 表示匹配任意数量的路由段或者子域。

注意 `**` 语法在模式的中间是不起作用的。
### 2. domains

自 Next.js 14 起因为使用了更为严格的 `remotePatterns` 而废弃。仅当所有的内容都来自你所能控制的域的时候你再使用。

与 `remotePatterns` 类似，`domains` 配置项提供了一个用于外部图片的 hostname 列表：

```javascript
// next.config.js
module.exports = {
  images: {
    domains: ['assets.acme.com'],
  },
}
```

但是注意 `domains` 不支持通配符，并且无法限制协议、端口或者路径名。所以更建议使用 `remotePatterns`。
### 3. loaderFile
如果你不希望使用 Next.js 内置的图片优化 API，那你可以自己配置，使用 `next.config.js` 的 `loaderFile` 配置项：

```javascript
// next.config.js
module.exports = {
  images: {
    loader: 'custom',
    loaderFile: './my/image/loader.js',
  },
}
```

`loaderFile` 必须指向相对于 Next.js 应用根目录的文件。该文件必须导出一个默认函数，该函数返回一个字符串。举个例子：

```javascript
'use client'
 
export default function myImageLoader({ src, width, quality }) {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
```

这会应用到所有的 `next/image` 的实例，如果你要修改个别图片，使用 `loader` prop。
### 4. deviceSizes
如果你知道用户的设备宽度，那你可以使用 `next.config.js`的 `deviceSizes`来声明一系列的设备宽度断点。当 `next/image` 组件使用 `sizes` prop 的时候，这些宽度会被用来推断正确加载的图片。

如果没有配置，默认值是：

```javascript
// next.config.js
module.exports = {
  images: {
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
  },
}
```
### 5. imageSizes
你可以使用 `next.config.js` 的 `imageSize` 属性声明一系列的图片宽度。

如果没有配置，默认值是：

```javascript
// next.config.js
module.exports = {
  images: {
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
}
```

`imageSize` 和 `deviceSizes` 会影响图片生成最终的 `srcset` 尺寸：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/186de6c29889461b9d4e2a0b6697481b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1178&h=436&s=253485&e=png&b=282828)

那么问题来了，都是用来生成最终的 `srcset`，直接用一个数组不就好了吗？为什么非要用两个数组？

你可以这样理解，`deviceSizes` 用来处理大图片，`imageSizes` 用来处理小图片，而且 `imageSizes` 只会在图片使用了 `sizes` prop 的时候生效，比如当你这样写：

```javascript
import Image from 'next/image'
import profilePic from './image.png'
 
export default function Page() {
  return (
    <Image
      src={profilePic}
      sizes="(max-width: 600px) 160px,
      320px"
      alt="Picture of the author"
    />
  )
}
```

对应生成的 `srcset` 就包含了deviceSizes 和 imageSizes 的所有尺寸：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e64c0676e9f4c7ab906f3cdf31fab8f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076&h=606&s=333340&e=png&b=282828)

当你使用了 `sizes` prop 的时候，说明图片的宽度是小于全屏宽度的。`imagesSizes` 的中的所有值应该都小于 `deviceSizes` 中的最小值。
### 6. formats
Next.js 默认的图片优化 API 会自动通过请求中的 Accept 请求头检测浏览器支持的图片格式。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1a458a9d4fb4ae6a2bb54db2ecd4766~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=980&h=146&s=29237&e=png&b=292929)

如果 `Accept` 匹配多个配置的格式，数组中的第一个会被首先使用。因此，数组的顺序很重要，如果没有匹配到，或者源图片为动图，图片优化 API 会自动回退到原本的图片格式。

如果没有配置，默认值是：

```javascript
// next.config.js
module.exports = {
  images: {
    formats: ['image/webp'],
  },
}
```

你可以使用下面的配置开启 AVIF 格式支持：

```javascript
// next.config.js
module.exports = {
  images: {
    formats: ['image/avif', 'image/webp'],
  },
}
```
### 7. minimumCacheTTL
图片会根据请求动态优化并存储在 `<distDir>/cache/images`目录。优化后的图像文件会被用于后续请求，直到缓存过期。当匹配到过期的文件时，过期图片会立刻失效，同时图片会在后台重新优化并使用新的失效日期储存在缓存中。

通过读取响应头中的 `x-nextjs-cache`标头确定图片的缓存状态：

- `MISS`：路径不在缓存中
- `STALE` ：路径缓存了但是超出了重新验证时间，它会在后台被更新
- `HIT` ：路径在缓存中，且未超过重新验证时间

过期时间可以通过两种方式定义：

一种是通过 `minimumCacheTTL`配置项，一种通过 `Cache-Control`标头，具体而言，使用`Cache-Control`标头的 `max-age` 字段。如果 `s-maxage`和 `max-age`都有，`s-maxage`优先。

两种方法如果同时设置，以较大者为准。

`minimumCacheTTL` 配置项用来设置缓存优化图片的过期时间，它以秒为单位。使用示例如下：

```javascript
// next.config.js
module.exports = {
  images: {
    minimumCacheTTL: 60,
  },
}
```

如果你需要更改每张图片的缓存行为，你可以通过 [headers](https://nextjs.org/docs/app/api-reference/next-config-js/headers) 配置图片资源的 `Cache-Control`标头。

大部分时候，建议使用静态图片导入，它会自动对文件内容进行哈希处理，并使用 `immutable` 的 `Cache-Control` 标头。

目前还没有重新验证缓存的机制，所以最好将 `minimumCacheTTL` 的值设低一点、否则你可能需要手动修改 `src` prop 或者删除 `<distDir>/cache/images`以更新缓存。
### 8. disableStaticImages
如果图片静态导入功能跟其他插件发生冲突，你希望禁用此功能：

```javascript
// next.config.js 
module.exports = {
  images: {
    disableStaticImages: true,
  },
}
```
### 9. dangerouslyAllowSVG
默认 loader 不会优化 SVG 图片。首先，SVG 是一种矢量格式，这意味着它可以无损地调整大小。其次，SVG 具有许多与 HTML/CSS 相同的功能，如果没有适当的内容安全策略，这些功能可能会导致漏洞。

如果你需要使用默认的图像优化 API 来提供 SVG 图像，设置 `next.config.js`的 `dangerouslyAllowSVG`值：

```javascript
// next.config.js
module.exports = {
  images: {
    dangerouslyAllowSVG: true,
    contentDispositionType: 'attachment',
    contentSecurityPolicy: "default-src 'self'; script-src 'none'; sandbox;",
  },
}
```

Next.js 强烈推荐设置 `contentDispositionType` 强制浏览器下载图片，以及 `contentSecurityPolicy`阻止执行图片中嵌入的脚本。
## 动画图像
默认 loader 将自动跳过动态图片的优化并按原样展示。

Next.js 会自动检测动态图片，支持 GIF、APNG 和 WebP 格式。对于特定的动态图片，如果你想显式声明跳过，使用 `unoptimized` 属性（这样就省得 Next.js 检测判断了）。
## 响应式图片
图片默认生成的 `srcset` 包括 `1x`、`2x` 图片，这是为了支持不同的设备像素比。不过有的时候，你希望渲染响应式图片，自动适配视口，这个时候，你就需要设置 `sizes` 以及 `style`（或者 `className`）。下面这些方式都可以用来渲染响应式图片：
### 1. 使用静态导入的响应式图片
如果源图片不是动态的，你可以通过静态导入创建一个响应式图片：
```javascript
// components/author.js
import Image from 'next/image'
import me from '../photos/me.jpg'
 
export default function Author() {
  return (
    <Image
      src={me}
      alt="Picture of the author"
      sizes="100vw"
      style={{
        width: '100%',
        height: 'auto',
      }}
    />
  )
}
```
### 2. 保持宽高比的响应式图片
如果源图片是动态或者远程 URL，你需要提供 `width` 和 `height` 来设置正确的响应式图片宽高比。

```javascript
// components/page.js
import Image from 'next/image'
 
export default function Page({ photoUrl }) {
  return (
    <Image
      src={photoUrl}
      alt="Picture of the author"
      sizes="100vw"
      style={{
        width: '100%',
        height: 'auto',
      }}
      width={500}
      height={300}
    />
  )
}
```
### 3. 使用 fill 属性的响应式图片
如果你不知道图片宽高比，那可以考虑使用 `fill` 属性，注意设置父元素为 `postion:relative` 当然不用这种方式。也可以使用 `object-fit` ，具体看你想要什么样的效果：

```javascript
// app/page.js
import Image from 'next/image'
 
export default function Page({ photoUrl }) {
  return (
    <div style={{ position: 'relative', width: '500px', height: '300px' }}>
      <Image
        src={photoUrl}
        alt="Picture of the author"
        sizes="500px"
        fill
        style={{
          objectFit: 'contain',
        }}
      />
    </div>
  )
}
```
### 4. 搭配 grid 实现
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6e595921c0a46468e0ad8f18decc19f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=592&s=256302&e=png&b=1a1a1a)
```javascript
import Image from 'next/image'
import mountains from '../public/mountains.jpg'
 
export default function Fill() {
  return (
    <div
      style={{
        display: 'grid',
        gridGap: '8px',
        gridTemplateColumns: 'repeat(auto-fit, minmax(400px, auto))',
      }}
    >
      <div style={{ position: 'relative', height: '400px' }}>
        <Image
          alt="Mountains"
          src={mountains}
          fill
          sizes="(min-width: 808px) 50vw, 100vw"
          style={{
            objectFit: 'cover', // cover, contain, none
          }}
        />
      </div>
      {/* And more images in the grid... */}
    </div>
  )
}
```
## 主题判断
如果你希望实现浅色和深色模式下显示不同的图片，你可以创建一个新组件包含两个 `<Image>` 组件，然后通过 CSS 媒体查询显示正确的那一个：

```css
// omponents/theme-image.module.css
.imgDark {
  display: none;
}
 
@media (prefers-color-scheme: dark) {
  .imgLight {
    display: none;
  }
  .imgDark {
    display: unset;
  }
}
```

```javascript
// components/theme-image.tsx
import styles from './theme-image.module.css'
import Image from 'next/image'
 
const ThemeImage = (props) => {
  const { srcLight, srcDark, ...rest } = props
 
  return (
    <>
      <Image {...rest} src={srcLight} className={styles.imgLight} />
      <Image {...rest} src={srcDark} className={styles.imgDark} />
    </>
  )
}
```
## 累计布局偏移
在使用 Next.js 图片组件的时候，你会发现，Next.js 要求必须有 width 和 height 属性，哪怕使用静态导入图片的方式，也只是不用自己手写这两个属性而已，Next.js 依然会为你自动添加 width 和 height，之所以这样做，就是为了防止发生布局偏移。所谓布局偏移，顾名思义，原本内容的位置突然发生偏移，多出现在加载的时候。导致布局偏移的原因有很多，图片没有尺寸是常见的一个原因，让我们看个演示视频：


![10TEOBGBqZm1SEXE7KiC.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84c33fdc9221466284dc5507a3573638~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1080&s=578501&e=gif&f=238&b=fdfcff)
    
这就是没有设置图片尺寸导致的布局偏移，如果设置尺寸呢：


![38UiHViz44OWqlKFe1VC.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37363353c8254f8c8f85010e5d9e9211~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1920&h=1080&s=782430&e=gif&f=187&b=fdfcff)

你会发现图片在加载的时候，浏览器为图片预留了位置。

不要小瞧布局偏移，为此专门有累计布局偏移（Cumulative Layout Shift，简称 CLS）这个 Web 性能衡量指标。这可是 Google 三大[核心网页指标](https://web.dev/articles/vitals?hl=zh-cn#core_web_vitals)之一。累计布局偏移会统计视口中可见内容的移动量以及移动的距离，综合算出一个得分。

`next/image` 的设计就是为了防止发生布局偏移，所以如果要调整图片大小，应该使用下面三种方式之一：

1. 自动静态导入
2. 显示声明 `width` 和 `height` 属性
3. 隐式声明，通过使用 fill 让图片填充父元素
## 参考链接

1. [https://www.youtube.com/watch?v=IU_qq_c_lKA&feature=youtu.be](https://www.youtube.com/watch?v=IU_qq_c_lKA&feature=youtu.be)
2. [https://web.dev/articles/lcp?hl=zh-cn](https://web.dev/articles/lcp?hl=zh-cn)
3. [Media | 2022 | The Web Almanac by HTTP Archive](https://almanac.httparchive.org/en/2022/media)
4. [How to use the Next.js Image Component Effectively](https://www.zachgollwitzer.com/posts/nextjs-image-component-tutorial#option-3-probe-your-remote-images-for-their-size)
5. [https://web.dev/articles/optimize-cls#images-without-dimensions](https://web.dev/articles/optimize-cls#images-without-dimensions)
6. [Optimizing: Images](https://nextjs.org/docs/app/building-your-application/optimizing/images#image-sizing)
7. [Components: <Image>](https://nextjs.org/docs/app/api-reference/components/image#minimumcachettl)


## 22.组件篇 | Font

## 前言

Next.js 内置了 `next/font` 组件，相比于传统使用字体的方式，使用 font 组件会更加灵活便捷。font 组件的使用主要分为两块，一块是 Google 字体，一块是本地字体，都是通过 font 组件实现，但具体配置上会略有不同。

本篇我们会先从传统使用字体的方式开始讲起，然后讲解 font 组件带来的便利和优化，最后深入细节，讲解 font 函数的具体参数，这些细节在学习的时候只用大致了解即可，在实际项目开发的时候可再具体了解。

## 1. 传统使用字体

我们先讲讲传统使用字体的方式。

最基本的方法是通过 `@font-face`指定一个自定义字体，字体文件可以来自远程文件，也可以来自本地文件。然后在 `font-family` 中使用该字体。

```css
// global.css
@font-face {
  font-family: "Bitstream Vera Serif Bold";
  src: url("https://mdn.github.io/css-examples/web-fonts/VeraSeBd.ttf");
}

body {
  font-family: "Bitstream Vera Serif Bold", serif;
}
```

借助 [Google Fonts](https://fonts.google.com/) 这样的字体网站，我们可以快速生成样式文件，再通过 `link` 标签或者 `@import` 的方式直接使用。

使用 `link` 标签：

```javascript
// layout.js
export default function Layout({ children }) {
  return (
    <html>
      <head>
        <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet" />
      </head>
      <body>
        {children}
      </body>
    </html>
  )
}
```

```css
// globals.css
body {
  font-family: "Ma Shan Zheng", serif;
}
```

使用 `@import`：

```css
// globals.css
@import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap');

body {
  font-family: "Ma Shan Zheng", serif;
}
```

字体效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c75a6d322de417c80e027ce0b10b7ea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=474\&h=128\&s=13330\&e=png\&b=000000)

## 2. next/font 与布局偏移

Next.js 内置了 `next/font` 组件，帮助你更好的管理和使用字体。`next/font`会自动优化字体（包括自定义字体），就比如借助 CSS 的 `size-adjust` 属性实现零布局偏移。

布局偏移我们在 Image 组件篇讲过，除了图片不设置宽高导致布局偏移，网页字体加载的时候也容易出现布局偏移，就比如：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72115f0d28574811bd7a2ecbc4f9f0b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1818\&h=626\&s=867578\&e=png\&b=d7dffb)

三行文字的 `font-size`都是 64px，唯一区别就是字体不同，但观察图片左侧三行文字的高度，你会发现虽然 font-size 设置的都是 64px，但实际对应的高度并不一定是 64px。这种时候，就可以借助 CSS 的 [size-adjust](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/size-adjust) 调整大小，保证最终都是 64px 大小。Next.js 自动做了这个优化。

除了防止布局偏移，`next/font` 还可以帮助你快捷使用 Google 字体，而且 CSS 和字体文件会在构建的时候下载，和其他静态资源一样被保存，浏览器也不会向 Google 发送任何请求，保证了性能和隐私性。更多功能我们会在本篇详细讲解。

`next/font` 具体又分为 `next/font/google` 和 `next/font/local`，分别对应使用 Google 字体和使用本地字体。我们逐一讲解。

## 3. next/font/google

### 3.1. 使用示例

借助 `next/font/google`，我们不需要像以前一样到 Google Fonts 复制样式文件的链接，并通过 link 或者 import 导入，而是可以直接导入想要使用的字体。使用示例如下：

```javascript
// app/layout.js
// 1. 导入想要使用的字体
import { Inter } from 'next/font/google'

// 2. 实例化字体对象，设置使用子集等
const inter = Inter({
  subsets: ['latin']
})

//  3. 应用，inter.className 会返回一个只读的 CSS 类名用于加载字体
export default function RootLayout({ children }) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  )
}
```

最终实现的代码为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a21325f8edb24dd5b891f2fcd5207b00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1624\&h=474\&s=211319\&e=png\&b=2a2a2a)

Next.js 推荐使用[可变字体](https://fonts.google.com/variablefonts)来获得最佳的性能和灵活性。如果不能使用可变字体，你需要声明 weight（字重，是指字体的粗细程度）:

```javascript
// app/layout.js
import { Roboto } from 'next/font/google'
 
const roboto = Roboto({
  weight: '400',
  subsets: ['latin']
})
 
export default function RootLayout({ children }) {
  return (
    <html lang="en" className={roboto.className}>
      <body>{children}</body>
    </html>
  )
}
```

### 3.2. 可变字体

那什么是可变字体呢？所谓可变字体，引用维基百科的介绍：

> OpenType 可变字体（英语：OpenType variable fonts）是字体格式 OpenType 在 1.8 版规范中引入的扩展规范，由苹果、微软、谷歌和 Adobe 联合开发，于 2016 年 9 月 14日 正式发布。支持这一规范的计算机字体可以储存轮廓变化数据，在初始字形轮廓的基础上自动生成丰富的变化造型，使用户可以自由调整文字的外观。

简单的来说，可变字体可以自由调整字宽、字重、倾斜等，从而实现一款字体展示出多款字体的效果。Next.js 推荐使用可变字体。

你也可以使用数组指定多个 weight、样式：

```javascript
// app/layout.js
const roboto = Roboto({
  weight: ['400', '700'],
  style: ['normal', 'italic'],
  subsets: ['latin'],
  display: 'swap',
})
```

如果字体是多单词，使用下划线（`_`）连接，比如 Roboto Mono，导入的时候写成 `Roboto_Mono`：

```javascript
// app/layout.js
import { Ma_Shan_Zheng } from 'next/font/google'

const font = Ma_Shan_Zheng({
  subsets: ['latin'],
  weight: '400'
})

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={font.className}>
      <body>{children}</body>
    </html>
  )
}
```

### 3.3. 指定子集

谷歌的字体是可以指定子集（[subset](https://fonts.google.com/knowledge/glossary/subsetting)）的，就比如 [Roboto Mono](https://fonts.google.com/specimen/Roboto+Mono?hl=zh-cn) 支持拉丁文、西里尔文和希腊文等，我们没有必要都用到，就可以使用 `subsets` 属性指定某个子集，还可以减少字体文件的大小并改善性能。

这些子集默认会被预加载（通过 `preload` 属性控制，本篇后续会讲到），如果 `preload` 为 `true`，但不指定子集会有警告。有些字体只有一个默认子集，比如 `latin`，也需要手动制定。

> 拉丁字母，又称罗马字母，指的是一套以古罗马字母为基础改造而来的成熟字母体系，最初在意大利半岛和西欧流通，在 19 世纪时扩散为全世界最通行的字母，亦是世界使用人数最多的字母，是现代绝大多数欧美国家的唯一标准字体。拉丁字母就是我们写的 26 个字母。所以很多字体的子集都有 latin。

```javascript
// app/layout.js
const inter = Inter({ subsets: ['latin'] })
```

那怎么知道一个字体有哪些子集呢？你随便指定一个子集，如果不是有效的，Next.js 会提示你有哪些可用子集：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca481be0e7249d48580d61367886e12~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=884\&h=716\&s=87290\&e=png\&b=202022)

## 4. next/font/local

使用本地字体，通过 `next/font/local`并使用 `src`声明本地文件的地址。Next.js 依然推荐使用可变字体。使用示例如下：

```javascript
// app/layout.js
import localFont from 'next/font/local'
 
const myFont = localFont({
  src: './my-font.woff2',
  display: 'swap',
})
 
export default function RootLayout({ children }) {
  return (
    <html lang="en" className={myFont.className}>
      <body>{children}</body>
    </html>
  )
}
```

`src` 也可以是数组形式，比如一个字体使用多个本地文件：

```javascript
onst roboto = localFont({
  src: [
    {
      path: './Roboto-Regular.woff2',
      weight: '400',
      style: 'normal',
    },
    {
      path: './Roboto-Italic.woff2',
      weight: '400',
      style: 'italic',
    },
    {
      path: './Roboto-Bold.woff2',
      weight: '700',
      style: 'normal',
    },
    {
      path: './Roboto-BoldItalic.woff2',
      weight: '700',
      style: 'italic',
    },
  ],
})
```

## 5. Font 函数参数

了解了 `next/font` 的两种主要用法后，我们来详细的介绍下 Font 函数参数：

```javascript
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  // 到底还有哪些参数呢？
})
```

`next/font/google` 和 `next/font/local`略有不同，这是比较表：

| **Key**                                                                                            | **font/google** | **font/local** | **类型**                     | **必传** |
| -------------------------------------------------------------------------------------------------- | --------------- | -------------- | -------------------------- | ------ |
| [src](https://nextjs.org/docs/app/api-reference/components/font#src)                               | ❌               | ✅              | String or Array of Objects | 是      |
| [weight](https://nextjs.org/docs/app/api-reference/components/font#weight)                         | ✅               | ✅              | String or Array            | 看情况    |
| [style](https://nextjs.org/docs/app/api-reference/components/font#style)                           | ✅               | ✅              | String or Array            | -      |
| [subsets](https://nextjs.org/docs/app/api-reference/components/font#subsets)                       | ✅               | ❌              | Array of Strings           | -      |
| [axes](https://nextjs.org/docs/app/api-reference/components/font#axes)                             | ✅               | ❌              | Array of Strings           | -      |
| [display](https://nextjs.org/docs/app/api-reference/components/font#display)                       | ✅               | ✅              | String                     | -      |
| [preload](https://nextjs.org/docs/app/api-reference/components/font#preload)                       | ✅               | ✅              | Boolean                    | -      |
| [fallback](https://nextjs.org/docs/app/api-reference/components/font#fallback)                     | ✅               | ✅              | Array of Strings           | -      |
| [adjustFontFallback](https://nextjs.org/docs/app/api-reference/components/font#adjustfontfallback) | ✅               | ✅              | Boolean or String          | -      |
| [variable](https://nextjs.org/docs/app/api-reference/components/font#variable)                     | ✅               | ✅              | String                     | -      |
| [declarations](https://nextjs.org/docs/app/api-reference/components/font#declarations)             | ❌               | ✅              | Array of Objects           | -      |

### 5.1. src 参数

在 `next/font/local`中必传，可以是字符串，也可以是对象数组（类型为：`Array<{path: string, weight?: string, style?: string}>`），路径地址相当于字体加载函数调用的位置。

比如 `app/page.js`中使用 `src:'./fonts/my-font.woff2'`调用字体加载函数，`my-font.woff2`就放置在 `app/fonts/`下。

### 5.2. weight

字重，概念参考 [font-weight](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-weight)。如果是可变字体，则非必传，如果不是可变字体，则必传。

值可以是字符串，如 `weight: '400'`、`weight: '100 900'`（可变字体，从 100 到 900 之间的范围），也可以是字符串数组，如 `weight: ['100','400','900']`(不可变字体的 3 个可能值)。

### 5.3. style

概念参考 [font-style](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style)，默认值为 `normal`，其他值还有 `italic`、`oblique`等，参考 [font-style](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style#values)。如果使用 `next/font/google` 的非可变字体，也可以传入一组样式值，如 `style: ['italic','normal']`。

### 5.4. subsets

子集的概念上节已经介绍过，就不多说了。

### 5.5. axes

axes（axis 的复数形式，中文翻译：轴），与 `subsets`一样，只用于 `next/font/google`中。前面我们讲到可变字体可以自由调整字宽、字重、倾斜等，从而实现一款字体展示出多款字体的效果。字宽、字重、倾斜等就是一种“变形轴"，我们以 [Inter 字体](https://fonts.google.com/variablefonts?vfquery=inter#font-families)为例，可以看到到 Inter 字体里不止一个变型轴：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d57e292b7e784a3898372187e65c6344~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1850\&h=348\&s=41509\&e=png\&b=202124)

Axes 一共有两个，`slnt` 和 `wght` 。`slnt` 是 `slant` 的意思，`wght` 是 `weight` 的意思。如果我们将这个字体下载下来然后上传到 <https://wakamaifondue.com/>  这个网站解析，我们就可以在线看到不同轴数值的调整带来的不同效果：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4adf669757034318acea7478d005a5c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2548\&h=486\&s=115801\&e=png\&b=f7f7f7)

“`wght` 我懂了，是字重，对应的 CSS 属性是 `font-weight`，那 `slnt` 呢？”

我们通常写 [font-style](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style#values) CSS 属性的时候，它的值默认是 `normal`，除了 `normal`，常用的就是 `italic` 和 `oblique`了，`italic` 表示斜体，`oblique` 表示倾斜体。查看 [CSS3 font-style 规范](https://www.w3.org/TR/css-fonts-3/#font-style-prop)，可以得知 italic 和 oblique 都是字体的不同样式，italic 的设计初衷是斜体样式，oblique 是保持原本直立结构的斜体，我们看个例子：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84fbde7bc324571a91931c9c6622a3a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=920\&h=770\&s=95963\&e=png\&b=202124)

我们以字体 `f` 为例的话，italic 的斜体更为“花哨”一点，这不是计算机能够模拟出来的，是需要作者单独设计的，而 `oblique` 则是在原本直立结构上让其倾斜，这个计算机可以模拟出来。

而在具体 font-style 使用的时候，如果选择 italic，没有对应的可用斜体版本，会选用倾斜体（oblique）替代。如果选择 `oblique`，如果没有对应的可用倾斜体版本，会选用斜体（italic）替代。如果都没有，计算机会模拟出一个倾斜体，你可以称之为仿 oblique。

回到 `oblique`，`slnt` 就是在 `oblique` 样式中控制倾斜程度的轴，所以你拖动 `slnt` 这个轴，字体会在不断的倾斜程度中变化。以后可能还会遇到其他轴，这是一个对应表：

| **轴**      | **名称**        | **对应 CSS**                                                                             |
| ---------- | ------------- | ------------------------------------------------------------------------------------------- |
| wght       | Weight        | [font-weight](https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight)                 |
| wdth       | Width         | [font-stretch](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-stretch)               |
| ital, slnt | Italic, Slant | [font-style](https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-style)                   |
| opsz       | Optical Size  | [font-optical-sizing](https://developer.mozilla.org/en-US/docs/Web/CSS/font-optical-sizing) |

axes 是一个字符串数组形式，比如 `axes: ['slnt']`，你可以在[Google 可变字体页面](https://fonts.google.com/variablefonts#font-families)查询字体的 Axes 有哪些。之所以需要声明，是因为默认情况下，只有 weight 轴会被留下以减少字体文件大小，如果需要其他的轴就需要单独声明。

### 5.6 display

概念参考 [font-display](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face/font-display)。默认我们加载字体的时候，使用该字体的地方会先显示空白，然后直到字体下载完成之后才会显示。CSS font-display 控制的就是这个过程。CSS font-display 的值有 `'auto'`、`'block'`, `'swap'`、`'fallback'`、 `'optional'`，与 `next/font` 组件的 display 的值一样。介绍下这些值加载效果的不同：

1.  **auto**：使用浏览器的预设值，一般是 block
2.  **block**：先显示空白（3s），然后切换为备用字体，等字体加载完毕后切换
3.  **swap**：先显示备用字体，等字体加载完成后切换
4.  **fallback**：先显示空白（大约 100ms），然后切换为备用字体，时间大概是 3s，3s 内能加载完字体，就使用字体，3s 内加载不完，后续接着使用备用字体
5.  **optional**：先显示空白（大约 100ms），100ms 内能加载完就用，加载不完就直接使用备用字体

CSS `font-display` 的默认值为 `auto`，`next/font` 组件的默认值为 `swap`。

### 5.7. preload

布尔值，制定字体是否应该被预加载，默认值为 `true`。

### 5.8. fallback

字体无法被加载时的备用字体，没有默认值，字符串数组形式，如 `fallback: ['system-ui', 'arial']`。

### 5.9. adjustFontFallback

对于 `next/font/google`，`adjustFontFallback` 是一个布尔值，设置是否应该使用自动备用字体以减少累积布局偏移。默认值为 `true`。

对于 `next/font/local`，`adjustFontFallback` 可以是字符串，也可以是 `false`。可能的值有 `Arial`、`Times New Roman`、`false`。默认值是 `Arial`。

`Arail`是经典的无衬线字体，`Times New Roman`是经典的衬线字体，其实就是让你选用衬线还是无衬线字体作为备用字体进行调整，当然你也可以选择不调整，那就是 `false`。谷歌字体之所以不用选，是因为 Next.js 自动帮你判断了。

### 5.10. variable

这个属性与 CSS 变量有关，我们先简单复习一下 CSS 变量的概念。

CSS 变量由开发者自己定义，先通过自定义属性标记设定值（比如： `--main-color: black;`），然后由 `var()` 函数来获取值（比如： `color: var(--main-color);`）。

好处有两个，一是方便重复使用，比如一个色值可能在多个地方用到，如果发生变化，就需要全局搜索替换，使用 CSS 变量，只用更改变量的值即可。二是语义化，比如，`--main-text-color` 会比 `#00ff00` 更易理解。自定义属性受级联的约束，并从其父级继承其值。

比如你在 html 元素上声明一个 CSS 变量：

```javascript
html {
  --main-bg-color: brown;
}
```

需要用到该色值的元素可以直接使用：

```javascript
p {
  background-color: var(--main-bg-color);
}
```

使用 `next/font` 如何声明一个 CSS 变量呢？便是借助 `variable` 属性：

```javascript
// app/page.js
import { Inter } from 'next/font/google'
import styles from '../styles/component.module.css'
 
const inter = Inter({
  variable: '--font-inter',
})
```

此时我们就建立了一个 CSS 变量 `--font-inter`，它的具体值在添加到 HTML 上后可以查看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97ad41fc5eda4f6790bdf5859ea24cb8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=588\&h=130\&s=22160\&e=png\&b=292929)

其中 `__Inter_a64ecd` 和  `__Inter_Fallback_a64ecd` 对应的是 Next.js 自动生成的自定义字体名字：

```javascript
/* latin */
@font-face {
  font-family: '__Inter_a64ecd';
  font-style: normal;
  font-weight: 100 900;
  font-display: swap;
  src: url(/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2) format('woff2');
  //...
}

@font-face {
  font-family: '__Inter_Fallback_a64ecd';
  src: local("Arial");
  ascent-override: 90.20%;
  descent-override: 22.48%;
  line-gap-override: 0.00%;
  size-adjust: 107.40%
}
```

所以 `--font-inter: '__Inter_a64ecd', '__Inter_Fallback_a64ecd';` 的意思就是声明了两个自定义字体。

PS：如果你不想要有 `__Inter_Fallback_a64ecd`，只有 `__Inter_a64ecd`，设置 `adjustFontFallback`为 false。

现在只是声明，我们还需要通过 `var()` 函数使用，将两个字体放到 `font-family` 属性中：

```css
// styles/component.module.css
.text {
  font-family: var(--font-inter);
  font-weight: 200;
  font-style: italic;
}
```

最后一步，将声明添加到父元素，将自定义的 text 样式添加到子元素，这样子元素才可以获取到父元素中声明的变量：

```javascript
// app/page.js
<main className={inter.variable}>
  <p className={styles.text}>Hello World</p>
</main>
```

有的时候，为了方便，会直接将声明添加到 HTML 元素上，这样所有的元素都可以使用该声明：

```javascript
// layout.js
import './globals.css' 
import { Inter } from 'next/font/google'


const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
})

export default function RootLayout({ children }) {
  return (
    <html className={`${inter.variable}`}>
      <body>{children}</body>
    </html>
  )
}
```

### 5.11. declarations

上一节我们看到 Next.js 自动生成的 `@font-face` 的内容：

```javascript
@font-face {
  font-family: '__Inter_a64ecd';
  font-style: normal;
  font-weight: 100 900;
  font-display: swap;
  src: url(/_next/static/media/c9a5bc6a7c948fb0-s.p.woff2) format('woff2');
  //...
}
```

但其实`@font-face`下的属性还有很多，有很多我们并不熟悉的如 `ascent-override`、`descent-override`、`font-feature-settings`、`font-variation-settings`、`line-gap-override`、`unicode-range`等，具体查看 [MDN @font-face](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face)。`declarations` 就是为了让你进一步自定义 `@font-face` 的生成，使用示例如下：

```javascript
declarations: [{ prop: 'ascent-override', value: '90%' }]
```

注意该属性只用于 `next/font/local`。

## 6. 应用样式的三种方法

### 6.1. className

目前，我们讲到的添加样式的方法都是通过 `className`属性：

```javascript
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin']
})

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={`${inter.className}`}>
      <body>{children}</body>
    </html>
  )
}
```

当你读取字体对象的 className 属性时，会返回一个只读的 CSS `className`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09054be7fdda4f238cb662eaf620bd69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1620\&h=292\&s=129207\&e=png\&b=292929)

在这个例子中，`inter.className` 返回的值为 `__className_a64ecd`，Next.js 对应在自动生成的 `layout.css` 中设置的样式为：

```css
.__className_a64ecd {
    font-family: '__Inter_a64ecd', '__Inter_Fallback_a64ecd';
    font-style: normal;
}

@font-face {
  font-family: '__Inter_a64ecd';
  //...
}

@font-face {
  font-family: '__Inter_Fallback_a64ecd';
  //...
}
```

### 6.2. style

除了 `className`，还可以使用 `style`，它会返回一个只读的 `style` 对象，示例代码如下：

```javascript
// layout.js
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin']
})

export default function RootLayout({ children }) {
  return (
    <html style={inter.style}>
      <body>{children}</body>
    </html>
  )
}
```

生成的 HTML 代码为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aea458236fe6459cbbb6d4cc33b12f6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1430\&h=256\&s=100571\&e=png\&b=2b2b2b)

### 6.3. CSS 变量

CSS 变量已经介绍过，就不多说了。

## 7. 常见问题

### 7.1. 使用多种字体

你可以导入并使用多种字体，有两种方法：

第一种方法是创建一个工具函数用于导出字体，然后在需要的时候导入字体，应用 `className`。这可以保证只有在使用它时候才预加载字体。

导出两个字体对象：

```javascript
// app/fonts.js
import { Inter, Roboto_Mono } from 'next/font/google'
 
export const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})
 
export const roboto_mono = Roboto_Mono({
  subsets: ['latin'],
  display: 'swap',
})
```

在需要的时候导入并使用：

```javascript
// app/layout.js
import { inter } from './fonts'
 
export default function Layout({ children }) {
  return (
    <html lang="en" className={inter.className}>
      <body>
        <div>{children}</div>
      </body>
    </html>
  )
}
```

```javascript
// app/page.js
import { roboto_mono } from './fonts'
 
export default function Page() {
  return (
    <>
      <h1 className={roboto_mono.className}>My page</h1>
    </>
  )
}
```

第二种方法是，创建一个 CSS 变量，可以跟你喜欢的 CSS 方案一起使用，举个例子：

```javascript
// app/layout.js
import { Inter, Roboto_Mono } from 'next/font/google'
 
const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
})
 
const roboto_mono = Roboto_Mono({
  subsets: ['latin'],
  variable: '--font-roboto-mono',
  display: 'swap',
})
 
export default function RootLayout({ children }) {
  return (
    <html lang="en" className={`${inter.variable} ${roboto_mono.variable}`}>
      <body>
        <h1>My App</h1>
        <div>{children}</div>
      </body>
    </html>
  )
}
```

最终实现的代码为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/092348c4217e4cfc911c6c84076a41d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1632\&h=736\&s=355012\&e=png\&b=2b2b2b)

你可以看到，声明了两个 CSS 变量，`--font-roboto-mono` 和 `--font-inter`，当你需要为字体添加样式的时候，直接使用该变量即可：

```css
// app/global.css
html {
  font-family: var(--font-inter);
}
 
h1 {
  font-family: var(--font-roboto-mono);
}
```

### 7.2. 搭配 Tailwind CSS

`next/font` 可以通过 CSS 变量的形式与 Tailwind CSS 搭配使用。

首先通过 `variable`声明 CSS 变量：

```javascript
// app/layout.js 
import './globals.css' 
import { Ma_Shan_Zheng, Roboto_Mono } from 'next/font/google'


const ma_shan_zheng = Ma_Shan_Zheng({
  subsets: ['latin'],
  display: 'swap',
  weight: '400',
  variable: '--font-ma-shan-zheng',
})
 
const roboto_mono = Roboto_Mono({
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-roboto-mono',
})

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={`${ma_shan_zheng.variable} ${roboto_mono.variable}`}>
      <body>{children}</body>
    </html>
  )
}
```

```css
// globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

然后，将 CSS 变量添加到 Tailwind CSS 配置中：

```javascript
// tailwind.config.js
module.exports = {
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      fontFamily: {
        "ma": ['var(--font-ma-shan-zheng)'],
        "mono": ['var(--font-roboto-mono)'],
      },
    },
  },
  plugins: [],
}
```

最后，以 `font-` 作为前缀如（`font-ma`、`font-mono`）为元素添加样式：

```jsx
// page.js
export default function Page() {
  return <h1 className="font-ma underline">你好，世界！Hello World!</h1>
}
```

### 7.3. 使用字体定义文件

每次调用字体函数的时候，该字体都会作为一个实例被托管，所以如果多个地方使用同一个字体，还是应该在一个地方加载，然后按需导入。这就是字体定义文件的作用。

举个例子，在根目录下的 `styles` 文件夹下创建一个 `fonts.ts`文件，然后声明字体定义：

```javascript
// styles/fonts.js
import { Inter, Lora, Source_Sans_3 } from 'next/font/google'
import localFont from 'next/font/local'
 

const inter = Inter()
const lora = Lora()

const sourceCodePro400 = Source_Sans_3({ weight: '400' })
const sourceCodePro700 = Source_Sans_3({ weight: '700' })

const greatVibes = localFont({ src: './GreatVibes-Regular.ttf' })
 
export { inter, lora, sourceCodePro400, sourceCodePro700, greatVibes }
```

现在你可以在代码中使用这些定义：

```javascript
// app/page.js
import { inter, lora, sourceCodePro700, greatVibes } from '../styles/fonts'
 
export default function Page() {
  return (
    <div>
      <p className={inter.className}>Hello world using Inter font</p>
      <p style={lora.style}>Hello world using Lora font</p>
      <p className={sourceCodePro700.className}>
        Hello world using Source_Sans_3 font with weight 700
      </p>
      <p className={greatVibes.className}>My title in Great Vibes font</p>
    </div>
  )
}
```

为了更轻松的访问字体定义文件，你可以在 `tsconfig.json` 或 `jsconfig.json` 中定义路径别名：

```javascript
// tsconfig.json
{
  "compilerOptions": {
    "paths": {
      "@/fonts": ["./styles/fonts"]
    }
  }
}
```

现在你可以这样使用：

```javascript
// app/about/page.js
import { greatVibes, sourceCodePro400 } from '@/fonts'
```

## 参考链接

1.  [Components: Font](https://nextjs.org/docs/app/api-reference/components/font)
2.  [Optimizing: Fonts](https://nextjs.org/docs/app/building-your-application/optimizing/fonts)
3.  <https://web.dev/articles/css-size-adjust?hl=zh-cn>
4.  <https://developers.google.com/fonts/docs/getting_started?hl=zh-cn#specifying_script_subsets>
5.  <https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg>
6.  [可变字体（Variable Fonts）尝鲜](https://io-oi.me/tech/get-started-with-variable-fonts/)
7.  <https://fonts.google.com/knowledge/glossary/oblique>


## 23.组件篇 | Link 和 Script

## 前言

Next.js 内置了 `<Link>` 和 `<Script>` 组件，`<Link> `组件实现了后台预获取资源，从而让页面转换更快更平滑，`<Script>` 组件使得你可以控制加载和执行第三方脚本等等。本篇会详细介绍这两个组件的用法和相关参数。

## `<Link>`

### 1. 介绍

Link 组件是一个拓展了 HTML `<a>` 元素的 React 组件，提供了预加载和客户端路由之间的导航功能。它是 Next.js 路由导航的主要方式。使用示例如下：

```javascript
// app/page.js
import Link from 'next/link'
 
export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

### 2. Props

| **Prop**                                                                        | **示例**            | **类型**           | **是否必须** |
| ------------------------------------------------------------------------------- | ----------------- | ---------------- | -------- |
| [href](https://nextjs.org/docs/app/api-reference/components/link#href-required) | href="/dashboard" | String or Object | 是      |
| [replace](https://nextjs.org/docs/app/api-reference/components/link#replace)    | replace={false}   | Boolean          | -        |
| [scroll](https://nextjs.org/docs/app/api-reference/components/link#scroll)      | scroll={false}    | Boolean          | -        |
| [prefetch](https://nextjs.org/docs/app/api-reference/components/link#prefetch)  | prefetch={false}  | Boolean          | -        |

### 3. href（必须）

导航跳转的路径或者 URL：

```jsx
<Link href="/dashboard">Dashboard</Link>
```

`href`也支持传入一个对象：

```jsx
// 导航至 /about?name=test
<Link
  href={{
    pathname: '/about',
    query: { name: 'test' },
  }}
  >
  About
</Link>
```

那你可能就好奇了，除了 `pathname` 和 `query`，还支持传入哪些对象参数？我们翻下 [`<Link>` 组件的源码](https://github.com/vercel/next.js/blob/canary/packages/next/src/client/link.tsx)就知道了：

```javascript
// next.js/packages/next/src/client /link.tsx
import type { UrlObject } from 'url'
type Url = string | UrlObject
type InternalLinkProps = {
  href: Url
}
```

可以看出，对象来自于 [url NPM 包](https://www.npmjs.com/package/url)，查阅 url 这个包，该对象的属性有（以 `'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'`为例）：

*   **href**：`'<http://user:pass@host.com:8080/p/a/t/h?query=string#hash>'`
*   **protocol**：`'http:'`
*   **host**: `'host.com:8080'`
*   **auth**: `'user:pass'`
*   **hostname**: `'host.com'`
*   **port**: `'8080'`
*   **pathname**: `'/p/a/t/h'`
*   **search**: `'?query=string'`
*   **path**: `'/p/a/t/h?query=string'`
*   **query**: `'query=string' or {'query':'string'}`
*   **hash**: `'#hash'`

### 4. replace

默认值为 `false`，当值为 `true` 的时候，`next/link`会替换浏览器当前的历史记录，而非在浏览器的历史项里新增一个 URL（[history.replaceState 方法](https://developer.mozilla.org/zh-CN/docs/Web/API/History_API#replacestate_%E6%96%B9%E6%B3%95)）。

```javascript
// app/page.js
import Link from 'next/link'
 
export default function Page() {
  return (
    <Link href="/dashboard" replace>
      Dashboard
    </Link>
  )
}
```

### 5. scroll

默认值为 `true`。`<Link>`组件的默认行为是滚动到一个新导航的顶部或者在前进后退导航中维持之前的滚动位置。当值为 `false`，`next/link`不会在导航后滚动到新的页面顶部（继续维持上一个路由的位置）。

```javascript
// app/page.js
import Link from 'next/link'
 
export default function Page() {
  return (
    <Link href="/dashboard" scroll={false}>
      Dashboard
    </Link>
  )
}
```

### 6. prefetch

默认值为 `true`。当值为 `true` 的时候，`next/link`会在后台预获取页面。这可以有效改善客户端导航性能。任何视口中的 `<Link />` （无论是初始加载的时候还是通过滚动）都会预加载。但是要注意：预获取仅在生产环境中开启。

你可以通过传递 `prefetch={false}`来禁用这个功能。

```javascript
// app/page.js
import Link from 'next/link'
 
export default function Page() {
  return (
    <Link href="/dashboard" prefetch={false}>
      Dashboard
    </Link>
  )
}
```

### 7. 其他 props

其他 props 会自动转发给底层的 `<a>` 元素，比如 `target="_blank"`、`className`。

### 8. 示例

#### 8.1. 链接至动态路由

```javascript
// app/blog/page.js
import Link from 'next/link'
 
function Page({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

#### 8.2 中间件

我们通常会用中间件实现鉴权等功能，然后让用户重定向到其他的页面。为了让  <Link /> 组件能够在有中间件的时候获取到重定向后的链接，你需要告诉 Next.js 用于展示的 URL 和用于预获取的 URL。

举个例子，当你访问 `/dashboard` 这个路由的时候，需要进行身份验证，如果身份验证通过，跳转到 `/auth/dashboard` 路由，如果没有通过，则跳转到公共访问的 `/public/dashboard` 路由，实现代码如下：

```javascript
// middleware.js
export function middleware(req) {
  const nextUrl = req.nextUrl
  if (nextUrl.pathname === '/dashboard') {
    if (req.cookies.authToken) {
      return NextResponse.rewrite(new URL('/auth/dashboard', req.url))
    } else {
      return NextResponse.rewrite(new URL('/public/dashboard', req.url))
    }
  }
}
```

这个时候，为了让 `<Link />` 组件预获取正确的地址，你可以这样写：

```javascript
import Link from 'next/link'
import useIsAuthed from './hooks/useIsAuthed'
 
export default function Page() {
  const isAuthed = useIsAuthed()
  const path = isAuthed ? '/auth/dashboard' : '/dashboard'
  return (
    <Link as="/dashboard" href={path}>
      Dashboard
    </Link>
  )
}
```

这里我们用到了 `as` 这个 prop，`as` 是一个遗留的 prop，早期为了搭配动态路由而实现。这是因为在早期实现跳转动态路由功能的时候，代码并不像上节例子展示的那样理所当然：

```javascript
const pids = ['id1', 'id2', 'id3']
{
  pids.map((pid) => (
    <Link href="/post/[pid]" as={`/post/${pid}`}>
      <a>Post {pid}</a>
    </Link>
  ))
}
```

这是因为早期设计中， `href` 基于文件系统路径，并不能在运行时被改变，跳转地址只能是 `"/post/[pid]"`这种形式，但为了让浏览器显示正确的地址，于是增加了 `as` prop，它是浏览器 URL 地址栏中展示的地址。

回到刚才这个例子：

```javascript
  <Link as="/dashboard" href={path}>
    Dashboard
  </Link>
```

因为 prefetch 基于的是 `href` 地址，为了 prefetch 到正确的地址，所以 `path` 做了 isAuthed 判断。但最终跳转的地址应该是 `/dashboard`，然后在中间件里做具体的判断，所以使用了 `as` prop。

## `<Script>`

### 1. 介绍

Next.js 内置的脚本组件，用于控制加载和执行三方脚本文件。使用基本示例如下：

```javascript
// app/dashboard/page.js
import Script from 'next/script'
 
export default function Dashboard() {
  return (
    <>
      <Script src="https://example.com/script.js" />
    </>
  )
}
```

这是用在 page.js 之中，也可以用在 layout.js 之中使用，实现为多个路由加载一个脚本：

```javascript
// app/dashboard/layout.js
import Script from 'next/script'
 
export default function DashboardLayout({ children }) {
  return (
    <>
      <section>{children}</section>
      <Script src="https://example.com/script.js" />
    </>
  )
}
```

这样当访问如 `dashboard/page.js` 或是子路由 `dashboard/settings/page.js`的时候，脚本都会获取。Next.js 会保证脚本只加载一次，即使用户在同一布局的多个路由之间导航。

如果你希望所有路由都加载一个脚本，那可以直接卸载根布局中：

```javascript
// app/layout.js 
import Script from 'next/script'
 
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
      <Script src="https://example.com/script.js" />
    </html>
  )
}
```

当然考虑到性能问题，尽可能在特定页面或布局中加载三方脚本。

### 2. Props

| **Prop**                                                                         | **示例**                            | **类型**   | 是否必传        |
| -------------------------------------------------------------------------------- | --------------------------------- | -------- | ----------- |
| [src](https://nextjs.org/docs/app/api-reference/components/script#src)           | `src="http://example.com/script"` | String   | 必传，除非使用内联脚本 |
| [strategy](https://nextjs.org/docs/app/api-reference/components/script#strategy) | `strategy="lazyOnload"`           | String   | -           |
| [onLoad](https://nextjs.org/docs/app/api-reference/components/script#onload)     | `onLoad={onLoadFunc}`             | Function | -           |
| [onReady](https://nextjs.org/docs/app/api-reference/components/script#onready)   | `onReady={onReadyFunc}`           | Function | -           |
| [onError](https://nextjs.org/docs/app/api-reference/components/script#onerror)   | `onError={onErrorFunc}`           | Function | -           |

### 3. src

外部脚本地址，字符串形式，外部绝对地址或者内部地址都可，除非使用内联脚本，否则该属性必传。

所谓内联脚本，就像我们正常使用 script 标签一样，`<Script />` 也支持直接在组件内书写 JavaScript 代码：

```javascript
<Script id="show-banner">
  {`document.getElementById('banner').classList.remove('hidden')`}
</Script>
```

注意必须为内联脚本分配一个 id，以保证 Next.js 追踪和优化脚本。

或者使用 `dangerouslySetInnerHTML`属性：

```javascript
<Script
  id="show-banner"
  dangerouslySetInnerHTML={{
    __html: `document.getElementById('banner').classList.remove('hidden')`,
  }}
/>
```

### 4. strategy

脚本加载策略，一共有四种：

1.  **beforeInteractive**： 在可交互前加载，适用于如机器人检测、Cookie 管理等
2.  **afterInteractive**：默认值，在可交互后加载，适用于如数据统计等
3.  **lazyOnload**：在浏览器空闲时间加载
4.  **worker**：（实验性质）通过 web worker 加载

`beforeInteractive`，顾名思义，在可交互之前加载。`beforeInteractive`脚本必须放在根布局（`app/layout.tsx`）之中，用于加载整站都需要的脚本，适用于一些在页面具有可交互前需要获取的关键脚本。它会被注入到 HTML 文档的 `head` 中，不管你写在组件的哪里：

```javascript
// app/layout.js
import Script from 'next/script'
 
export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>{children}</body>
      <Script
        src="https://example.com/script.js"
        strategy="beforeInteractive"
      />
    </html>
  )
}
```

虽然我们将 Script 组件写在 body 标签之后，但依然被注入到 head 中：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87a4d28110fe4b25b94fcbd7a8a17a0d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1114\&h=392\&s=156886\&e=png\&b=282828)

`afterInteractive`，顾名思义，在页面可交互后（不一定是完全可交互）后加载，这是 Script 组件默认的加载策略，适用于需要尽快加载的脚本。`afterInteractive`脚本可以写在任何页面或者布局中，并且只有当浏览器中打开该页面的时候才会加载和执行。

```javascript
// app/page.js
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="afterInteractive" />
    </>
  )
}
```

`lazyOnload`，在浏览器空闲的时候注入到 HTML 客户端，并在页面所有资源都获取后开始加载。此策略是用于不需要提前加载的后台或者低优先级脚本。lazyOnload 脚本可以写在任何页面或者布局中，并且只有当浏览器中打开该页面的时候才会加载和执行。

```javascript
// app/page.js
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="lazyOnload" />
    </>
  )
}
```

`worker`，实验性质的加载策略，目前并不稳定，并且不能在 `app` 目录下使用，所以请谨慎使用。使用该策略的脚本将开一个 web worker 线程执行，从确保主线程处理关键的代码。它的背后是使用 [Partytown](https://partytown.builder.io/) 处理。尽管这个策略可以用于任何脚本，但作为一种高级用法，并不保证支持所有第三方脚本。

使用 worker 策略，需要通过 `next.config.js` 的 `nextScriptWorkers` 配置项开启：

```javascript
// next.config.js
module.exports = {
  experimental: {
    nextScriptWorkers: true,
  },
}
```

此时当你运行 `npm run dev`的时候，Next.js 会提示你安装 Partytown：

```javascript
npm install @builder.io/partytown
```

当完成设置后，定义 `strategy="worker"`将会在应用中实例化 Partytown，并将脚本放在 web worker 中。不过 `worker` 脚本目前只能在 `pages/` 目录下使用：

```javascript
// pages/home.js
import Script from 'next/script'
 
export default function Home() {
  return (
    <>
      <Script src="https://example.com/script.js" strategy="worker" />
    </>
  )
}
```

### 5. onLoad

一些三方脚本需要在脚本加载完毕后执行 JavaScript 代码以完成实例化或者调用函数。如果使用 `afterInteractive` 或者 `lazyOnload` 作为加载策略，则可以在加载完后使用 `onLoad` 属性执行代码：

```javascript
'use client'
// app/page.js
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script
        src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js"
        onLoad={() => {
          console.log(_.sample([1, 2, 3, 4]))
        }}
      />
    </>
  )
}
```

注意：`onLoad` 不能在服务端组件中使用，只能在客户端中使用。而且 `onLoad` 不能和 `beforeInteractive` 一起使用，使用 `onReady` 代替。

### 6. onReady

某些三方脚本要求用户在脚本完成加载后以及每次组件挂载的时候执行 JavaScript 代码，就比如地图导航。你可以使用 onLoad 属性处理首次加载，使用 onReady 属性处理组件每次重新挂载的时候执行代码：

```javascript
'use client'
// app/page.js 
import { useRef } from 'react'
import Script from 'next/script'
 
export default function Page() {
  const mapRef = useRef()
 
  return (
    <>
      <div ref={mapRef}></div>
      <Script
        id="google-maps"
        src="https://maps.googleapis.com/maps/api/js"
        onReady={() => {
          new google.maps.Map(mapRef.current, {
            center: { lat: -34.397, lng: 150.644 },
            zoom: 8,
          })
        }}
      />
    </>
  )
}
```

这个例子演示了每次组件挂载时如何重新实例化 Google Maps JS。注意：与 `onLoad` 相同，`onReady` 也不能在服务端组件中使用，只能在客户端中使用。

### 7. onError

当脚本加载失败的时候用于捕获错误，此时可以使用 onError 属性处理：

```javascript
'use client'
// app/page.js
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script
        src="https://example.com/script.js"
        onError={(e: Error) => {
          console.error('Script failed to load', e)
        }}
      />
    </>
  )
}
```

注意：`onError` 不能在服务端组件中使用，只能在客户端中使用。而且 `onError` 也不能和 `beforeInteractive` 一起使用。

### 8. 其他 prop

原生的 `<script>` 元素有很多 DOM 属性，其他添加在 Script 组件的 prop 都会自动转发给底层的 `<script>` 元素。

```javascript
// app/page.js
import Script from 'next/script'
 
export default function Page() {
  return (
    <>
      <Script
        src="https://example.com/script.js"
        id="example-script"
        nonce="XUENAJFW"
        data-test="script"
      />
    </>
  )
}
```

## 参考链接

1.  [https://github.com/vercel/next.js/blob/v9.5.2/docs/api-reference/next/link.md#dynamic-routes](https://github.com/vercel/next.js/blob/v9.5.2/docs/api-reference/next/link.md#dynamic-routes)
2.  [Optimizing: Scripts](https://nextjs.org/docs/app/building-your-application/optimizing/scripts)
3.  [Components: <Link>](https://nextjs.org/docs/app/api-reference/components/link)
4.  [Components: <Script>](https://nextjs.org/docs/app/api-reference/components/script)


## 24.Metadata 篇 | 基于配置

## 前言

Metadata，中文译为“元数据”，简单的来说就是描述数据的数据。

例如，一个 HTML 文件是一种数据，但 HTML 文件也能在 `<head>` 元素中包含描述该文档的数据，比如该文件的标题和字符编码。这些数据就被称为“元数据”。

```html
<head>
  <meta charset="utf-8" />
  <title>我的测试页面</title>
</head>
```

不止标题和字符编码，元数据是一个非常丰富的概念，`<head>` 中的各种 meta 标签都是元数据，比如这是描述文档作者和文档信息的元数据：

```html
<meta name="author" content="Chris Mills" />
<meta name="description" content="the description content" />
```

这是根据 [Open Graph 协议](https://ogp.me/)编写的元数据，当分享到诸如 Facebook 这样的社交平台的时候，会展示特殊的格式和信息：

```javascript
<meta property="og:image" content="..." />
<meta property="og:description" content="..." />
<meta property="og:title" content="..." />
```

网站的自定义图标、`robots.txt`、`sitemap.xml` 等也是元数据：

```html
<link rel="icon" href="favicon.ico" type="image/x-icon" />
```

元数据的丰富会改善 SEO 和 web 可共享性（比如定义一些特殊的字段用于内容分享到一些社交平台），为了方便定义和管理这些元数据，Next.js 提供了 Metadata API。在 Next.js 中，添加元数据的方法分为两类：

1.  基于配置的元数据：在 `layout.js`或 `page.js`中导出一个静态 `metadata` 对象或者一个动态的 `generateMetadata` 函数。
2.  基于文件的元数据：添加一个静态或者动态生成的特殊文件

通过这些选项，Next.js 会自动为页面生成相关的 `<head>` 元素。

## 1. 基于配置（Config-based）

### 1.1. 静态元数据

要定义一个静态元数据，需要从 `layout.js` 或者 `page.js` 文件中导出一个 `Metadata` 对象：

```javascript
// layout.js | page.js
export const metadata = {
  title: '...',
  description: '...',
}
 
export default function Page() {}
```

具体 Metadata 对象有哪些字段呢？我数了数[源码中的字段](https://github.com/vercel/next.js/blob/canary/packages/next/src/lib/metadata/default-metadata.tsx)，有 31 个，因为内容很多，所以放在本篇后面具体讲解。我们先了解下主要的定义元数据的方式。

### 1.2. 动态元数据

动态元数据是指依赖动态信息如当前路由参数、外部数据、父级路由段`metadata`等信息的元数据。要定义动态元数据，需要导出一个名为 `generateMetadata`的函数，该函数返回一个 Metadata 对象。使用示例如下：

```javascript
// app/products/[id]/page.js
export async function generateMetadata({ params, searchParams }, parent) {
  // 读取路由参数
  const id = params.id
 
  // 获取数据
  const product = await fetch(`https://.../${id}`).then((res) => res.json())
 
  // 获取和拓展父路由段 metadata
  const previousImages = (await parent).openGraph?.images || []
 
  return {
    title: product.title,
    openGraph: {
      images: ['/some-specific-page-image.jpg', ...previousImages],
    },
  }
}
 
export default function Page({ params, searchParams }) {}
```

让我们详细讲解下 generateMetadata 函数。该函数接收两个参数，`props` 和 `parent`。

`props` 指的是包含当前路由参数的对象，该对象又有两个字段，一个是 `params`，一个是 `searchParams`。

*   params 包含当前动态路由参数的对象，让我们举些例子你就知道了:

| **Route**                       | **URL**   | **params**              |
| ------------------------------- | --------- | ----------------------- |
| app/shop/\[slug]/page.js        | /shop/1   | { slug: '1' }           |
| app/shop/\[tag]/\[item]/page.js | /shop/1/2 | { tag: '1', item: '2' } |
| app/shop/\[...slug]/page.js     | /shop/1/2 | { slug: \['1', '2'] }   |

那如果访问的不是动态路由呢？那 params 就是一个空对象 `{}`。

*   `searchParams` 是一个包含当前 URL 搜索参数的对象，举个例子：

| **URL 网址** | **searchParams**   |
| --------------- | ------------------ |
| /shop?a=1       | { a: '1' }         |
| /shop?a=1\&b=2  | { a: '1', b: '2' } |
| /shop?a=1\&a=2  | { a: \['1', '2'] } |

`searchParams` 只在 `page.js` 中会有。

而 `parent` 是一个包含父路由段 metadata 对象的 promise 对象，所以示例代码中用的是 `(await parent).openGraph`获取。

注意：无论是静态元数据还是动态元数据**都只在服务端组件中支持**。如果不依赖运行时的信息，则应该尽可能使用静态元数据方式。

缓存篇里也会讲，在 `generateMetadata`、`generateStaticParams`、布局、页面和服务端组件中的 fetch 请求会自动记忆化，所以不用担心多次请求有性能损失。

Next.js 会在等待 `generateMetadata`中数据请求完毕再开始 UI 流式传输给客户端，这可以保证流式响应的第一部分包含 `<head>` 标签。

## 2. 基于文件（File-based）

这些特殊的文件都可用于元数据：

*   favicon.ico、apple-icon.jpg 和 icon.jpg
*   opengraph-image.jpg 和 twitter-image.jpg
*   robots.txt
*   sitemap.xml

基于文件是什么意思呢？我们以 icon 为例，icon 被用于设置浏览器网页标签的图标，虽然也可以使用静态元数据的方式设置（具体讲 metadata 对象的时候会讲到），但是 Next.js 提供了更便捷的方式，那就是约定一个文件名为 `icon` 的图片，格式支持 `.ico`、`.jpg`, `.jpeg`, `.png`, `.svg`。也就是添加一个名为 `icon.(ico|jpg|jpeg|png|svg)`的图片，Next.js 就会为该路由生成对应的元数据标签：

```html
<link
  rel="icon"
  href="/icon?<generated>"
  type="image/<generated>"
  sizes="<generated>"
/>
```

甚至如果你想动态生成该图片也可以实现，约定一个名为 `icon.(js|.ts|.tsx)`的文件，返回一张图片即可。

其他文件也是同理，使用这种方式快捷直观。不过具体这些文件该怎么设置，因为涉及的 API 太多，统一放在后面讲解。

要注意：基于文件的元数据具有更高的优先级，并会覆盖任何基于配置的元数据。

## 3. 行为

### 3.1. 默认字段

有两个默认的 `meta` 标签，即使路由未定义元数据也会添加，一个是设置网站字符编码的 `charset`，一个是设置网站视口宽度和比例的 `viewport`：

```html
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
```

当然这两个元数据标签也都是可以覆盖的。

### 3.2. 顺序

一个页面和它的布局以及它的父布局，都设置了一些元数据字段，有的字段重复，有的字段不同，那么 Next.js 该怎么处理呢？

这个逻辑其实我们也很容易想到，具体页面的设置应该优先级更高。Next.js 就是按照从根路由到 `page.js`的顺序处理，比如当你访问 `/blog/1`，处理顺序为：

1.  `app/layout.tsx`（根布局）
2.  `app/blog/layout.tsx`（嵌套布局布局）
3.  `app/blog/[slug]/page.tsx`（具体页面）

### 3.3. 字段覆盖

Next.js 会按照这个顺序，将各层元数据对象**浅合并**，计算得到最终的元数据。重复的将会根据顺序进行替换。让我们举个例子，加入根布局的 `metadata` 设置为：

```javascript
// app/layout.js
export const metadata = {
  title: 'Acme',
  openGraph: {
    title: 'Acme',
    description: 'Acme is a...',
  },
}
```

`page.js` 的设置为：

```javascript
// app/blog/page.js
export const metadata = {
  title: 'Blog',
  openGraph: {
    title: 'Blog',
  },
}
 
// 输出:
// <title>Blog</title>
// <meta property="og:title" content="Blog" />
```

在这个例子中：

1.  `app/layout.js` 中的 `title` 被 `app/blog/page.js` 中的 `title` 替换
2.  `app/layout.js` 中的 `openGraph` 字段被 `app/blog/page.js` 中的 `openGraph` 替换，注意因为是浅合并，所以 `description` 字段丢失了。

如果你想在多个路由之间共享一些字段，那你可以将他们提取到一个单独的变量中，比如在 `app`下建立一个 `shared-metadata.js`文件共享的字段：

```javascript
// app/shared-metadata.js
export const openGraphImage = { images: ['http://...'] }
```

当需要使用时：

```javascript
// app/page.js 
import { openGraphImage } from './shared-metadata'
 
export const metadata = {
  openGraph: {
    ...openGraphImage,
    title: 'Home',
  },
}
```

```javascript
// app/about/page.js
import { openGraphImage } from '../shared-metadata'
 
export const metadata = {
  openGraph: {
    ...openGraphImage,
    title: 'About',
  },
}
```

在这个例子中，OG 图片在 `app/layout.js` 和 `app/about/page.js` 中共享，然而 `title` 却是不同的。

### 3.4. 字段继承

比如根布局的设置为：

```javascript
// app/layout.js
export const metadata = {
  title: 'Acme',
  openGraph: {
    title: 'Acme',
    description: 'Acme is a...',
  },
}
```

页面的设置为：

```javascript
// app/about/page.js
export const metadata = {
  title: 'About',
}
 
// 输出:
// <title>About</title>
// <meta property="og:title" content="Acme" />
// <meta property="og:description" content="Acme is a..." />
```

在这个例子中：

*   `app/layout.js` 中的 `title` 被 `app/about/page.js` 中的 `title` 替代
*   `app/layout.js` 中的所有 `openGraph` 字段被 `app/about/page.js` 继承，因为 `app/about/page.js` 没有设置 `openGraph` 字段

## 4. JSON-LD

### 4.1 介绍

JSON-LD，英文全称：`JavaScript Object Notation for Linked Data`，当然这个太“全”了，稍微简写一点就是 `JSON for Linking Data`，官方文档地址：[json-ld.org/](https://link.juejin.cn?target=https%3A%2F%2Fjson-ld.org%2F)，是一种基于 JSON 的数据格式，用于向 Google 和其他搜索引擎描述网站上的内容。

比如如果我们在 Google 搜索 「Chocolate in a mug」，我们会看到这样的搜索结果：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b52b7f8ab794983b616499bd121855c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512\&h=551\&s=37338\&e=webp\&b=212327)

这个搜索结果有评分（4.5）、评价（581条）等内容，我们打开页面，就可以看到搜索展示的这个内容其实对应了 `application/ld+json` 中的内容：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5305016c5a9a4739b34f1338fd5ea6bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512\&h=391\&s=112846\&e=webp\&b=f5f2f1)

### 4.2 正常添加

如果我们也要实现这样的效果，方便搜索引擎展现，该怎么做呢？

在页面加入这种结构化数据的方法很简单，只用在页面添加这样一段脚本就可以了：

```html
<script type="application/ld+json">
  // ...
</script>
```

具体里面的内容需要参考比如 Google 搜索中心提供的[《结构化数据常规指南》](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fsearch%2Fdocs%2Fadvanced%2Fstructured-data%2Fsd-policies)，如果你写的是文章，参考 [Article 章节](https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fsearch%2Fdocs%2Fadvanced%2Fstructured-data%2Farticle)后，可以写入以下这些属性：

```html
<script type="application/ld+json">
  {
  "@context": "https://schema.org",
  "@type": "Article",
  "headline": "这里填写标题",
  "image": [
  "https://ts.yayujs.com/icon-144x144.png"
  ],
  "datePublished": "2021-11-10T22:06:06.000Z",
  "dateModified": "2022-03-04T16:00:00.000Z",
  "author": [{
  "@type": "Person",
  "name": "冴羽",
  "url": "https://github.com/mqyqingfeng/Blog"
  }]
  }
</script>
```

### 4.3 Next.js 添加

如何在 Next.js 中添加 JOSN-LD 呢？Next.js 推荐在 `layout.js`或 `page.js`组件中使用 `<script>` 标签，使用示例如下：

```javascript
// app/products/[id]/page.js
export default async function Page({ params }) {
  const product = await getProduct(params.id)
 
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'Product',
    name: product.name,
    image: product.image,
    description: product.description,
  }
 
  return (
    <section>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      {/* ... */}
    </section>
  )
}
```

如果你使用 TypeScript，可以配合使用 [schema-dts](https://www.npmjs.com/package/schema-dts) 这个包：

```javascript
import { Product, WithContext } from 'schema-dts'
 
const jsonLd: WithContext<Product> = {
  '@context': 'https://schema.org',
  '@type': 'Product',
  name: 'Next.js Sticker',
  image: 'https://nextjs.org/imgs/sticker.png',
  description: 'Dynamic at the speed of static.',
}
```

添加 JSON-LD 并部署后，你可以使用 <https://search.google.com/test/rich-results> 来测试网页是否支持富媒体搜索结果，使用 <https://validator.schema.org/> 测试页面的结构化数据，输入 `https://yayujs.com`试试。

## 5. Metadata 字段

接下来我们来介绍下 Metadata 对象的字段有哪些，由于字段很多，你可以先了解一下有哪些，需要使用的时候再查找使用。每个字段都配有使用的例子。

### 5.1. title

设置文档的标题，该值可以是一个简单的字符串，也可以是一个可选的模板对象。

#### 5.1.1. 字符串

先说字符串：

```javascript
// layout.js | page.js
export const metadata = {
  title: 'Next.js',
}
```

注意在 `layout.js` 和 `page.js` 中都可以定义，输出结果为：

```javascript
<title>Next.js</title>
```

#### 5.1.2. 模板对象

再说模板对象：

```javascript
// app/layout.js 
export const metadata = {
  title: {
    default: '...',
    template: '...',
    absolute: '...',
  },
}
```

其中 `default`为没有定义 `title` 的子路由提供一个备用 title：

```javascript
// app/layout.tsx
export const metadata = {
  title: {
    default: 'Acme',
  },
}
```

```javascript
// app/about/page.tsx
export const metadata = {}
 
// Output: <title>Acme</title>
```

`template` 可用于为子路由的 `title` 添加一个前缀或者后缀，比如：

```javascript
// app/layout.js
export const metadata = {
  title: {
    template: '%s | Acme',
    default: 'Acme', // 设置 template 的时候，default 必传
  },
}
```

```javascript
// app/about/page.js
export const metadata = {
  title: 'About',
}
 
// Output: <title>About | Acme</title>
```

使用 `template` 的时候要注意：

1.  使用 `title.template` 的时候，`title.default` 是必要的
2.  定义在 `layout.js` 中的 `title.template` 不会应用于同级的 `page.js` 中的 `title`
3.  定义在 `page.js` 中的 `title.template` 不会有效果，因为页面没有子路由段。
4.  如果路由没有定义 `title` 或者 `title.default`，`title.template` 是不生效的

`absolute`用于设置标题，但会忽略父路由段中设置的 `title.template`：

```javascript
// app/layout.js
export const metadata = {
  title: {
    template: '%s | Acme',
  },
}
```

```javascript
// app/about/page.js
export const metadata = {
  title: {
    absolute: 'About',
  },
}
 
// Output: <title>About</title>
```

这三个值在 `layout.js` 和 `page.js` 中的表现会有不同，让我们细致梳理一下：

在 `layout.js` 中：

1.  `title`（字符串）和 `title.default` 定义的是未设置标题的子路由段的默认标题。它会根据最近的父路由段中的 `title.template` 进行拓展。举个例子：

```javascript
// app/layout.js
export const metadata = {
  title: {
    default: 'home',
    template: '%s | Home'
  }
}
```

```javascript
// app/about/layout.js
export const metadata = {
  title: {
    default: 'about'
  }
}
```

如果 `/about/company`没有定义自己标题，那它的标题为：`about | Home`。而如果最近的父路由段没有定义 `title.template`，那就不进行拓展。

PS：不过根据 demo 测试，如果 `app/layout.js` 如上相同设置，`app/about/layout.js` 不设置，`app/about/company/layout.js` 设置 `default: 'company'`，访问 `/about/company/members`时，标题为 `company | Home`，也就是说实际的测试结果是如果完全不设置 metadata，默认标题会根据最近的存在的 `title.template` 进行扩展，并不一定是最近的父路由段中的 `title.template`。

2.  `title.absolute` 定义子路由段的默认标题，它会忽略来自父路由段的 `title.template`，也就是说即使最近的父路由段有 `title.template`，也不进行拓展（所以才叫 "absoulte" 绝对标题）
3.  `title.template` 为子路由段定义一个新标题模板，也就是说即使每层 layout 都设置了 `title.template`，也不会出现 `xxx | Company | About | Home` 这种标题，设置标题的子路由段只会根据父路由段的 `title.template` 进行设置。

在 `page.js` 中：

1.  如果一个页面没有定义自己的标题，它会使用最近的父级解析标题，注意是“最近的‘父级解析标题’”，而非“‘最近的父级’解析标题”。

PS：根据 demo 测试，如果 `page.js` 未设置 `title`，会优先使用同级 `layout.js` 中设置的 `title`，包括字符串、`title.default` 和` title.abslolute` 的方式。

如果祖先 `layout.js` 中只有一层设置了标题，而其他都未设置，页面的标题会使用该标题，比如 `app/layout.js`中设置 `title: 'home'`，`app/about/company/members`中的各层 `layout.js`都未设置，`/about/company/members` 的 `title` 为 `home`。欢迎写 demo 验证。

2.  如果 `page.js` 定义了路由 title（字符串），它会根据最近的父路由段中的 title.template 进行拓展。

PS：不过根据 demo 测试，如同 `layout.js`，如果父级完全不设置 metadata，标题会根据最近的存在的 `title.template` 进行扩展，并不一定是最近的父路由段中的 `title.template`。

换句话说，如果不设置 `layout.js` 的 `metadata`，在标题的处理上，相当于这层不存在。

3.  使用 `title.absolute` 定义路由标题，它会忽略父路由段中的 `title.template`.
4.  `page.js` 中设置 `title.template`没有效果。

总之，在使用的时候，尽可能保证每个页面都有设置 title，就不会遇到奇怪的逻辑了。

### 5.2. description

设置页面的描述：

```javascript
// layout.js | page.js
export const metadata = {
  description: 'The React Framework for the Web',
}
```

输出的 HTML 为：

```javascript
<meta name="description" content="The React Framework for the Web" />
```

### 5.3. 基础字段

```javascript
// layout.js | page.js
export const metadata = {
  generator: 'Next.js',
  applicationName: 'Next.js',
  referrer: 'origin-when-cross-origin',
  keywords: ['Next.js', 'React', 'JavaScript'],
  authors: [{ name: 'Seb' }, { name: 'Josh', url: 'https://nextjs.org' }],
  creator: 'Jiachi Liu',
  publisher: 'Sebastian Markbåge',
  formatDetection: {
    email: false,
    address: false,
    telephone: false,
  },
}
```

输出的 HTML 为：

```html
<meta name="application-name" content="Next.js" />
<meta name="author" content="Seb" />
<link rel="author" href="https://nextjs.org" />
<meta name="author" content="Josh" />
<meta name="generator" content="Next.js" />
<meta name="keywords" content="Next.js,React,JavaScript" />
<meta name="referrer" content="origin-when-cross-origin" />
<meta name="color-scheme" content="dark" />
<meta name="creator" content="Jiachi Liu" />
<meta name="publisher" content="Sebastian Markbåge" />
<meta name="format-detection" content="telephone=no, address=no, email=no" />
```

### 5.4. metadataBase

设置 metadata 字段中地址的 URL 前缀，看个例子就明白了：

```javascript
// layout.js | page.js
export const metadata = {
  metadataBase: new URL('https://acme.com'),
  alternates: {
    canonical: '/',
    languages: {
      'en-US': '/en-US',
      'de-DE': '/de-DE',
    },
  },
  openGraph: {
    images: '/og-image.png',
  },
}
```

输出的 HTML 为：

```html
<link rel="canonical" href="https://acme.com" />
<link rel="alternate" hreflang="en-US" href="https://acme.com/en-US" />
<link rel="alternate" hreflang="de-DE" href="https://acme.com/de-DE" />
<meta property="og:image" content="https://acme.com/og-image.png" />
```

关于 `metadataBase` 和 `metadata`，Next.js 会自动处理，并不是简单的字符串拼接，比如当你设置 `metadataBase`为：

```javascript
// app/layout.js
export const metadata = {
  metadataBase: new URL('https://acme.com'),
}
```

如果你传入 `metadata` 的值为：

| **metadata 字段**                  | **解析 URL**                       |
| -------------------------------- | -------------------------------- |
| /                                | <https://acme.com>               |
| ./                               | <https://acme.com>               |
| payments                         | <https://acme.com/payments>      |
| /payments                        | <https://acme.com/payments>      |
| ./payments                       | <https://acme.com/payments>      |
| ../payments                      | <https://acme.com/payments>      |
| <https://beta.acme.com/payments> | <https://beta.acme.com/payments> |

其他关于 metadataBase：

1.  `metadataBase` 通常设置在`app/layout.js`，应用于所有路由
2.  `metadataBase` 可以设置的更具体，比如 `https://app.acme.com`、`https://acme.com/start/from/here`等
3.  如果 `metadata` 提供了绝对地址，`metadataBase` 就会被忽略
4.  在没有配置 `metadataBase` 的时候，`metadata` 使用相对地址会报错
5.  Next.js 会在 `metadataBase` 和相对地址间处理多余的斜线，比如 `metadataBase` 为 `https://acme.com/`，`metadata` 为 `/path`，Next.js 也能正确处理为 `https://acme.com/path`。

### 5.5. openGraph

```javascript
// layout.js | page.js
export const metadata = {
  openGraph: {
    title: 'Next.js',
    description: 'The React Framework for the Web',
    url: 'https://nextjs.org',
    siteName: 'Next.js',
    images: [
      {
        url: 'https://nextjs.org/og.png',
        width: 800,
        height: 600,
      },
      {
        url: 'https://nextjs.org/og-alt.png',
        width: 1800,
        height: 1600,
        alt: 'My custom alt',
      },
    ],
    locale: 'en_US',
    type: 'website',
  },
}
```

输出的 HTML 为：

```javascript
<meta property="og:title" content="Next.js" />
<meta property="og:description" content="The React Framework for the Web" />
<meta property="og:url" content="https://nextjs.org/" />
<meta property="og:site_name" content="Next.js" />
<meta property="og:locale" content="en_US" />
<meta property="og:image:url" content="https://nextjs.org/og.png" />
<meta property="og:image:width" content="800" />
<meta property="og:image:height" content="600" />
<meta property="og:image:url" content="https://nextjs.org/og-alt.png" />
<meta property="og:image:width" content="1800" />
<meta property="og:image:height" content="1600" />
<meta property="og:image:alt" content="My custom alt" />
<meta property="og:type" content="website" />
```

```javascript
export const metadata = {
  openGraph: {
    title: 'Next.js',
    description: 'The React Framework for the Web',
    type: 'article',
    publishedTime: '2023-01-01T00:00:00.000Z',
    authors: ['Seb', 'Josh'],
  },
}
```

输出的 HTML 为：

```html
<meta property="og:title" content="Next.js" />
<meta property="og:description" content="The React Framework for the Web" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-01-01T00:00:00.000Z" />
<meta property="article:author" content="Seb" />
<meta property="article:author" content="Josh" />
```

### 5.6. robots

```javascript
// layout.js | page.js
export const metadata = {
  robots: {
    index: false,
    follow: true,
    nocache: true,
    googleBot: {
      index: true,
      follow: false,
      noimageindex: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
}
```

输出的 HTML 为：

```javascript
<meta name="robots" content="noindex, follow, nocache" />
<meta
  name="googlebot"
  content="index, nofollow, noimageindex, max-video-preview:-1, max-image-preview:large, max-snippet:-1"
/>
```

### 5.7. icons

```javascript
// layout.js | page.js
export const metadata = {
  icons: {
    icon: '/icon.png',
    shortcut: '/shortcut-icon.png',
    apple: '/apple-icon.png',
    other: {
      rel: 'apple-touch-icon-precomposed',
      url: '/apple-touch-icon-precomposed.png',
    },
  },
}
```

输出的 HTML 为：

```javascript
<link rel="shortcut icon" href="/shortcut-icon.png" />
<link rel="icon" href="/icon.png" />
<link rel="apple-touch-icon" href="/apple-icon.png" />
<link
  rel="apple-touch-icon-precomposed"
  href="/apple-touch-icon-precomposed.png"
/>
```

```javascript
export const metadata = {
  icons: {
    icon: [{ url: '/icon.png' }, new URL('/icon.png', 'https://example.com')],
    shortcut: ['/shortcut-icon.png'],
    apple: [
      { url: '/apple-icon.png' },
      { url: '/apple-icon-x3.png', sizes: '180x180', type: 'image/png' },
    ],
    other: [
      {
        rel: 'apple-touch-icon-precomposed',
        url: '/apple-touch-icon-precomposed.png',
      },
    ],
  },
}
```

输出的 HTML 为：

```javascript
<link rel="shortcut icon" href="/shortcut-icon.png" />
<link rel="icon" href="/icon.png" />
<link rel="apple-touch-icon" href="/apple-icon.png" />
<link
  rel="apple-touch-icon-precomposed"
  href="/apple-touch-icon-precomposed.png"
/>
<link rel="icon" href="https://example.com/icon.png" />
<link
  rel="apple-touch-icon"
  href="/apple-icon-x3.png"
  sizes="180x180"
  type="image/png"
/>
```

### 5.8. themeColor

metadata 中的 themeColor 已废弃，使用 [viewport 配置项](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-5)

### 5.9. manifest

```javascript
// layout.js | page.js
export const metadata = {
  manifest: 'https://nextjs.org/manifest.json',
}
```

输出的 HTML 为：

```javascript
<link rel="manifest" href="https://nextjs.org/manifest.json" />
```

### 5.10. twitter

```javascript
// layout.js | page.js
export const metadata = {
  twitter: {
    card: 'summary_large_image',
    title: 'Next.js',
    description: 'The React Framework for the Web',
    siteId: '1467726470533754880',
    creator: '@nextjs',
    creatorId: '1467726470533754880',
    images: ['https://nextjs.org/og.png'],
  },
}
```

输出的 HTML 为：

```javascript
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site:id" content="1467726470533754880" />
<meta name="twitter:creator" content="@nextjs" />
<meta name="twitter:creator:id" content="1467726470533754880" />
<meta name="twitter:title" content="Next.js" />
<meta name="twitter:description" content="The React Framework for the Web" />
<meta name="twitter:image" content="https://nextjs.org/og.png" />
```

```javascript
// layout.js | page.js
export const metadata = {
  twitter: {
    card: 'app',
    title: 'Next.js',
    description: 'The React Framework for the Web',
    siteId: '1467726470533754880',
    creator: '@nextjs',
    creatorId: '1467726470533754880',
    images: {
      url: 'https://nextjs.org/og.png',
      alt: 'Next.js Logo',
    },
    app: {
      name: 'twitter_app',
      id: {
        iphone: 'twitter_app://iphone',
        ipad: 'twitter_app://ipad',
        googleplay: 'twitter_app://googleplay',
      },
      url: {
        iphone: 'https://iphone_url',
        ipad: 'https://ipad_url',
      },
    },
  },
}
```

输出的 HTML 为：

```javascript
<meta name="twitter:site:id" content="1467726470533754880" />
<meta name="twitter:creator" content="@nextjs" />
<meta name="twitter:creator:id" content="1467726470533754880" />
<meta name="twitter:title" content="Next.js" />
<meta name="twitter:description" content="The React Framework for the Web" />
<meta name="twitter:card" content="app" />
<meta name="twitter:image" content="https://nextjs.org/og.png" />
<meta name="twitter:image:alt" content="Next.js Logo" />
<meta name="twitter:app:name:iphone" content="twitter_app" />
<meta name="twitter:app:id:iphone" content="twitter_app://iphone" />
<meta name="twitter:app:id:ipad" content="twitter_app://ipad" />
<meta name="twitter:app:id:googleplay" content="twitter_app://googleplay" />
<meta name="twitter:app:url:iphone" content="https://iphone_url" />
<meta name="twitter:app:url:ipad" content="https://ipad_url" />
<meta name="twitter:app:name:ipad" content="twitter_app" />
<meta name="twitter:app:name:googleplay" content="twitter_app" />
```

### 5.11. viewport

Next.js 14 起已废弃，使用 [viewport 配置项](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-5)

### 5.12. verification

```javascript
// layout.js | page.js
export const metadata = {
  verification: {
    google: 'google',
    yandex: 'yandex',
    yahoo: 'yahoo',
    other: {
      me: ['my-email', 'my-link'],
    },
  },
}
```

输出的 HTML 为：

```javascript
<meta name="google-site-verification" content="google" />
<meta name="y_key" content="yahoo" />
<meta name="yandex-verification" content="yandex" />
<meta name="me" content="my-email" />
<meta name="me" content="my-link" />
```

### 5.13. appleWebApp

```javascript
// layout.js | page.js
export const metadata = {
  itunes: {
    appId: 'myAppStoreID',
    appArgument: 'myAppArgument',
  },
  appleWebApp: {
    title: 'Apple Web App',
    statusBarStyle: 'black-translucent',
    startupImage: [
      '/assets/startup/apple-touch-startup-image-768x1004.png',
      {
        url: '/assets/startup/apple-touch-startup-image-1536x2008.png',
        media: '(device-width: 768px) and (device-height: 1024px)',
      },
    ],
  },
}
```

输出的 HTML 为：

```html
<meta
  name="apple-itunes-app"
  content="app-id=myAppStoreID, app-argument=myAppArgument"
/>
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-title" content="Apple Web App" />
<link
  href="/assets/startup/apple-touch-startup-image-768x1004.png"
  rel="apple-touch-startup-image"
/>
<link
  href="/assets/startup/apple-touch-startup-image-1536x2008.png"
  media="(device-width: 768px) and (device-height: 1024px)"
  rel="apple-touch-startup-image"
/>
<meta
  name="apple-mobile-web-app-status-bar-style"
  content="black-translucent"
/>
```

### 5.14. alternates

```javascript
// layout.js | page.js
export const metadata = {
  alternates: {
    canonical: 'https://nextjs.org',
    languages: {
      'en-US': 'https://nextjs.org/en-US',
      'de-DE': 'https://nextjs.org/de-DE',
    },
    media: {
      'only screen and (max-width: 600px)': 'https://nextjs.org/mobile',
    },
    types: {
      'application/rss+xml': 'https://nextjs.org/rss',
    },
  },
}
```

输出的 HTML 为：

```javascript
<link rel="canonical" href="https://nextjs.org" />
<link rel="alternate" hreflang="en-US" href="https://nextjs.org/en-US" />
<link rel="alternate" hreflang="de-DE" href="https://nextjs.org/de-DE" />
<link
  rel="alternate"
  media="only screen and (max-width: 600px)"
  href="https://nextjs.org/mobile"
/>
<link
  rel="alternate"
  type="application/rss+xml"
  href="https://nextjs.org/rss"
/>
```

### 5.15. appLinks

```javascript
// layout.js | page.js
export const metadata = {
  appLinks: {
    ios: {
      url: 'https://nextjs.org/ios',
      app_store_id: 'app_store_id',
    },
    android: {
      package: 'com.example.android/package',
      app_name: 'app_name_android',
    },
    web: {
      url: 'https://nextjs.org/web',
      should_fallback: true,
    },
  },
}
```

输出的 HTML 为：

```html
<meta property="al:ios:url" content="https://nextjs.org/ios" />
<meta property="al:ios:app_store_id" content="app_store_id" />
<meta property="al:android:package" content="com.example.android/package" />
<meta property="al:android:app_name" content="app_name_android" />
<meta property="al:web:url" content="https://nextjs.org/web" />
<meta property="al:web:should_fallback" content="true" />
```

### 5.16. archives

```javascript
// layout.js | page.js
export const metadata = {
  archives: ['https://nextjs.org/13'],
}
```

输出的 HTML 为：

```html
<link rel="archives" href="https://nextjs.org/13" />
```

### 5.17. assets

```javascript
// layout.js | page.js
export const metadata = {
  assets: ['https://nextjs.org/assets'],
}
```

输出的 HTML 为：

```html
<link rel="assets" href="https://nextjs.org/assets" />
```

### 5.18. bookmarks

```javascript
// layout.js | page.js
export const metadata = {
  bookmarks: ['https://nextjs.org/13'],
}
```

输出的 HTML 为：

```javascript
<link rel="bookmarks" href="https://nextjs.org/13" />
```

### 5.19. category

```javascript
// layout.js | page.js
export const metadata = {
  category: 'technology',
}
```

输出的 HTML 为：

```html
<meta name="category" content="technology" />
```

### 其他

所有的 metadata 选项都可以通过像本节介绍的这种方式直接覆盖，Next.js 内部已经定义了这些字段。然而你也可能会想自定义一些 metadata 标签，此时就可以使用 other 选项：

```javascript
export const metadata = {
  other: {
    custom: 'meta',
  },
}
```

输出的 HTML 为：

```html
<meta name="custom" content="meta" />
```

## 参考链接

1.  [Optimizing: Metadata](https://nextjs.org/docs/app/building-your-application/optimizing/metadata)
2.  [Metadata - MDN Web 文档术语表：Web 相关术语的定义 | MDN](https://developer.mozilla.org/zh-CN/docs/Glossary/Metadata)
3.  [“头”里有什么——HTML 元信息 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML)
4.  [https://nextjs.org/docs/app/api-reference/functions/generate-metadata](https://nextjs.org/docs/app/api-reference/functions/generate-metadata)


## 25.Metadata 篇 | 基于文件

## 前言

上篇我们讲到添加元数据的方法分为两类：

1.  基于配置的元数据：在 `layout.js`或 `page.js`中导出一个静态 `metadata` 对象或者一个动态的 `generateMetadata` 函数。
2.  基于文件的元数据：添加一个静态或者动态生成的特殊文件

其中基于文件的元数据可以用来添加网站的应用图标、OG 图片、robots.txt、sitemap.xml、manifest.json。本篇我们详细讲解具体的用法和配置内容。

## 1. favicon、icon 和 apple-icon

### 1.1. 介绍

Next.js 约定 `favicon`、`icon`、`apple-icon`文件都可以用来设置应用的图标。它们可以设置浏览器标签页中的图标、收藏夹（书签）中的图标、手机屏幕图标、搜索引擎结果中的图标等等。

有两种方式可以设置图标：

1.  使用静态文件
2.  使用代码生成

让我们一一开始介绍。

### 1.2. 使用静态文件

#### 1.2.1. 文件约定

在 `/app`目录下放置一个名为 `favicon`、`icon` 或者 `apple-icon`图片文件即可设置图标。

它们之间的区别在于 `favicon` 图片只能位于 `app/` 根目录（当然这样说不太严谨，考虑到路由组的存在，准确的说应该是顶层）。`icon` 可以放在更深层的目录里，更精细的设置图标。`apple-icon` 则顾名思义，设置在苹果设备中显示的图标。这三种文件对应的图片格式、生效目录、和 `rel` 属性如下：

| 文件名称                                                                                                   | 支持的图片格式                             | 生效目录       | 对应 `<link>` 标签 `rel` 属性         |
| ------------------------------------------------------------------------------------------------------ | ----------------------------------- | ---------- | ------------------------------- |
| [favicon](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons#favicon)       | `.ico`                              | `app/`     | `<link rel="icon" />`             |
| [icon](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons#icon)             | `.ico`、`.jpg`、`.jpeg`、`.png`、`.svg` | `app/**/*` | `<link rel="icon" />`             |
| [apple-icon](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons#apple-icon) | `.jpg`、`.jpeg`、`.png`               | `app/**/*` | `<link rel="apple-touch-icon" />` |

#### 1.2.2. favicon

favicon 是 favorites icon 的缩写，用于设置网站或网页相关的图标。最早定义 favicon 的方式是将一个名为 `favicon.ico`的文件放在服务器根目录下，浏览器会在加载网页的时候，请求 `/favicon.ico`文件作为图标。后来才出现了使用 `<link>` 标签这种更为灵活的方法：

```html
<link rel="icon" href="/favicon.ico" />
```

目前大多数浏览器都支持这两种方法，在 Next.js 中分别对应着使用 favicon 和使用 icon 文件。

在 `/app`下添加一个名为 `favicon.ico`的图片文件，对应 HTML 输出为：

```html
<link rel="icon" href="/favicon.ico" sizes="any" />
```

注意其中 `sizes="any"`，这是为了避免一个[浏览器 bug](https://evilmartians.com/chronicles/how-to-favicon-in-2021-six-files-that-fit-most-needs) 而特意这样写的。添加文件后，你可以通过访问 `/favicon.ico`（对应到本地开发的时候，地址是 `http://localhost:3000/favicon.ico` ）查看该图标文件。该图标默认会应用于网站所有路由，如果想更细粒度的控制某个网页的图标，那就用 icon。

#### 1.2.3. icon

添加一个 `icon.(ico|jpg|jpeg|png|svg)`图片文件，对应 HTML 输出为：

```html
<link
  rel="icon"
  href="/icon?<generated>"
  type="image/<generated>"
  sizes="<generated>"
/>
```

#### 1.2.4. apple-icon

apple-icon，顾名思义，针对苹果设备使用的图标，用于将网页添加到 iPhone 或 iPad 屏幕快捷方式时使用的图标。添加一个 `apple-icon.(jpg|jpeg|png)`图片文件，对应 HTML 输出为：

```html
<link
  rel="apple-touch-icon"
  href="/apple-icon?<generated>"
  type="image/<generated>"
  sizes="<generated>"
/>
```

#### 1.2.5. 行为

你可以通过在文件名中添加数字后缀设置多个图标，比如 `icon1.png`、`icon2.png`、`apple-icon1.png`、`apple-icon2.png`。

为什么会需要多个图标呢？我们在查看页面源码的时候，经常会看到这样的代码：

```html
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
```

根据设备、应用、场景的不同，会使用不同尺寸大小的图片，比如不同的浏览器、不同的场景（标签、Google 搜索结果、书签、移动端图标）、不同的系统如 IOS 和 Windows 使用的图片大小都可能不同。

而生成的 `<link>` 标签的属性如 `rel`、`href`、`type`、`sizes`是根据图标类型和文件内容生成的，比如一个 32x32 大小的 `.png`图标生成的属性有 `type="image/png"`和 `sizes="32x32"`。

你可以使用这两个网站帮助生成 icon：

1.  <https://realfavicongenerator.net/>
2.  <https://www.favicon.cc/>

### 1.3. 使用代码生成

#### 1.3.1. 介绍

除了直接使用图片文件，你也可以用代码生成图标。依然是新建一个名为 `icon` 或 `apple-icon`的文件，不过这次的后缀是 `.js`、`.ts`、`.tsx`。

最简单的生成一个图标的方式是通过 `next/og`的 `ImageResponse` API，使用示例如下：

```javascript
// app/icon.js
import { ImageResponse } from 'next/og'
 
// 路由段配置
export const runtime = 'edge'
 
// 图片 metadata
export const size = {
  width: 32,
  height: 32,
}
export const contentType = 'image/png'
 
// 图片生成
export default function Icon() {
  return new ImageResponse(
    (
      // ImageResponse JSX 元素
      <div
        style={{
          fontSize: 24,
          background: 'black',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: 'white',
        }}
      >
        A
      </div>
    ),
    // ImageResponse options
    {
      // 方便复用 size
      ...size,
    }
  )
}
```

对应输出的 HTML 为：

```html
<link rel="icon" href="/icon?<generated>" type="image/png" sizes="32x32" />
```

效果为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3935cd7bad5744f6a7202ee3effec055~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=500\&h=86\&s=8014\&e=png\&b=3a3a3a)

第一次看这个例子的时候，可能会有很多疑问，`ImageResponse`是什么？怎么用？其中的写法怎么这么奇怪？配置项有哪些等等。不用着急，我们会一一讲解。

先说几点注意事项：

1.  从 v14.0.0 起，`ImageResponse` 从 `next/server`转移到 `next/og`，如果出现导入错误，那就升级版本或者使用 `next/server`
2.  默认情况下，生成的图标是静态优化的，也就是说会在构建的时候生成并缓存，除非使用了动态函数（比如 cookies()、headers() 这些）或者未缓存数据。
3.  你不能生成 `favicon` 图标。使用 icon 或者 favicon.ico 静态文件代替。
4.  你可以使用 `generateImageMetadata` API 在一个文件中生成多个 Icon。（好家伙，又多了一个要介绍的 API）

接下来我们详细介绍下涉及到的 API。

#### 1.3.2. 默认导出函数

默认导出函数接收一个可选参数 `params`，这是一个包含动态路由参数的对象，与上一篇介绍 `generateMetadata` 中的 `params` 参数一样：

```jsx
// app/shop/[slug]/icon.js
export default function Image({ params }) {
  // ...
}
```

| **Route**                       | **URL**     | **params**               |
| ------------------------------- | ----------- | ------------------------- |
| `app/shop/icon.js`              | `/shop`     | `{}`                      |
| `app/shop/[slug]/icon.js`       | `/shop/1`   | `{ slug: '1' }`           |
| `app/shop/[tag]/[item]/icon.js` | `/shop/1/2` | `{ tag: '1', item: '2' }` |
| `app/shop/[...slug]/icon.js`    | `/shop/1/2` | `{ slug: ['1', '2'] }`    |

函数应该返回一个  [Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob) | [ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [TypedArray](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [DataView](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [ReadableStream](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream) | [Response](https://developer.mozilla.org/zh-CN/docs/Web/API/Response) 类型的值。

#### 1.3.3. 图片元数据配置

除了导出图片文件本身，你也可以选择性的导出`size`、`contentType` 变量来设置该图片的元数据：

| **Option**                                                                                                     | **Type**                                                                                                                |
| -------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| [size](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#size)               | { width: number; height: number }                                                                                       |
| [contentType](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#contenttype) | string (具体有哪些值，参考 [image MIME type](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types#image_types)） |

设置 `size`：

```javascript
// icon.js | apple-icon.js
export const size = { width: 32, height: 32 }
 
export default function Icon() {}
```

对应 HTML 输出为：

```html
<link rel="icon" sizes="32x32" />
```

设置 `contentType`：

```javascript
// icon.js | apple-icon.js
export const contentType = 'image/png'
 
export default function Icon() {}
```

对应 HTML 输出为：

```html
<link rel="icon" type="image/png" />
```

#### 1.3.4. 路由段配置

`icon` 和 `apple-icon` 其实是特殊的路由处理程序，所以它们也可以像其他页面和布局一样，使用路由段配置：

| **Option**                                                                                                         | **Type**                                                             | 默认值        |
| ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------- | ---------- |
| [dynamic](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#dynamic)                 | `'auto' &#124; 'force-dynamic' &#124; 'error' &#124; 'force-static'` | `'auto'`   |
| [revalidate](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#revalidate)           | `false &#124; 'force-cache' &#124; 0 &#124; number`                  | `false`    |
| [runtime](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#runtime)                 | `'nodejs' &#124; 'edge'`                                             | `'nodejs'` |
| [preferredRegion](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config#preferredregion) | `'auto' &#124; 'global' &#124; 'home' &#124; string &#124; string[]` | `'auto'`   |

使用示例如下：

```javascript
// app/icon.js
export const runtime = 'edge'
 
export default function Icon() {}
```

### 1.4. ImageResponse

关于 `ImageResponse` 构造函数，它可以帮助你使用 JSX 和 CSS 生成动态图片，这对于生成社交媒体图片（Open Graph 图像、Twitter 卡片等）非常有用，因为这些图片往往依赖于动态的内容。

`ImageResponse` 的 Type 为：

```typescript
import { ImageResponse } from 'next/og'
 
new ImageResponse(
  element: ReactElement,
  options: {
    width?: number = 1200
    height?: number = 630
    emoji?: 'twemoji' | 'blobmoji' | 'noto' | 'openmoji' = 'twemoji',
    fonts?: {
      name: string,
      data: ArrayBuffer,
      weight: number,
      style: 'normal' | 'italic'
    }[]
    debug?: boolean = false
 
    // Options that will be passed to the HTTP response
    status?: number = 200
    statusText?: string
    headers?: Record<string, string>
  },
)
```

在具体的实现上，其实用的是 Vercel 自家产品 [satori](https://github.com/vercel/satori)，这是一个支持 JSX，将 HTML 和 CSS 转为 SVG 的库，所以关于 ImageResponse 具体如何写，支持哪些 HTML 和 CSS，参考 [satori 的文档](https://github.com/vercel/satori#html-elements)即可。

还有一个 `generateImageMetadata` API ，搭配默认导出函数，可以生成多张图片，下节结束后会讲到。

## 2. opengraph-image 和 twitter-image

### 2.1. 介绍

关于 opengraph 的具体作用可以参考我写的《[VuePress 博客之 SEO 优化（四） Open Graph protocol](https://juejin.cn/post/7073416301720371213)》。

简单的来说，按照 Open Graph Protocol 这个协议描述页面信息，社交网站（如 Facebook）就会按照页面上 og 标签的内容呈现给用户。twitter-image 作用类似，只不过是用于 twitter。

使用方式有两种，一种是静态图片文件，一种是使用代码生成。

### 2.2. 静态文件

与添加图标文件一样，直接在路由文件夹下添加对应的图片即可，只不过约定的文件名和支持的格式不同：

| 文件名称                                                                                                                             | 支持的图片格式                        |
| -------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| [opengraph-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#opengraph-image)           | `.jpg`、`.jpeg`、 `.png`、 `.gif` |
| [twitter-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#twitter-image)               | `.jpg`、`.jpeg`、`.png`、`.gif`   |
| [opengraph-image.alt](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#opengraph-imagealttxt) | `.txt`                         |
| [twitter-image.alt](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#twitter-imagealttxt)     | `.txt`                         |

#### 2.2.1. opengraph-image

添加一个 `opengraph-image.(jpg|jpeg|png|gif)`图片文件，对应 HTML 输出为：

```html
<meta property="og:image" content="<generated>" />
<meta property="og:image:type" content="<generated>" />
<meta property="og:image:width" content="<generated>" />
<meta property="og:image:height" content="<generated>" />
```

#### 2.2.2 twitter-image

添加一个 `twitter-image.(jpg|jpeg|png|gif)`图片文件，对应 HTML 输出为：

```html
<meta name="twitter:image" content="<generated>" />
<meta name="twitter:image:type" content="<generated>" />
<meta name="twitter:image:width" content="<generated>" />
<meta name="twitter:image:height" content="<generated>" />
```

#### 2.2.3. opengraph-image.alt.txt

当使用 `opengraph-image.(jpg|jpeg|png|gif)`图片的时候，再添加一个 `opengraph-image.alt.txt`作为该图片的 alt 文字：

```html
About Acme
```

对应输出的 HTML 为：

```html
<meta property="og:image:alt" content="About Acme" />
```

#### 2.2.4. twitter-image.alt.txt

当使用 `twitter-image.(jpg|jpeg|png|gif)`图片的时候，再添加一个 `twitter-image.alt.txt`作为该图片的 alt 文字：

```html
About Acme
```

对应输出的 HTML 为：

```html
<meta property="twitter:image:alt" content="About Acme" />
```

### 2.3. 代码生成

#### 2.3.1 介绍

想必你已经知道该怎么做了：

| 文件名             | 支持的文件格式            |
| --------------- | ------------------ |
| opengraph-image | `.js`、`.ts`、`.tsx` |
| twitter-image   | `.js`、`.ts`、`.tsx` |

代码与上节的图标图片生成类似，默认导出函数、路由段配置都相同，图片元数据配置上略有差别。示例代码如下：

```javascript
// app/about/opengraph-image.js
import { ImageResponse } from 'next/og'
 
export const runtime = 'edge'

export const alt = 'About Acme'
export const size = {
  width: 1200,
  height: 630,
}
 
export const contentType = 'image/png'
 
export default async function Image() {
  // Font
  const interSemiBold = fetch(
    new URL('./Inter-SemiBold.ttf', import.meta.url)
  ).then((res) => res.arrayBuffer())
 
  return new ImageResponse(
    (
      <div
        style={{
          fontSize: 128,
          background: 'white',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        About Acme
      </div>
    ),
    {
      ...size,
      fonts: [
        {
          name: 'Inter',
          data: await interSemiBold,
          style: 'normal',
          weight: 400,
        },
      ],
    }
  )
}
```

这个例子顺便演示了如何使用字体文件生成图片，对应输出的 HTML 为：

```html
<meta property="og:image" content="<generated>" />
<meta property="og:image:alt" content="About Acme" />
<meta property="og:image:type" content="image/png" />
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />
```

#### 2.3.2. 图片元数据配置

除了导出图片文件本身，你也可以选择性的导出 `alt`、`size`、`contentType` 变量来设置该图片的元数据：

| **Option**                                                                                                     | **Type**                                                                                                                |
| -------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| [alt](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#alt)                 | string                                                                                                                  |
| [size](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#size)               | { width: number; height: number }                                                                                       |
| [contentType](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image#contenttype) | string (具体有哪些值，参考 [image MIME type](https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types#image_types)） |

相比图标，多了一个 `alt` 变量。设置 `alt`：

```javascript
// opengraph-image.js | twitter-image.js
export const alt = 'My images alt text'
 
export default function Image() {}
```

对应 HTML 输出为：

```html
<meta property="og:image:alt" content="My images alt text" />
```

设置 `size`：

```javascript
// opengraph-image.js | twitter-image.js
export const size = { width: 1200, height: 630 }
 
export default function Image() {}
```

对应 HTML 输出为：

```html
<meta property="og:image:width" content="1200" />
<meta property="og:image:height" content="630" />
```

设置 `contentType`：

```javascript
export const contentType = 'image/png'
 
export default function Image() {}
```

对应 HTML 输出为：

```html
<meta property="og:image:type" content="image/png" />
```

#### 2.3.3. 使用外部数据

图标的生成往往不需要使用外部数据，但是 opengraph-image 和 twitter-image 可能需要，比如当我们访问 `/posts/1`的时候，可以获取该文章的信息，然后使用文章的标题生成一张图片：

```javascript
// app/posts/[slug]/opengraph-image.js
import { ImageResponse } from 'next/og'
 
export const runtime = 'edge'
 
export const alt = 'About Acme'
export const size = {
  width: 1200,
  height: 630,
}
export const contentType = 'image/png'
 
export default async function Image({ params }) {
  const post = await fetch(`https://.../posts/${params.slug}`).then((res) =>
    res.json()
  )
 
  return new ImageResponse(
    (
      <div
        style={{
          fontSize: 48,
          background: 'white',
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        {post.title}
      </div>
    ),
    {
      ...size,
    }
  )
}
```

## 3. generateImageMetadata 生成多张图片

使用 `generateImageMetadata` 可以生成一张图片的不同版本或者返回多张图片。使用语法如下：

```javascript
// icon.js
export function generateImageMetadata({ params }) {
  // ...
}
```

`params` 跟本篇“默认导出函数”这节中的 `params` 用法相同，用于获取动态路由参数，就不多说了。

`generateImageMetadata` 函数应该返回一个包含图片元数据的对象数组。每一个对象必须包含一个 `id` 值:

| **Image Metadata Object** | **Type**                            |
| ------------------------- | ----------------------------------- |
| `id`                      | `string`（必传）                        |
| `alt`                     | `string`                            |
| `size`                    | `{ width: number; height: number }` |
| `contentType`             | `string`                            |

使用示例如下：

```javascript
// icon.js
import { ImageResponse } from 'next/og'
 
export function generateImageMetadata() {
  return [
    {
      contentType: 'image/png',
      size: { width: 48, height: 48 },
      id: 'small',
    },
    {
      contentType: 'image/png',
      size: { width: 72, height: 72 },
      id: 'medium',
    },
  ]
}
 
export default function Icon({ id }) {
  return new ImageResponse(
    (
      <div
        style={{
          width: '100%',
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontSize: 88,
          background: '#000',
          color: '#fafafa',
        }}
      >
        Icon {id}
      </div>
    )
  )
}
```

在这个例子中，我们生成了不同尺寸的图标图片。使用 `generateImageMetadata` 时，默认导出函数的 props 又会多一个 id 参数，可以根据 id 生成不同的图标内容。`generateImageMetadata`以数组形式定义了生成的图片数量和元数据，然后遍历该数组，将 id 参数传入默认导出函数，生成多张图片。

我们再举一个贴近实际开发的例子，假设一个产品有多张说明图，根据网址参数获取产品说明图数据，生成多张 Open Graph 图片：

```javascript
// app/products/[id]/opengraph-image.js
import { ImageResponse } from 'next/og'
import { getCaptionForImage, getOGImages } from '@/app/utils/images'
 
export async function generateImageMetadata({ params }) {
  const images = await getOGImages(params.id)
 
  return images.map((image, idx) => ({
    id: idx,
    size: { width: 1200, height: 600 },
    alt: image.text,
    contentType: 'image/png',
  }))
}
 
export default async function Image({ params, id }) {
  const productId = params.id
  const imageId = id
  // 获取图片说明
  const text = await getCaptionForImage(productId, imageId)
 
  return new ImageResponse(
    (
      <div
        style={
          {
            // ...
          }
        }
      >
        {text}
      </div>
    )
  )
}
```

## 4. robots.txt

### 4.1. 介绍

robots.txt 用于告诉搜索引擎可以爬取网站中的哪些 URL。使用 robots.txt 也有两种方式，一种是使用静态文件，一种是使用代码生成。

### 4.2. 静态文件

`app/` 目录下直接添加一个 `robots.txt` 即可：

```javascript
User-Agent: *
Allow: /
Disallow: /private/
Sitemap: https://acme.com/sitemap.xml
```

### 4.3. 代码生成

添加一个 `robots.js` 或 `robots.ts`文件，该文件导出一个 Robots对象。使用示例如下：

```javascript
// app/robots.js
export default function robots() {
  return {
    rules: {
      userAgent: '*',
      allow: '/',
      disallow: '/private/',
    },
    sitemap: 'https://acme.com/sitemap.xml',
  }
}
```

输出内容为：

```javascript
User-Agent: *
Allow: /
Disallow: /private/
Sitemap: https://acme.com/sitemap.xml
```

如果使用 TypeScript，Robots 对象的 type 为：

```typescript
type Robots = {
  rules:
    | {
        userAgent?: string | string[]
        allow?: string | string[]
        disallow?: string | string[]
        crawlDelay?: number
      }
    | Array<{
        userAgent: string | string[]
        allow?: string | string[]
        disallow?: string | string[]
        crawlDelay?: number
      }>
  sitemap?: string | string[]
  host?: string
}
```

## 5. sitemap.xml

### 5.1. 介绍

`sitemap.xml`，顾名思义，站点地图，用于帮助搜索引擎更高效的爬取网站。使用方式依然是两种，一种使用静态文件，一种使用代码生成。

### 5.2. 静态文件
`app/sitemap.xml`：
```xml
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://acme.com</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>yearly</changefreq>
    <priority>1</priority>
  </url>
  <url>
    <loc>https://acme.com/about</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>https://acme.com/blog</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.5</priority>
  </url>
</urlset>
```

### 5.3. 代码生成

添加一个 `sitemap.js`或 `sitemap.ts`文件，该文件导出一个 Sitemap 对象。使用示例如下：

```javascript
// app/sitemap.js
export default function sitemap() {
  return [
    {
      url: 'https://acme.com',
      lastModified: new Date(),
      changeFrequency: 'yearly',
      priority: 1,
    },
    {
      url: 'https://acme.com/about',
      lastModified: new Date(),
      changeFrequency: 'monthly',
      priority: 0.8,
    },
    {
      url: 'https://acme.com/blog',
      lastModified: new Date(),
      changeFrequency: 'weekly',
      priority: 0.5,
    },
  ]
}
```

对应的输出为：

```xml
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>https://acme.com</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>yearly</changefreq>
    <priority>1</priority>
  </url>
  <url>
    <loc>https://acme.com/about</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>monthly</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>https://acme.com/blog</loc>
    <lastmod>2023-04-06T15:02:24.021Z</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.5</priority>
  </url>
</urlset>
```

如果使用 TypeScript，Sitemap 对象的 type 为：

```typescript
type Sitemap = Array<{
  url: string
  lastModified?: string | Date
  changeFrequency?:
    | 'always'
    | 'hourly'
    | 'daily'
    | 'weekly'
    | 'monthly'
    | 'yearly'
    | 'never'
  priority?: number
}>
```

## 6. manifest.json

### 6.1. 介绍

开发 PWA 时会要求网站提供一个`manifest.json`文件设置网站的相关信息。使用方法依然是两种，一种静态文件，一种代码生成，直接看例子吧！

### 6.2. 静态文件

`app/manifest.json` | `app/manifest.webmanifest`：

```json
{
  "name": "My Next.js Application",
  "short_name": "Next.js App",
  "description": "An application built with Next.js",
  "start_url": "/"
  // ...
}
```

### 6.3. 代码生成

添加一个 `manifest.js`或 `manifest.ts`文件，该文件返回一个 Manifest 对象。使用示例如下：

```javascript
// app/manifest.js
export default function manifest() {
  return {
    name: 'Next.js App',
    short_name: 'Next.js App',
    description: 'Next.js App',
    start_url: '/',
    display: 'standalone',
    background_color: '#fff',
    theme_color: '#fff',
    icons: [
      {
        src: '/favicon.ico',
        sizes: 'any',
        type: 'image/x-icon',
      },
    ],
  }
}
```

Manifest 对象具体有哪些字段参考[ MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/Manifest)。

## 参考链接

1.  [Optimizing: Metadata](https://nextjs.org/docs/app/building-your-application/optimizing/metadata)
2.  [Metadata Files: favicon, icon, and apple-icon](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/app-icons)
3.  [Metadata Files: manifest.json](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/manifest)
4.  [Metadata Files: opengraph-image and twitter-image](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/opengraph-image)
5.  [Metadata Files: robots.txt](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/robots)
6.  [Metadata Files: sitemap.xml](https://nextjs.org/docs/app/api-reference/file-conventions/metadata/sitemap)
7.  [Functions: ImageResponse](https://nextjs.org/docs/app/api-reference/functions/image-response)
8.  [Functions: generateImageMetadata](https://nextjs.org/docs/app/api-reference/functions/generate-image-metadata)


## 26.优化篇 | 懒加载

## 懒加载

懒加载，英文：Lazy Loading，又被称为“延迟加载”，其重要性不言而喻。这是因为随着互联网的发展，网页资源大小在快速增长，为了提高加载的速度，带来更好的用户体验，便产生了懒加载这种技术理念，减少初始加载的资源，让部分资源等到合适的时候再去加载。

Next.js 基于懒加载做了很多优化，实现了延迟加载客户端组件和导入库，只在需要的时候才在客户端引入它们。举个例子，比如延迟加载模态框相关的代码，直到用户点击打开的时候。

在 Next.js 中有两种方式实现懒加载：

1.  使用 `React.lazy()` 和 `Suspense`
2.  使用 `next/dynamic`实现动态导入

默认情况下，服务端组件自动进行代码分隔，并且可以使用流将 UI 片段逐步发送到客户端，所以懒加载应用于客户端。

## React.lazy 与 Suspense

我们先讲讲 React 的 lazy 方法，lazy 可以实现延迟加载组件代码，直到组件首次被渲染。换句话说，直到组件需要渲染的时候才加载组件的代码。使用示例如下：

```javascript
import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
```

通过在组件外部调用 lazy 方法声明一个懒加载的 React 组件，非常适合搭配 `<Suspense>` 组件使用：

```javascript
<Suspense fallback={<Loading />}>
  <h2>Preview</h2>
  <MarkdownPreview />
</Suspense>
```

一个简单完整的例子如下：

```javascript
import { Suspense, lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));

export default function Page() {
  return (
    <Suspense fallback={'loading'}>
      <h2>Preview</h2>
      <MarkdownPreview />
    </Suspense>
  );
}
```

当然这个例子在实际开发中并无意义，因为延迟加载的目的在于需要的时候才去加载，结果这里没有条件判断就直接开始了加载，那还用延迟加载干什么，徒然降低了性能和加载时间。

React 官网提供了一个非常的好的完整示例：<https://react.dev/reference/react/lazy#suspense-for-code-splitting>

```javascript
import { useState, Suspense, lazy } from 'react';
import Loading from './Loading.js';

const MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));

export default function MarkdownEditor() {
  const [showPreview, setShowPreview] = useState(false);
  const [markdown, setMarkdown] = useState('Hello, **world**!');
  return (
    <>
      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />
      <label>
        <input type="checkbox" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />
        Show preview
      </label>
      <hr />
      {showPreview && (
        <Suspense fallback={<Loading />}>
          <h2>Preview</h2>
          <MarkdownPreview markdown={markdown} />
        </Suspense>
      )}
    </>
  );
}

// 添加一个固定的延迟时间，以便你可以看到加载状态
function delayForDemo(promise) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  }).then(() => promise);
}

```

在这个例子中，只有当用户点击了 Show preview 选择框，`showPreview` 为 `true` 的时候才去加载 `<Suspense>` 和 `<MarkdownPreview>` 组件，这是更符合实际开发中的例子。

效果如下：

![1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82c7bd19fe5243ce9156126645ae7ca2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=721\&h=249\&s=12410\&e=gif\&f=10\&b=fdfdfd)

## next/dynamic

不过开发 Next.js 应用的时候，大部分时候并不需要用到 React.lazy 和 Suspense，使用 `next/dynamic` 即可，它本质就是 React.lazy 和 Suspense 的复合实现。在 `app`和 `pages`目录下都可以使用。

### 1. 基本示例

它的基本用法如下：

```javascript
import dynamic from 'next/dynamic'
 
const WithCustomLoading = dynamic(
  () => import('../components/WithCustomLoading'),
  {
    loading: () => <p>Loading...</p>,
  }
)
 
export default function Page() {
  return (
    <div>
      <WithCustomLoading />
    </div>
  )
}
```

dynamic 函数的第一个参数表示加载函数，用法同 lazy 函数。第二个参数表示配置项，可以设置加载组件，如同 Suspense 中的 fallback。看似很简单，但使用的时候也有很多细节要注意：

1.  import() 中的路径不能是模板字符串或者是变量
2.  import() 必须在 dynamic() 中调用
3.  dynamic() 跟 lazy() 函数一样，需要放在模块顶层

前面我们讲过懒加载只应用于客户端的，如果动态导入的是一个服务端组件，只有这个服务端组件中的客户端组件才会被懒加载，服务端组件本身是不会懒加载的。

```javascript
// app/page.js
import dynamic from 'next/dynamic'
 
// Server Component:
const ServerComponent = dynamic(() => import('../components/ServerComponent'))
 
export default function ServerComponentExample() {
  return (
    <div>
      <ServerComponent />
    </div>
  )
}
```

### 2. 跳过 SSR

之前讲客户端组件和服务端组件的时候，客户端组件默认也是会被预渲染的（SSR）。如果要禁用客户端组件的预渲染，可以将 `ssr` 选项设置为 `false`。让我们看个例子：

```javascript
'use client'
// app/page.js
import { useState } from 'react'
import dynamic from 'next/dynamic'
 
// Client Components:
const ComponentA = dynamic(() => import('../components/a.js'))
const ComponentB = dynamic(() => import('../components/b.js'))
const ComponentC = dynamic(() => import('../components/c.js'), { ssr: false })
 
export default function ClientComponentExample() {
  const [showMore, setShowMore] = useState(false)
 
  return (
    <div>
      {/* 立刻加载，但会使用一个独立的客户端 bundle */}
      <ComponentA />
 
      {/* 按需加载 */}
      {showMore && <ComponentB />}
      <button onClick={() => setShowMore(!showMore)}>Toggle</button>
 
      {/* 只在客户端加载 */}
      <ComponentC />
    </div>
  )
}
```

三个组件内容相同，都是：

```javascript
'use client'

export default function Page() {
  return <h1>Hello World!</h1>
}
```

加载效果如下：

![10.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa116662caa84e0c95f3d187204ba3ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=747\&h=353\&s=22839\&e=gif\&f=17\&b=fefefe)

从效果上看，设置 `ssr` 为 `false` 的 `<ComponentC>` 会比 `<ComponentA>` 晚显示，`<ComponentB>` 在点击的时候才会显示。

这三个组件的加载到底有什么区别呢？

首先是预渲染，`ComponentA` 默认会被预渲染，`ComponentC` 因为设置了 `ssr` 为 `false`，不会被预渲染，也就是说，如果查看页面的 HTML 源码，可以看到这样的渲染代码：

```html
<div>
  <h1>Hello World!</h1>
  <button>Toggle</button>
  <template data-dgst="NEXT_DYNAMIC_NO_SSR_CODE"></template>
</div>
```

`ComponentA`  渲染了 HTML，`ComponentC` 只是留了一个占位。所以加载的时候，`ComponentA` 立刻就渲染了出来，`ComponentC` 会先显示空白，然后再展示出内容。

其次是 bundle，三个动态加载的组件都会打包成一个单独的包，`ComponentA` 和 `ComponentC` 的包都会尽快加载，CompoentB 的包会在点击按钮的时候才加载：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0dc5c7a2d9c45a3b73163ee2fe0bbea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2168\&h=1082\&s=365204\&e=png\&b=272727)

那你可能要问了，这个组件不就一个 Hello World！吗？`ComponentB` 在点击的时候才渲染，确实需要加载。`ComponentC` 只有一个占位，也确实需要加载，可 `ComponentA` 有什么可加载的？

这个例子比较简单，但实际开发并不如此，SSR 只能渲染出无交互的 HTML，还需要再加载一个 JS 文件，用于给比如 HTML 元素上添加事件，使其具有交互能力等（这个过程又称为水合）。所以使用懒加载的组件 Next.js 会打包一个单独的 bundle。

### 3. 导入命名导出（Named Exports）

JavaScript 支持两种导出方式：默认导出（default export）和命名导出（named export）。

```javascript
// 默认导出
export default function add(a, b) {
  return a + b;
}
```

```javascript
// 命名导出
export function add(a, b) {
  return a + b;
}
```

如果要动态导入一个命名导出的组件，用法会略有不同，直接举个示例代码：

假如要导入 Hello 组件，然而 Hello 组件以命名导出的形式导出：

```javascript
'use client'
// components/hello.js
export function Hello() {
  return <p>Hello!</p>
}
```

关键字 import 可以像调用函数一样来动态的导入模块。以这种方式调用，将返回一个 promise，将模块作为对象传入 then 函数：

```javascript
// app/page.js
import dynamic from 'next/dynamic'
 
const ClientComponent = dynamic(() =>
  import('../components/hello').then((mod) => mod.Hello)
)
```

## 加载外部库

使用 `import()`函数可以按需加载外部库，比如当用户在搜索框输入的时候才开始加载模糊搜索库，这个例子就演示了如何使用 `fuse.js` 实现模糊搜索。

```javascript
'use client'
// app/page.js
import { useState } from 'react'
 
const names = ['Tim', 'Joe', 'Bel', 'Lee']
 
export default function Page() {
  const [results, setResults] = useState()
 
  return (
    <div>
      <input
        type="text"
        placeholder="Search"
        onChange={async (e) => {
          const { value } = e.currentTarget
          const Fuse = (await import('fuse.js')).default
          const fuse = new Fuse(names)
 
          setResults(fuse.search(value))
        }}
      />
      <pre>Results: {JSON.stringify(results, null, 2)}</pre>
    </div>
  )
}
```

## 谈谈懒加载

本篇的最后，我们简单聊聊在开发中使用懒加载的感受。Next.js 中的懒加载看似很好，但其实应用中有很多局限。就以刚才的例子为例：

```javascript
'use client'
 
import { useState } from 'react'
import dynamic from 'next/dynamic'
 
const ComponentA = dynamic(() => import('../components/a.js'))
const ComponentB = dynamic(() => import('../components/b.js'))
const ComponentC = dynamic(() => import('../components/c.js'), { ssr: false })
 
export default function ClientComponentExample() {
  const [showMore, setShowMore] = useState(false)
 
  return (
    <div>
      <ComponentA />
      {showMore && <ComponentB />}
      <button onClick={() => setShowMore(!showMore)}>Toggle</button>
      <ComponentC />
    </div>
  )
}
```

首先，为了实现懒加载，我们需要将组件抽离到单独的文件中，这样做虽然有些繁琐，倒也可以接受。

其次，在这个例子中，其实只有 ComponentB 应用懒加载是有用的，ComponentA 和 ComponentC 应用懒加载，会导致初始加载的时候多加载两个 bundle，反而因为浏览器同时请求多个 bundle 降低了加载速度。所以懒加载的例子都是应用于那些初始并不渲染的组件。

最后，为了保证用户有一个流畅的体验，其实我们并不希望交互的时候才开始获取 JS，代码其实是应该预获取的。但是预获取的逻辑是需要开发者自己定义的。这就造成了更多的工作量。

## 参考链接

1.  <https://github.com/vercel/next.js/blob/canary/packages/next/src/shared/lib/dynamic.tsx>
2.  <https://www.builder.io/blog/the-challenges-of-lazy-loading-in-javascript>
3.  <https://www.fullctx.dev/p/lazy-loading-in-react-and-nextjs>


## 27.渲染篇 | Edge Runtime

## 1. Edge Runtime

### 1.1 介绍

学习 Next.js 的时候，我们可能会接触到 Edge Runtime 和 Node.js Runtime 这两个概念。在 Next.js 中，你可以把运行时（runtime）理解为执行期间一组可用的库、API、和常规功能的集合。在服务端，有两个可以用于渲染应用的运行时：

*   Nodejs Runtime，这是默认的运行时，可以使用 Node.js API 和其生态的包
*   Edge Runtime，基于 [Web API](https://nextjs.org/docs/app/api-reference/edge)

在 Next.js 中，Edge Runtime 是 Nodejs API 的子集，功能上虽有限制，但对应也更轻量，速度也更快，适用于开发小而简单的功能，以低延迟实现动态、个性化的内容。

仅仅是这样的了解是不是还很懵逼？为了讲解 Edge Runtime 这个概念，我们先从 CDN 开始说起。

CDN，全称 Content Delivery Network，中文译为“内容分发网络”，它是由分布于不同地理位置的服务器及数据中心组成的虚拟网络，目的在于以最小的延迟将内容分发给用户。简单的来说，你在杭州请求在美国的网站，因为物理距离太远，响应会有延迟，但如果将网站的内容同步到杭州的服务器上，转而请求杭州服务器上的内容，响应时间就会加快。这组在杭州的用于缓存和传送网络内容的服务器就被称为 “Edge”。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a3950cc3954c3481d299f66fd5a810~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1536\&h=1409\&s=231537\&e=png\&a=1\&b=f3f3f3)
以前的 Edge 只能存储一些静态的资源，但这不够强大，当你已经是个成熟的 Edge 时，你得学着能够执行代码，当能够执行代码时，CDN 网络就变成了更为强大的边缘网络（Edge Network），在 Edge 发生的计算，也被称为边缘计算，它可以为主要服务器分担一部分处理内容。理解这些概念，也有助于理解 Edge Runtime 这个概念，其术语 Edge 指的正是这种面向即时无服务器计算的环境。

你可能会想到 Serverless。Serverless 很好，但每次请求的时候都会开启不同的实例，并重新初始化环境，尽管底层架构会做很多优化，但依然不能最大限度的复用资源。而对于 Edge Runtime，你可以通过 Vercel Edge functions 或者 Cloudflare workers 或者其他一些工具来部署 Edge Runtime 环境，Edge Runtime 并不运行 Nodejs，而使用 V8 引擎和 Web APIs，这样更加轻量，启动速度更快。多个请求可以使用一个实例，更好的复用资源。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c30eb01fb754f45b86d336f4468fd5c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1760\&h=1352\&s=844342\&e=png\&b=fcf9f9)
有了 Edge Runtime 的优化再加上 Streaming，这就更快了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380bb3c168b845a28c08088e4437317e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1938\&h=1304\&s=384225\&e=png\&b=fdfafa)
总结一下，你可以把 Edge Runtime 理解成一个特殊的运行环境，在这个环境里，只能使用标准的 Web APIs，但对应也会带来更好的性能。至于具体支持哪些，查看 Next.js 提供的 [Edge Runtime Supports](https://nextjs.org/docs/app/api-reference/edge) 文档。

### 1.2 开启

你可以在 Next.js 中为单个路由指定运行时。为此，你需要声明一个名为 `runtime` 的变量并导出它。变量必须是字符串，值为 `'nodejs'` 或者 `'edge'`。举个例子：

```javascript
// app/page.js
export const runtime = 'edge' // 'nodejs' (default) | 'edge'
```

也可以在布局上定义 `runtime`，这会将 Edge Runtime 应用于该布局下的所有路由：

```javascript
// app/layout.js
export const runtime = 'edge' // 'nodejs' (default) | 'edge'
```

如果你没有声明，默认是 Node.js Runtime，所以如果不打算修改，也无须使用该选项。

## 参考链接

1.  <https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming>
2.  <https://edge-runtime.vercel.app/>
3.  <https://www.cdnetworks.com/cn/what-is-a-cdn/>
4.  <https://zhuanlan.zhihu.com/p/510366735>


## 28.路由篇 | 国际化

## 前言

前面我们都在讲 App Router 带来的强大功能，但也不总是会更加便捷，就比如国际化的处理相比以前 Pages Router 反而复杂了一点，需要借助上节讲到的中间件进行来实现。

本篇我们会介绍 Next.js 的国际化实现方式，并为大家普及国际化的基础术语和概念，考虑到并不是所有的同学都有国际化需求，本篇内容可以选择性学习。

## 1. 相关术语

### 1.1. 国际化与本地化

Internationalization，简写 **i18n**（首末字符 i 和 n，18 为中间的字符数），中文译为“国际化”。引用百度百科的解释：

> 在资讯领域，国际化(i18n)指让产品（出版物，软件，硬件等）无需做大的改变就能够适应不同的语言和地区的需要。对程序来说，在不修改内部代码的情况下，能根据不同语言及地区显示相应的界面。

与 Internationalization 相关的一个单词叫做 localization，简写 **L10n**，中文译为“本地化”。

> 在信息技术领域，国际化与本地化是指修改软件使之能适应目标市场的语言、地区差异以及技术需要。
>
> 国际化是指在设计软件，将软件与特定语言及地区脱钩的过程。当软件被移植到不同的语言及地区时，软件本身不用做内部工程上的改变或修正。本地化则是指当移植软件时，加上与特定区域设置有关的信息和翻译文件的过程。
>
> 国际化和本地化之间的区别虽然微妙，但却很重要。国际化意味着产品有适用于任何地方的“潜力”；本地化则是为了更适合于“特定”地方的使用，而另外增添的特色。用一项产品来说，国际化只需做一次，但本地化则要针对不同的区域各做一次。这两者之间是互补的，并且两者合起来才能让一个系统适用于各地
>
> 简而言之，“国际化”是“本地化”的一部分，主要是指国际化的实现机制和翻译工作， “本地化”包含“国际化”，是对“国际化”的补充和完善，它还包括为实现对某种特定语言良好的支持而进行的有针对性的翻译调整以及对软件进行的打补丁工作。

这样说有些抽象，举个具体的例子，当访问 `/dashboard`的时候，默认显示中文，当访问 `/en/dashboard` 的时候，显示英文，当访问 `/fr/dashboard`的时候，显示法语，这套逻辑的实现属于国际化。

比如要进军阿拉伯市场，但阿拉伯语是从右到左（RTL）的语言，这就可能需要你重新设计界面，这就属于本地化。调整时间日期格式、货币、文化图片、符合、手势等等也都属于本地化。

### 1.2. locale

讲解完国际化和本地化，我们再说一个术语 —— locale。你可以把它理解为软件运行时的语言环境，它是一组语言和格式首选项的标识符。locale 的命名规则为：

```markdown
language[_territory[.codeset]][@modifier]
```

翻译成中文：

```markdown
 [语言[_地域][.字符集] [@修正值]
```

其中 language 是 [ISO 639-1 标准](https://zh.wikipedia.org/zh-hans/ISO_639-1)中定义的双字母的语言代码，territory 是 [ISO 3166-1 标准](https://zh.wikipedia.org/wiki/ISO_3166-1)中定义的双字母的国家和地区代码，codeset 是字符集的名称 (如 UTF-8等)，而 modifier 则是某些 locale 变体的修正符。

以汉语为例，`zh_CN.GB2312`就表示中国地区的汉语，字符集采用 GB2312。

冷知识：

1. 英语用 en 表示，取自于 English，德语用 de 表示，取自于 Deutsch，这是“德语”的德语，汉语用 zh 表示，取自于“中文”的汉语拼音：Zhōngwén，但也不总是如此，比如日语用 ja 表示，尽管日语拼音是 Nihongo。
2. 除了 zh\_CN 还有 zh-HK（中国香港）、zh-SG（新加坡）、zh-TW（中国台湾）。

## 2. 实现方式

Next.js 可以让你通过配置路由和渲染内容支持多种语言，让我们看看怎么实现吧。

### 2.1. 判断区域设置

首先 Next.js 推荐使用浏览器中的语言首选项来判断要使用的区域设置，为此你需要分析传入的请求，确定要使用的区域设置。我们知道，请求头中是有 `Accept-Language`这个标头的，我们就可以根据这个字段的值来确定。

![截屏2023-11-22 下午9.06.57.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/694faf9092c0484a905950176d80bd43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1254\&h=304\&s=75458\&e=png\&b=292929)

为了方便分析，我们可以借助一些库来实现，比如：

```javascript
// middleware.js
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'
 
let headers = { 'accept-language': 'en-US,en;q=0.5' }
let languages = new Negotiator({ headers }).languages()
let locales = ['en-US', 'nl-NL', 'nl']
let defaultLocale = 'en-US'
 
match(languages, locales, defaultLocale) // -> 'en-US'
```

首先是 [negotiator](https://www.npmjs.com/package/negotiator) 这个库，将请求作为参数传给 Negotiator 构造函数，就可以通过 `new Negotiator(request).languages()` 快速获取支持的语言，比如请求的 accept-language 为 `'en;q=0.8, es, pt'`， `new Negotiator(request).languages()`  的值为 `['es', 'pt', 'en']`。

其次是 [@formatjs/intl-localematcher](https://www.npmjs.com/package/@formatjs/intl-localematcher) 这个库，它的 match 函数，顾名思义，帮助匹配出最适合的语言，比如：

```javascript
// middleware.js
// match(languages, locales, defaultLocale)

// 结果为 'fr'，因为 locales 里只有 fr 和 en
match(['fr-XX', 'en'], ['fr', 'en'], 'en')

// 结果为 'en'，因为 locales 里没有 zh，所以使用了 defaultLocale
match(['zh'], ['fr', 'en'], 'en')
```

### 2.2. 中间件处理

找到了合适的 locale，现在我们就可以根据 locale 来实现子路径（`/fr/products`）或者域（`my-site.fr/products`）国际化，也就是根据用户的浏览器语言设置对应跳转到如 `/fr/products`这样的国际化路由地址。示例代码如下：

```javascript
// middleware.js
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'

let locales = ['en-US', 'nl-NL', 'nl']
const defaultLocale = 'en-US'

function getLocale(request) { 
  const headers = { 'accept-language': request.headers.get('accept-language') || '' };
  // 这里不能直接传入 request，有更简单的写法欢迎评论留言
  const languages = new Negotiator({ headers }).languages();

  return match(languages, locales, defaultLocale)
 }
 
export function middleware(request) {
  const { pathname } = request.nextUrl
  // 判断请求路径中是否已存在语言，已存在语言则跳过
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )
 
  if (pathnameHasLocale) return
 
  // 获取匹配的 locale
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // 重定向，如 /products 重定向到 /en-US/products
  return Response.redirect(request.nextUrl)
}
 
export const config = {
  matcher: [
    // 跳过所有内部路径 (_next)
    '/((?!_next).*)',
    // 可选: 仅在根 URL (/) 运行
    // '/'
  ],
}
```

最后，因为添加上述代码后比如访问 `/dashboard`，会跳转到 `/en-US/dashboard`，而此时并没有对应的处理程序，所以还要将 `app/`下所有的特殊文件都放在 `app/[lang]`下。因为借助了动态路由，lang 参数会被转发给每个布局和页面，你可以在布局或页面中获取到 lang 参数：

```javascript
// app/[lang]/page.js
export default async function Page({ params: { lang } }) {
  return ...
}
```

根布局也可以放在新文件中，如 `app/[lang]/layout.js`。

### 2.3. 本地化

现在我们来解决翻译的问题，本质是根据用户的区域设置来改变显示的内容，但解决的模式并不算是 Next.js 中的特殊内容，任何 Web 应用程序都可以这样解决。

假设我们希望应用能够同时支持英语和荷兰语，我们可以维护两个不同的字典，字典会提供从某个键到本地化字符串的映射，例如：

```javascript
// dictionaries/en.json
{
  "products": {
    "cart": "Add to Cart"
  }
}
```

```javascript
// dictionaries/nl.json
{
  "products": {
    "cart": "Toevoegen aan Winkelwagen"
  }
}
```

然后我们可以创建一个 `getDictionary` 函数加载对应语言的字典：

```javascript
import 'server-only'
 
const dictionaries = {
  en: () => import('./dictionaries/en.json').then((module) => module.default),
  nl: () => import('./dictionaries/nl.json').then((module) => module.default),
}
 
export const getDictionary = async (locale) => dictionaries[locale]()
```

最后根据当前选择的语言，在布局或者页面中获取字典，展示对应的翻译文字：

```javascript
// app/[lang]/page.js
import { getDictionary } from './dictionaries'
 
export default async function Page({ params: { lang } }) {
  const dict = await getDictionary(lang) // en
  return <button>{dict.products.cart}</button> // Add to Cart
}
```

由于 `app/` 目录下的所有布局和页面默认都是服务端组件，所以不用担心翻译文件的大小会影响客户端 JavaScript bundle 的大小，这段代码只会在服务端上运行，并且只有生成的 HTML 会发送到浏览器。

### 2.4. 静态生成

如果要为一组区域设置生成静态路由，我们可以在布局或页面中使用 [generateStaticParams](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-1)。可以在全局中使用，比如这个例子就是在根布局中：

```javascript
// app/[lang]/layout.js
export async function generateStaticParams() {
  return [{ lang: 'en-US' }, { lang: 'de' }]
}
 
export default function Root({ children, params }) {
  return (
    <html lang={params.lang}>
      <body>{children}</body>
    </html>
  )
}
```

## 小结

恭喜你，完成了本节内容的学习！

这一节我们介绍了国际化相关的术语概念，然后讲解了 Next.js 中的国际化实现方式。首先 Next.js 推荐使用浏览器中的语言首选项来判断要使用的区域设置，为此你需要分析传入的请求，确定要使用的区域设置。

然后借助中间件实现路由的重定向，将 `/dashboard` 重定向到如 `/en-US/dashboard`这样的地址，此外还需要借助字典模式实现语言的本地化工作。

但是要注意：

本篇只是讲解实现国际化的基本原理，在实际项目开发中，并不会如此从零实现，实战项目中使用请参考：

1. [《实战篇 | React Notes | 国际化》](https://juejin.cn/book/7307859898316881957/section/7309112133474582578)
2. [《实战篇 | 移动端 Web | Crowdin 与本地化》](https://juejin.cn/book/7307859898316881957/section/7309115955198558217)


## 参考链接

1.  [I18N](https://baike.baidu.com/item/I18N/6771940)
2.  [wiki/区域设置](https://zh.wikipedia.org/wiki/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE)
3.  [Routing: Internationalization | Next.js](https://nextjs.org/docs/app/building-your-application/routing/internationalization)


## 29.配置篇 | TypeScript 和 ESLint

## 前言

使用 `create-next-app`创建项目的时候，Next.js 会提示是否使用 TypeScript 和 ESLint，本篇会详细介绍 TypeScript 和 ESLint 的配置内容，帮助大家了解默认设置中支持的功能和逻辑。

## TypeScript

Next.js 内置了对 TypeScript 的支持，会自动安装所需依赖以及进行合适的配置。

### 1. 新项目

当你运行 `create-next-app` 创建项目的时候，就会让你选择是否使用 TypeScript，默认是 `Yes`：

```bash
npx create-next-app@latest
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/338e1a0cbeae4e6dbed45b8aabcab1db~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2048\&h=400\&s=1160077\&e=png\&b=090f16)

### 2. 现有项目

将文件重命名为 `.ts`或者 `.tsx`，然后运行 `next dev`和 `next build`，Next.js 会自动安装所需依赖，以及添加一个包含推荐配置项的 `tsconfig.json`文件。

如果你已经有了一个 `jsconfig.json` 文件，那就需要你手动拷贝 `jsconfig.json`中的内容（比如 `paths`）到 `tsconfig.json`中，然后删除掉之前的 `jsconfig.json`文件。

### 3. TypeScript 插件

Next.js 包含了一个自定义的 TypeScript 插件和类型检查器。VScode 和其他代码编辑器可以用其实现高级类型检查和自动补写功能。

在 VSCode 中开启：

1.  打开命令面板（`Ctrl/⌘` + `Shift` + `P`）
2.  搜索 `TypeScript: Select TypeScript Version`
3.  选择“`Use Workspace Versiion`”

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f51c0de853c0406c888bbe530ab425c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=637\&s=265220\&e=png\&b=212329)

现在，当你编辑文件的时候，自定义 TypeScript 插件就会启用。当运行 `next build`的时候，会执行自定义类型检查器。

插件功能介绍：

1.  当使用了无效的路由段配置会出现警告：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92a7d286aa984ea48754705c1772f15f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2204\&h=426\&s=137977\&e=png\&b=1f1f1f)

2.  显示上下文文档：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23bbc37a4282495b9ca8ea4802de1632~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2192\&h=592\&s=197306\&e=png\&b=252526)

3.  显示可用选项：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/778168b2f93e4ce99b86d1dae56f389c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1826\&h=394\&s=99703\&e=png\&b=202020)

4.  确保 `use client`被正确使用：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac2531413a04757bf683c1655adc604~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1534\&h=554\&s=107023\&e=png\&b=1f1f1f)

5.  确保客户端 hooks（如 useState）只在客户端组件中使用：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45148815980341b38c6b766c60388871~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1256\&h=410\&s=88021\&e=png\&b=202020)

### 4. 最低 TypeScript 版本要求

Next.js 推荐最少要 v4.5.2 版本以获取如导入名称的 type 修饰符（type Modifiers on Import Names）等功能：

```typescript
// 可以直接导入类型
import { someFunc, type BaseType } from "./some-module.js";

export class Thing implements BaseType {
  someMethod() {
    someFunc();
  }
}
```

### 5. 静态写入链接

Next.js 可以静态写入链接，防止使用 `next/link` 时出现拼写或者其他错误，从而保证页面导航地址的正确性。

要使用此功能，需要在项目使用 TypeScript 的前提下，在 `next.config.js` 中使用 `experimental.typedRoutes`选项开启：

```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
}
 
module.exports = nextConfig
```

Next.js 将会在 `.next/types` 中生成一个包含所有路由信息的链接定义，从而让 TypeScript 据此来进行链接提示。

目前，支持任何字符串文字，包括动态路由。对于非文字字符，目前则需要手工使用 `as Route`标示 `href` :

```javascript
import type { Route } from 'next';
import Link from 'next/link'
 
// 如果 href 是有效路由，则不会出现 TypeScript 错误
<Link href="/about" />
<Link href="/blog/nextjs" />
<Link href={`/blog/${slug}`} />
<Link href={('/blog' + slug) as Route} />
 
// 如果 href 不是有效路由，则会出现 TypeScript 错误，这里出现了拼写错误
<Link href="/aboot" />
```

如果要在一个使用 `next/link` 包装的自定义组件中接收 `href` 属性，使用泛型：

```javascript
import type { Route } from 'next'
import Link from 'next/link'
 
function Card<T extends string>({ href }: { href: Route<T> | URL }) {
  return (
    <Link href={href}>
      <div>My Card</div>
    </Link>
  )
}
```

### 6. next.config.js 中的类型检查

`next.config.js` 必须是一个 JavaScript 文件，它不会被 TypeScript 或者 Babel 解析，但你可以使用 JSDoc 添加一些类型检查，举个例子：

```javascript
// @ts-check
 
/**
 * @type {import('next').NextConfig}
 **/
const nextConfig = {
  /* config options here */
}
 
module.exports = nextConfig
```

### 7. 忽略 TypeScript 错误

当出现 TypeScript 错误的时候，使用 `next build` 构建生产版本会失败。但如果你希望及时有错误，也要构建出生产代码，那你可以禁用内置的类型检查。打开 `next.config.js`启用 `typescript.ignoreBuildErrors` 选项：

```javascript
// next.config.js
module.exports = {
  typescript: {
    // !! WARN !!
    // 其实是很危险的操作
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}
```

## ESLint

### 1. ESLint 配置选项

Next.js 提供了开箱即用的 ESLint 功能（如果你创建项目的时候选择了 ESLint），查看 `package.json`会看到：

```json
// package.json
{
  "scripts": {
    "lint": "next lint"
  }
}
```

然后运行 `npm run lint` 或者`yarn lint`:

```shell
yarn lint
```

如果应用中并没有 ESLint 相关的配置，则会引导你安装和配置：

```shell
? How would you like to configure ESLint?

❯ Strict (recommended)
Base
Cancel
```

这个时候你会看到三个选项：

1.  **Strict**

这是首次设置 ESLint 的推荐配置。包括 Next.js 基础 ESLint 配置以及更严格的核心 Web 指标规则集。查看 `.eslintrc.json`文件：

```json
// .eslintrc.json
{
  "extends": "next/core-web-vitals"
}
```

2.  **Base**

只包括 Next.js 基础 ESLint 配置，查看 `.eslintrc.json`文件：

```json
// .eslintrc.json
{
  "extends": "next"
}
```

这个时候你可能困惑 `Strict` 模式下不是包含了基础 ESLint 配置吗？为什么 `Strict` 下的 `extends` 没有 `"next"`呢？这是因为 `"next/core-web-vitals"` 的规则拓展了 `"next"`，也就是说包含了 `"next"` ，所以无须再次 extends 了。

3.  **Cancel**

不包括任何 ESLint 配置。当你需要自定义 ESLint 配置的时候，选择此项。

如果选择了前两个配置项的任何一个，Next.js 都会自动安装 `eslint` 和 `eslint-config-next` 作为应用的依赖项，以及在项目的根目录创建一个包含你选择的配置的 `.eslintrc.json` 文件。

现在你就可以运行 `next lint`捕获错误。一般 ESLint 设置完成后，它会在每次 `next build` 的时候自动运行。如果有错误会导致构建失败，警告则不会。

### 2. ESLint 配置

默认配置 `eslint-config-next`包含以下插件：

*   [eslint-plugin-react](https://www.npmjs.com/package/eslint-plugin-react)
*   [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks)
*   [eslint-plugin-next](https://www.npmjs.com/package/@next/eslint-plugin-next)

初次接触 ESLint 的同学可能对 ESLint 的 `config` 和 `plugin` 概念有些困惑。我们简单讲一下区别。

现在假设你是 Next.js 的开发者，为了让用户更好的使用 Next.js，需要根据 Next.js 的用法自定义一些 ESLint 规则，就比如我们在讲 `<Script>` 组件的时候讲到内联脚本：

```javascript
<Script id="show-banner">
  {`document.getElementById('banner').classList.remove('hidden')`}
</Script>
```

Next.js 要求必须为内联脚本分配一个 id，以保证 Next.js 追踪和优化脚本。如果用户没有传入 id，就可以使用 ESLint 提示一个错误。为了实现这个自定义规则，我们就需要编写一个插件，名为 `eslint-plugin-next`，其中 `eslint-plugin-`这个前缀是 ESLint 要求的。它的代码结构类似于：

```javascript
module.exports = {
  rules: {
    'inline-script-id': require('./rules/inline-script-id'),
    // ... 其他规则
  }
}
```

开发了一堆规则还不够，正如打游戏的时候，游戏难度有简单、适中、困难、地狱，规则集合也是一样，我们也可以用这些规则建立多个分类，比如推荐、严格、宽松等，这个也可以写在插件代码中，代码结构类似于：

```javascript
module.exports = {
  rules: {
    'inline-script-id': require('./rules/inline-script-id'),
    // ... 其他规则
  },
  configs: {
    recommended: {
      plugins: ['next'],
      rules: {
        // warnings
        'next/inline-script-id': 'warn',
        // errors
        'next/other-rule': 'error',
      },
    },
    strict: {
      plugins: ['next'],
      rules: {
        'next/inline-script-id': 'error',
        'next/other-rule': 'error',
      },
    },
  },
}
```

在这个示例中，我们为我们的 `eslint-plugin-next`插件定义了两套配置，一套名为 `recommended`，一套名为 `strict`。其中 `plugins: ['next']` 表示加载名为 `eslint-plugin-next`的插件（ESLint 会自动补全名字），其实就是自己，然后 `rules`设定使用哪些规则和规则的提示，比如同样是 `inline-script-id` 这条规则，在 `recommended` 中，我们设定为 `warn`，但是在 `strict` 中，既然是严格，我们就设定为 `error`。

有了这个插件还不够，Next.js 是基于 React 的，关于 React 的用法，也有一些 ESLint 规则，React 的开发者对应开发了 eslint-plugin-react 插件。这个插件虽然不错，但是个别规则我不想用，又该怎么办呢？为了帮助开发者提供一个更加“成品”的配置项，你可以定义一个 `eslint-config-next`配置，其中 `eslint-config-`这个前缀是 ESLint 要求的。它的代码结构类似于：

```javascript
module.exports = {
  extends: [
    'plugin:next/recommended',
  ],
  plugins: ['react'],
  rules: {
    'react/no-unknown-property': 'warn',
    'react/jsx-no-target-blank': 'off'
  }
}
```

在这个例子中，我们使用 extends 表示使用已有的配置，`'plugin:next/recommended'`表示的就是 `eslint-plugin-next`插件中的 recommended 配置。plugins 表示加载的插件，但是这只是加载，具体使用哪些规则，你还需要写 rules 自定义。

这个成品的配置，我们可以在 `.eslintrc.json`中，使用 extends 语法直接继承：

```javascript
{
  "extends": "next"
}
```

因为所有的配置包都是以 `eslint-config-`开头，所以不需要写成 `"extends": "eslint-config-next"`，ESLint 会自动补全。

简而言之，就如它们的名字一样，`plugin` 侧重于规则的编写，`config` 侧重于规则的配置。`plugin` 使用 `plugins: [xxx]`的形式加载，但还需要编写 `rules` 才能使用。`config` 可以使用 `extends`语法直接继承，无须再额外编写。`extends` 语法也可以继承 `plugin` 中编写的配置，语法为 `extends: ['plugin:xxxx/xxx']`这种形式。

### 3. ESLint 插件

Next.js 提供了一个 ESLint 插件 [eslint-plugin-next](https://www.npmjs.com/package/@next/eslint-plugin-next)，已经绑定在基本配置（eslint-config-next）中，完整的 21 条规则可以查看 <https://nextjs.org/docs/app/building-your-application/configuring/eslint#eslint-plugin>

### 4. 自定义应用目录

如果你正在使用 `eslint-plugin-next`，但是没有在根目录里安装 Next.js（比如 monorepo 项目），你可以使用 `.eslintrc` 的 `settings` 属性告诉 `eslint-plugin-next` 哪里找到你的 Next.js 应用：

```json
// .eslintrc.json
{
  "extends": "next",
  "settings": {
    "next": {
      "rootDir": "packages/my-app/"
    }
  }
}
```

`rootDir` 可以是一个路径（相对地址或者绝对地址），也可以使用通配符，比如 `packages/*/`，也可以是一个包含路径或使用通配符的地址的数组。

### 5. 自定义检查目录和文件

默认情况下，Next.js 会为 `pages/`、`app/`、`components/`、`lib/`和 `src/` 目录下的所有文件运行 ESLint。不过你可以使用`next.config.js` 的 `eslint.dirs` 选项指定检查的目录：

```javascript
// next.config.js
module.exports = {
  eslint: {
    dirs: ['pages', 'utils'], 
  },
}
```

同样，你可以使用 `next lint` 的 `--dir` 和 `--file` 指定检查的目录和文件：

```bash
next lint --dir pages --dir utils --file bar.js
```

### 6. 缓存

为了提高性能，Next.js 默认会缓存 ESLint 处理信息，存在`.next/cache`或者构建目录下 。如果需要禁用缓存，使用 `next lint` 的 `--no-cache`：

```bash
next lint --no-cache
```

### 7. 禁用规则

如果你希望修改或者禁用插件（`react`、`react-hooks`、`next`）中的规则，你可以直接在 `.eslintrc` 中使用 `rules` 属性更改它们：

```json
// .eslintrc.json
{
  "extends": "next",
  "rules": {
    "react/no-unescaped-entities": "off",
    "@next/next/no-page-custom-font": "off"
  }
}
```

### 8. core-web-vitals

前面讲到，首次运行 `next lint`并选择 `Strict` 选项，会开启使用 `next/core-web-vitals`规则集：

```json
{
  "extends": "next/core-web-vitals"
}
```

通过[查看源码](https://github.com/vercel/next.js/blob/canary/packages/eslint-plugin-next/src/index.ts)，可以得知目前 `core-web-vitals` 配置相比于默认配置会更加严格：

```javascript
module.exports = {
  rules: {
    // ...
  },
  configs: {
    recommended: {
      plugins: ['@next/next'],
      rules: {
        // warnings
        '@next/next/no-html-link-for-pages': 'warn',
        '@next/next/no-sync-scripts': 'warn',
         //...
      },
    },
    'core-web-vitals': {
      plugins: ['@next/next'],
      extends: ['plugin:@next/next/recommended'],
      rules: {
        '@next/next/no-html-link-for-pages': 'error',
        '@next/next/no-sync-scripts': 'error',
      },
    },
  },
}
```

其实目前也就将 2 条规则设定的更严格了一些，一条是 `no-html-link-for-pages`，也就是不要用 `<a>` 标签，而是用 Link 组件替代：

```javascript
function Home() {
  return (
    <div>
      <a href="/about">About Us</a>
    </div>
  )
}
```

你应该改为使用：

```javascript
import Link from 'next/link'
 
function Home() {
  return (
    <div>
      <Link href="/about">About Us</Link>
    </div>
  )
}
 
export default Home
```

另外一条是 `no-sync-scripts`，不要用同步脚本，也就推荐使用 Script 组件或者为 script 添加 defer 或者 async 属性：

使用 Script 组件：

```javascript
import Script from 'next/script'
 
function Home() {
  return (
    <div class="container">
      <Script src="https://third-party-script.js"></Script>
      <div>Home Page</div>
    </div>
  )
}
 
export default Home
```

添加 async 或 defer 属性：

```javascript
<script src="https://third-party-script.js" async />
<script src="https://third-party-script.js" defer />
```

### 9. 搭配其他工具

#### 9.1. prettier

ESLint 也包含代码格式化规则，可能会跟已经存在的 Prettier 配置冲突。我们推荐使用 `eslint-config-prettier` 让 ESLint 和 Prettier 能够协同工作。

首先安装依赖：

```bash
npm install --save-dev eslint-config-prettier
 
yarn add --dev eslint-config-prettier
 
pnpm add --save-dev eslint-config-prettier
 
bun add --dev eslint-config-prettier
```

然后添加 `prettier`到 `.eslintrc.json`中：

```json
// .eslintrc.json
{
  "extends": ["next", "prettier"]
}
```

#### 9.2. lint-staged

开发的时候，你肯定不希望修改了一个文件后，又所有文件都执行一次 ESLint 检查，那你就可以使用 lint-staged，它会在暂存的 git 文件上（git add 的那些文件）执行 ESLint 检查。

为了搭配使用 lint-staged，你需要将以下内容添加到根目录的 `.lintstagedrc.js` 文件：

```javascript
// .lintstagedrc.js
const path = require('path')
 
const buildEslintCommand = (filenames) =>
  `next lint --fix --file ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(' --file ')}`
 
module.exports = {
  '*.{js,jsx,ts,tsx}': [buildEslintCommand],
}
```

### 10. 迁移现有配置

如果你已经有了单独的 ESLint 配置，并且想要保持原有的配置，那你可以基于目前的配置，直接从 Next.js ESLint 插件（eslint-plugin-next）中拓展规则：

```javascript
module.exports = {
  extends: [
    //...
    'plugin:@next/next/recommended',
  ],
}
```

或者是引入 `eslint-config-next`，不过确保它在其他配置项后，举个例子：

```json
// .eslintrc.json
{
  "extends": ["eslint:recommended", "next"]
}
```

## 参考链接

1.  [Configuring: TypeScript | Next.js](https://nextjs.org/docs/app/building-your-application/configuring/typescript)
2.  [Configuring: ESLint | Next.js](https://nextjs.org/docs/app/building-your-application/configuring/eslint)


## 3.路由篇 | App Router

## 前言

路由（Router）是 Next.js 应用的重要组成部分。在 Next.js 中，路由决定了一个页面如何渲染或者一个请求该如何返回。

Next.js 有两套路由解决方案，之前的方案称之为“Pages Router”，目前的方案称之为“App Router”，两套方案目前是兼容的，都可以在 Next.js 中使用。

从 v13.4 起，App Router 已成为默认的路由方案，新的 Next.js 项目建议使用 App Router。

本篇我们会学习 App Router 下路由的定义方式和常见的文件约定。

## 1. 文件系统（file-system）

Next.js 的路由基于的是文件系统，也就是说，一个文件就可以是一个路由。举个例子，你在 `pages` 目录下创建一个 `index.js` 文件，它会直接映射到 `/` 路由地址：

```javascript
// pages/index.js
import React from 'react'
export default () => <h1>Hello world</h1>
```

在 `pages` 目录下创建一个 `about.js` 文件，它会直接映射到 `/about` 路由地址：

```javascript
// pages/about.js
import React from 'react'
export default () => <h1>About us</h1>
```

## 2. 从 Pages Router 到 App Router

现在你打开使用 `create-next-app` 创建的项目，你会发现默认并没有 `pages` 这个目录。查看 `packages.json`中的 Next.js 版本，如果版本号大于 `13.4`，那就对了！

Next.js 从 v13 起就使用了新的路由模式 —— App Router。之前的路由模式我们称之为“Pages Router”，为保持渐进式更新，依然存在。从 v13.4 起，App Router 正式进入稳定化阶段，App Router 功能更强、性能更好、代码组织更灵活，以后就让我们使用新的路由模式吧！

可是这俩到底有啥区别呢？Next.js 又为什么升级到 App Router 呢？知其然知其所以然，让我们简单追溯一下。以前我们声明一个路由，只用在 `pages` 目录下创建一个文件就可以了，以前的目录结构类似于：

```javascript
└── pages
    ├── index.js
    ├── about.js
    └── more.js
```

这种方式有一个弊端，那就是 `pages` 目录的所有 js 文件都会被当成路由文件，这就导致比如组件不能写在 `pages` 目录下，这就不符合开发者的使用习惯。（当然 Pages Router 还有很多其他的问题，只不过目前我们介绍的内容还太少，为了不增加大家的理解成本，就不多说了）

升级为新的 App Router 后，现在的目录结构类似于：

```javascript
src/
└── app
    ├── page.js 
    ├── layout.js
    ├── template.js
    ├── loading.js
    ├── error.js
    └── not-found.js
    ├── about
    │   └── page.js
    └── more
        └── page.js
```

使用新的模式后，你会发现 `app` 下多了很多文件。这些文件的名字并不是我乱起的，而是 Next.js 约定的一些特殊文件。从这些文件的名称中你也可以了解文件实现的功能，比如布局（layout.js）、模板（template.js）、加载状态（loading.js）、错误处理（error.js）、404（not-found.js）等。

简单的来说，App Router 制定了更加完善的规范，使代码更好被组织和管理。至于这些文件具体的功能和介绍，不要着急，本篇我们会慢慢展开。

## 3. 使用 Pages Router

当然你也可以继续使用 Pages Router，如果你想使用 Pages Router，只需要在 `src` 目录下创建一个 `pages` 文件夹或者在根目录下创建一个 `pages`文件夹。其中的 JS 文件会被视为 Pages Router 进行处理。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e3628b5a76b4bdc87b423b377f80946~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=444\&s=212184\&e=png\&b=141414)

但是要注意，虽然两者可以共存，但 App Router 的优先级要高于 Pages Router。而且如果两者解析为同一个 URL，会导致构建错误。

注意：你在 Next.js 官方文档进行搜索的时候，左上角会有 App 和 Pages 选项，这对应的就是 App Router 和 Pages Router：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab940655f6c14e428a72c91b1f727681~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1382\&h=586\&s=71771\&e=png\&b=040404)

因为两种路由模式的使用方式有很大不同，所以搜索的时候注意选择正确的的路由模式。

## 4. 使用 App Router

### 4.1. 定义路由（Routes）

现在让我们开始正式的学习 App Router 吧。

首先是定义路由，文件夹被用来定义路由。每个文件夹都代表一个对应到 URL 片段的路由片段。创建嵌套的路由，只需要创建嵌套的文件夹。举个例子，下图的 `app/dashboard/settings`目录对应的路由地址就是 `/dashboard/settings`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c35a76b0027c4e9fb5bc0d5807f479f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=594\&s=339521\&e=png\&b=141414)

### 4.2. 定义页面（Pages）

那如何保证这个路由可以被访问呢？你需要创建一个特殊的名为 `page.js` 的文件。至于为什么叫 `page.js`呢？除了 `page` 有“页面”这个含义之外，你可以理解为这是一种约定或者规范。（如果你是 Next.js 的开发者，你也可以约定为 `index.js`甚至 `yayu.js`！）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40820ff4957244899288d7534bd4c525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=687\&s=314397\&e=png\&b=171717)

在上图这个例子中：

* `app/page.js` 对应路由 `/`
* `app/dashboard/page.js` 对应路由 `/dashboard`
* `app/dashboard/settings/page.js` 对应路由`/dashboard/settings`
* `analytics` 目录下因为没有 `page.js` 文件，所以没有对应的路由。这个文件可以被用于存放组件、样式表、图片或者其他文件。

**当然不止 `.js`文件，Next.js 默认是支持 React、TypeScript 的，所以 `.js`、`.jsx`、`.tsx` 都是可以的。**

那 `page.js` 的代码该如何写呢？最常见的是展示 UI，比如：

```javascript
// app/page.js
export default function Page() {
  return <h1>Hello, Next.js!</h1>
}
```

访问 `http://localhost:3000/`，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78d38b112da542488c81d5412fc407ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=556\&h=200\&s=19870\&e=png\&b=000000)

线上查看代码和效果：[CodeSandbox Pages](https://codesandbox.io/p/devbox/objective-ellis-ywn8jd?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt475kks00073b6iw2cbcpjg%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt475kkr00023b6ihi25h458%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt475kkr00043b6i9lkjph4n%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt475kks00063b6i9l5o6xnw%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt475kkr00023b6ihi25h458%2522%253A%257B%2522id%2522%253A%2522clt475kkr00023b6ihi25h458%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522clt475kks00063b6i9l5o6xnw%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt475kkr00053b6i8y93zpk4%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clt475kks00063b6i9l5o6xnw%2522%252C%2522activeTabId%2522%253A%2522clt475kkr00053b6i8y93zpk4%2522%257D%252C%2522clt475kkr00043b6i9lkjph4n%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt475kkr00033b6i40hrddok%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt475kkr00043b6i9lkjph4n%2522%252C%2522activeTabId%2522%253A%2522clt475kkr00033b6i40hrddok%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

### 4.3. 定义布局（Layouts）

布局是指多个页面共享的 UI。在导航的时候，布局会保留状态、保持可交互性并且不会重新渲染，比如用来实现后台管理系统的侧边导航栏。

定义一个布局，你需要新建一个名为 `layout.js`的文件，该文件默认导出一个 React 组件，该组件应接收一个 `children` prop，`chidren` 表示子布局（如果有的话）或者子页面。

举个例子，我们新建目录和文件如下图所示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7872449f6e4c6fb1808f518db7783f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=606\&s=295670\&e=png\&b=151515)

相关代码如下：

```javascript
// app/dashboard/layout.js
export default function DashboardLayout({
  children,
}) {
  return (
    <section>
      <nav>nav</nav>
      {children}
    </section>
  )
}
```

```javascript
// app/dashboard/page.js
export default function Page() {
  return <h1>Hello, Dashboard!</h1>
}
```

当访问 `/dashboard`的时候，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43c72c2017354f1e9c292c2bbb9aaa40~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=710\&h=268\&s=27102\&e=png\&b=000000)

其中，`nav` 来自于 `app/dashboard/layout.js`，`Hello, Dashboard!` 来自于 `app/dashboard/page.js`

**你可以发现：同一文件夹下如果有 layout.js 和 page.js，page 会作为 children 参数传入 layout。换句话说，layout 会包裹同层级的 page。**

`app/dashboard/settings/page.js` 代码如下：

```javascript
// app/dashboard/settings/page.js
export default function Page() {
  return <h1>Hello, Settings!</h1>
}
```

当访问 `/dashboard/settings`的时候，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53456de28a684fe3902eb2ce5f4c07a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=808\&h=266\&s=29753\&e=png\&b=000000)

其中，`nav` 来自于 `app/dashboard/layout.js`，`Hello, Settings!` 来自于 `app/dashboard/settings/page.js`

**你可以发现：布局是支持嵌套的**，`app/dashboard/settings/page.js` 会使用 `app/layout.js` 和 `app/dashboard/layout.js` 两个布局中的内容，不过因为我们没有在 `app/layout.js` 写入可以展示的内容，所以图中没有体现出来。

线上查看代码和效果：[CodeSandbox Layouts](https://codesandbox.io/p/devbox/layouts-v3csx2?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt489j2g00073b6h88j62aog%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt489j2g00023b6he9lxbh9s%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt489j2g00043b6h2v7dpi6i%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt489j2g00063b6hmqcdputt%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt489j2g00023b6he9lxbh9s%2522%253A%257B%2522id%2522%253A%2522clt489j2g00023b6he9lxbh9s%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522clt489j2g00063b6hmqcdputt%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt489j2g00053b6hi3oec3fe%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%252Fsettings%2522%257D%255D%252C%2522id%2522%253A%2522clt489j2g00063b6hmqcdputt%2522%252C%2522activeTabId%2522%253A%2522clt489j2g00053b6hi3oec3fe%2522%257D%252C%2522clt489j2g00043b6h2v7dpi6i%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt489j2g00033b6h5p3d7t5v%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt489j2g00043b6h2v7dpi6i%2522%252C%2522activeTabId%2522%253A%2522clt489j2g00033b6h5p3d7t5v%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

#### 根布局（Root Layout）

布局支持嵌套，最顶层的布局我们称之为根布局（Root Layout），也就是 `app/layout.js`。它会应用于所有的路由。除此之外，这个布局还有点特殊。

使用 `create-next-app` 默认创建的 `layout.js` 代码如下：

```javascript
// app/layout.js
import './globals.css'
import { Inter } from 'next/font/google'

const inter = Inter({ subsets: ['latin'] })

export const metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}

```

其中：

1.  `app` 目录必须包含根布局，也就是 `app/layout.js` 这个文件是必需的。
2.  根布局必须包含 `html` 和 `body`标签，其他布局不能包含这些标签。如果你要更改这些标签，不推荐直接修改，参考[《Metadata 篇》](https://juejin.cn/book/7307859898316881957/section/7309079119902277669)。
3.  你可以使用[路由组](https://juejin.cn/book/7307859898316881957/section/7308693561648611379#heading-5)创建多个根布局。
4.  默认根布局是[服务端组件](https://juejin.cn/book/7307859898316881957/section/7309076661532622885)，且不能设置为客户端组件。

### 4.4. 定义模板（Templates）

模板类似于布局，它也会传入每个子布局或者页面。但不会像布局那样维持状态。

模板在路由切换时会为每一个 children  创建一个实例。这就意味着当用户在共享一个模板的路由间跳转的时候，将会重新挂载组件实例，重新创建 DOM 元素，不保留状态。这听起来有点抽象，没有关系，我们先看看模板的写法，再写个 demo 你就明白了。

定义一个模板，你需要新建一个名为 `template.js` 的文件，该文件默认导出一个 React 组件，该组件接收一个 `children` prop。我们写个示例代码。

在 `app`目录下新建一个 `template.js`文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e19139c038fe4c528f89874541928670~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=444\&s=216678\&e=png\&b=151515)

`template.js` 代码如下：

```javascript
// app/template.js
export default function Template({ children }) {
  return <div>{children}</div>
}
```

你会发现，这用法跟布局一模一样。它们最大的区别就是状态的保持。如果同一目录下既有 `template.js` 也有 `layout.js`，最后的输出效果如下：

```javascript
<Layout>
  {/* 模板需要给一个唯一的 key */}
  <Template key={routeParam}>{children}</Template>
</Layout>
```

也就是说 `layout` 会包裹 `template`，`template` 又会包裹 `page`。

某些情况下，模板会比布局更适合：

* 依赖于 useEffect 和 useState 的功能，比如记录页面访问数（维持状态就不会在路由切换时记录访问数了）、用户反馈表单（每次重新填写）等

* 更改框架的默认行为，举个例子，布局内的 Suspense 只会在布局加载的时候展示一次 fallback UI，当切换页面的时候不会展示。但是使用模板，fallback 会在每次路由切换的时候展示

注：关于模板的适用场景，可以参考[《Next.js v14 的模板（template.js）到底有啥用？》](https://juejin.cn/post/7343569488744300553)，对这两种情况都做了举例说明

#### 布局 VS 模板

为了帮助大家更好的理解布局和模板，我们写一个 demo，展示下两者的特性。

项目目录如下：

```javascript
app
└─ dashboard
   ├─ layout.js
   ├─ page.js
   ├─ template.js
   ├─ about
   │  └─ page.js
   └─ settings
      └─ page.js
```

其中 `dashboard/layout.js` 代码如下：

```javascript
'use client'

import { useState } from 'react'
import Link from 'next/link'

export default function Layout({ children }) {
  const [count, setCount] = useState(0)
  return (
    <>
      <div>
        <Link href="/dashboard/about">About</Link>
        <br/>
        <Link href="/dashboard/settings">Settings</Link>
      </div>
      <h1>Layout {count}</h1>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
      {children}
    </>
  )
}
```

`dashboard/template.js` 代码如下：

```javascript
'use client'

import { useState } from 'react'

export default function Template({ children }) {
  const [count, setCount] = useState(0)
  return (
    <>
      <h1>Template {count}</h1>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
      {children}
    </>
  )
}
```

`dashboard/page.js`代码如下：

```javascript
export default function Page() {
  return <h1>Hello, Dashboard!</h1>
}
```

`dashboard/about/page.js`代码如下：

```javascript
export default function Page() {
  return <h1>Hello, About!</h1>
}
```

`dashboard/settings/page.js`代码如下：

```javascript
export default function Page() {
  return <h1>Hello, Settings!</h1>
}
```

最终展示效果如下（为了方便区分，做了部分样式处理）：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d33ef3073ed46ce9f234880630246dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2558\&h=1624\&s=480097\&e=png\&b=000000)

现在点击两个 `Increment` 按钮，会开始计数。随便点击下数字，然后再点击 `About`或者 `Settings`切换路由，你会发现，Layout 后的数字没有发生变化，Template 后的数字重置为 0。这就是所谓的状态保持。

![10.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461a47c030d64fc7890e35de58feb950~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450\&h=342\&s=33835\&e=gif\&f=54\&b=010101)

注：当然如果刷新页面，Layout 和 Template 后的数字肯定都重置为 0。

线上查看代码和效果：[CodeSandbox Templates VS Layouts](https://codesandbox.io/p/devbox/templates-h25kzz?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt48u2gb00073b6hi8zrj7z5%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt48u2gb00023b6h6qaf1m82%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt48u2gb00043b6hvw4el4sp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt48u2gb00063b6ht7hvjihq%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt48u2gb00023b6h6qaf1m82%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt48u2ga00013b6hrwr6p06f%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt48u2gb00023b6h6qaf1m82%2522%252C%2522activeTabId%2522%253A%2522clt48u2ga00013b6hrwr6p06f%2522%257D%252C%2522clt48u2gb00063b6ht7hvjihq%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt48u2gb00053b6ho6d4dyg7%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%2522%257D%255D%252C%2522id%2522%253A%2522clt48u2gb00063b6ht7hvjihq%2522%252C%2522activeTabId%2522%253A%2522clt48u2gb00053b6ho6d4dyg7%2522%257D%252C%2522clt48u2gb00043b6hvw4el4sp%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt48u2gb00033b6hgzgomtf5%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt48u2gb00043b6hvw4el4sp%2522%252C%2522activeTabId%2522%253A%2522clt48u2gb00033b6hgzgomtf5%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

### 4.5. 定义加载界面（Loading UI）

现在我们已经了解了 `page.js`、`layout.js`、`template.js`的功能，然而特殊文件还不止这些。App Router 提供了用于展示加载界面的 `loading.js`。

这个功能的实现借助了 React 的`Suspense` API。关于 Suspense 的用法，可以查看 [《React 之 Suspense》](https://juejin.cn/post/7163934860694781989)。它实现的效果就是当发生路由变化的时候，立刻展示 fallback UI，等加载完成后，展示数据。

```jsx
// 在 ProfilePage 组件处于加载阶段时显示 Spinner
<Suspense fallback={<Spinner />}>
  <ProfilePage />
</Suspense>
```

初次接触 Suspense 这个概念的时候，往往会有一个疑惑，那就是——“在哪里控制关闭 fallback UI 的呢？”

哪怕在 React 官网中，对背后的实现逻辑并无过多提及。但其实实现的逻辑很简单，简单的来说，ProfilePage 会 throw 一个数据加载的 promise，Suspense 会捕获这个 promise，追加一个 then 函数，then 函数中实现替换 fallback UI 。当数据加载完毕，promise 进入 resolve 状态，then 函数执行，于是更新替换 fallback UI。

了解了原理，那我们来看看如何写这个 `loading.js`吧。`dashboard` 目录下我们新建一个 `loading.js`。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a410face8c0443bda0bba48a3fa4a602~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=606\&s=292947\&e=png\&b=151515)

`loading.js`的代码如下：

```javascript
// app/dashboard/loading.js
export default function DashboardLoading() {
  return <>Loading dashboard...</>
}
```

同级的 `page.js` 代码如下：

```javascript
// app/dashboard/page.js
async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 3000))
  return {
    message: 'Hello, Dashboard!',
  }
}
export default async function DashboardPage(props) {
  const { message } = await getData()
  return <h1>{message}</h1>
}
```

不再需要其他的代码，loading 的效果就实现了：

![11.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cd31cc361fb418f9657597e6916cc59~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450\&h=342\&s=7964\&e=gif\&f=9\&b=000000)

线上查看代码和效果：[CodeSandbox Loading](https://codesandbox.io/p/devbox/loading-yw7zlg?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt4b2khv00073b6hu9pjxkod%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt4b2khv00023b6hl69ez1j6%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%257D%252C%2522clt4b2khv00063b6his95k772%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%257D%252C%2522clt4b2khv00043b6hupnzd9jd%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

就是这么简单。其关键在于 `page.js`导出了一个 async 函数。

`loading.js` 的实现原理是将 `page.js`和下面的 children 用 `<Suspense>` 包裹。因为`page.js`导出一个 async 函数，Suspense 得以捕获数据加载的 promise，借此实现了 loading 组件的关闭。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804284470c16423eb3d3d2d4510996ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=766\&s=442672\&e=png\&b=191919)

当然实现 loading 效果，不一定非导出一个 async 函数。也可以借助 React 的 `use` 函数。现在我们在 `dashboard`下新建一个 `about`目录，在其中新建 `page.js`文件。

`/dashboard/about/page.js` 代码如下：

```javascript
// /dashboard/about/page.js
import { use } from 'react'

async function getData() {
  await new Promise((resolve) => setTimeout(resolve, 5000))
  return {
    message: 'Hello, About!',
  }
}

export default function Page() {
  const {message} = use(getData())
  return <h1>{message}</h1>
}
```

同样实现了 loading  效果：

![12.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa3f3e67b3e348348c03a6492e4581f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450\&h=342\&s=6554\&e=gif\&f=6\&b=000000)

线上查看代码和效果：[CodeSandbox Loading](https://codesandbox.io/p/devbox/loading-yw7zlg?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt4b2khv00073b6hu9pjxkod%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt4b2khv00023b6hl69ez1j6%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00023b6hl69ez1j6%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00013b6hs9i6fr2l%2522%257D%252C%2522clt4b2khv00063b6his95k772%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%252Fabout%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00063b6his95k772%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00053b6hmql3m7p5%2522%257D%252C%2522clt4b2khv00043b6hupnzd9jd%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt4b2khv00043b6hupnzd9jd%2522%252C%2522activeTabId%2522%253A%2522clt4b2khv00033b6h55d7v2oi%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

如果你想针对 `/dashboard/about` 单独实现一个 loading 效果，那就在 `about` 目录下再写一个 `loading.js` 即可。

如果同一文件夹既有 `layout.js` 又有 `template.js` 又有 `loading.js` ，那它们的层级关系是怎样呢？

对于这些特殊文件的层级问题，直接一张图搞定：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0551d59d32b486e8f869e0e6ca8f157~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=641\&s=327102\&e=png\&b=1c1c1c)

### 4.6. 定义错误处理（Error Handling）

再讲讲特殊文件 `error.js`。顾名思义，用来创建发生错误时的展示 UI。

其实现借助了 React 的 [Error Boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) 功能。简单来说，就是给 page.js 和 children 包了一层 `ErrorBoundary`。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2005b09883440cdab2d9a2be0217883~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=901\&s=497446\&e=png\&b=1a1a1a)

我们写一个 demo 演示一下 `error.js` 的效果。`dashboard` 目录下新建一个 `error.js`，目录效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16665406e384c35870c4aa68ea9875a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=606\&s=293046\&e=png\&b=151515)

`dashboard/error.js`代码如下：

```javascript
'use client' // 错误组件必须是客户端组件
// dashboard/error.js
import { useEffect } from 'react'
 
export default function Error({ error, reset }) {
  useEffect(() => {
    console.error(error)
  }, [error])
 
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button
        onClick={
          // 尝试恢复
          () => reset()
        }
      >
        Try again
      </button>
    </div>
  )
}
```

为触发 Error 错误，同级 `page.js` 的代码如下：

```javascript
"use client";
// dashboard/page.js
import React from "react";

export default function Page() {
  const [error, setError] = React.useState(false);

  const handleGetError = () => {
    setError(true);
  };

  return (
    <>{error ? Error() : <button onClick={handleGetError}>Get Error</button>}</>
  );
}
```

效果如下：

![13.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e09190375f63426fbe4ac89c5f8e246f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=450\&h=342\&s=15591\&e=gif\&f=28\&b=000000)

有时错误是暂时的，只需要重试就可以解决问题。所以 Next.js 会在 `error.js` 导出的组件中，传入 `reset` 函数，帮助尝试从错误中恢复。该函数会触发重新渲染错误边界里的内容。如果成功，会替换展示重新渲染的内容。

线上查看代码和效果：[CodeSandbox Error](https://codesandbox.io/p/devbox/error-l6gr2j?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt4bdci200073b6h91twyt7o%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt4bdci200023b6h529g4j8y%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt4bdci200043b6hd7knjpp1%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt4bdci200063b6h8vy2xj52%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt4bdci200023b6h529g4j8y%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4bdci100013b6h9h1wm21z%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522FILE%2522%252C%2522filepath%2522%253A%2522%252FREADME.md%2522%257D%255D%252C%2522id%2522%253A%2522clt4bdci200023b6h529g4j8y%2522%252C%2522activeTabId%2522%253A%2522clt4bdci100013b6h9h1wm21z%2522%257D%252C%2522clt4bdci200063b6h8vy2xj52%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4bdci200053b6hxtxruqpi%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fdashboard%2522%257D%255D%252C%2522id%2522%253A%2522clt4bdci200063b6h8vy2xj52%2522%252C%2522activeTabId%2522%253A%2522clt4bdci200053b6hxtxruqpi%2522%257D%252C%2522clt4bdci200043b6hd7knjpp1%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4bdci200033b6hwspjksxq%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt4bdci200043b6hd7knjpp1%2522%252C%2522activeTabId%2522%253A%2522clt4bdci200033b6hwspjksxq%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

还记得上节讲过的层级问题吗？让我们回顾一下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eeb2e4b635f0473785c0ba9d79df01b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=641\&s=327102\&e=png\&b=1c1c1c)

从这张图里你会发现一个问题：因为 `Layout` 和 `Template` 在 `ErrorBoundary` 外面，这说明错误边界不能捕获同级的 `layout.js` 或者 `template.js` 中的错误。如果你想捕获特定布局或者模板中的错误，那就需要在父级的 `error.js` 里进行捕获。

那问题来了，如果已经到了顶层，就比如根布局中的错误如何捕获呢？为了解决这个问题，Next.js 提供了 `global-error.js`文件，使用它时，需要将其放在 `app` 目录下。

`global-error.js`会包裹整个应用，而且当它触发的时候，它会替换掉根布局的内容。所以，`global-error.js` 中也要定义 `<html>` 和 `<body>` 标签。

`global-error.js`示例代码如下：

```javascript
'use client'
// app/global-error.js
export default function GlobalError({ error, reset }) {
  return (
    <html>
      <body>
        <h2>Something went wrong!</h2>
        <button onClick={() => reset()}>Try again</button>
      </body>
    </html>
  )
}
```
注：`global-error.js` 用来处理根布局和根模板中的错误，`app/error.js` 建议还是要写的

### 4.7. 定义 404 页面

最后再讲一个特殊文件 —— `not-found.js`。顾名思义，当该路由不存在的时候展示的内容。

Next.js 项目默认的 not-found 效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92bd888fdae94703885dcec24825c2d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=872\&h=340\&s=18455\&e=png\&b=000000)

如果你要替换这个效果，只需要在 `app` 目录下新建一个 `not-found.js`，代码示例如下：

```javascript
import Link from 'next/link'
 
export default function NotFound() {
  return (
    <div>
      <h2>Not Found</h2>
      <p>Could not find requested resource</p>
      <Link href="/">Return Home</Link>
    </div>
  )
}
```

not-found 的效果就会更改为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aff4d53c41c94d55b597f8d924f13187~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=806\&h=326\&s=37554\&e=png\&b=000000)


关于 `app/not-found.js` 一定要说明一点的是，它只能由两种情况触发：

1.  当组件抛出了 notFound 函数的时候
1.  当路由地址不匹配的时候

所以 `app/not-found.js` 可以修改默认 404 页面的样式。但是，如果 `not-found.js`放到了任何子文件夹下，它只能由 `notFound`函数手动触发。比如这样：

```javascript
// /dashboard/blog/page.js
import { notFound } from 'next/navigation'

export default function Page() {
  notFound()
  return <></>
}
```

执行 notFound 函数时，会由最近的 not-found.js 来处理。但如果直接访问不存在的路由，则都是由 `app/not-found.js` 来处理。

对应到实际开发，当我们请求一个用户的数据时或是请求一篇文章的数据时，如果该数据不存在，就可以直接丢出 `notFound` 函数，渲染自定义的 `not-found.js` 界面。示例代码如下：

```javascript
// app/dashboard/blog/[id]/page.js
import { notFound } from 'next/navigation'
 
async function fetchUser(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const user = await fetchUser(params.id)
 
  if (!user) {
    notFound()
  }
 
  // ...
}
```

注：后面我们还会讲到“路由组”这个概念，当 `app/not-found.js` 和路由组一起使用的时候，可能会出现问题。具体参考 [《Next.js v14 如何为多个根布局自定义不同的 404 页面？竟然还有些麻烦！欢迎探讨》](https://juejin.cn/post/7351321244125265930)

## 小结

恭喜你，完成了本节内容的学习！

这一节我们重点讲解了 Next.js 基于文件系统的路由解决方案 App Router，介绍了用于定义页面的`page.js`、定义布局的`layout.js`、定义模板的`template.js`、定义加载界面的`loading.js`、定义错误处理的`error.js`、定义 404 页面的`not-found.js`。现在你再看 App Router 的这个目录结构：

```javascript
src/
└── app
    ├── page.js 
    ├── layout.js
    ├── template.js
    ├── loading.js
    ├── error.js
    └── not-found.js
    ├── about
    │   └── page.js
    └── more
        └── page.js
```

> 简单的来说，App Router 制定了更加完善的规范，使代码更好被组织和管理。

对此是不是有了更加深刻的理解呢？然而这还只有 Next.js 强大的路由功能的一小部分。下篇让我们继续学习。

## 参考链接

1.  [Routers - MDN Web Docs Glossary: Definitions of Web-related terms | MDN](https://developer.mozilla.org/en-US/docs/Glossary/Routers)
2.  [Building Your Application: Routing](https://nextjs.org/docs/app/building-your-application/routing)
3.  [Routing: Defining Routes](https://nextjs.org/docs/app/building-your-application/routing/defining-routes)
4.  [Routing: Pages and Layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts)
5.  [Routing: Loading UI and Streaming](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming)
6.  [Routing: Error Handling](https://nextjs.org/docs/app/building-your-application/routing/error-handling)
7.  [File Conventions: not-found.js](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)
8.  [Functions: notFound](https://nextjs.org/docs/app/api-reference/functions/not-found)


## 30.配置篇 | MDX

## 前言

Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。它通常用于在网站和博客上编写内容。比如当你这样书写：

```markdown
**love** using [Next.js](https://nextjs.org/)
```

对应输出为：

```html
<p>I <strong>love</strong> using <a href="https://nextjs.org/">Next.js</a></p>
```

而 [MDX](https://mdxjs.com/) 是 Markdown 的超集，不仅支持 Markdown 本身，还支持在 Markdown 文档中插入 JSX 代码，还可以导入（import）组件，添加交互内容。

实际上，MDX 可以看作是一种融合了 markdown 和 JSX 的格式，就像下面这个示例：

```markdown
# Hello, world!

<div className="note">
  > Some notable things in a block quote!
</div>
```

在这个例子中，标题是 markdown 格式，而那些类似 HTML 的标签则是 JSX 格式。markdown 侧重于编写内容，JSX 侧重于组件添加交互性，看起来是不是很棒？

而 Next.js 既可以支持本地的 MDX 内容，也可以支持服务端动态获取 MDX 文件。Next.js 插件会将 markdown 和 React 组件转换为 HTML。

那就让我们赶紧看看该如何使用 MDX 吧！

## 1. 本地 MDX

本地使用  MDX 需要借助 `@next/mdx`这个包，它从本地文件中获取数据，能够处理 markdown 和 MDX。你需要在 `/pages` 或者`/app` 目录下创建一个以 `.mdx`为扩展名的页面文件。具体的配置和用法如下：

### 1.1. 开始配置

安装渲染 MDX 相关的包：

```bash
npm install @next/mdx @mdx-js/loader @mdx-js/react @types/mdx
```

在应用根目录（`app/` 和 `src/` 的父级）创建一个名为 `mdx-components.js` 的文件，这个文件是在 App Router 中使用 MDX 必须要用到的，没有这个文件会无法正常工作。文件的代码为：

```javascript
// mdx-components.js
export function useMDXComponents(components) {
  return {
    ...components,
  }
}
```

然后更新 `next.config.js`文件：

```javascript
// next.config.js
const withMDX = require('@next/mdx')()
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx']
}
 
module.exports = withMDX(nextConfig)
```

基本配置就完毕了。

### 1.2. 基本用法

现在在 `/app` 目录下创建一个 MDX 页面：

```javascript
  your-project
  ├── app
  │   └── my-mdx-page
  │       └── page.mdx
  └── package.json
```

现在你可以在 MDX 页面使用 markdown 和导入 React 组件：

```javascript
import ComponentA from '../components/a'
 
# Welcome to my MDX page!
 
This is some **bold** and _italics_ text.
 
This is a list in markdown:
 
- One
- Two
- Three
 
Checkout my React component:
 
<ComponentA />
```

打开 `/my-mdx-page` 查看渲染的结果：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dca9e4b9a2cc4250ac9fbe1a06e0c4ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1368\&h=962\&s=106754\&e=png\&b=ffffff)

## 2. 远程 MDX

如果你的 markdown 或者 MDX 文件位于其他位置，你可以在服务端动态获取它，有两个常用的社区包用于获取 MDX 内容：

*   [next-mdx-remote](https://github.com/hashicorp/next-mdx-remote#react-server-components-rsc--nextjs-app-directory-support)
*   [contentlayer](https://www.contentlayer.dev/)

使用外部内容的时候要注意，因为 MDX 会编译成 JavaScript，并且在服务端执行。所以你应该从信任的地方获取 MDX 内容，否则可能导致“远程代码执行”（remote code execution，简写：RCE，让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统）

下面的例子中使用了 `next-mdx-remote`：

```javascript
// app/my-mdx-page-remote/page.js
import { MDXRemote } from 'next-mdx-remote/rsc'

// app/page.js
export default function Home() {
  return (
    <MDXRemote
      source={`# Hello World

      This is from Server Components!
      `}
    />
  )
}
```

当然这个例子中，没有远程获取，而是直接使用了 mdx 文本，打开 `/my-mdx-page-remote` 查看渲染的 MDX：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c53ce4d2e5c34328a318ac011ad449c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1106\&h=418\&s=44123\&e=png\&b=fefefe)
结合远程获取的示例代码为：

```javascript
// app/my-mdx-page-remote/page.js
import { MDXRemote } from 'next-mdx-remote/rsc'
 
export default async function RemoteMdxPage() {
  // MDX 文本
  const res = await fetch('https://...')
  const markdown = await res.text()
  return <MDXRemote source={markdown} />
}
```

那你可能要问，组件呢？组件怎么传进去？一个示例代码如下：

```javascript
// app/my-mdx-page-remote/page.js
import { MDXRemote } from 'next-mdx-remote/rsc'

import ComponentA from '../components/a'

const components = { ComponentA }

export default function Home(props) {
  return (
    <MDXRemote
      source={`Some **mdx** text, with a component <ComponentA />`}
      components={components}
    />
  )
}

```

ComponentA 的组件代码很简单：

```javascript
// app/components/a.js
export default function Page() {
  return <span>Hello World!</span>
}
```

打开 `/my-mdx-page-remote` 查看渲染的 MDX：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bafac3ec8dd4b618fd6ee05242decad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1128\&h=244\&s=33669\&e=png\&b=fefefe)

## 3. 共享布局

要在 MDX 页面之间共享布局，你可以使用 App Router 内置的布局功能：

```javascript
// app/my-mdx-page/layout.js
export default function MdxLayout({ children }) {
  return <div style={{ color: 'blue' }}>{children}</div>
}
```

## 4. 使用插件拓展功能

如果 MDX 样式和功能并不能满足你的要求，那你可能就需要自定义使用和开发插件了。为了帮助你了解如何使用和开发插件，你需要先了解下 MDX 的原理。

简单的来说，MDX 的编译分为两步，一步处理 Markdown，一步处理 HTML。处理的伪代码如下：

```javascript
import { unified } from 'unified'
import remarkParse from 'remark-parse'
import remarkRehype from 'remark-rehype'
import rehypeSanitize from 'rehype-sanitize'
import rehypeStringify from 'rehype-stringify'
 
main()
 
async function main() {
  const file = await unified()
    .use(remarkParse) // 将 markdown 转换为 markdown AST
    .use(remarkRehype) // 转换为 HTML AST
    .use(rehypeSanitize) // HTML 消毒，处理不安全的内容，防止 XSS 攻击
    .use(rehypeStringify) // 将 AST 转换为 HTML
    .process('Hello, Next.js!')
 
  console.log(String(file)) // <p>Hello, Next.js!</p>
}
```

处理 Markdown 的这部分工具体系统称为 [Remark](https://github.com/remarkjs/remark)，处理 HTML 的这部分工具体系统称为 [Rehype](https://github.com/rehypejs/rehype)。Remark 和 Rehype 目前已经有不少的生态插件，比如[语法高亮（rehype-pretty-code）](https://github.com/atomiks/rehype-pretty-code)、[标题自动链接（rehype-autolink-headings）](https://github.com/rehypejs/rehype-autolink-headings)、[生成目录（remark-toc）](https://github.com/remarkjs/remark-toc)等。

如果你想直接使用这些插件，就比如支持 [GFM](https://github.github.com/gfm/)（GitHub Flavored Markdown，目前最流行的 Markdown 扩展语法，它提供了包括表格、任务列表、删除线、围栏代码、Emoji 等在内的标记语法），对应插件是 [remark-gfm](https://github.com/remarkjs/remark-gfm)，可以通过修改 `next.config.js` 来加载插件。

不过因为 remark 和 rehype 都是 ESM（ECMAScript modules），你需要使用 `next.config.mjs` 作为配置文件：

```javascript
// next.config.mjs
import remarkGfm from 'remark-gfm'
import createMDX from '@next/mdx'
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],
}
 
const withMDX = createMDX({
  // 添加 markdown 插件
  options: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [],
  },
})

export default withMDX(nextConfig)
```

GFM 新增了删除线语法：

```markdown
~~这是一段删除文字~~
```

如果不使用 GFM 插件，无法渲染成删除线：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd5ee310b81346ee808066823faa9c6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=832\&h=218\&s=26014\&e=png\&b=fdfdfd)

使用后则会正常渲染：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11103ae1c03e463ba3468982988402c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=826\&h=230\&s=25346\&e=png\&b=fefefe)

## 5. 自定义元素

正常我们书写 markdown，比如写个标题：

```markdown
# header
```

对应 HTML 输出为：

```html
<h1>header</h1>
```

如果我们希望自定义这个输出的结果以及样式，该怎么实现呢？

为了实现这个功能，打开应用根目录定义的 `mdx-components.js`文件，然后添加自定义元素：

```javascript
// mdx-components.js
import Image from 'next/image'
 
export function useMDXComponents(components) {
  return {
    h1: ({ children }) => <h1 style={{ fontSize: '30px' }}>{children}</h1>,
    ...components,
  }
}
```

此时的效果为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73f22f6b3e0d4399af5bb55cc3419b6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1796\&h=404\&s=115661\&e=png\&b=fefefe)

那么问题来了，我怎么知道 markdown 语法都对应的什么标签呢？又可以修改哪些标签呢？这个可以查看 MDX 的文档：<https://mdxjs.com/table-of-components/>

这里要注意的是当使用 img 的时候，如果直接使用 `![]()`语法，加载本地图片，并不会成功：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5b9ea4d77c43a89f2515a5be151f00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1802\&h=344\&s=83338\&e=png\&b=fefefe)

为了加载成功，需要使用 [remark-mdx-images](https://www.npmjs.com/package/remark-mdx-images) 这个插件，安装插件后，修改 `next.config.mjs`：

```javascript
// next.config.mjs
import remarkGfm from 'remark-gfm'
import createMDX from '@next/mdx'
import remarkMdxImages from "remark-mdx-images";

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],
}
 
const withMDX = createMDX({
  // 添加 markdown 插件
  options: {
    remarkPlugins: [remarkGfm, remarkMdxImages],
    rehypePlugins: [],
  },
})

export default withMDX(nextConfig)
```

再修改 `mdx-components.js`：

```javascript
// mdx-components.js
import Image from 'next/image'
 
export function useMDXComponents(components) {
  return {
    h1: ({ children }) => <h1 style={{ fontSize: '30px' }}>{children}</h1>,
    img: (props) => (
      <Image
        sizes="100vw"
        style={{ width: '100%', height: 'auto' }}
        {...props}
      />
    ),
    ...components,
  }
}
```

此时图片即可正常加载：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08e534297a3045fc8991463e6e302add~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2132\&h=912\&s=1167143\&e=png\&b=2c2c2c)

## 6. Frontmatter

Frontmatter 是一个类似于 YAML 的键值对结构，用于储存页面相关的数据。

```markdown
---
title: 你好世界
created: 2023-11-18
---
Hello World!
```

默认情况下，`@next/mdx`并不支持 frontmatter，但社区有很多解决方案，比如：

*   [remark-frontmatter](https://github.com/remarkjs/remark-frontmatter)
*   [gray-matter](https://github.com/jonschlinkert/gray-matter)

我们以 [remark-frontmatter](https://github.com/remarkjs/remark-frontmatter) 为例进行讲解，当搭配 MDX 的时候，还需要使用 [remark-mdx-frontmatter](https://github.com/remcohaszing/remark-mdx-frontmatter)。

首先安装依赖：

```bash
npm install remark-frontmatter remark-mdx-frontmatter
```

然后修改 `next.config.mjs`：

```javascript
import remarkGfm from 'remark-gfm'
import createMDX from '@next/mdx'
import remarkMdxImages from "remark-mdx-images";
import remarkFrontmatter from 'remark-frontmatter'
import remarkMdxFrontmatter from 'remark-mdx-frontmatter'

/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['js', 'jsx', 'mdx', 'ts', 'tsx'],
}
 
const withMDX = createMDX({
  // 添加 markdown 插件
  options: {
    remarkPlugins: [
      remarkGfm, 
      remarkMdxImages,
      [remarkFrontmatter],
      [remarkMdxFrontmatter]
    ],
    rehypePlugins: [],
  },
})

export default withMDX(nextConfig)
```

基本配置就完成了，但是要注意，这两个插件的效果并不是像我们写 VuePress 中的 md 文档一样，可以用 frontmatter 中的数据定义页面的标题等数据，我们现在建立一个 mdx 文档：

```markdown
---
title: 这是文章标题
author: 冴羽
---

# header1
```

页面不会有什么变化，页面的标题不会变成 frontmatter 中设置的这个标题，也不会输出 `<meta name="author" content="冴羽">`这种 HTML 标签，这两个插件的作用就是储存元数据，用转换后的 JS 描述就是：

```javascript
export const frontmatter = {
  title: '这是文章标题'，
  author: '冴羽'
}

export default function MDXContent() {
  return <h1>header1</h1>
}
```

也就是说，使用这两个插件后，如果导入这个 MDX 文档，会有一个 frontmatter 导出对象，让你能够获取到在 MDX 文档中通过 frontmatter 格式设置的值，仅此而已。我们新建一个 `page.js`验证一下：

```javascript
import {frontmatter} from '../my-mdx-page/page.mdx'

export default function Page() {
  console.log(frontmatter)
  return  <h1>Hello World!</h1>
}
```

可以看命令行中看到输出：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da51d562f2404aeeba1a7dc571c10298~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=620\&h=56\&s=53556\&e=png\&b=020509)

那你可能想，这有什么用呢？

这可以为我们的开发提供很多便利。试想我们开发一个博客功能，在 `contents` 文件夹下建立多个 MDX 文档，作为我们的博客内容。当我们访问比如 `article/1`的时候，导入对应 id 的 MDX 文档，然后获取其中的元数据，渲染通用的一些展示内容，比如标题、作者、更新时间、标签等，这不就是一个很实用的功能嘛\~

当然这样说有些抽象，我们简单写个 demo，文件目录结构如下：

```javascript
  your-project
  ├── app
  │   └── content
  │       └── 1.mdx
  │   └── article
  │       └── [id]
	│       		└── page.js
  └── package.json
```

`app/content/1.mdx`的内容如下：

```markdown
---
title: Next.js 小册
author: 冴羽
---

# 一级标题

这是正文内容
```

这是我们要获取的文章具体内容。`article/[id]/page.js`的代码如下：

```javascript
// article/[id]/page.js
export default async function Page({ params: {id} }) {
  const articleModule = await import(`../../content/${id}.mdx`);
  const { default: Component, frontmatter: {title, author} } = articleModule;

  return (
    <main>
       <div>文章标题：{title}</div>
       <div>文章作者：{author}</div>
       <Component /> 
    </main>
  )
}
```

在这个例子中，我们通过 import() 获取到了模块内容，然后解构出了 frontmatter 对象和页面内容组件。打开 `http://localhost:3000/article/1`，渲染的结果为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b091f71112014377ae32069c175069c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1076\&h=480\&s=53560\&e=png\&b=fefefe)

当然了，如果你对 frontmatter 没有那么热爱，其实你也可以直接在`.mdx` 文件导出一个 meta 对象，示例代码如下：

```javascript
export const meta = {
  title: 'Next.js 小册',
  author: '冴羽'
}

# 一级标题

这是正文内容
```

修改下 `article/[id]/page.js`的代码（将 frontmatter 替换为 meta）：

```javascript
export default async function Page({ params: {id} }) {
  const articleModule = await import(`../../content/${id}.mdx`);
  const { default: Component, meta: {title, author} } = articleModule;

  return (
    <main>
       <div>文章标题：{title}</div>
       <div>文章作者：{author}</div>
       <Component /> 
    </main>
  )
}
```

也可以正常渲染：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14cf9aeadd14487f9153eb50bfd804d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=906\&h=460\&s=50538\&e=png\&b=fefefe)

所以就看你是否想要使用 Frontmatter 这种格式。

## 7. 使用基于 Rust 的 MDX 编译器

Next.js 支持一个用 Rust 编写的 MDX 编译器。目前这个编译器还在实验中，不建议生产环境中使用。但如果你想要尝试这个新编译器，在`next.config.js`中开启配置：

```javascript
// next.config.js
module.exports = withMDX({
  experimental: {
    mdxRs: true,
  },
})
```

## 参考链接

1.  <https://github.com/altano/alan.norbauer.com/blob/main/next.config.mjs>
2.  [Configuring: MDX | Next.js](https://nextjs.org/docs/pages/building-your-application/configuring/mdx)
3.  <https://github.com/remarkjs/remark-frontmatter>
4.  <https://mdxjs.com/>
5.  <https://www.npmjs.com/package/@next/mdx>
6.  <https://github.com/remarkjs/remark>
7.  <https://github.com/rehypejs/rehype>


## 31.配置篇 | 草稿模式和内容安全策略

## 前言

本篇我们介绍草稿模式和内容安全策略，两者都是特殊场景下会用到的解决方案。草稿模式用于针对特定情况切换到动态渲染，正如它的名字一样，适用于内容系统的草稿展示。内容安全策略用于阻止脚本恶意加载。现在让我们开始学习吧。

## 1. 草稿模式（Draft Mode）

### 1.1. 介绍

草稿模式一般是结合 headless CMS 使用。先说说 CMS，所谓 CMS，Content Management System，中文译为内容管理系统。

> 内容管理系统的定义可以很狭窄，通常是指门户或商业网站的发布和管理系统；定义也可以很宽泛，个人网站系统也可归入其中。Wiki也是一种内容管理系统，Blog也算是一种内容管理系统。

比如常用于搭建博客的 Wordpress 就是一个知名的内容管理系统。这些年来，headless CMS 也流行了起来。所谓 headless CMS，简单的来说，CMS 不再负责内容的展现，只提供内容存储库以及 API，这使得开发人员可以自定义展示内容，虽然带来了一定的工作量，但也让开发更加灵活自由。

现在说回 Next.js，当你从 headless CMS 中获取数据展示内容的时候，通常静态渲染（编译成 HTML，然后直接展现）就可以了，但如果你是在 headless CMS 中编写草稿，并希望能在页面立即查看到草稿内容时，静态渲染就不合适了，你会希望 Next.js 在请求时而非在构建时渲染页面，获取的是草稿内容而非发布的内容。这个时候就需要草稿模式了。它会让 Next.js 针对特定情况切换到动态渲染。让我们来看看怎么实现的吧。

### 1.2. 实现

#### 1.2.1. 创建并访问路由处理程序

首先，创建一个路由处理程序，名字无所谓，就比如 `app/api/draft/route.js`。

然后，从 `next/headers`中导入 `draftMode`，调用 `enable()` 方法。

```javascript
// app/api/draft/route.js
import { draftMode } from 'next/headers'
 
export async function GET(request) {
  draftMode().enable()
  return new Response('Draft mode is enabled')
}
```

这将设置一个 cookie 用于开启草稿模式，后续包含这个 cookie 的请求都会触发草稿模式，从而改变静态生成页面的行为。

关于这个 cookie，现在通过浏览器开发工具查看 `/api/draft`请求，你会在 `Set-Cookie` 响应头中发现一个名为 `__prerender_bypass`的 cookie，就是此 cookie 控制了页面的展现方式。此外，每次运行 `next build`的时候都会生成一个新的 cookie 值以确保该值不会被猜到。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac10557004dc4aaa8fcef1fed316fe44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2546\&h=1352\&s=391251\&e=png\&b=242424)

如果你想要更加安全的使用草稿模式，这是一个建议的使用方式：

首先，创建一个秘密的 token 字符串，此密钥只有你的 Next.js 应用程序和 headless CMS 知道，这个密钥可以防止无权访问 CMS 的用户访问草稿 URL。

然后，设置类似下面这样的草稿 URL，假设路由处理程序的地址是 `app/api/draft/route.js`，对应的草稿 URL 为：

```markdown
https://<your-site>/api/draft?secret=<token>&slug=<path>
```

其中 `<path>` 表示你想要查看的页面路径，比如你想要查看 `/posts/foo`，这里就是 `&slug=/posts/foo`。

最后你就可以在路由处理程序中，进行各种判断比如密钥是否匹配，参数是否存在，然后再开启 Draft Mode，重定向到预览的路径，示例代码如下：

```javascript
// app/api/draft/route.js
import { draftMode } from 'next/headers'
import { redirect } from 'next/navigation'
 
export async function GET(request) {
  const { searchParams } = new URL(request.url)
  const secret = searchParams.get('secret')
  const slug = searchParams.get('slug')
 
  if (secret !== 'MY_SECRET_TOKEN' || !slug) {
    return new Response('Invalid token', { status: 401 })
  }
 
  const post = await getPostBySlug(slug)
 
  if (!post) {
    return new Response('Invalid slug', { status: 401 })
  }
 
  draftMode().enable()
 
  redirect(post.slug)
}
```

如果成功的话，浏览器就会重定向到你想要查看的路径。

#### 1.2.2. 更新页面

第二步就是通过检查 `draftMode().isEnabled`的值来更新页面。如果请求的页面有设置 cookie，此时 `isEnabled` 的值就会是 `true`。

```javascript
// app/page.js
import { draftMode } from 'next/headers'
 
async function getData() {
  const { isEnabled } = draftMode()
 
  const url = isEnabled
    ? 'https://draft.example.com'
    : 'https://production.example.com'
 
  const res = await fetch(url)
 
  return res.json()
}
 
export default async function Page() {
  const { title, desc } = await getData()
 
  return (
    <main>
      <h1>{title}</h1>
      <p>{desc}</p>
    </main>
  )
}
```

这样，当你从 headless CMS 或者手动带 secret 和 slug 访问路由处理程序的时候，你应该能成功的看到草稿内容。

#### 1.2.3. 其他

默认情况下，草稿模式的 session 会在浏览器关闭时结束。如果你想要手动清理草稿模式的 cookie，你可以创建一个路由处理程序，在此程序中调用 `draftMode().disable()`。

```javascript
// app/api/disable-draft/route.js
import { draftMode } from 'next/headers'
 
export async function GET(request) {
  draftMode().disable()
  return new Response('Draft mode is disabled')
}
```

然后，发送一个请求到 `/api/disalbe-draft` 调用路由处理程序，如果你使用 `next/link` 来调用这个路由，你必须传递 `prefetch={false}`来防止 prefetch 时意外删除 cookie。

## 2. 内容安全策略（Content Security Policy）

### 2.1. HTTP CSP

介绍 Next.js 的 CSP 实现方式前，我们先说下 HTTP 请求中的 [CSP](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)。

所谓 CSP，Content Security Policy，中文译为“内容安全策略”。CSP 用于检测并削弱某些特定类型的攻击，包括跨站脚本（XSS）和数据注入攻击等。

该安全策略的实现基于一个叫做 Content-Security-Policy 的 HTTP 首部。除此之外，<meta> 元素也可以被用来配置该策略，例如：

```javascript
<meta
  http-equiv="Content-Security-Policy"
  content="default-src 'self'; img-src https://*; child-src 'none';" />
```

CSP 到底是怎么缓解攻击的呢？以 XSS 攻击为例：

> XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。
>
> CSP 通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除 XSS 攻击所依赖的载体。一个 CSP 兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本（包括内联脚本和 HTML 的事件处理属性）。

你可以使用 [Content-Security-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy) HTTP 标头来指定你的策略，像这样：

```javascript
Content-Security-Policy: policy
```

policy 表示策略，是一个包含了各种描述你的 CSP 策略指令的字符串。对于不同类型的项目都有特定的指令，因此每种类型都可以有自己的指令，包括字体、frame、图像、音频和视频媒体、script 和 worker。比如我们要限制图片的加载需要用 `img-src`，限制多媒体文件的加载需要用 `media-src`，限制脚本的加载需要用 `script-src`，举个例子：

```markdown
Content-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com
```

在这个例子里，各种内容默认仅允许从文档所在的源获取，但存在如下例外：

*   图片可以从任何地方加载 (注意“\*”通配符)
*   多媒体文件仅允许从 media1.com 和 media2.com 加载（不允许从这些站点的子域名）
*   可运行脚本仅允许来自于 userscripts.example.com

具体有哪些指令（`*-src`这种）可以查看 MDN 的 [CSP 指令文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/base-uri)，我数了一下，具体有 29 种指令。而具体的指令内容的书写方式除了 `'self'` 这种表示自身域，`media1.com`这种表示具体的域名之外，还有总共 13 种类型写法，具体可以查看 [CSP source values](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/Sources)。

我们举一个后面讲解会用到的—— `'nonce-<base64-value>'`，使用示例如下：

```markdown
Content-Security-Policy: default-src 'self'; script-src 'nonce-rBcd2m'
```

`'nonce-<base64-value>'`表示允许使用加密随机数的特定内联脚本。还记得 `<script>` 有一个 [nonce](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/nonce) 属性吗？就是搭配 CSP 来使用：

```html
<script nonce="rBcd2m">
	//...
</script>
```

如果脚本 nonce 的值跟 CSP 中的值一致，该脚本的内容就可以得到执行。

### 2.2. Next.js CSP

回到 Next.js，尽管 CSP 可以阻止恶意脚本，不过有的时候，使用内联脚本是必需的。在这种情况下，就需要借助随机数来保证脚本正确执行，为此我们需要借助 Next.js 中间件来实现，举个例子：

```javascript
// middleware.js
import { NextResponse } from 'next/server'
 
export function middleware(request) {
  const nonce = Buffer.from(crypto.randomUUID()).toString('base64')
  const cspHeader = `
    default-src 'self';
    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';
    style-src 'self' 'nonce-${nonce}';
    img-src 'self' blob: data:;
    font-src 'self';
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
    block-all-mixed-content;
    upgrade-insecure-requests;
`
  const contentSecurityPolicyHeaderValue = cspHeader
    .replace(/\s{2,}/g, ' ')
    .trim()
 
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-nonce', nonce)
  requestHeaders.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  const response = NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  })
  response.headers.set(
    'Content-Security-Policy',
    contentSecurityPolicyHeaderValue
  )
 
  return response
}
```

中间件可以让你能够在页面渲染之前添加标题和随机数。每次查看页面时，都会生成一个新的随机数。这也意味着你必须使用动态渲染来添加随机数。


默认情况下，中间件会在所有请求上运行，如果要运行在特定路径上，使用 matcher，具体参考小册[《路由篇 | 路由处理程序和中间件》](https://juejin.cn/book/7307859898316881957/section/7308914343129645065)。Next.js 建议忽略匹配 prefetch（来自 `next/link`）和静态资源，它们也不需要 CSP header。

```javascript
// middleware.js
export const config = {
  matcher: [
    /*
     * 匹配所有的请求路径，除了以这些开头的
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    {
      source: '/((?!api|_next/static|_next/image|favicon.ico).*)',
      missing: [
        { type: 'header', key: 'next-router-prefetch' },
        { type: 'header', key: 'purpose', value: 'prefetch' },
      ],
    },
  ],
}
```

然后你就可以在服务端组件中读取随机数，从而脚本组件正确执行：

```javascript
// app/page.jsx
import { headers } from 'next/headers'
import Script from 'next/script'
 
export default function Page() {
  const nonce = headers().get('x-nonce')
 
  return (
    <Script
      src="https://www.googletagmanager.com/gtag/js"
      strategy="afterInteractive"
      nonce={nonce}
    />
  )
}
```

## 参考链接

1.  [内容安全策略（CSP） - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)
2.  [Configuring: Draft Mode | Next.js](https://nextjs.org/docs/app/building-your-application/configuring/draft-mode)
3.  [Configuring: Content Security Policy | Next.js](https://nextjs.org/docs/app/building-your-application/configuring/content-security-policy)


## 32.部署篇 | 静态导出

## 前言

我们正常部署 Next.js 应用都是需要在服务器上起一个 server 来实现，但其实也可以不这样做。Next.js 也支持类似于静态网站或者单页应用（SPA）的形式。这就是本章要讲解的静态导出（Static Exports）功能。

它的效果是这样的：当你执行构建（`npm run build`）后，Next.js 会为每一个路由生成一个单独的 HTML 文件，以及相关使用的 CSS、JavaScript、图片等资源，这些内容会放到你指定的文件夹下，你可以将这个文件夹下的内容直接部署使用。

但效果跟传统的静态网站不一样的是，Next.js 生成的网站效果类似于 SPA，即路由虽然发生变化，但页面不会加载刷新。

让我们看看怎么实现静态导出吧！

## 1. 配置

要启用静态导出，修改 `next.config.js` 的导出模式：

```javascript
// next.config.js
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  output: 'export',
  // 可选: 默认导出目录为 out，distDir 可以更改这个目录名 `out` -> `dist`
  // distDir: 'dist',
}
 
module.exports = nextConfig
```

运行 `next build` 后，Next.js 会创建一个名为 `out` 的文件夹包含该应用所需的 HTML、CSS、JS 等资源。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0575099c35f3432bac5e2af8734dca71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3290\&h=634\&s=336366\&e=png\&b=1d1f20)

## 2. 行为

为了支持静态导出，Next.js 的核心部分都进行了改造，让我们了解一下这些核心部分在静态导出的时候的行为和特性吧：

### 2.1. 服务端组件

当配置静态导出运行 `next build` 的时候，`app` 目录下的服务端组件会在构建期间运行，这个过程类似于传统的静态站点生成。

这些组件会渲染成静态的 HTML 文件（用于初始化页面加载）和客户端路由导航之间的静态 payload。当使用静态导出时，服务端组件不需要进行任何更改，除非它们使用了动态服务端函数，下文会讲到在静态导出中不支持的功能。

```jsx
// app/page.jsx
export default async function Page() {
  // 在 `next build` 的时候 fetch 请求会执行
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1')
  const data = await res.json()
 
  return <main>{data.title}</main>
}
```

编译变成 HTML 文件后：

```html
<!DOCTYPE html>
<html>

<head>
  <meta charSet="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
	///...
</head>

<body>
  <main>sunt aut facere repellat provident occaecati excepturi optio reprehenderit</main>
  //...
</body>

</html>
```

### 2.2. 客户端组件

页面不一定总是静态资源，有点时候，也需要在页面打开或者发生交互的时候获取数据，此时就需要使用客户端组件。如果要在客户端获取数据，可以使用带有 [SWR](https://github.com/vercel/swr) 的客户端组件记忆化请求：

```javascript
'use client'
// app/other/page.js
import useSWR from 'swr'
 
const fetcher = (url) => fetch(url).then((r) => r.json())
 
export default function Page() {
  const { data, error } = useSWR(
    `https://jsonplaceholder.typicode.com/posts/1`,
    fetcher
  )
  if (error) return 'Failed to load'
  if (!data) return 'Loading...'
 
  return data.title
}
```

因为路由导航发生在客户端，其行为类似于传统的 SPA。举个例子：

```javascript
// app/page.js
import Link from 'next/link'
 
export default function Page() {
  return (
    <>
      <h1>Index Page</h1>
      <p>
        <Link href="/other">Other Page</Link>
      </p>
    </>
  )
}
```

现在我们运行 `npm run build` 执行构建，然后对导出的 `out` 文件夹起一个服务（VSCode 可以用 Live Server 这个插件），你会发现它的表现类似于 SPA：

![1111.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/088c675b6c0f483d83cadd3ae7425cc6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=421\&h=309\&s=19314\&e=gif\&f=17\&b=fefefe)

这是为了避免在客户端加载不必要的 JavaScript 代码，从而减小 bundle 的大小，实现更快的页面加载。

但它跟传统的 SPA 还不一样。因为传统 SPA 的 HTML 是一个“空的”，只有一个可以挂载的根节点比如这样：

```html
<div id='root'></div>
<script src="app.js" />
```

但 Next.js 构建出来的无论是服务端组件还是客户端组件，都是有 HTML 内容的。

### 2.3. 图片优化

在使用静态导出的时候，并不能使用带有默认 loader 的 `next/image` 组件，举个例子：

```javascript
// app/page.js
import Image from 'next/image'
import profilePic from './me.png'
 
export default function Page() {
  return (
    <Image
      src={profilePic}
      alt="Picture of the author"
    />
  )
}
```

开发模式下会出现错误提示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b87cea08bfec4f12bd0243cf2a50e401~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1898\&h=320\&s=98953\&e=png\&b=ffffff)

你可以自定义配置一个 loader，比如使用 Cloudinary（提供基于云的图像和视频管理服务。用户能够上载，存储，管理，操纵和交付用于网站和应用程序的图像和视频）。

首先配置 `next.config.js`：

```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  images: {
    loader: 'custom',
    loaderFile: './my-loader.js',
  },
}
 
module.exports = nextConfig
```

其次，添加自定义 loader 的代码：

```javascript
// my-loader.js
export default function cloudinaryLoader({ src, width, quality }) {
  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`]
  return `https://res.cloudinary.com/demo/image/upload/${params.join(
    ','
  )}${src}`
}
```

现在，你就可以使用 `next/image` 组件：

```javascript
// app/page.js
import Image from 'next/image'
 
export default function Page() {
  return <Image alt="turtles" src="/turtles.jpg" width={300} height={300} />
}
```


此时图片能够正确展示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/526da7f547d8452a80140affc5571e77~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1790\&h=742\&s=838758\&e=png\&b=2b2b2b)

你可能会想：“好麻烦！我就想简单展示个图片，还要去找个图片服务吗？”，其实你也可以直接使用 `<img>` 标签，但对应会失去 `next/image` 组件带来的优化。比如把图片放在 `/public` 下后使用 img 标签读取也可以正常展示：

```javascript
// app/page.js
export default function Page() {
  return <img width="300" src="/image.png" />
}
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e84d8d5821148ac9c6e6d0a550953ce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1796\&h=526\&s=439599\&e=png\&b=2c2b2b)

### 2.4. 路由处理程序

路由处理程序在运行 `next build` 的时候会渲染一个静态的响应。只有在 `GET` 请求被支持。这可以用于生成静态的 HTML、JSON、TXT 或者其他文件。举个例子：

```javascript
// app/data.json/route.js
export async function GET() {
  return Response.json({ name: 'Lee' })
}
```

`app/data.json/rout.js` 会在 `next build` 的时候渲染成一个静态的名为 `data.json`的文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16c4393ca4b24e448fee96ce1292254c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1306\&h=586\&s=140151\&e=png\&b=1e2022)

如果你需要从传入的请求中读取动态值，那就不能使用静态导出了。

### 2.5. 浏览器 API

在运行 `next build` 的时候，客户端组件会被预渲染成  HTML。因为 Web APIs 像 `window`、`localStorage` 和 `navigator` 在服务端是不可用的，所以你需要保证仅在浏览器中运行的时候才访问这些 API，举个例子：

```javascript
'use client';
 
import { useEffect } from 'react';
 
export default function ClientComponent() {
  useEffect(() => {
    // 现在可以访问 `window`
    console.log(window.innerHeight);
  }, [])
 
  return ...;
}
```

## 3. 不支持的功能

需要 Nodejs server 的功能或者在构建过程中需要计算的动态逻辑都是不支持的，具体有：

*   [Dynamic Routes](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes) 中 `dynamicParams: true`
*   [Dynamic Routes](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes) 没有使用`generateStaticParams()`
*   [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) 依赖传入的请求
*   [Cookies](https://nextjs.org/docs/app/api-reference/functions/cookies)
*   [Rewrites](https://nextjs.org/docs/app/api-reference/next-config-js/rewrites)
*   [Redirects](https://nextjs.org/docs/app/api-reference/next-config-js/redirects)
*   [Headers](https://nextjs.org/docs/app/api-reference/next-config-js/headers)
*   [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware)
*   [Incremental Static Regeneration](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)
*   [Image Optimization](https://nextjs.org/docs/app/building-your-application/optimizing/images) 使用默认 loader
*   [Draft Mode](https://nextjs.org/docs/app/building-your-application/configuring/draft-mode)

在 `next dev` 的时候尝试使用这些功能都会导致错误。

## 4. 部署

使用静态导出，Next.js 可以部署和托管在任何能处理 HTML、CSS 、JS 静态资源的 Web 服务器上。

运行 `next build` 的时候，Next.js 会生成静态文件到 `out` 文件夹下，举个例子，假如你有这些路由：

*   `/`
*   `/blog/[id]`

运行 `next build`后，Next.js 会生成以下文件：

*   `/out/index.html`
*   `/out/404.html`
*   `/out/blog/post-1.html`
*   `/out/blog/post-2.html`

有 `post-1.html、post-2.html` 这些文件是因为定义了 `generateStaticParams`，不使用该函数也无法静态导出。

但此时路由跳转的时候会有一个问题，就比如从 `/`跳转到 `/other`，第一次没有问题，因为页面类似于 SPA，但是刷新 `/other`就会导致错误，原本的 `/other` 被编译成了 `other.html`，访问 `/other.html` 才会正常访问。让我们看下演示：

![1112.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/541d355a7bd3484295dca0d94edd7160~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=590\&h=302\&s=80542\&e=gif\&f=52\&b=fefefe)

为了解决这个问题，如果你使用了比如 Nginx，那你可以配置一个从传入请求到正确文件的重写：

```javascript
# nginx.conf
server {
  listen 80;
  server_name acme.com;
 
  root /var/www/out;
 
  location / {
      try_files $uri $uri.html $uri/ =404;
  }
 
  # 当配置 `trailingSlash: false`，这是必要的
  # 当配置 `trailingSlash: true`，可以省略
  location /blog/ {
      rewrite ^/blog/(.*)$ /blog/$1.html break;
  }
 
  error_page 404 /404.html;
  location = /404.html {
      internal;
  }
}
```

## 参考链接

1. [https://nextjs.org/docs/app/building-your-application/deploying/static-exports](https://nextjs.org/docs/app/building-your-application/deploying/static-exports)


## 33.API 篇 | next.config.js（上）

## 前言

Next.js 可以通过根目录的 `next.config.js` 进行配置：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  /* config options here */
}
 
module.exports = nextConfig
```

正如文件的扩展名是 `.js`，`next.config.js` 是一个常规的 Node.js 模块，而不是一个 JSON 文件。它会在 Next.js server 和构建阶段被用到，并且不包含在浏览器构建中（代码不会打包到客户端）。

如果你需要 ECMAScript 模块，你可以使用 `next.config.mjs`：

```javascript
/**
 * @type {import('next').NextConfig}
 */
const nextConfig = {
  /* config options here */
}
 
export default nextConfig
```

你也可以使用一个函数：

```javascript
export default (phase, { defaultConfig }) => {
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
```

从 Next.js 12.1.0 起，你还可以使用一个异步函数：

```javascript
module.exports = async (phase, { defaultConfig }) => {
  /**
   * @type {import('next').NextConfig}
   */
  const nextConfig = {
    /* config options here */
  }
  return nextConfig
}
```

其中 `phase` 表示配置加载的当前上下文。通过[查看源码](https://github.com/vercel/next.js/blob/5e6b008b561caf2710ab7be63320a3d549474a5b/packages/next/shared/lib/constants.ts#L19-L23)，可以知道 `phase` 的值一共有 5 个：

```javascript
export const PHASE_EXPORT = 'phase-export'
export const PHASE_PRODUCTION_BUILD = 'phase-production-build'
export const PHASE_PRODUCTION_SERVER = 'phase-production-server'
export const PHASE_DEVELOPMENT_SERVER = 'phase-development-server'
export const PHASE_TEST = 'phase-test'
```

可以通过 `next/constants` 导入，根据不同的阶段进行自定义配置：

```javascript
const { PHASE_DEVELOPMENT_SERVER } = require('next/constants')
 
module.exports = (phase, { defaultConfig }) => {
  if (phase === PHASE_DEVELOPMENT_SERVER) {
    return {
      /* 这里放 development 配置选项 */
    }
  }
 
  return {
    /* 除了 development 阶段的其他阶段的配置 */
  }
}
```

在这个例子中，注释行的地方就是你可以放配置的地方，实际上，Next.js 定义的配置非常多，可以查看[源码配置文件](https://github.com/vercel/next.js/blob/canary/packages/next/src/server/config-shared.ts)。

然而，这些配置又都不是必须的，也没有必要清楚的了解每个配置的作用，大致看一下，有个印象即可，需要用到的时候再去细查。

因为要讲解的配置有 36 个，内容繁琐细节且庞大，所以 `next.config.js` 的配置部分拆分为上下两篇。上篇讲解请求相关的 headers、redirects、rewrites，这是 Next.js 中常用的配置，且内容有很多相似之处，放在一起方便触类旁通。下篇讲解剩余的 33 个配置，每个配置内容都不多，了解即可。

现在让我们开始学习吧！

## 1. headers

### 1.1. 介绍

Headers 用于设置自定义 HTTP 标头，使用 `next.config.js` 的 `headers`字段：

```javascript
module.exports = {
  async headers() {
    return [
      {
        source: '/about',
        headers: [
          {
            key: 'x-custom-header',
            value: 'my custom header value',
          },
          {
            key: 'x-another-custom-header',
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

此时访问 `/about`，可以看到：

![截屏2023-11-09 下午3.40.56.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca0818d69f76450182e9e9834080e0eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2304\&h=1528\&s=400155\&e=png\&b=2a2a2a)

`headers`是一个异步函数，该函数返回一个包含 `soruce` 和 `headers` 属性的对象数组，其中：

*   `source` 表示传入的请求路径
*   `headers` 是一个包含 key 和 value 属性的响应标头对象数组

除了这两个值外，还可以设置：

*   `basePath`：`false` 或者 `undefined`。当值为 `false` ，匹配时不会包含 `basePath`，只能用于外部重写
*   `locale`：`false` 或者 `undefined`，匹配时是否应该包含 locale
*   `has`：一个有 `type`、`key`、`value` 属性的对象数组
*   `missing`：一个有 `type`、`key`、`value` 属性的对象数组

headers 会在文件系统（包括页面和 `/public` 文件）之前被触发。

这些字段我们来一一举例介绍。

### 1.2. source

source 表示传入的请求路径，除了可以匹配具体的值，还支持三种匹配模式：

#### 路径匹配

普通的路径匹配，举个例子，`/blog:slug` 会匹配 `/blog/hello-world`（无嵌套路径，也就是说 `/blog/hello-world/about`不会匹配）

```javascript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/blog/:slug',
        headers: [
          {
            key: 'x-slug',
            value: ':slug', // 匹配参数可以在 value 中使用
          },
          {
            key: 'x-slug-:slug', // 匹配参数可以在 key 中使用
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

访问 `/blog/hello-world`，可以看到：

![截屏2023-11-09 下午4.00.05.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f430b2c5e9a44a7d88dcaf32a3bdbad9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2294\&h=1516\&s=410172\&e=png\&b=2a2a2a)

但访问 `/blog/hello-world/about`就不会有自定义标头。

#### 通配符路径匹配

在参数后使用 `*` 实现通配符路径匹配，举个例子：`/blog/:slug*` 会匹配 `/blog/a/b/c/d/hello-world`：

```javascript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/blog/:slug*',
        headers: [
          {
            key: 'x-slug',
            value: ':slug*',
          },
          {
            key: 'x-slug-:slug*',
            value: 'my other custom header value',
          },
        ],
      },
    ]
  },
}
```

访问 `/blog/hello-world/about`，可以看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72fc974d27674c02a4e40057c49cc1ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=786\&h=84\&s=20629\&e=png\&b=282828)

访问 `/blog/hello-world` 也是有的：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c5756cc8262461a945a66436db9ee92~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=700\&h=88\&s=17996\&e=png\&b=282828)

#### 正则表达式路径匹配

在参数后用括号将正则表达式括住实现正则表达式匹配，举个例子：`blog/:slug(\\d{1,})` 匹配 `/blog/123` 而不匹配 `/blog/abc`

```javascript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/blog/:post(\\d{1,})',
        headers: [
          {
            key: 'x-post',
            value: ':post',
          },
        ],
      },
    ]
  },
}
```

访问 `/blog/123`，可以看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0738859e301945d9967e538636722a43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=402\&h=52\&s=7281\&e=png\&b=282828)

注意：这 8 个字符  `(`、`)`、 `{`、 `}`、 `:`、 `*`、 `+`、 `?` 都会用于正则表达式匹配，所以需要用到这些字符本身的时候，使用 `\\`转义

```javascript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        // 匹配 `/english(default)/something`
        source: '/english\\(default\\)/:slug',
        headers: [
          {
            key: 'x-header',
            value: 'value',
          },
        ],
      },
    ]
  },
}
```

### 1.3. headers

headers 无须多说，我们聊聊 headers 的覆盖行为。

如果两个 headers 匹配相同的路径以及设置了相同的 header key，最后一个 header 的 key 会覆盖前一个。举个例子：

```javascript
// next.config.js
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'x-hello',
            value: 'there',
          },
        ],
      },
      {
        source: '/hello',
        headers: [
          {
            key: 'x-hello',
            value: 'world',
          },
        ],
      },
    ]
  },
}
```

在这个例子中，当访问 `/hello` 时，既匹配 `/:path*`，又匹配 `/hello`，而两个 source 对应设置的 `x-hello` 的 key 值不同，因为`/hello` 是最后一个 header，所以最终的值是 `world`。

那如果匹配了相同的路径，但设置的  header key 不冲突呢？那就都会添加，举个例子：

```javascript
module.exports = {
  async headers() {
    return [
      {
        source: '/:path*',
        headers: [
          {
            key: 'hello',
            value: 'hello',
          },
          {
            key: 'hello2',
            value: 'hello2',
          }
        ],
      },
      {
        source: '/hello',
        headers: [
          {
            key: 'hello',
            value: 'world',
          },
          {
            key: 'hello3',
            value: 'hello3',
          },
        ],
      },
    ]
  },
}
```

最终的结果为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea5a1ecfec794a40b85c6684899f2914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=248\&h=128\&s=11341\&e=png\&b=282828)

### 1.4. basePath

`basePath`的值为 `false` 或者 `undefined`。当值为 `false` ，匹配时不会包含 `basePath`，举个例子：

```javascript
// next.config.js
module.exports = {
  basePath: '/docs',
 
  async headers() {
    return [
      {
        source: '/with-basePath', // 匹配 /docs/with-basePath
        headers: [
          {
            key: 'x-hello',
            value: 'world',
          },
        ],
      },
      {
        source: '/without-basePath', // 匹配 /without-basePath
        headers: [
          {
            key: 'x-hello',
            value: 'world',
          },
        ],
        basePath: false, // 因为设置了 false
      },
    ]
  },
}
```

在这个例子中，设置了 `basePath` 为 `/docs`，正常 headers 中的 source 会匹配 basePath + source 构成的链接，除非你设置了 `basePath` 为 `false`。

### 1.5. locale

`locale` 的值为 `false` 或者 `undefined`，决定匹配时是否应该包含 locale，其实效果跟 basePath 类似.

考虑到部分同学对 `locale` 不太熟悉，我们先简单的讲下 `locale`配置项，locale 的作用就是国际化（i18n），`next.config.js` 针对 Pages Router 提供了 i18n 配置项，注意是在 Pages Router 下，在 App Router 下 Next.js 已经不再提供直接的支持，具体内容查看小册国际化章节。

比如我们在 `pages` 目录下新建一个 `article.js` 文件：

```javascript
// pages/article.js
export default function Home() {
  return  <h1>Hello Article!</h1>
}
```

然后 `next.config.js` 修改配置项：

```javascript
// next.config.js
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'de', 'zh'],
    defaultLocale: 'zh',
  }
}
```

此时，访问 `/en/article`、`/fr/article`、`/de/article` 都会重写为 `/article`，注意是重写，就是路由地址不变，但内容是 `/article`的内容。访问 `/zh/article` 会重定向到 `/article`。

而如果你在 `app/article`目录下新建一个 `article.js` 文件，文件内容同上。

此时，访问 `/en/article`、`/fr/article`、`/de/article` 都会 404 错误。访问 `/zh/article` 会重写为 `/article`。说明在 App Router 下只有 `i18n.defaultLocale` 是生效的。

好了，基本介绍完毕，主要是为了让大家了解配置项中的 i18n 的作用。我们再看 headers 中的 locales 设置，举个例子：

```javascript
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'de'],
    defaultLocale: 'en',
  },
 
  async headers() {
    return [
      {
        // 自动处理所有的 locales
        // 也就是 `/en/with-locale`、`/fr/with-locale`、`/de/with-locale`、`/with-locale` 都会匹配
        source: '/with-locale', 
        headers: [
          {
            key: 'x-hello',
            value: 'world1',
          },
        ],
      },
      {
        // 因为 locale 设置为 false，所以不会自动处理 locales
        // 也就是只匹配 `/nl/with-locale-manual`
        source: '/nl/with-locale-manual',
        locale: false,
        headers: [
          {
            key: 'x-hello',
            value: 'world2',
          },
        ],
      },
      {
        // 匹配 '/' 因为 `en` 是 defaultLocale
        // 也就是只匹配 `/`、`/en`
        source: '/en',
        locale: false,
        headers: [
          {
            key: 'x-hello',
            value: 'world3',
          },
        ],
      },
      {
        // 会转换为 /(en|fr|de)/(.*) 所以不会匹配顶层
        // 也就是 `/` 和 `/fr` 都不会匹配到
        // 如果要匹配到这两个，可以用 `/:path*`
        source: '/(.*)',
        headers: [
          {
            key: 'x-hello',
            value: 'world4',
          },
        ],
      },
    ]
  },
}
```

注意，虽然 i18n.locales 配置在 App Router 下不生效，但这也只是导致页面出现 404 错误而已，并不会影响处理标头，即便页面 404，你可以正常的查看标头。

### 1.6. has 和 missing

`has` 和 `missing` 是用来处理请求中的 header、cookie 和请求参数是否匹配某些字段，或者不匹配某些字段的时候，才应用 header。

举个例子，比如请求 `/article?id=1&author=yayu`，`has` 可以要求请求中必须有 id 参数，或者 id 参数等于 xxx 的时候才返回某个标头。`missing` 可以要求请求中必须没有 id 参数，或者 id 参数不等于 xxx 的时候才返回某个标头。

`has` 和 `missing` 对象有下面这些字段：

*   `type`: `String`类型，值为 `header`、`cookie`、`host`、`query` 之一
*   `key`: `String`类型，所选类型（也就是上面的四种值）中要匹配的 key
*   `value`： `String` 或者 `undefined`，要检查的值。如果值为 `undefiend`，任何值都不会匹配。支持使用一个类似正则的字符串捕获值的特殊部分。比如 `first-(?<paramName>.*)`用于匹配 `first-second`，然后就可以用 `:paramName`获取 `second` 这个值

听起来有些复杂，看个例子其实就懂了：

```javascript
// next.config.js
module.exports = {
  async headers() {
    return [
      // 如果 header 中 `x-add-header` 字段存在
      // 那就返回 `x-another-header` 标头
      {
        source: '/:path*',
        has: [
          {
            type: 'header',
            key: 'x-add-header',
          },
        ],
        headers: [
          {
            key: 'x-another-header',
            value: 'hello',
          },
        ],
      },
      // 如果 header 中 `x-no-header` 字段不存在
      // 就返回 `x-another-header` 标头
      {
        source: '/:path*',
        missing: [
          {
            type: 'header',
            key: 'x-no-header',
          },
        ],
        headers: [
          {
            key: 'x-another-header',
            value: 'hello',
          },
        ],
      },
      // 如果 source、query、cookie 都匹配
      // 就返回 `x-authorized` 标头
      {
        source: '/specific/:path*',
        has: [
          {
            type: 'query',
            key: 'page',
            value: 'home',
          },
          {
            type: 'cookie',
            key: 'authorized',
            value: 'true',
          },
        ],
        headers: [
          {
            key: 'x-authorized',
            value: 'hello',
          },
        ],
      },
      //如果 header 中 `x-authorized` 存在且等于 yes 或 true
      // 就返回 `x-another-header` 标头
      {
        source: '/:path*',
        has: [
          {
            type: 'header',
            key: 'x-authorized',
            value: '(?<authorized>yes|true)',
          },
        ],
        headers: [
          {
            key: 'x-another-header',
            value: ':authorized',
          },
        ],
      },
      // 如果 host 是 `example.com`,
      // 应用 header
      {
        source: '/:path*',
        has: [
          {
            type: 'host',
            value: 'example.com',
          },
        ],
        headers: [
          {
            key: 'x-another-header',
            value: 'hello',
          },
        ],
      },
    ]
  },
}
```

注意，has 和 missing 判断的都是请求头中的值。 type 的四种类型为 header、cookie、host、query，其中下图中的值都是 header：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f286f2e743624f39b7f0ab7678bc7a10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548\&h=544\&s=121143\&e=png\&b=282828)

cookie 指的是其中的 Cookie 标头，Next.js 已经自动做了解析，所以可以直接判断 Cookie 中的字段值：

![image (1).png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b0f0c3bde944941b01ece1cd01f43c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1548\&h=544\&s=118810\&e=png\&b=282828)

host 就是主机名 + 端口，query 表示参数。以 `'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'`为例的话，**host** 的值为 `host.com:8080`。**query** 为 `query=string`。

### 1.7. Cache-Control

你不能在 `next.config.js` 中为页面或静态资源设置 `Cache-Control`标头，因为该标头会在生产中被覆盖，以确保有效缓存响应和静态资源。

### 1.8. 选项

#### X-DNS-Prefetch-Control

[X-DNS-Prefetch-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control)  头控制着浏览器的 DNS 预读取功能。DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，无论是图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。

因为预读取会在后台执行，所以 DNS 很可能在链接对应的东西出现之前就已经解析完毕。这能够减少用户点击链接时的延迟。

```json
{
  key: 'X-DNS-Prefetch-Control',
  value: 'on'
}
```

#### Strict-Transport-Security

[Strict-Transport-Security](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Strict-Transport-Security)（通常简称为 HSTS）响应标头用来通知浏览器应该只通过 HTTPS 访问该站点，并且以后使用 HTTP 访问该站点的所有尝试都应自动重定向到 HTTPS。

使用下面的配置，所有当前和未来的子域都将使用 `max-age` 为 2 年的 HTTPS：

```javascript
{
  key: 'Strict-Transport-Security',
  value: 'max-age=63072000; includeSubDomains; preload'
}
```

#### X-Frame-Options

[X-Frame-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Frame-Options) HTTP 响应头是用来给浏览器指示允许一个页面可否在 `<frame>`、`<iframe>`、`<embed>` 或者 `<object>` 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免点击劫持 (en-US)攻击。

此标头已经被 [frame-ancestors](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy/frame-ancestors) 替代，它在现代浏览器中有更好的支持。

#### Permissions-Policy

[Permissions-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Permissions-Policy)  响应标头提供了一种可以在本页面或包含的 iframe 上启用或禁止浏览器特性的机制，之前叫做 `Feature-Policy`。

```json
{
  key: 'Permissions-Policy',
  value: 'camera=(), microphone=(), geolocation=(), browsing-topics=()'
}
```

#### X-Content-Type-Options

如果 `Content-Type` 标头没有被显示设置，[X-Content-Type-Options](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options) 会阻止浏览器尝试猜测内容类型。这可以防止允许用户上传和共享文件的网站受到 XSS 攻击。

这个标头只有一个有效值是 `nosniff`。

```json
{
  key: 'X-Content-Type-Options',
  value: 'nosniff'
}
```

#### Referrer-Policy

[Referrer-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy) 控制当从当前网页导航到另一个网页时携带的信息内容：

```json
{
  key: 'Referrer-Policy',
  value: 'origin-when-cross-origin'
}
```

## 2. redirects

### 2.1. 介绍

重定向，顾名思义，将请求路径重定向到其他目标路径。配置重定向，使用 `next.config.js` 的 `redirects`，示例如下：

```javascript
module.exports = {
  async redirects() {
    return [
      {
        source: '/about',
        destination: '/',
        permanent: true,
      },
    ]
  },
}
```

`redirects` 是一个异步函数，该函数返回一个包含 `source`、`destination` 和 `permanent` 属性的对象数组，其中：

*   `source` 表示传入的请求路径
*   `destination` 表示你重定向的的目标路径
*   `permanent` 值为 true 或者  false。如果为 true，使用 308 状态码，表示客户端或搜索引擎永久缓存重定向。如果是 false，使用 307 状态码表示临时未缓存。

为什么 Next.js 使用 307 和 308 呢？传统都是使用 302 表示临时重定向，301 表示永久重定向，但是很多浏览器会将重定向的请求方法修改为 GET，而不管原本的方法是什么。举个例子，如果浏览器发送了一个 POST 请求，`/v1/users` ，然后返回了 302 状态码，新地址是 `/v2/users`，则后续的请求会是 GET `/V2/users` 而不是 POST `/v2/users`，Next.js 用 307 临时重定向和 308 永久重定向状态码就是为了显示保留之前使用的请求方法。

除了这三个值外，还可以设置：

*   `basePath`：`false` 或者 `undefined`。当值为 `false` ，匹配时不会包含 `basePath`，只能用于外部重写
*   `locale`：`false` 或者 `undefined`，匹配时是否应该包含 locale
*   `has`：一个有 `type`、`key`、`value` 属性的对象数组
*   `missing`：一个有 `type`、`key`、`value` 属性的对象数组

重定向会在文件系统（包括页面和 `/public` 文件）之前被触发。

重定向不会应用于客户端路由（`Link`、`router.push`），除非使用了中间件，且有匹配的路径。

当应用重定向的时候，请求路径的参数也会传递给重定向目标路径。举个例子：

```javascript
{
  source: '/old-blog/:path*',
  destination: '/blog/:path*',
  permanent: false
}
```

当请求`/old-blog/post-1?hello=world`时，客户端会重定向到 `/blog/post-1?hello=world`。

### 2.2. source

#### 路径匹配

普通的路径匹配，举个例子，比如 `/old-blog/:slug`会匹配 `/old-blog/hello-world`（无嵌套路径，也就是说 `/old-blog/hello-world/about`不会匹配）

```javascript
// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: '/old-blog/:slug',
        destination: '/news/:slug',
        permanent: true,
      },
    ]
  },
}
```

#### 通配符路径匹配

在参数后使用 `*` 实现通配符路径匹配，举个例子：`/blog/:slug*` 会匹配 `/blog/a/b/c/d/hello-world`：

```javascript
// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: '/blog/:slug*',
        destination: '/news/:slug*',
        permanent: true,
      },
    ]
  },
}
```

#### 正则表达式路径匹配

在参数后用括号将正则表达式括住实现正则表达式匹配，举个例子：`/post/:slug(\\d{1,})` 匹配 `/post/123` 而不匹配 `/post/abc`

```javascript
// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        source: '/post/:slug(\\d{1,})',
        destination: '/news/:slug',
        permanent: false,
      },
    ]
  },
}
```

注意：这 8 个字符  `(`、`)`、 `{`、 `}`、 `:`、 `*`、 `+`、 `?` 都会用于正则表达式匹配，所以需要用到这些字符本身的时候，使用 `\\`转义

```javascript
// next.config.js
module.exports = {
  async redirects() {
    return [
      {
        // 匹配 `/english(default)/something`
        source: '/english\\(default\\)/:slug',
        destination: '/en-us/:slug',
        permanent: false,
      },
    ]
  },
}
```

### 2.3. basePath

当使用 `basePath` 的时候，每一个 `source` 和 `destination` 都会自动添加 `basePath` 作为前缀，除非你为重定向设置 `basePath: false`：

```javascript
// next.config.js
module.exports = {
  basePath: '/docs',
 
  async redirects() {
    return [
      {
        source: '/with-basePath', // 自动变成 /docs/with-basePath
        destination: '/another', // 自动变成 /docs/another
        permanent: false,
      },
      {
        // does not add /docs since basePath: false is set
        source: '/without-basePath',
        destination: 'https://example.com',
        basePath: false,
        permanent: false,
      },
    ]
  },
}
```

### 2.4. locale

当使用 `i18n`的时候，每一个 `source` 和 `destination` 都会自动根据 `locales`添加前缀进行处理，除非你为重定向设置 `locale: false`。如果设置 `locale: false`，你必须使用一个 `locale` 作为 `source` 和 `destination` 的前缀才能够正确匹配，让我们看个例子：

```javascript
// next.config.js
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'de'],
    defaultLocale: 'en',
  },
 
  async redirects() {
    return [
      {
        // /with-locale -> /another
        // /en/with-locale -> /en/another
        // /fr/with-locale -> /fr/another
        // /de/with-locale -> /de/another
        source: '/with-locale',
        destination: '/another',
        permanent: false,
      },
      {
        // 因为 locale 设置为 false，所以不会自动处理
        // /nl/with-locale-manual -> /nl/another
        source: '/nl/with-locale-manual',
        destination: '/nl/another',
        locale: false,
        permanent: false,
      },
      {
        // 因为 `en` 是 defaultLocale，所以匹配 '/'
        // /en -> /en/another
        // / -> /en/another
        source: '/en',
        destination: '/en/another',
        locale: false,
        permanent: false,
      },
      // 尽管 locale 设置为 false，但匹配所有 locale
      // /page -> /en/newpage
      // /en/page -> /en/newpage
      // /fr/page -> /fr/newpage
      // /de/page -> /de/newpage
      {
        source: '/:locale/page',
        destination: '/en/newpage',
        permanent: false,
        locale: false,
      },
      {
        // 转换为 /(en|fr|de)/(.*) 所以不会匹配 `/`
        // /page -> /another2
        // /fr/page -> /fr/another2
        // 匹配 `\` 或 `/fr` 使用 /:path*
        source: '/(.*)',
        destination: '/another2',
        permanent: false,
      },
    ]
  },
}
```

### 2.5. has 和 missing

`has` 和 `missing` 是用来处理请求中的 header、cookie 和请求参数是否匹配某些字段，或者不匹配某些字段的时候，才发生重定向。

举个例子，比如请求 `/article?id=1&author=yayu`，`has` 可以要求请求中必须有 id 参数，或者 id 参数等于 xxx 的时候才重定向。`missing` 可以要求请求中必须没有 id 参数，或者 id 参数不等于 xxx 的时候才重定向。

`has` 和 `missing` 对象有下面这些字段：

*   `type`: `String`类型，值为 `header`、`cookie`、`host`、`query` 之一
*   `key`: `String`类型，所选类型（也就是上面的四种值）中要匹配的 key
*   `value`： `String` 或者 `undefined`，要检查的值。如果值为 `undefiend`，任何值都不会匹配。支持使用一个类似正则的字符串捕获值的特殊部分。比如 `first-(?<paramName>.*)`用于匹配 `first-second`，然后就可以用 `:paramName`获取 `second` 这个值

其实跟 headers 是一样的，只不是过一个是返回标头，一个是发生重定向。

```javascript
// next.config.js
module.exports = {
  async redirects() {
    return [
      // 如果 header `x-redirect-me` 存在,
      // 才应用重定向
      {
        source: '/:path((?!another-page$).*)',
        has: [
          {
            type: 'header',
            key: 'x-redirect-me',
          },
        ],
        permanent: false,
        destination: '/another-page',
      },
      // 如果 `x-dont-redirect` 存在,
      // 不会应用重定向
      {
        source: '/:path((?!another-page$).*)',
        missing: [
          {
            type: 'header',
            key: 'x-do-not-redirect',
          },
        ],
        permanent: false,
        destination: '/another-page',
      },
      // 如果 source, query, 和 cookie 匹配,
      // 会应用重定向
      {
        source: '/specific/:path*',
        has: [
          {
            type: 'query',
            key: 'page',
            value: 'home',
          },
          {
            type: 'cookie',
            key: 'authorized',
            value: 'true',
          },
        ],
        permanent: false,
        destination: '/another/:path*',
      },
      // 如果 header `x-authorized` 存在，并且是 yes huozhe true,
      // 会应用重定向
      {
        source: '/',
        has: [
          {
            type: 'header',
            key: 'x-authorized',
            value: '(?<authorized>yes|true)',
          },
        ],
        permanent: false,
        destination: '/home?authorized=:authorized',
      },
      // 如果 host 是 `example.com`,
      // 会应用重定向
      {
        source: '/:path((?!another-page$).*)',
        has: [
          {
            type: 'host',
            value: 'example.com',
          },
        ],
        permanent: false,
        destination: '/another-page',
      },
    ]
  },
}
```

## 3. rewrites

### 3.1. 介绍

重写允许你将传入的请求路径映射到其他目标路径。它与重定向的不同之处在于，重写相当于扮演了 URL 代理的角色，会屏蔽目标路径，地址还是这个地址，但路由逻辑发生了变化。而重定向则是导航至新的页面，浏览器中的 URL 也会发生更改。配置重定向，使用 `next.config.js` 的 `rewrites`，示例如下：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/about',
        destination: '/',
      },
    ]
  },
}
```

重写会应用于客户端路由，在这个例子中，如果使用`<Link href="/about">` 会应用重写。

`rewrites` 是一个异步函数，该函数可以返回一个包含 `source`、`destination` 属性的对象数组，其中：

*   `source` 表示传入的请求路径
*   `destination` 表示你重写的的目标路径
*   `basePath`：`false` 或者 `undefined`。当值为 `false` ，匹配时不会包含 `basePath`，只能用于外部重写
*   `locale`：`false` 或者 `undefined`，匹配时是否应该包含 locale
*   `has`：一个有 `type`、`key`、`value` 属性的对象数组
*   `missing`：一个有 `type`、`key`、`value` 属性的对象数组

如果返回的是这种数组，重写会在检查文件系统（页面和 /public 文件）之后和动态路由之前应用。

也可以返回一个具有特定属性的对象，这是为了实现更精细的控制，示例代码如下：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return {
      beforeFiles: [
        // 在 headers/redirects 之后
        // 在 _next/public files 文件之前触发
        {
          source: '/some-page',
          destination: '/somewhere-else',
          has: [{ type: 'query', key: 'overrideMe' }],
        },
      ],
      afterFiles: [
        // 在 pages/public 之后，在动态路由之前触发
        {
          source: '/non-existent',
          destination: '/somewhere-else',
        },
      ],
      fallback: [
        // 在 pages/public files 和动态路由之后触发
        {
          source: '/:path*',
          destination: `https://my-old-site.com/:path*`,
        },
      ],
    }
  },
}
```

这个时候就要说到 Next.js 的路由的检查顺序是：

1.  headers
2.  redirects
3.  beforeFiles 重写
4.  `public` 目录下的静态文件、`_next/static` 文件、非动态的页面
5.  afterFiles 重写，如果每次匹配，
6.  fallback 重写，会在渲染 404 页面之前和动态路由、所有静态资源检查前被引用

### 3.2. 重写参数

如果 `destination`没有使用参数（例子中的`:path*`），那么 `source` 的中的参数会以查询字符串的形式（query）默认传递给 `destination`：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/old-about/:path*',
        destination: '/about',
      },
    ]
  },
}
```

假设 `app/about/page.js`的代码为：

```javascript
// app/about/page.js
export default function Page(props) {
  console.dir(props)
  return  <h1>Hello About!</h1>
}
```

访问 `/old-about/article?id=1`，打印的值为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf100c8b0fbc475b9a2472359b7e3190~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=900\&h=36\&s=49552\&e=png\&b=010509)

`source` 中的参数 article 可以在 searchParams 中查到。

如果 `destination`使用了参数，则不会自动传递任何参数：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/docs/:path*',
        destination: '/:path*',
      },
    ]
  },
}
```

访问 `/docs/about?id=1`，打印的值为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cef281c1d70417b9104f5ce57478ecd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=602\&h=48\&s=41058\&e=png\&b=010508)

如果 `destination`使用了参数，你依然可以手动传递参数：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/:first/:second',
        destination: '/:first?second=:second'
      },
    ]
  },
}
```

在这个例子中，因为 `destination` 使用了 `:first` 参数，所以 `:second` 参数不会自动被添加到 query 中，但我们可以通过例子中的方式手动添加，使得能够在 query 中获取。

访问 `/about/article?id=1`，打印的值为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fceaf76a61f403b81e8cf524e622c9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=888\&h=44\&s=56783\&e=png\&b=010508)

### 3.3. source

#### 路径匹配

普通的路径匹配，举个例子，比如 `/blog/:slug`会匹配 `/blog/hello-world`（无嵌套路径，也就是说 `/blog/hello-world/about`不会匹配）

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/blog/:slug',
        destination: '/news/:slug',
      },
    ]
  },
}
```

#### 通配符路径匹配

在参数后使用 `*` 实现通配符路径匹配，举个例子：`/blog/:slug*` 会匹配 `/blog/a/b/c/d/hello-world`：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/blog/:slug*',
        destination: '/news/:slug*', // Matched parameters can be used in the destination
      },
    ]
  },
}
```

#### 3.3.3. 正则表达式路径匹配

在参数后用括号将正则表达式括住实现正则表达式匹配，举个例子：`/post/:slug(\\d{1,})` 匹配 `/post/123` 而不匹配 `/post/abc`

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/old-blog/:post(\\d{1,})',
        destination: '/blog/:post',
      },
    ]
  },
}
```

注意：这 8 个字符  `(`、`)`、 `{`、 `}`、 `:`、 `*`、 `+`、 `?` 都会用于正则表达式匹配，所以需要用到这些字符本身的时候，使用 `\\`转义

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        // this will match `/english(default)/something` being requested
        source: '/english\\(default\\)/:slug',
        destination: '/en-us/:slug',
      },
    ]
  },
}
```

### 3.4. basePath

当使用 `basePath` 的时候，每一个 `source` 和 `destination` 都会自动添加 `basePath` 作为前缀，除非你为重写设置 `basePath: false`：

```javascript
// next.config.js
module.exports = {
  basePath: '/docs',
 
  async rewrites() {
    return [
      {
        source: '/with-basePath', // 自动变成 /docs/with-basePath
        destination: '/another', // 自动变成 /docs/another
      },
      {
        // 不会添加 /docs 到 /without-basePath 因为 basePath 设置为 false 
        source: '/without-basePath',
        destination: 'https://example.com',
        basePath: false,
      },
    ]
  },
}
```

### 3.5. locale

当使用 `i18n`的时候，每一个 `source` 和 `destination` 都会自动根据 `locales`添加前缀进行处理，除非你为重写设置 `locale: false`。如果设置 `locale: false`，你必须使用一个 `locale` 作为 `source` 和 `destination` 的前缀才能够正确匹配，让我们看个例子：

```javascript
// next.config.js
module.exports = {
  i18n: {
    locales: ['en', 'fr', 'de'],
    defaultLocale: 'en',
  },
 
  async rewrites() {
    return [
      {
        // /with-locale -> /another
        // /en/with-locale -> /en/another
        // /fr/with-locale -> /fr/another
        // /de/with-locale -> /de/another
        source: '/with-locale',
        destination: '/another',
      },
      {
        // 因为 locale 设置为 false，所以不会自动处理
        // /nl/with-locale-manual -> /nl/another
        source: '/nl/with-locale-manual',
        destination: '/nl/another',
        locale: false,
      },
      {
        // 因为 `en` 是 defaultLocale，所以匹配 '/'
        // /en -> /en/another
        // / -> /en/another
        source: '/en',
        destination: '/en/another',
        locale: false
      },
      // 尽管 locale 设置为 false，但匹配所有 locale
      {
        source: '/:locale/api-alias/:path*',
        destination: '/api/:path*',
        locale: false,
      },
      {
        // 转换为 /(en|fr|de)/(.*) 所以不会匹配 `/`
        // /page -> /another
        // /fr/page -> /fr/another
        // 匹配 `\` 或 `/fr` 使用 /:path*
				source: '/(.*)',
        destination: '/another',
      },
    ]
  },
}
```

### 3.6. has 和 missing

`has` 和 `missing` 是用来处理请求中的 header、cookie 和请求参数是否匹配某些字段，或者不匹配某些字段的时候，才发生重写。

举个例子，比如请求 `/article?id=1&author=yayu`，`has` 可以要求请求中必须有 id 参数，或者 id 参数等于 xxx 的时候才重写。`missing` 可以要求请求中必须没有 id 参数，或者 id 参数不等于 xxx 的时候才重写。

`has` 和 `missing` 对象有下面这些字段：

*   `type`: `String`类型，值为 `header`、`cookie`、`host`、`query` 之一
*   `key`: `String`类型，所选类型（也就是上面的四种值）中要匹配的 key
*   `value`： `String` 或者 `undefined`，要检查的值。如果值为 `undefiend`，任何值都不会匹配。支持使用一个类似正则的字符串捕获值的特殊部分。比如 `first-(?<paramName>.*)`用于匹配 `first-second`，然后就可以用 `:paramName`获取 `second` 这个值

其实跟 redirects 是一样的，只不是过一个是重定向，一个是重写。

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      // 如果 header `x-rewrite-me` 存在,
      // 会应用重写
      {
        source: '/:path*',
        has: [
          {
            type: 'header',
            key: 'x-rewrite-me',
          },
        ],
        destination: '/another-page',
      },
      // 如果 `x-rewrite-me` 不存在
      // 会应用重写
      {
        source: '/:path*',
        missing: [
          {
            type: 'header',
            key: 'x-rewrite-me',
          },
        ],
        destination: '/another-page',
      },
      // 如果 source, query, 和 cookie 匹配,
      // 会应用重写
      {
        source: '/specific/:path*',
        has: [
          {
            type: 'query',
            key: 'page',
            value: 'home',
          },
          {
            type: 'cookie',
            key: 'authorized',
            value: 'true',
          },
        ],
        destination: '/:path*/home',
      },
      // 如果 header `x-authorized` 存在且为 yes 或 true
      // 会应用重写
      {
        source: '/:path*',
        has: [
          {
            type: 'header',
            key: 'x-authorized',
            value: '(?<authorized>yes|true)',
          },
        ],
        destination: '/home?authorized=:authorized',
      },
      // 如果 host 是 `example.com`,
      // 会应用重写
      {
        source: '/:path*',
        has: [
          {
            type: 'host',
            value: 'example.com',
          },
        ],
        destination: '/another-page',
      },
    ]
  },
}
```

### 3.7. 重写到外部 URL

rewrites 可以重写到外部 url，这在增量采用 Next.js 的项目中特别有用，比如这个例子就是将应用中的 `/blog` 路由全部重写到外部网址：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return [
      {
        source: '/blog',
        destination: 'https://example.com/blog',
      },
      {
        source: '/blog/:slug',
        destination: 'https://example.com/blog/:slug',
      },
    ]
  },
}
```

如果设置了 `trailingSlash:true`，你也需要在 `source` 中插入一个尾部斜杠。如果目标地址也需要尾部斜杠，也应该包含在 `destination` 参数中。

```javascript
// next.config.js
module.exports = {
  trailingSlash: true,
  async rewrites() {
    return [
      {
        source: '/blog/',
        destination: 'https://example.com/blog/',
      },
      {
        source: '/blog/:path*/',
        destination: 'https://example.com/blog/:path*/',
      },
    ]
  },
}
```

### 3.8. 增量采用 Next.js

可以让 Next.js 在检查所有 Next.js 路由后，如果没有对应的路由，那就代理现有的网站。这样你将更多页面迁移成 Next.js 时，就无需重写配置：

```javascript
// next.config.js
module.exports = {
  async rewrites() {
    return {
      fallback: [
        {
          source: '/:path*',
          destination: `https://custom-routes-proxying-endpoint.vercel.app/:path*`,
        },
      ],
    }
  },
}
```

## 参考链接

1.  <https://nextjs.org/docs/app/api-reference/next-config-js>
2.  <https://nextjs.org/docs/app/api-reference/next-config-js/headers>
3.  <https://nextjs.org/docs/app/api-reference/next-config-js/redirects>
4.  <https://nextjs.org/docs/app/api-reference/next-config-js/rewrites>


## 34.API 篇 | next.config.js（下）

## 前言

本篇我们讲解 `next.config.js` 剩下的 31 个配置项。

## 1. assetPrefix

assetPrefix 用于设置资源前缀，举个例子：

```javascript
// next.config.js
const isProd = process.env.NODE_ENV === 'production'
 
module.exports = {
  // Use the CDN in production and localhost for development.
  assetPrefix: isProd ? 'https://cdn.mydomain.com' : undefined,
}
```

Next.js 会自动为从 `/_next`路径（`.next/static/`文件夹）加载的 JavaScript 和 CSS 文件添加资源前缀。以这个例子为例，当请求 JS 代码片段的时候，原本地址是：

    /_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js

会变成：

    https://cdn.mydomain.com/_next/static/chunks/4b9b41aaa062cbbfeff4add70f256968c51ece5d.4d708494b3aed70c04f0.js

注意：虽然这里请求的路径是在 `/_next`下，但实际文件在 `.next/` 下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7909926b75be482794f1ef581f49490a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1652\&h=194\&s=91172\&e=png\&a=1\&b=1e2022)

让我们在开发环境中测试一下这个配置，原本请求的地址是：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6055de0f0211497cbddcdf245c836cc8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1988\&h=350\&s=120792\&e=png\&b=2a2a2a)

配置后会变成：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632ded0ea9d645609a1179425ed2afbb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2020\&h=278\&s=94793\&e=png\&b=303030)

注意：

1.  你应该上传到 CDN 的只有 `.next/static/`的内容，不要上传 `.next/` 剩余的部分，这会导致你暴露服务端代码和其他配置。
2.  `assetPrefix`不会影响 `public` 文件夹下的文件。对于 `public` 下的资源，你需要自己处理前缀。

## 2. basePath

`basePath` 用于设置应用的路径前缀。举个例子：

```javascript
// next.config.js
module.exports = {
  basePath: '/docs',
}
```

修改 `app/page.js`的代码为：

```javascript
import Link from 'next/link'

export default function HomePage() {
  return (
    <>
      <Link href="/about">About Page</Link>
    </>
  )
}
```

使用 `basePath` 后，直接访问 `/`会导致 404 错误：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5e0c817eaa3482d90a35b5bac3b659c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=954\&h=370\&s=36505\&e=png\&b=000000)

你应该访问 `/docs`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfc1763307904f718a7c8fe700bc2c68~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=768\&h=246\&s=25063\&e=png\&b=ffffff)
如果你不希望访问 `/` 导致 404 错误，那你可以来个重写或者重定向：

```javascript
// next.config.js
module.exports = {
  basePath: '/docs',
  async redirects() {
    return [
        {
            source: '/',
            destination: '/docs',
            basePath: false,
            permanent: false
        }
    ]
  }
}
```

当你使用 `next/link` 和 `next/router` （App Router 下使用 `next/navigation`）链接到其他页面时，`basePath` 就会自动应用。举个例子，`/about` 会自动变成 `/docs/about`：

```javascript
export default function HomePage() {
  return (
    <>
      <Link href="/about">About Page</Link>
    </>
  )
}
```

输出的 HTML 为：

```html
<a href="/docs/about">About Page</a>
```

当你使用 `next/image`组件的时候，你应该在 `src` 前添加 `basePath`（如果你使用静态导入就正常处理即可）：

```javascript
import Image from 'next/image'
 
function Home() {
  return (
    <>
      <h1>My Homepage</h1>
      <Image
        src="/docs/me.png"
        alt="Picture of the author"
        width={500}
        height={500}
      />
      <p>Welcome to my homepage!</p>
    </>
  )
}
 
export default Home
```

在这个例子中，图片放在 `/public`目录下，正常使用 `/me.png` 即可访问，设置 `basePath` 为 `/docs` 后，应该改为使用 `/docs/me.png`。

## 3. compress

Next.js 提供 gzip 压缩来压缩渲染的内容和静态文件。如果你想禁用压缩功能：

```javascript
// next.config.js
module.exports = {
  compress: false,
}
```

## 4. devIndicators

当你编辑代码，Next.js 正在编译应用的时候，页面右下角会有一个编译指示器。

![FVWEU.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9013933fbed34b7f8d155aac131d2e58~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=406\&h=256\&s=17318\&e=gif\&f=13\&b=ffffff)

这个指示器只会在开发模式下展示，生产环境中不会展示。如果你想更改它的位置，就比如它跟页面的其他元素位置发生冲突了：

```javascript
module.exports = {
  devIndicators: {
    buildActivityPosition: 'bottom-right',
  },
}
```

默认值是 `bottom-right`，其他值还有` bottom-left`、`top-right`、`top-left`。

如果你想禁用它：

```javascript
module.exports = {
  devIndicators: {
    buildActivity: false,
  },
}
```

## 5. distDir

`distDir` 用于自定义构建目录，默认是 `.next`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11046c79e6a24fb49cfb437a3140ec4f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1652\&h=194\&s=91172\&e=png\&a=1\&b=1e2022)

举个例子：

```javascript
module.exports = {
  distDir: 'build',
}
```

现在如果你运行 `next build`，Next.js 会使用 `build` 文件夹而不是 `.next`文件夹。注意：`distDir` 不能离开你的项目目录，举个例子，`../build`就是一个无效目录。

## 6. env

Next.js 9.4 后使用新的方式添加环境变量，新的方式更加直观方便、功能强大，具体内容参考[《
配置篇 | 环境变量、路径别名与 src 目录》](https://juejin.cn/book/7307859898316881957/section/7309078454316564507)。

添加一个环境变量到 JavaScript bundle 中，举个例子：

```javascript
module.exports = {
  env: {
    customKey: 'my-value',
  },
}
```

现在你可以在代码中通过 `process.env.customKey` 获取：

```javascript
function Page() {
  return <h1>The value of customKey is: {process.env.customKey}</h1>
}
 
export default Page
```

Next.js 会在构建的时候，将 `process.env.customKey`替换为 `my-value`（因为 webpack [DefinePlugin](https://webpack.js.org/plugins/define-plugin/) 的特性，不支持通过解构赋值）。举个例子：

```javascript
return <h1>The value of customKey is: {process.env.customKey}</h1>
```

相当于：

```javascript
return <h1>The value of customKey is: {'my-value'}</h1>
```

最终的结果是：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b4438a2a8d40ba8726edc48ea45635~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1514\&h=288\&s=41470\&e=png\&b=ffffff)

## 7. eslint

如果项目中检测到 ESLint，Next.js 会在出现错误的时候，让生产构建（`next build`）失败。

如果你希望即使有错误，也要构建生产代码，可以禁止内置的 ESLint：

```javascript
module.exports = {
  eslint: {
    ignoreDuringBuilds: true,
  },
}
```

## 8. generateBuildId

Next.js 会在 `next build` 的时候生成一个 ID，用于标示应用正在使用的版本。应该使用相同的构建并启动多个容器（Docker）。

如果你要为环境的每个阶段进行重建，你需要在不同的容器间生成一致的构建 ID（比如测试、开发、预生产、生产等不同的阶段对应不同的容器，但最好使用相同的构建 ID），使用 `next.config.js` 的 `generateBuildId`：

```javascript
module.exports = {
  generateBuildId: async () => {
    // This could be anything, using the latest git hash
    return process.env.GIT_HASH
  },
}
```

## 9. generateEtags

Next.js 默认会为每个页面生成 [etags](https://en.wikipedia.org/wiki/HTTP_ETag)，如果你希望禁用 HTML 页面生成 etags，使用 `next.config.js` 的 `generateEtags`：

```javascript
module.exports = {
  generateEtags: false
}
```

## 10. httpAgentOptions

在 Nodejs 18 之前，Next.js 会自动使用 [undici](https://github.com/nodejs/undici) 作为 `fetch()` 的 polyfill，并且默认开启 HTTP [Keep-Alive](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive)。

如果禁用服务端所有 fetch() 请求的 HTTP Keep-Alive ，使用 `next.config.js` 的 `httpAgentOptions` 配置：

```javascript
module.exports = {
  httpAgentOptions: {
    keepAlive: false,
  },
}
```

## 11. images

如果你想要使用云提供商优化图片而不使用 Next.js 内置的图像优化 API，那可以在 `next.config.js` 中进行如下配置：

```javascript
module.exports = {
  images: {
    loader: 'custom',
    loaderFile: './my/image/loader.js',
  },
}
```

`loaderFile` 必须指向一个相对于应用根目录的地址，这个文件必须导出一个返回字符串的默认函数，例如：

```javascript
export default function myImageLoader({ src, width, quality }) {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
```

就比如你想要使用 Cloudflare，参考 Cloudflare 的 [url-format](https://developers.cloudflare.com/images/url-format) 文档：

```javascript
// Docs: https://developers.cloudflare.com/images/url-format
export default function cloudflareLoader({ src, width, quality }) {
  const params = [`width=${width}`, `quality=${quality || 75}`, 'format=auto']
  return `https://example.com/cdn-cgi/image/${params.join(',')}/${src}`
}
```

此为全局修改，如果你只想更改部分图片，那你可以使用 `loader` prop：

```javascript
'use client'
 
import Image from 'next/image'
 
const imageLoader = ({ src, width, quality }) => {
  return `https://example.com/${src}?w=${width}&q=${quality || 75}`
}
 
export default function Page() {
  return (
    <Image
      loader={imageLoader}
      src="me.png"
      alt="Picture of the author"
      width={500}
      height={500}
    />
  )
}
```

## 12. incrementalCacheHandlerPath

用于自定义 Next.js 的缓存处理程序，举个例子：

```javascript
module.exports = {
  experimental: {
    incrementalCacheHandlerPath: require.resolve('./cache-handler.js'),
  },
}
```

自定义的缓存示例代码为：

```javascript
// cache-handler.js
const cache = new Map()
 
module.exports = class CacheHandler {
  constructor(options) {
    this.options = options
    this.cache = {}
  }
 
  async get(key) {
    return cache.get(key)
  }
 
  async set(key, data) {
    cache.set(key, {
      value: data,
      lastModified: Date.now(),
    })
  }
}
```

完整的 API 参考 <https://nextjs.org/docs/app/api-reference/next-config-js/incrementalCacheHandlerPath>

## 13. logging

当在开发模式运行 Next.js ，你可以配置日志等级以及控制台是否记录完整 URL。目前，logging 只应用于使用 fetch API 的数据获取，还不能用于 Next.js 其他日志。

```javascript
module.exports = {
  logging: {
    fetches: {
      fullUrl: true,
    },
  },
}
```

## 14. mdxRs

使用新的 Rust 编译器编译 MDX 文件，和 `@next/mdx` 一起使用：

```javascript
const withMDX = require('@next/mdx')()
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['ts', 'tsx', 'mdx'],
  experimental: {
    mdxRs: true,
  },
}
 
module.exports = withMDX(nextConfig)
```

## 15. onDemandEntries

onDemandEntries 用于控制开发模式下服务端如何处理内存中构建的页面：

```javascript
module.exports = {
  onDemandEntries: {
    // period (in ms) where the server will keep pages in the buffer
    maxInactiveAge: 25 * 1000,
    // number of pages that should be kept simultaneously without being disposed
    pagesBufferLength: 2,
  },
}
```

## 16. optimizePackageImports

有些包可以导出成百上千个模块，这会导致开发和生产中的性能问题。

添加一个包到 `experimental.optimizePackageImports` 后，Next.js 只会加载实际用到的模块：

```javascript
module.exports = {
  experimental: {
    optimizePackageImports: ['package-name'],
  },
}
```

`@mui/icons-material`, `@mui/material`, `date-fns`, `lodash`, `lodash-es`, `react-bootstrap`, `@headlessui/react`, `@heroicons/react`以及 `lucide-react` ，这些库默认已经优化。

## 17. output

在构建的时候，Next.js 会自动追踪每个页面和它的依赖项，以确定部署一个生产版本所需要的所有文件。

这个功能会帮你大幅减少部署的大小。之前使用 Docker 部署的时候，你需要安装 `dependencies` 中的所有文件才能运行 `run start`。从 Next.js 12 起，你可以追踪 `.next/` 目录中的输出文件以实现只包含必要的文件。

之所以能够实现，是因为在 `next build` 的时候，Next.js 会使用 `@vercel/nft` 静态分析 `import`、`require` 和` fs` 使用情况来确定页面加载的所有文件。

Next.js 的生产服务器也会在 `.next/next-server.js.nft.json`中追踪所有它所需要的文件和输出。这个文件就可以被用来在每次追踪的时候，读取文件列表，然后将文件拷贝到部署位置上。

现在让我们在 `next.config.js` 中开启：

```javascript
module.exports = {
  output: 'standalone',
}
```

Next.js 会自动在 `.next`中创建一个 `standalone` 文件夹，然后拷贝 `node_modules` 中生产部署会用到的所有必需文件。靠着这个文件夹，都不需要再次安装 `node_modules` 即可实现部署。

## 18. pageExtension

默认情况下，Next.js 接受 `.tsx`、`.ts`、`.js`、`.jsx`作为拓展名的文件。 pageExtension 用于接受其他的扩展名比如 markdown （`.md`、`.mdx`）

```javascript
const withMDX = require('@next/mdx')()
 
/** @type {import('next').NextConfig} */
const nextConfig = {
  pageExtensions: ['ts', 'tsx', 'mdx'],
  experimental: {
    mdxRs: true,
  },
}
 
module.exports = withMDX(nextConfig)
```

## 19. 局部渲染

局部渲染是一个实验性的功能，目前在 `next@canary` 中可用：

```bash
npm install next@canary
```

开启局部渲染：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: true,
  },
}
 
module.exports = nextConfig
```

注意：局部渲染目前不能用于客户端导航。

## 20. poweredByHeader

默认情况下，Next.js 会添加 `x-powered-by`标头，如果要禁用此功能：

```javascript
module.exports = {
  poweredByHeader: false,
}
```

## 21. productionBrowserSourceMaps

SourceMap 默认在开发环境中开启，在生产构建的时候会禁用以防止源码泄漏，但如果你非要开启：

```javascript
module.exports = {
  productionBrowserSourceMaps: true,
}
```

## 22. reactStrictMode

从 Next.js 13.4 起，严格模式在 App Router 下默认为 `true`，所以这个配置仅用于 Pages Router。不过你依然可以设置 `reactStrictMode: false` 来禁用严格模式。

React 的严格模式是一个为了突出应用中潜在问题的功能，在开发模式中使用会有助于识别不安全的生命周期、过期的 API 用法以及其他功能。使用严格模式，在 `next.config.js` 中配置：

```javascript
module.exports = {
  reactStrictMode: true,
}
```

如果不希望整个应用都使用严格模式，只针对某些页面使用的话，那可以用 `<React.StrictMode>`。

## 23. serverComponentsExternalPackages

Next.js 会自动打包服务端组件和路由处理程序中的依赖项。如果某一个依赖项使用了 Nodejs 特定的功能，那你可以选择从 Bundle 中去除该依赖项，然后使用原生的 Nodejs `require`。

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    serverComponentsExternalPackages: ['@acme/ui'],
  },
}
 
module.exports = nextConfig
```

## 24. trailingSlash

默认情况下，Next.js 会将带尾部斜杠的 URL 重定向到没有尾部斜杠的地址.举个例子，`/about/`会重定向到 `/about`。你也可以进行相反的配置，将没有尾部斜杠的地址重定向到带尾部斜杠的地址：

```javascript
module.exports = {
  trailingSlash: true,
}
```

现在，`/about`重定到 `/about/`。

## 25. transpilePackages

Next.js 可以自动编译和打包来自本地的包（如 monorepos）或者外部依赖（node\_modules）。以前是通过使用 [next-transpile-modules](https://www.npmjs.com/package/next-transpile-modules) 这个包，有了这个选项就可以直接使用了：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  transpilePackages: ['@acme/ui', 'lodash-es'],
}
 
module.exports = nextConfig
```

## 26. turbo

这些功能是实验性的，只有当使用 `next --turbo` 的时候才会开启。

目前，Turbopack 支持 webpack loader API 的子集，允许你在 Turbopack 中使用一些 webpack loader 转换代码。举个例子：

```javascript
module.exports = {
  experimental: {
    turbo: {
      rules: {
        // Option format
        '*.md': [
          {
            loader: '@mdx-js/loader',
            options: {
              format: 'md',
            },
          },
        ],
        // Option-less format
        '*.mdx': ['@mdx-js/loader'],
      },
    },
  },
}
```

现在，你可以在应用中使用：

```javascript
import MyDoc from './my-doc.mdx'
 
export default function Home() {
  return <MyDoc />
}
```

类似于 webpack 的 resolve.alias，Turbopack 也可以配置别名：

```javascript
module.exports = {
  experimental: {
    turbo: {
      resolveAlias: {
        underscore: 'lodash',
        mocha: { browser: 'mocha/browser-entry.js' },
      },
    },
  },
}
```

在这个例子中，使用 `import underscore from 'underscore'`其实会导入 lodash。

Turbopack 也支持条件别名，目前只支持 browser 这个条件。在这个例子中，当 Turbopack 以浏览器环境为目标的时候，导入 mocha 模块相当于导入 mocha/browser-entry.js。

## 27. typedRouters

对静态类型链接的实验性支持，此功能需要在 App Router 下以及开启使用 TypeScript：

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    typedRoutes: true,
  },
}
 
module.exports = nextConfig
```

## 28. typescript

如果出现 TypeScript 错误，生产构建（`next build`）会失败。如果你希望即便有错误，也要构建生产代码：

```javascript
module.exports = {
  typescript: {
    // !! WARN !!
    // Dangerously allow production builds to successfully complete even if
    // your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}
```

## 29. urlImports

URL 导入是一项实验性功能，允许你从外部服务器导入模块。

如果你要使用该功能，使用示例如下：

```javascript
module.exports = {
  experimental: {
    urlImports: ['https://example.com/assets/', 'https://cdn.skypack.dev'],
  },
}
```

在这个例子中，添加了允许的资源前缀（毕竟要保证安全）。

然后你就可以直接通过 URL 导入模块：

```javascript
import { a, b, c } from 'https://example.com/assets/some/module.js'
```

当使用 URL 导入的时候，Next.js 会创建一个 `next.lock`目录包含一个 lockfile 和获取的资源。这个目录必须要提交到 Git，不能通过 `.gitignore`忽略。

当运行 `next dev`的时候，Next.js 会下载并添加所有新发现的导入 URL 到 lockfile 中。当运行 `next build`的时候，Next.js 会只使用 lockfile 构建用于生产版本的应用。

使用 URL 导入的一些例子：

使用 skypack：

```javascript
import confetti from 'https://cdn.skypack.dev/canvas-confetti'
import { useEffect } from 'react'
 
export default () => {
  useEffect(() => {
    confetti()
  })
  return <p>Hello</p>
}
```

静态图片导入：

```javascript
import Image from 'next/image'
import logo from 'https://example.com/assets/logo.png'
 
export default () => (
  <div>
    <Image src={logo} placeholder="blur" />
  </div>
)
```

CSS 中的 URLs：

```javascript
.className {
  background: url('https://example.com/assets/hero.jpg');
}
```

导入资源：

```javascript
const logo = new URL('https://example.com/assets/file.txt', import.meta.url)
 
console.log(logo.pathname)
 
// prints "/_next/static/media/file.a9727b5d.txt"
```

## 30. 自定义 Webpack 配置

为了扩展 webpack 的用法，你需要在 next.config.js 中定义一个函数用于扩展它的配置，举个例子：

```javascript
module.exports = {
  webpack: (
    config,
    { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }
  ) => {
    // Important: return the modified config
    return config
  },
}
```

webpack 函数会被执行两次，一次在服务端，一次在客户端，你可以使用 isServer 属性来区分是客户端配置还是服务端配置。

webpack 函数的第二个参数是一个具有以下属性的对象：

*   `buildId`：`String`，构建 ID，构建的唯一标识
*   `dev`：`Boolean` 编译是否会在开发中完成
*   `isServer`：`Boolean`，如果 true 表示服务端编译，如果 false 表示客户端编译
*   `nextRuntime`：`String | undefined`，服务端编译的目标运行时，要么是 `"edge"` ，要么是 `"nodejs"`，`undefined`用于客户端编译
*   `defaultLoaders`：`Object` Next.js 内部使用的默认加载器
    *   `babel`：`Object` 默认的 `babel-loader` 配置

`defaultLoaders.babel` 示例用法：

```javascript
// 这段来自于 @next/mdx 插件源码:
// https://github.com/vercel/next.js/tree/canary/packages/next-mdx
module.exports = {
  webpack: (config, options) => {
    config.module.rules.push({
      test: /\.mdx/,
      use: [
        options.defaultLoaders.babel,
        {
          loader: '@mdx-js/loader',
          options: pluginOptions.options,
        },
      ],
    })
 
    return config
  },
}
```

## 31. webVitalsAttribution

在调试 Web Vitals 相关的问题时，如果能查明根源通常会很有帮助。比如在 CLS 中，我们可能想知道最大的布局偏移发生时偏移的第一个元素，或者 LCP 中，我们可能想要知道 LCP 对应的元素。如果该元素是图片，知道它的 URL 有助于我们进行优化。

这就需要用到 webVitalsAttribution 配置项，它会帮助我们获取更深层的信息如 [PerformanceEventTiming](https://developer.mozilla.org/docs/Web/API/PerformanceEventTiming)、[PerformanceNavigationTiming](https://developer.mozilla.org/docs/Web/API/PerformanceNavigationTiming)、[PerformanceResourceTiming](https://developer.mozilla.org/docs/Web/API/PerformanceResourceTiming)。

```javascript
experimental: {
  webVitalsAttribution: ['CLS', 'LCP']
}
```

有效的归因值都是 web-vitals 中的特定指标，在 [NextWebVitalsMetric](https://github.com/vercel/next.js/blob/442378d21dd56d6e769863eb8c2cb521a463a2e0/packages/next/shared/lib/utils.ts#L43) 中可以查看：

```javascript
export type NextWebVitalsMetric = {
  id: string
  startTime: number
  value: number
} & (
  | {
      label: 'web-vital'
      name: 'FCP' | 'LCP' | 'CLS' | 'FID' | 'TTFB' | 'INP'
    }
  | {
      label: 'custom'
      name:
        | 'Next.js-hydration'
        | 'Next.js-route-change-to-render'
        | 'Next.js-render'
    }
)
```

## 参考链接

1.  <https://nextjs.org/docs/app/api-reference/next-config-js>


## 35.API 篇 | 常用函数与方法（上）

## 前言

本篇我们讲解请求相关的常用方法，有：

1.  [fetch](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-1)
2.  [cookies](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-7)
3.  [headers](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-20)
4.  [NextRequest](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-23)
5.  [NextResponse](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-33)
6.  [redirect](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-44)
7.  [permanentRedirect](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-46)
8.  [notFound](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-48)
9.  [useParams](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-50)
10. [usePathname](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-54)
11. [useRouter](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-58)
12. [useSearchParams](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-68)

用到的时候到此篇查看具体的语法即可。

## 1. fetch

### 1.1. 介绍

Next.js 扩展了原生的 Web [fetch API](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)，可以为每个请求设置自己的缓存模式，你可以在服务端组件中搭配 `async` 和 `await` 直接调用：

```javascript
// app/page.js
export default async function Page() {
  // 请求会被缓存
  // 类似于 Pages Router 下的 `getStaticProps`.
  // `force-cache` 是默认选项，不写也行
  const staticData = await fetch(`https://...`, { cache: 'force-cache' })
 
  // 每次请求的时候都会重新获取
  // 类似于 Pages Router 下的 `getServerSideProps`.
  const dynamicData = await fetch(`https://...`, { cache: 'no-store' })
 
  // 请求会被缓存，最多缓存 10s
  // 类似于 Pages Router 下的 `getStaticProps` 使用 `revalidate` 选项.
  const revalidatedData = await fetch(`https://...`, {
    next: { revalidate: 10 },
  })
 
  return <div>...</div>
}
```

这里要注意的是，浏览器中的 fetch 其实也是有 cache 选项的：

```javascript
async function postData(url = "", data = {}) {
  const response = await fetch(url, {
    method: "POST",
    cache: "no-cache", // *default, no-cache, reload, force-cache, only-if-cached
    body: JSON.stringify(data), 
  });
  return response.json();
}
```

浏览器中的 fetch cache 选项控制的是与浏览器交互的 HTTP 缓存，而我们在服务端中用的 fetch cache 选项控制的其实是 Next.js 自己的缓存逻辑，它会将这些请求缓存起来，方便以后重复请求的时候用到。它们具体的 cache 选项内容也会有所不同，接下来会讲到。

### 1.2. fetch(url, options)

#### options.cache

用于配置 Next.js 数据缓存（[Data Cache](https://nextjs.org/docs/app/building-your-application/caching#data-cache)）

```javascript
fetch(`https://...`, { cache: 'force-cache' | 'no-store' })
```

*   `force-cache`是默认值，表示优先从缓存中查找匹配请求，当没有匹配项或者匹配项过时时，才从服务器上获取资源并更新缓存。
*   `no-store`表示每次请求都从服务器上获取资源，不从缓存中查，也不更新缓存。

如果没有提供 cache 选项，默认为 `force-cache`，但如果你使用了动态函数（如 cookies()），它的默认值就会是 `no-store`。

#### options.next.revalidate

```javascript
fetch(`https://...`, { next: { revalidate: false | 0 | number } })
```

设置资源的缓存时间：

*   `false`（默认）：语义上相当于 `revalidate: Infinity`，资源无限期缓存
*   `0`：防止资源被缓存
*   `number` ：指定资源的缓存时间，最多 `n`秒

如果一个单独的 `fetch()` 请求的 `revalidate` 值比路由段配置中的 `revalidate` 还低，整个路由的 revalidate 时间都会减少。如果同一路由下有两个使用相同 URL 的请求，但设置了不同的 `revalidate`值，用较低的那个值。

为了方便，如果 `revalidate` 设置了数字，无须再设置 `cache` 选项，设置为`0` 会应用 `cache: 'no-store'`，设置为正值会应用 `cache: 'force-cache'`。冲突的配置如 `{ revalidate: 0, cache: 'force-cache' }`和 `{ revalidate: 10, cache: 'no-store' }`会导致报错。

#### options.next.tags

```javascript
fetch(`https://...`, { next: { tags: ['collection'] } })
```

设置资源的缓存标签，数据可以使用 `revalidateTag` 按需重新验证。自定义标签的最大长度是 256 个字符。

## 2. cookies

### 2.1. 介绍

`cookies` 函数用于：

1.  在服务端组件读取传入请求的 cookie
2.  在 Server Action 或路由处理程序中写入返回请求的 cookie

注意：之前的文章里也多次提到，`cookies()` 是一个动态函数，因为其返回值无法提前知道。所以在页面或者布局中使用该函数会导致路由转变为动态渲染。

### 2.2. cookies

#### cookies().get(name)

该方法传入一个 cookie 名，返回一个具有 `name` 和 `value` 属性的对象。如果没有找到，返回 `undefined`，如果匹配到多个 cookie，则返回第一个匹配到的。

```javascript
// app/page.js
import { cookies } from 'next/headers'
 
export default function Page() {
  const cookieStore = cookies()
  // 如果匹配到，theme 的值为 { name: 'theme', value: 'xxxx' }
  // 如果没有匹配到，theme 的值为 undefined
  const theme = cookieStore.get('theme')
  return '...'
}
```

#### cookies().getAll(name)

该方法类似于 `get`，但会以数组形式返回所有匹配到的 `cookies` ，匹配不到则返回空数组。如果没有指定 `name`，则返回所有可用的 cookie。

```javascript
// app/page.js
import { cookies } from 'next/headers'
 
export default function Page() {
  const cookieStore = cookies()
  // 如果匹配到，theme 的值为 [{ name: 'theme', value: 'xxxx' }]
  // 如果没有匹配到，theme 的值为 []
  const theme = cookieStore.get('theme')
  return '...'
}
```

另一个示例如下：

```javascript
// app/page.js
import { cookies } from 'next/headers'
 
export default function Page() {
  const cookieStore = cookies()
  return cookieStore.getAll().map((cookie) => (
    <div key={cookie.name}>
      <p>Name: {cookie.name}</p>
      <p>Value: {cookie.value}</p>
    </div>
  ))
}
```

#### cookies().has(name)

该方法传入一个 cookie 名，返回一个判断该 cookie 是否存在的布尔值。

```javascript
// app/page.js
import { cookies } from 'next/headers'
 
export default function Page() {
  const cookiesList = cookies()
  // true | false
  const hasCookie = cookiesList.has('theme')
  return '...'
}
```

#### cookies().set(name, value, options)

该方法用于设置 cookie。

```javascript
'use server'
// app/actions.js
import { cookies } from 'next/headers'
 
async function create(data) {
  cookies().set('name', 'lee')
  // or
  cookies().set('name', 'lee', { secure: true })
  // or
  cookies().set({
    name: 'name',
    value: 'lee',
    httpOnly: true,
    path: '/',
  })
}
```

具体 options 除了 name、value 通过[查看源码](https://github.com/vercel/next.js/blob/7874ad265962dd1659497cbd8f5c71ddceee207b/packages/next/src/compiled/%40edge-runtime/cookies/index.js#L74)可以得知，还有 domain、expires、httponly、maxage、path、samesite、secure、priority。

#### 删除 cookie

删除 cookie 的方式有多种：

##### cookies().delete(name)

删除指定名称的 cookie

```javascript
'use server'
// app/actions.js
import { cookies } from 'next/headers'
 
export async function create(data) {
  cookies().delete('name')
}
```

##### cookies().set(name, '')

将指定名称的 cookie 设置为空值

```javascript
'use server'
// app/actions.js
import { cookies } from 'next/headers'
 
export async function create(data) {
  cookies().set('name', '')
}
```

##### cookies().set(name, value, { maxAge: 0 })

设置 maxAge 为 0，立即使 cookie 过期

```javascript
'use server'
// app/actions.js
import { cookies } from 'next/headers'
 
export async function create(data) {
  cookies().set('name', 'value', { maxAge: 0 })
}
```

##### cookies().set(name, value, { expires: timestamp })

设置 expires 为过去的值都会使 cookie 过期

```javascript
'use server'
// app/actions.js
import { cookies } from 'next/headers'
 
export async function create(data) {
  const oneDay = 24 * 60 * 60 * 1000
  cookies().set('name', 'value', { expires: Date.now() - oneDay })
}
```

#### 测试删除效果

如果你想要测试这些删除效果：

```javascript
'use client'
// app/page.js
import { create } from './action'

export default function Page({ params }) {
 
  return (
    <form action={create}>
      <input type="text" name="name" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

效果如下：

![1113.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa74c93649545959ec04e3ea0cb5a46~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=864\&h=199\&s=26031\&e=gif\&f=8\&b=2e2e2e)

## 3. headers

### 3.1. 介绍

`headers()` 函数用于从服务端组件中读取传入的 HTTP 请求头。它拓展了 [Web Headers API](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers)。它是只读的，这意味着你不能 `set`/`delete` 返回的请求头。headers() 和 cookies() 一样都是动态函数，其返回值无法提前知道，一旦使用会导致路由切换到动态渲染。

```javascript
// app/page.js
import { headers } from 'next/headers'
 
export default function Page() {
  const headersList = headers()
  const referer = headersList.get('referer')
 
  return <div>Referer: {referer}</div>
}
```

### 3.2. API

```javascript
const headersList = headers()
```

headers() 不接收任何参数，返回一个只读的 [Web Headers](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers) 对象，所以没有 set、append、delete 这些方法：

*   [Headers.entries()](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/entries)：以 [迭代器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols) 的形式返回 Headers 对象中所有的键值对
*   [Headers.get()](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/get)：以 [String](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String) 的形式从 Headers 对象中返回指定 header 的全部值
*   [Headers.has()](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/has)：以布尔值的形式从 Headers 对象中返回是否存在指定的 header
*   [Headers.keys()](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/keys)：以[迭代器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)的形式返回 Headers 对象中所有存在的 header 名
*   [Headers.values()](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers/values)：以[迭代器](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)的形式返回 Headers 对象中所有存在的 header 的值
*   [Headers.forEach()](https://developer.mozilla.org/en-US/docs/Web/API/Headers/forEach)：对对象中的每个键/值对执行一次回调函数

举个例子：

```javascript
// app/page.js
import { headers } from 'next/headers'
 
async function getUser() {
  const headersInstance = headers()
  const authorization = headersInstance.get('authorization')
  // 转发 authorization header
  const res = await fetch('...', {
    headers: { authorization },
  })
  return res.json()
}
 
export default async function UserPage() {
  const user = await getUser()
  return <h1>{user.name}</h1>
}
```

## 4. NextRequest

### 4.1. 介绍

NextRequest 拓展了 [Web Resquest API](https://developer.mozilla.org/docs/Web/API/Request)，提供了一些便捷的方法。

### 4.2. cookies

用于读取和更改请求的 [Set-Cookie](https://developer.mozilla.org/docs/Web/HTTP/Headers/Set-Cookie)标头。

#### set(name, value)

设置 cookie：

```javascript
// 请求会有一个 `Set-Cookie:show-banner=false;path=/home` 标头
request.cookies.set('show-banner', 'false')
```

#### get(name)

返回指定名称的 cookie 值，找不到就返回 undefined，多个就返回第一个：

```javascript
// { name: 'show-banner', value: 'false', Path: '/home' }
request.cookies.get('show-banner')
```

#### getAll()

返回指定名称的 cookie 值，未指定则返回所有，数组形式：

```javascript
// [
//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
//   { name: 'experiments', value: 'winter-launch', Path: '/home' },
// ]
request.cookies.getAll('experiments')
// 返回所有 cookie 值
request.cookies.getAll()
```

#### delete(name)

用于删除 cookie：

```javascript
// 返回 true 表示删除成功, false 表示没有删掉任何东西
request.cookies.delete('experiments')
```

#### has(name)

判断是否有该 cookie 值，有则返回 true，无则返回 false

```javascript
request.cookies.has('experiments')
```

#### clear()

删除请求的 `Set-Cookie` 标头

```javascript
request.cookies.clear()
```

### 4.3. nextUrl

拓展了原生的 [URL API](https://developer.mozilla.org/zh-CN/docs/Web/API/URL)，提供了一些便捷的方法：

```javascript
// 假设请求是 /home, pathname 是 /home
request.nextUrl.pathname
// 请求是 /home?name=lee, searchParams 是 { 'name': 'lee' }
request.nextUrl.searchParams
```

## 5. NextResponse

### 5.1. 介绍

NextResponse 拓展了 [Web Response API](https://developer.mozilla.org/docs/Web/API/Response)，提供了一些便捷的方法。

### 5.2. cookies

用于读取和更改响应的 Set-Cookie 标头。

#### set(name, value)

```javascript
// 请求未 /home
let response = NextResponse.next()
// 设置 cookie
response.cookies.set('show-banner', 'false')
// Response 的 Set-Cookie 标头为 `Set-Cookie:show-banner=false;path=/home`
return response
```

#### get(name)

```javascript
// 假设请求为 /home
let response = NextResponse.next()
// { name: 'show-banner', value: 'false', Path: '/home' }
response.cookies.get('show-banner')
```

#### getAll()

```javascript
// 假设请求为 /home
let response = NextResponse.next()
// [
//   { name: 'experiments', value: 'new-pricing-page', Path: '/home' },
//   { name: 'experiments', value: 'winter-launch', Path: '/home' },
// ]
response.cookies.getAll('experiments')
// 返回所有 cookie 值
response.cookies.getAll()
```

#### delete(name)

```javascript
// 假设请求为 /home
let response = NextResponse.next()
// 返回 true 表示删除成功, false 表示没有删掉任何东西
response.cookies.delete('experiments')
```

### 5.3. json

使用给定的 JSON 正文生成响应：

```javascript
// app/api/route.js
import { NextResponse } from 'next/server'
 
export async function GET(request) {
  return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 })
}
```

### 5.4. redirect()

生成重定向到新 URL 的响应：

```javascript
import { NextResponse } from 'next/server'
 
return NextResponse.redirect(new URL('/new', request.url))
```

在 `NextResponse.redirect()`方法使用前可以创建和更改 [URL](https://developer.mozilla.org/zh-CN/docs/Web/API/URL)，举个例子，你可以使用  `request.nextUrl` 获取当前的 URL，然后据此更改成重定向的 URL：

```javascript
import { NextResponse } from 'next/server'
 
const loginUrl = new URL('/login', request.url)
// 添加 ?from=/incoming-url 参数到 /login URL
loginUrl.searchParams.set('from', request.nextUrl.pathname)
// 重定向到新 URL
return NextResponse.redirect(loginUrl)
```

### 5.5. rewrite()

保留原始 URL 的同时生成一个重写到指定 URL 的响应：

```javascript
import { NextResponse } from 'next/server'
 
// 传入请求: /about, 浏览器显示 /about
// 重写请求: /proxy, 浏览器显示 /about
return NextResponse.rewrite(new URL('/proxy', request.url))
```

### 5.6. next()

常用在中间件，用于提前返回并继续路由：

```javascript
import { NextResponse } from 'next/server'
 
return NextResponse.next()
```

也可以在生成响应的时候转发 `headers`。

```javascript
import { NextResponse } from 'next/server'
 
const newHeaders = new Headers(request.headers)
// 添加新 header
newHeaders.set('x-version', '123')
// 返回新的 headers
return NextResponse.next({
  request: {
    headers: newHeaders,
  },
})
```

## 6. redirect

### 6.1. 介绍

`redirect`函数，顾名思义，重定向地址，可用于服务端组件、路由处理程序、Server Actions。在 Streaming 中，使用重定向将插入一个 meta 标签以在客户端发起重定向，其他情况，它会返回一个 307 HTTP 重定向响应。如果资源不存在，可以直接使用 notFound 函数，并不一定需要 redirect 来处理。

`redirect` 函数接受两个参数：

```javascript
redirect(path, type)
```

其中：

*   `path` 字符串类型，表示重定向的 URL，可以是相对路径，也可以是绝对路径
*   `type` 值为 `replace` （默认）或者 `push`（Server Actions 中默认），表示重定向的类型

默认情况下，`redirect` 在 Sever Actions 中会用 `push`（添加到浏览器历史栈），在其他地方用 `replace`（在浏览器历史栈中替换当前的 URL）。你可以通过指定 `type`参数覆盖此行为。

注意：在服务端组件中使用 `type`参数没有效果。

`redirect` 函数不返回任何值

举个例子：

```javascript
// app/team/[id]/page.js
import { redirect } from 'next/navigation'
 
async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const team = await fetchTeam(params.id)
  if (!team) {
    redirect('/login')
  }
 
  // ...
}
```

## 7. permanentRedirect

### 7.1. 介绍

`permanentRedirect`，作用也是重定向，可用于服务端组件、客户端组件、路由处理程序、Server Actions。在 Streaming 中，使用重定向将插入一个 meta 标签以在客户端发起重定向，其他情况，它会返回一个 308 HTTP 重定向响应。。如果资源不存在，可以直接使用 notFound 函数。

permanentRedirect 函数接受两个参数：

```javascript
permanentRedirect(path, type)
```

其中：

*   `path` 字符串类型，表示重定向的 URL，可以是相对路径，也可以是绝对路径
*   `type` 值为 `replace` （默认）或者 `push`（Server Actions 中默认），表示重定向的类型

默认情况下，permanentRedirect 在 Sever Actions 中会用 `push`（添加到浏览器历史栈），在其他地方用 `replace`（在浏览器历史栈中替换当前的 URL）。你可以通过指定 `type`参数覆盖此行为。

注意：在服务端组件中使用 `type`参数没有效果。

permanentRedirect 函数不返回任何值

举个例子：

```javascript
// app/team/[id]/page.js
import { permanentRedirect } from 'next/navigation'
 
async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const team = await fetchTeam(params.id)
  if (!team) {
    permanentRedirect('/login')
  }
 
  // ...
}
```

## 8. notFound

### 8.1. 介绍

调用 `notFound()`函数会抛出一个 `NEXT_NOT_FOUND`错误，并且中止该路由段的渲染。通过声明一个 `not-found.js`文件可以为此路由段渲染一个 Not Found UI 来优雅的处理这个错误。

```javascript
// app/user/[id]/page.js 
import { notFound } from 'next/navigation'
 
async function fetchUser(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const user = await fetchUser(params.id)
 
  if (!user) {
    notFound()
  }
 
  // ...
}
```

## 9. useParams

### 9.1. 介绍

`useParams`是一个客户端组件 hook，用于读取当前 URL 的动态参数：

```javascript
'use client'
// app/example-client-component.js
import { useParams } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const params = useParams()
 
  // 路由 -> /shop/[tag]/[item]
  // URL -> /shop/shoes/nike-air-max-97
  // `params` -> { tag: 'shoes', item: 'nike-air-max-97' }
  console.log(params)
 
  return <></>
}
```

### 9.2. 参数

`useParams`不接收任何参数。

```javascript
const params = useParams()
```

### 9.3. 返回值

`useParams` 返回一个包含当前路由动态参数的对象，让我们直接看个例子就明白了：

| **Route 路线**               | **URL 网址** | **useParams()**         |
| ------------------------------- | --------------- | ----------------------- |
| app/shop/page.js                | /shop           | null                    |
| app/shop/\[slug]/page.js        | /shop/1         | { slug: '1' }           |
| app/shop/\[tag]/\[item]/page.js | /shop/1/2       | { tag: '1', item: '2' } |
| app/shop/\[...slug]/page.js     | /shop/1/2       | { slug: \['1', '2'] }   |

## 10. usePathname

### 10.1. 介绍

`usePathname` 是一个客户端组件 hook，用于读取当前 URL 的 pathname。

```javascript
'use client'
// app/example-client-component.js
import { usePathname } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const pathname = usePathname()
  return <p>Current pathname: {pathname}</p>
}
```

`usePathname` 需要用在客户端组件中。

### 10.2. 参数

`usePathname`不接收任何参数。

```javascript
const pathname = usePathname()
```

### 10.3. 返回值

usePathname 返回当前 URL pathname 的字符串，让我们直接看个例子就明白了：

| **URL**             | 返回值                   |
| ------------------- | --------------------- |
| `/`                 | `'/'`                 |
| `/dashboard`        | `'/dashboard'`        |
| `/dashboard?v=2`    | `'/dashboard'`        |
| `/blog/hello-world` | `'/blog/hello-world'` |

举个例子：

```javascript
'use client'
// app/example-client-component.js
import { usePathname, useSearchParams } from 'next/navigation'
 
function ExampleClientComponent() {
  const pathname = usePathname()
  const searchParams = useSearchParams()
  useEffect(() => {
    // 监听路由变化
  }, [pathname, searchParams])
}
```

## 11. useRouter

### 11.1. 介绍

`useRouter` hook 用于在客户端组件中更改路由：

```javascript
'use client'
// app/example-client-component.js
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

在 Next.js 中，优先推荐使用 `<Link>` 组件来导航，其次再针对一些特殊的需求使用 `useRouter`。

### 11.2. useRouter()

#### push

`router.push(href: string, { scroll: boolean })`执行一个客户端导航，会将新地址添加到浏览器历史栈中

#### replace

`router.replace(href: string, { scroll: boolean })`执行一个客户端导航，但不会在浏览器历史栈中添加新的条目。

#### refresh

`router.refresh()` 刷新当前路由

#### prefetch

`router.prefetch(href: string)`预获取提供的路由，加快客户端导航速度

#### back

`router.back()` 向后导航到浏览器历史栈中的上一页

#### forward()

`router.forward()`向前导航到浏览器历史栈中的下一页

### 11.3. 示例

让我们看个例子：

```javascript
'use client'
// app/components/navigation-events.js
import { useEffect } from 'react'
import { usePathname, useSearchParams } from 'next/navigation'
 
export function NavigationEvents() {
  const pathname = usePathname()
  const searchParams = useSearchParams()
 
  useEffect(() => {
    const url = `${pathname}?${searchParams}`
    console.log(url)
    // ...
  }, [pathname, searchParams])
 
  return null
}
```

注意：当使用 App Router 的时候，从`next/navigation`中导入 `useRouter` ，而非 `next/router`。Pages Router 下的 pathname 改为使用 `usePathname()`，Pages Router 下的 query 改为使用 `useSearchParams()`。

在这个例子中，我们通过组合 `usePathname` 和 `useSearchParams` 来监听页面更改。我们可以将这个函数导入到布局中：

```javascript
// app/layout.js
import { Suspense } from 'react'
import { NavigationEvents } from './components/navigation-events'
 
export default function Layout({ children }) {
  return (
    <html lang="en">
      <body>
        {children}
 
        <Suspense fallback={null}>
          <NavigationEvents />
        </Suspense>
      </body>
    </html>
  )
}
```

在这个例子中，之所以能够生效，是因为在静态渲染的时候， `useSearchParams()`会导致客户端渲染到最近的 Suspense 边界。

再换一个例子，当导航到新路由时，Next.js 会默认滚动到页面的顶部。你可以在 `router.push()` 或 `router.replace()`中传递 `scroll: false`来禁用该行为。

```javascript
'use client'
// app/example-client-component.jsx
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button
      type="button"
      onClick={() => router.push('/dashboard', { scroll: false })}
    >
      Dashboard
    </button>
  )
}
```

## 12. useSearchParams

### 12.1. 介绍

`useSearchParams`是一个客户端组件 hook，用于读取当前 URL 的查询字符串。`useSearchParams` 返回一个只读版本的 [URLSearchParams](https://developer.mozilla.org/docs/Web/API/URLSearchParams)，举个例子：

```javascript
'use client'
// app/dashboard/search-bar.js
import { useSearchParams } from 'next/navigation'
 
export default function SearchBar() {
  const searchParams = useSearchParams()
 
  const search = searchParams.get('search')
 
  // URL -> `/dashboard?search=my-project`
  // `search` -> 'my-project'
  return <>Search: {search}</>
}
```

### 12.2. 参数

`useSearchParams` 不接收任何参数。

```javascript
const searchParams = useSearchParams()
```

### 12.3. 返回值

`useSearchParams` 返回一个只读版本的 [URLSearchParams](https://developer.mozilla.org/docs/Web/API/URLSearchParams)，它包含一些读取 URL 查询参数的工具方法，比如：

*   [URLSearchParams.get()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/get) 返回查询参数的第一个找到的值，举个例子：

| **URL**             | **searchParams.get("a")**     |
| ------------------- | ----------------------------- |
| /dashboard?a=1      | '1'                           |
| /dashboard?a=       | ''                            |
| /dashboard?b=3      | null                          |
| /dashboard?a=1\&a=2 | '1' （返回第一个，要获取所有，使用 getAll()） |

*   [URLSearchParams.has()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/has) 返回指定的查询参数是否存在，举个例子：

| **URL**        | **searchParams.has("a")** |
| -------------- | ------------------------- |
| /dashboard?a=1 | true                      |
| /dashboard?b=3 | false                     |

其他方法还有 [getAll()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/getAll)、 [keys()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/keys)、 [values()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/values)、 [entries()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/entries)、 [forEach()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/forEach) 和 [toString()](https://developer.mozilla.org/docs/Web/API/URLSearchParams/toString)，都是基于 [URLSearchParams](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams/getAll)。

### 12.4. 行为

#### 静态渲染

如果路由是静态渲染，调用 `useSearchParams()` 会导致树到最近的 `Suspense`边界发生客户端渲染。应该尽可能将使用 `useSearchParams` 的组件放在 `Suspense` 边界中以减少客户端渲染的内容，举个例子：

```javascript
'use client'
// app/dashboard/search-bar.js
import { useSearchParams } from 'next/navigation'
 
export default function SearchBar() {
  const searchParams = useSearchParams()
 
  const search = searchParams.get('search')

  // 当使用静态渲染的时候，不会在服务端打印
  console.log(search)
 
  return <>Search: {search}</>
}
```

```javascript
// app/dashboard/page.js
import { Suspense } from 'react'
import SearchBar from './search-bar'
 
function SearchBarFallback() {
  return <>placeholder</>
}
 
export default function Page() {
  return (
    <>
      <nav>
        <Suspense fallback={<SearchBarFallback />}>
          <SearchBar />
        </Suspense>
      </nav>
      <h1>Dashboard</h1>
    </>
  )
}
```

#### 动态渲染

如果路由是动态渲染的，在客户端组件的初始服务端渲染的时候，`useSearchParams` 在服务端是可用的。

```javascript
'use client'
// app/dashboard/search-bar.js
import { useSearchParams } from 'next/navigation'
 
export default function SearchBar() {
  const searchParams = useSearchParams()
 
  const search = searchParams.get('search')

  // 初始渲染的时候会在服务端打印，后续导航中客户端也会打印
  console.log(search)
 
  return <>Search: {search}</>
}
```

```javascript
// app/dashboard/page.js
import SearchBar from './search-bar'
 
export const dynamic = 'force-dynamic'
 
export default function Page() {
  return (
    <>
      <nav>
        <SearchBar />
      </nav>
      <h1>Dashboard</h1>
    </>
  )
}
```

#### 服务端组件

在 Page（服务端组件）中获取参数，使用 [searchParams](https://nextjs.org/docs/app/api-reference/file-conventions/page#searchparams-optional) prop。
Layout 中（服务端组件）并不会有  [searchParams](https://nextjs.org/docs/app/api-reference/file-conventions/page#searchparams-optional) prop，这是因为在共享一个布局的多个页面之间导航的时候并不会重新渲染，这也就导致  searchParams 不会发生变化。所以要想获得准确的查询参数，使用 Page 的  [searchParams](https://nextjs.org/docs/app/api-reference/file-conventions/page#searchparams-optional) prop 或是在客户端组件中使用  [useSearchParams](https://nextjs.org/docs/app/api-reference/functions/use-search-params) hook 它们会在客户端重新渲染的时候带上最新的 searchParams。

### 12.5. 示例

你可以使用 useRouter 或者 Link 设置新的 `searchParams`。当路由变化后，当前的 page.js 会收到一个更新的 `searchParams` prop：

```javascript
// app/example-client-component.js
export default function ExampleClientComponent() {
  const router = useRouter()
  const pathname = usePathname()
  const searchParams = useSearchParams()
 
  const createQueryString = useCallback(
    (name, value) => {
      const params = new URLSearchParams(searchParams)
      params.set(name, value)
 
      return params.toString()
    },
    [searchParams]
  )
 
  return (
    <>
      <p>Sort By</p>
 
      {/* 使用 useRouter */}
      <button
        onClick={() => {
          // <pathname>?sort=asc
          router.push(pathname + '?' + createQueryString('sort', 'asc'))
        }}
      >
        ASC
      </button>
 
      {/* 使用 <Link> */}
      <Link
        href={
          // <pathname>?sort=desc
          pathname + '?' + createQueryString('sort', 'desc')
        }
      >
        DESC
      </Link>
    </>
  )
}
```
## 参考链接

1. [https://nextjs.org/docs/app/api-reference/functions](https://nextjs.org/docs/app/api-reference/functions)

## 36.API 篇 | 常用函数与方法（下）

## 前言

本篇我们讲解请求相关的常用方法，有：

1.  [generateStaticParams](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-1)
2.  [generateViewport](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-5)
3.  [revalidatePath](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-12)
4.  [revalidateTag](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-23)
5.  [unstable\_cache](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-30)
6.  [unstable\_noStore](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-34)
7.  [useSelectedLayoutSegment](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-37)
8.  [useSelectedLayoutSegments](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-41)

用到的时候到此篇查看具体的语法即可。

## 1. generateStaticParams

### 1.1. 介绍

`generateStaticParams`和动态路由一起使用，用于在构建时静态生成路由：

```javascript
// app/product/[id]/page.js
export function generateStaticParams() {
  return [{ id: '1' }, { id: '2' }, { id: '3' }]
}
 
// 对应会生成 3 个静态路由：
// - /product/1
// - /product/2
// - /product/3
export default function Page({ params }) {
  const { id } = params
  // ...
}
```

可以在 `generateStaticParams` 使用 fetch 请求，这个例子更贴近实际的开发场景：

```javascript
// app/blog/[slug]/page.js
export async function generateStaticParams() {
  const posts = await fetch('https://.../posts').then((res) => res.json())
 
  return posts.map((post) => ({
    slug: post.slug,
  }))
}
 
export default function Page({ params }) {
  const { slug } = params
  // ...
}
```

关于 `generateStaticParams`：

*   你可以使用 `dynamicParams` 路由段配置控制当访问不是由 `generateStaticParams` 生成的动态段时发生的情况
*   在 `next dev`的时候，当你导航到路由时，`generateStaticParams`才会被调用
*   在 `next build`的时候，`generateStaticParams` 会在对应的布局或页面生成之前运行
*   在 重新验证（ISR）的时候，`generateStaticParams` 不会再次被调用
*   `generateStaticParams` 替代了 Pages Router 下的 `getStaticPaths` 函数的功能

上面这个例子是处理单个动态段，`generateStaticParams` 也可以处理多个动态段：

```javascript
// app/products/[category]/[product]/page.js
export function generateStaticParams() {
  return [
    { category: 'a', product: '1' },
    { category: 'b', product: '2' },
    { category: 'c', product: '3' },
  ]
}
 
// 对应会生成 3 个静态路由：
// - /products/a/1
// - /products/b/2
// - /products/c/3
export default function Page({ params }) {
  const { category, product } = params
  // ...
}
```

也可以处理 Catch-all 动态段：

```javascript
// app/product/[...slug]/page.js
export function generateStaticParams() {
  return [{ slug: ['a', '1'] }, { slug: ['b', '2'] }, { slug: ['c', '3'] }]
}
 
// 对应会生成 3 个静态路由：
// - /product/a/1
// - /product/b/2
// - /product/c/3
export default function Page({ params }) {
  const { slug } = params
  // ...
}
```

### 1.2. 参数

`generateStaticParams` 支持传入一个可选 `options.params` 参数。如果一个路由中的多个动态段都使用了 `generateStaticParams`，子 `generateStaticParams` 函数会为每一个父 `generateStaticParams`生成的 `params` 执行一次。

这句话是什么意思呢？举个例子，现在我们有这样一个 `/products/[category]/[product]`路由地址，这个路由里有两个动态段 `[category]`和 `[product]`，`[product]` 依赖于 `[category]`，毕竟要先知道类目才能该类目下知道有哪些产品。为了解决这个问题：

首先生成父段：

```javascript
// app/products/[category]/layout.js
export async function generateStaticParams() {
  const products = await fetch('https://.../products').then((res) => res.json())
 
  return products.map((product) => ({
    category: product.category.slug,
  }))
}
 
export default function Layout({ params }) {
  // ...
}
```

然后子 `generateStaticParams`函数就可以使用父 `generateStaticParams`函数返回的 `params` 参数动态生成自己的段：

```javascript
// app/products/[category]/[product]/page.js
export async function generateStaticParams({ params: { category } }) {
  const products = await fetch(
    `https://.../products?category=${category}`
  ).then((res) => res.json())
 
  return products.map((product) => ({
    product: product.id,
  }))
}
 
export default function Page({ params }) {
  // ...
}
```

在这个例子中，`params` 对象就包含了从父 `generateStaticParams`生成的 `params`，可以用此生成子段的 `params`。

这种填充动态段的方式被称为“**自上而下生成参数**”，子段依赖于父段的数据。但如果不依赖，就比如提供一个接口，直接返回所有的产品和对应的目录信息，完全可以直接生成，示例代码如下：

```javascript
// app/products/[category]/[product]/page.js
export async function generateStaticParams() {
  const products = await fetch('https://.../products').then((res) => res.json())
 
  return products.map((product) => ({
    category: product.category.slug,
    product: product.id,
  }))
}
 
export default function Page({ params }) {
  // ...
}
```

不需要再写父 `generateStaticParams` 函数，直接一步到位，这种填充动态段的方式被称为“**自下而上生成参数**”。

### 1.3. 返回值

`generateStaticParams` 应该返回一个对象数组，其中每个对象表示单个路由的填充动态段：

*   对象的每个属性都是路由要填充的动态段
*   属性名就是段名，属性值就是该段应该填写的内容

直接描述反而有些复杂，其实很简单，比如：

`/product/[id]`这种动态路由，`generateStaticParams` 应该返回一个类似于 `[{id: xxx}, {id: xxx}, ...]` 的对象。

对于 `/products/[category]/[product]`这种动态路由，`generateStaticParams` 应该返回一个类似于 `[{category: xxx, product: xxx}, {category: xxx, product: xxx}, ...]` 的对象。

对于 `/products/[...slug]`这种动态路由，`generateStaticParams` 应该返回一个类似于`[{slug: [xxx, xxx, ...]}, {slug: [xxx, xxx, ...]}, ...]` 的对象。

返回类型描述如下：

| **示例路由**                    | **generateStaticParams 返回类型**        |
| -------------------------------- | ----------------------------------------- |
| `/product/[id]`                  | `{ id: string }[]`                        |
| `/products/[category]/[product]` | `{ category: string, product: string }[]` |
| `/products/[...slug]`            | `{ slug: string[] }[]`                    |

## 2. generateViewport

你可以自定义页面的初始 viewport，有两种方法：

1.  使用静态的 `viewport` 对象
2.  使用动态的 `generateViewport` 函数

使用的时候要注意：

1.  `viewport` 对象和 `generateViewport` 函数**仅支持在服务端组件中导出**
2.  不能在同一路由段中同时导出  `viewport` 对象和 `generateViewport` 函数
3.  如果视口不依赖运行时的一些信息，尽可能使用 `viewport` 对象的方式进行定义

### 2.1. viewport 对象

从 `layout.js` 或者 `page.js` 中导出一个名为 `viewport` 的对象：

```javascript
// layout.js | page.js 
export const viewport = {
  themeColor: 'black',
}
 
export default function Page() {}
```

### 2.2. generateViewport

从 `layout.js` 或者 `page.js` 中导出一个名为 `generateViewport` 的函数，该函数返回包含一个或者多个viewport 字段的 Viewport 对象：

```javascript
export function generateViewport({ params }) {
  return {
    themeColor: '...',
  }
}
```

### 2.3. Viewport 字段

#### themeColor

[theme-color](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name/theme-color)，用户的浏览器将根据所设定的建议颜色来改变用户界面，比如在 Android 上的 Chrome 设定颜色后：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1883c72300c54e49acc88652d7edaa04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=894\&h=686\&s=103058\&e=png\&a=1\&b=0385f7)
支持简单的主题颜色设置：

```javascript
// layout.js | page.js
export const viewport = {
  themeColor: 'black',
}
```

对应输出为：

```html
<meta name="theme-color" content="black" />
```

也支持带 media 属性的主题颜色设置：

```javascript
export const viewport = {
  themeColor: [
    { media: '(prefers-color-scheme: light)', color: 'cyan' },
    { media: '(prefers-color-scheme: dark)', color: 'black' },
  ],
}
```

对应输出为：

```javascript
<meta name="theme-color" media="(prefers-color-scheme: light)" content="cyan" />
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="black" />
```

#### `width`, `initialScale`, 和 `maximumScale`

这其实是 `viewport`元标签的默认设置值，通常不需要手动设置：

```javascript
// layout.js | page.js
export const viewport = {
  width: 'device-width',
  initialScale: 1,
  maximumScale: 1,
  // 也支持
  // interactiveWidget: 'resizes-visual',
}
```

对应输出为：

```javascript
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1"
/>
```

#### colorScheme

[colorScheme](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta/name)，指定与当前文档兼容的一种或多种配色方案。 浏览器将优先采用此元数据的值，然后再使用用户的浏览器或设备设置，来确定页面上的各种默认颜色和元素外观，例如背景色、前景色、窗体控件和滚动条。<meta name="color-scheme"> 的主要用途是指示当前页面与浅色模式和深色模式的兼容性，以及选用这两种模式时的优先顺序。它的值有 `normal`、`light`、`dark`、`only light`。

```javascript
// layout.js | page.js
export const viewport = {
  colorScheme: 'dark',
}
```

```javascript
<meta name="color-scheme" content="dark" />
```

## 3. revalidatePath

### 3.1. 介绍

`revalidatePath` 用于按需清除特定路径上的缓存数据，可用于 Node.js 和 Edge Runtimes。

使用 `revalidatePath` 的时候要知道，在 Next.js 中，清除数据缓存并重新获取最新数据的过程就叫做重新验证（Revalidation），即便在动态路由段中调用了多次 `revalidatePath`，也不会立即触发多次重新验证，只有当下次访问的时候才会重新获取数据并更新缓存。

### 3.2. 参数

```javascript
revalidatePath(path: string, type?: 'page' | 'layout'): void;
```

*   `path` 可以是路由字符串（如 `/product/123`），也可以是文件系统地址字符串（如 `/product/[slug]/page`），必须少于 1024 个字符
*   `type`可选参数，要重新验证的地址类型，值为 `page`或 `layout`

### 3.3. 返回值

`revalidatePath` 不返回任何值

### 3.4. 示例

#### 重新验证特定 URL

```javascript
import { revalidatePath } from 'next/cache'
revalidatePath('/blog/post-1')
```

#### 重新验证页面路径

```javascript
import { revalidatePath } from 'next/cache'
revalidatePath('/blog/[slug]', 'page')
// 带路由组也可以
revalidatePath('/(main)/post/[slug]', 'page')
```

注意在这个例子中，仅重新验证与所提供的 page 文件对应的 URL，也就是说，不会重新验证在这之下的页面，比如 /`blog/[slug]` 不会让 `/blog/[slug]/[author]` 也失效

#### 重新验证布局路径

```javascript
import { revalidatePath } from 'next/cache'
revalidatePath('/blog/[slug]', 'layout')
// 带路由组也可以
revalidatePath('/(main)/post/[slug]', 'layout')
```

在这个例子中，这会何重新验证任何使用这个布局的页面，也就是说， /`blog/[slug]`也会让 `/blog/[slug]/[author]` 失效

#### 重新验证所有数据

```javascript
import { revalidatePath } from 'next/cache'
 
revalidatePath('/', 'layout')
```

这会清除客户端路由缓存，并在下次访问时重新验证数据缓存。

#### Server Action

```javascript
'use server'
// app/actions.js
import { revalidatePath } from 'next/cache'
 
export default async function submit() {
  await submitForm()
  revalidatePath('/')
}
```

#### 路由处理程序

```javascript
// app/api/revalidate/route.js
import { revalidatePath } from 'next/cache'
 
export async function GET(request) {
  const path = request.nextUrl.searchParams.get('path')
 
  if (path) {
    revalidatePath(path)
    return Response.json({ revalidated: true, now: Date.now() })
  }
 
  return Response.json({
    revalidated: false,
    now: Date.now(),
    message: 'Missing path to revalidate',
  })
}
```

## 4. revalidateTag

### 4.1. 介绍

`revalidateTag` 用于按需清除特定标签的缓存数据，可用于 Node.js 和 Edge Runtimes。

使用 `revalidateTag` 的时候要知道，在 Next.js 中，清除数据缓存并重新获取最新数据的过程就叫做重新验证（Revalidation），即便在动态路由段中调用了多次 `revalidateTag`，也不会立即触发多次重新验证，只有当下次访问的时候才会重新获取数据并更新缓存。

### 4.2. 参数

```javascript
revalidateTag(tag: string): void;
```

*   tag 表示要重新验证的标签，必须小于或等于 256 个字符。

添加标签的方式：

```javascript
fetch(url, { next: { tags: [...] } });
```

### 4.3. 返回值

`revalidateTag` 不返回任何值

### 4.4. 示例

#### Server Action

```javascript
// app/actions.js
import { revalidateTag } from 'next/cache'
 
export async function GET(request) {
  const tag = request.nextUrl.searchParams.get('tag')
  revalidateTag(tag)
  return Response.json({ revalidated: true, now: Date.now() })
}
```

#### 路由处理程序

```javascript
// app/api/revalidate/route.js
import { revalidateTag } from 'next/cache'
 
export async function GET(request) {
  const tag = request.nextUrl.searchParams.get('tag')
  revalidateTag(tag)
  return Response.json({ revalidated: true, now: Date.now() })
}
```

## 5. unstable\_cache

### 5.1. 介绍

`unstable_cache` 用于缓存昂贵操作的结果（如数据库查询）并在之后的请求中复用结果，使用示例如下：

```javascript
import { getUser } from './data';
import { unstable_cache } from 'next/cache';
 
const getCachedUser = unstable_cache(
  async (id) => getUser(id),
  ['my-app-user']
);
 
export default async function Component({ userID }) {
  const user = await getCachedUser(userID);
  ...
}
```

### 5.2. 参数

```javascript
const data = unstable_cache(fetchData, keyParts, options)()
```

*   `fetchData`：获取要缓存数据的异步函数，该函数返回一个 Promise
*   `keyParts`：用于标识缓存键名的数组，必须包含全局唯一的值
*   `options`：用于控制缓存行为，具体包含：
    *   `tags`: 用于控制缓存失效的标签数组
    *   `revalidate`：缓存需要重新验证的秒数

### 5.3. 返回值

`unstable_cache` 返回一个函数，该函数调用时会返回一个解析为缓存数据的 Promise。如果数据不在缓存中，则会调用提供的函数，将结果缓存并返回。

## 6. unstable\_noStore

### 6.1. 介绍

`unstable_noStore`用于声明退出静态渲染和表明该组件不应缓存，使用示例如下：

```javascript
import { unstable_noStore as noStore } from 'next/cache';
 
export default async function Component() {
  noStore();
  const result = await db.query(...);
  ...
}
```

`unstable_noStore`相当于在 `fetch` 上添加了 `cache: 'no-store'`。`unstable_noStore` 比 `export const dynamic = 'force-dynamic'`更好的一点是它更细粒度，可以在每个组件的基础上使用。

### 6.2. 示例

如果你不想向 `fetch` 传递额外的选项如 `cache: 'no-store'` 或 `next: { revalidate: 0 }`，你可以使用 `noStore()`作为替代。

```javascript
import { unstable_noStore as noStore } from 'next/cache';
 
export default async function Component() {
  noStore();
  const result = await db.query(...);
  ...
}
```

## 7. useSelectedLayoutSegment

### 7.1. 介绍

`useSelectedLayoutSegment`是一个客户端组件 hook，用于读取比调用该方法所在的布局低一级的激活路由段。这个功能对于导航 UI 非常有用，比如父布局中的选项卡，需要根据当前所处的路由段来更改样式，基础使用示例代码如下：

```javascript
'use client'
// app/example-client-component.js
import { useSelectedLayoutSegment } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const segment = useSelectedLayoutSegment()
 
  return <p>Active segment: {segment}</p>
}
```

为了解释这个 hook 的作用和用法，我们来写一个 demo，demo 效果如下：

![1115.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a02042ee7ef4d379e4540e093f0bad7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=458\&h=209\&s=52469\&e=gif\&f=30\&b=fefefe)

这个 demo 模拟的是侧边栏点击切换当前文章，你可以看到，随着路由的切换，对应链接的样式也发生了变化。代码如下：

```javascript
// app/blog/layout.js
import BlogNavLink from './blog-nav-link'
import getFeaturedPosts from './get-featured-posts'
 
export default async function Layout({ children }) {
  const featuredPosts = await getFeaturedPosts()
  return (
    <div>
      {featuredPosts.map((post) => (
        <div key={post.id}>
          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>
        </div>
      ))}
      <div>{children}</div>
    </div>
  )
}
```

```javascript
'use client'
// app/blog/blog-nav-link.js
import Link from 'next/link'
import { useSelectedLayoutSegment } from 'next/navigation'
 
export default function BlogNavLink({ slug, children }) {
  const segment = useSelectedLayoutSegment()
  const isActive = slug === segment
 
  return (
    <Link
      href={`/blog/${slug}`}
      style={{ fontWeight: isActive ? 'bold' : 'normal' }}
    >
      {children}
    </Link>
  )
}
```

```javascript
// app/blog/get-featured-posts.js
export default async function getFeaturedPosts() {
  await new Promise((resolve) => setTimeout(resolve, 3000))
  return [
    { id: '1', slug: 'article1', title: '文章 1'},
    { id: '2', slug: 'article2', title: '文章 2'},
    { id: '3', slug: 'article3', title: '文章 3'}
  ]
}
```

```javascript
// app/blog/[slug]/page.js
export default function Page({ params }) {
  return <div>当前 slug: {params.slug}</div>
}
```

在这个例子中，`useSelectedLayoutSegment` 是在 `app/blog/layout.js`这个布局中调用的，所以访问 `/blog/article1` 的时候，返回的是比这个布局低一级的路由段，也就是会返回 `article1`，然后我们在 `blog-nav-link.js` 中根据该返回值和当前 slug 进行判断，从而实现了当前所处链接加粗功能。

`useSelectedLayoutSegment`返回比调用该方法所在的布局低一级的激活路由段，也就是说，即使你访问 `blog/article1/about`，因为调用该方法的布局依然是 `app/blog/layout.js`，所以返回的值依然是 `article1`。

### 7.2 参数

```javascript
const segment = useSelectedLayoutSegment(parallelRoutesKey?: string)
```

`useSelectedLayoutSegment` 接收一个可选的 parallelRoutesKey 参数，用于读取平行路由中的激活路由段。

### 7.3 返回值

如果不存在，会返回 `null`，让我们再看几个例子：

| **Layout**                | **访问 URL**                     | **返回值**       |
| ------------------------- | ------------------------------ | ------------- |
| `app/layout.js`           | `/`                            | `null`        |
| `app/layout.js`           | `/dashboard`                   | `'dashboard'` |
| `app/dashboard/layout.js` | `/dashboard`                   | `null`        |
| `app/dashboard/layout.js` | `/dashboard/settings`          | `'settings'`  |
| `app/dashboard/layout.js` | `/dashboard/analytics`         | `'analytics'` |
| `app/dashboard/layout.js` | `/dashboard/analytics/monthly` | `'analytics'` |

## 8. useSelectedLayoutSegments

### 8.1. 介绍

`useSelectedLayoutSegments` 是一个客户端组件 hook，用于读取调用该方法所在的布局以下所有的激活路由段。

`useSelectedLayoutSegments` 与 `useSelectedLayoutSegment` 的区别是：

*   `useSelectedLayoutSegment` 返回的是布局下一级的激活路由段
*   `useSelectedLayoutSegments` 返回的是布局下所有的激活路由段

以上节的 demo 为例，当在 `app/blog/layout.js`布局中调用这两个方法：

访问 `/blog/article1`，`useSelectedLayoutSegment` 返回`'article1'`，`useSelectedLayoutSegments`返回` `\['article1']\`\`。

访问 `/blog/article1/about`，`useSelectedLayoutSegment`返回 `'article1'`，`useSelectedLayoutSegments`返回 `['article1', 'about']`。

`useSelectedLayoutSegments`可以用于实现如面包屑功能，基础使用示例代码如下：

```javascript
'use client'
// app/example-client-component.js
import { useSelectedLayoutSegments } from 'next/navigation'
 
export default function ExampleClientComponent() {
  const segments = useSelectedLayoutSegments()
 
  return (
    <ul>
      {segments.map((segment, index) => (
        <li key={index}>{segment}</li>
      ))}
    </ul>
  )
}
```

### 8.2. 参数

```javascript
const segments = useSelectedLayoutSegments(parallelRoutesKey?: string)
```

### 8.3. 返回值

以数组形式返回，如果没有，返回空数组。注意如果使用了路由组，也会返回，所以可以再用一个 `filter()` 排除掉以括号为开头的条目。让我们再看几个例子：

| **Layout**                | **访问 URL**            | **返回值**                     |
| ------------------------- | --------------------- | --------------------------- |
| `app/layout.js`           | `/`                   | `[]`                        |
| `app/layout.js`           | `/dashboard`          | `['dashboard']`             |
| `app/layout.js`           | `/dashboard/settings` | `['dashboard', 'settings']` |
| `app/dashboard/layout.js` | `/dashboard`          | `[]`                        |
| `app/dashboard/layout.js` | `/dashboard/settings` | `['settings']`              |

## 参考链接

1. [https://nextjs.org/docs/app/api-reference/functions](https://nextjs.org/docs/app/api-reference/functions)

## 37.实战篇 | React Notes | 项目介绍与创建

## 前言

欢迎来到实战篇！基础篇的目标是带大家复习基础知识，以及用作使用手册，方便大家在以后的项目开发中查询 API 用法，属于这本小册的“赠送面积”。从本篇起就进入小册的正式内容了。

我们的第一个实战项目是 **React Notes**，因为 Next.js v14 基于 React Server Component 构建的 App Router，而 React Server Component 的起源是 2020 年 12 月 21 日 React 官方发布的关于 React Server Components 的[介绍文章](https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html)。

这篇文章同时配上了由 Dan Abramov 和 Lauren Tan 两位 React 团队的工程师分享的长约 1h 的[演讲](https://www.youtube.com/watch?time_continue=15\&v=TQQPAU21ZUw\&embeds_referring_euri=https%3A%2F%2Flegacy.reactjs.org%2F\&source_ve_path=MzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMjg2NjY\&feature=emb_logo)和 [Demo](https://github.com/reactjs/server-components-demo)，详细的介绍了 React Server Components 的出现背景和使用方式（这是这个 Demo 的一个[线上工程](https://stackblitz.com/edit/react-server-components-demo-u57n2t?file=README.md)，你可以在这个地址上调试学习）。

当时这个 [Demo](https://github.com/reactjs/server-components-demo) 就是 **React Notes**，实战篇的第一个项目从这个“起源 Demo”开始讲起，既是一种追溯致敬，也是为了帮助大家在实战中体会 React Server Component 的特性和优势，毕竟当时 React 的工程师写了这个 Demo 用于新特性的展示，自然是要覆盖它的各种用法和特性。

这个 Demo 中的 Server 是自己写的，数据库用的是 PostgreSQL，如果要本地预览原本的 Demo 效果，参照 Demo 的介绍，本地安装 PostgreSQL，创建数据库，连接数据库，再运行项目即可成功开启。这里具体的实现步骤就不多讲了，反正我们的实战篇会用 Next.js 重新实现这个项目。

## 需求文档

先让我介绍下 React Notes 的项目效果，正如它的名字表明的那样，这是一个笔记系统，可以增删改查笔记，笔记支持 markdown 格式。

首页效果如下，界面分为两列，左侧是笔记列表，右侧是笔记内容：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/081f4269b85447a0ae044465ea9fa2f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3076\&h=1570\&s=258799\&e=png\&b=f4f6f9)

点击左边的 `New` 按钮，可以增加一个 Note，增加后，左侧笔记列表也会同时更新：

![React Notes 增加.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3411f724c4eb4d1997311f245723df14~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1191\&h=720\&s=108873\&e=gif\&f=42\&b=f4f6f9)

在编辑的时候，也可以删除一个 Note，删除后左侧笔记列表也会同时更新：

![React Notes 删除.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dad06db2883947c288dc871c769db98b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1209\&h=892\&s=166272\&e=gif\&f=32\&b=fefefe)

可以对现有的 Note 进行修改：

![React Notes 修改.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/769756f0159a465097938e39a0eac2de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1209\&h=892\&s=113504\&e=gif\&f=44\&b=fefefe)

还可以在左侧用搜索框查找一个 Note：

![React Notes 查找.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2111a45e641438daab0ae9d3394dc90~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1209\&h=892\&s=324795\&e=gif\&f=91\&b=f6f8fa)

看起来效果是不是平平无奇？但是注意一点，在这个例子中，我们先在左侧笔记列表中展开了一个笔记，然后又新建了一个笔记，在新建后，左侧笔记列表刷新，但展开的笔记依然保持了之前的状态。

## 技术文档

现在我们要用 Next.js 实现这个项目，该怎么实现呢？

首先是技术选型，Next.js 的 App Router 自然是要用的，TypeScript 为了减少代码展示量就不使用了，ESLint 要使用，用于校验代码，Tailwind CSS 不需要，因为重写样式浪费时间，我们直接导入原 Demo 的样式文件即可。

后端数据库选择什么都可以，不过考虑到初期大家对 Next.js 尤其是 App Router 的使用不太习惯，再加上数据库的安装和使用也需要额外学习，我们先集中学习如何写好 Next.js 项目，数据方面先使用模拟数据来实现。

那么新的问题来了，怎么写模拟数据呢？第一种方式是在代码里直接写入数据。第二种方式是使用比如 faskMock 这样的工具生成静态接口。但是我们毕竟要做增删改查，无论是直接写数据还是静态接口都难以实现真的对数据源进行修改，所以最后我想了下，干脆用 [Redis](https://redis.io/) 做好了，作为经典的 NoSQL 数据库，使用起来也很方便。等 Next.js 部分完成学习之后，我们再替换为其他数据库。（其实我还试了用[维格表](https://developers.vika.cn/api/introduction)做数据库，但维格表接口有每秒最多 2 次的限制，于是就放弃了）

其次是路由分析，原 Demo 中都是在 `localhost:4000`下实现的，各种操作并不会产生路由变化，但既然我们用了 Next.js，不妨改成使用路由的方式，想了下，应该有这样几个路由：

1.  首页肯定是 `/`，点击左上角的 React Note Logo 会导航至首页 `/`
2.  点击左侧笔记列表中的一项，导航至 `/note/xxxx`路由，渲染具体笔记内容
3.  当点击 `NEW` 按钮的时候导航到 `/note/edit`路由上，点击 `Done`导航至刚创建的 `/note/xxxx`路由
4.  导航至 `/note/xxxx`后，点击 `EDIT` 按钮，进入 `/note/edit/xxxx` 路由，点击 `Done`导航至刚修改的 `/note/xxxx`路由，点击 `DELETE` 导航至首页 `/`
5.  当在左侧搜索框输入字符的时候，对应路由添加 `?q=searchText` 参数

对应到 Next.js 的项目目录，至少要有这些文件：

```javascript
next-react-notes                 
├─ app                                     
│  ├─ note                       
│  │  ├─ [id]                         
│  │  │  └─ page.js              
│  │  └─ edit                    
│  │     ├─ [id]                 
│  │     │  └─ page.js              
│  │     └─ page.js                        
│  ├─ layout.js                  
│  └─ page.js                                
```

考虑到左侧笔记列表出现在所有的路由中，我们将左侧的内容包括搜索栏和笔记列表，统一放在根布局 `layout.js` 中。

再者是组件划分，示意图如下：

![截屏2023-12-14 下午4.08.38.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0ce14cd1fd74018ac9e956d1da4864f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2450\&h=1740\&s=147434\&e=png\&b=ffffff)

左侧是 `<Sidebar>` 组件，子组件中有：

1.  `<SidebarSearchField>` 组件负责搜索框
2.  `<EditButton>` 组件负责添加按钮
3.  `<SidebarNoteList>` 组件负责笔记列表
    1.  再拆分为具体的 `<SidebarNoteItem>` 组件负责每一条具体的笔记内容

右侧是 `<Note>` 组件，子组件有：

1.  `<EditButton>` 组件负责编辑按钮
2.  `<NoteEditor>` 组件负责笔记的编辑界面
3.  `<NotePreview>` 组件负责笔记的预览界面

对项目有了大致的了解和规划，剩下的就让我们在项目里具体完善吧，现在开始动手吧。

## 开始项目

### 1. 创建项目

使用 `create-next-app`脚手架[创建项目](https://juejin.cn/book/7307859898316881957/section/7307280276332544027#heading-1)，运行：

```bash
npx create-next-app@latest
```

相关选择如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb2ac654862f445fb9146ce39caba318~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1150\&h=328\&s=618397\&e=png\&b=0b141d)

运行 `npm run dev`，打开 `localhost: 3000`开启项目：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60cd55caf07d46ab9832700283dd1f3d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2034\&h=1490\&s=294221\&e=png\&b=000000)

### 2. 配置路径别名

为了让代码文件职责清晰，我们将组件统一放在根目录下的 `components`目录下，工具库放在根目录下的 `lib`目录下，为了方便引入，我们配置一下[路径别名](https://juejin.cn/book/7307859898316881957/section/7309078454316564507#heading-13)，修改 `jsconfig.json`：

```javascript
{
  "compilerOptions": {
    "paths": {
      "@/components/*": ["components/*"],
      "@/lib/*": ["lib/*"]
    }
  }
}
```

### 3. 修改根布局和根页面

修改 `app/page.js`：

```javascript
// app/page.js
export default async function Page() {
  return (
    <div className="note--empty-state">
      <span className="note-text--empty-state">
        Click a note on the left to view something! 🥺
      </span>
    </div>
  )
}

```

修改 `app/layout.js`：

```javascript
import './style.css'
import Sidebar from '@/components/Sidebar'

export default async function RootLayout({
  children
}) {

  return (
    <html lang="en">
      <body>
        <div className="container">
          <div className="main">
            <Sidebar />
            <section className="col note-viewer">{children}</section>
          </div>
        </div>
      </body>
    </html>
  )
}

```

在 `/components`下新建一个名为 `Sidebar.js` 的文件，代码为：

```javascript
import React from 'react'
import Link from 'next/link'

export default async function Sidebar() {
  return (
    <>
      <section className="col sidebar">
        <Link href={'/'} className="link--unstyled">
          <section className="sidebar-header">
            <img
              className="logo"
              src="/logo.svg"
              width="22px"
              height="20px"
              alt=""
              role="presentation"
            />
            <strong>React Notes</strong>
          </section>
        </Link>
        <section className="sidebar-menu" role="menubar">
            {/* SideSearchField */}
        </section>
        <nav>
          {/* SidebarNoteList */}
        </nav>
      </section>
    </>
  )
}
```

### 4. 引入所需样式和图片文件

在根布局里我们引用了 `style.css`，`style.css`里声明了所有的样式，但这个文件不需要我们自己写，因为[原 Demo](https://github.com/reactjs/server-components-demo/tree/main) 里就已经将所有的样式写到了一个 [style.css](https://github.com/reactjs/server-components-demo/blob/main/public/style.css) 文件，我们只需要将这个文件拷贝到 `app`目录下即可。

这个项目里还会用到一些图片，我们将原 Demo 里 [public 目录](https://github.com/reactjs/server-components-demo/tree/main/public)下的 5 张 SVG 图片：`checkmark.svg`、`chevron-down.svg`、`chevron-up.svg`、`cross.svg`、`logo.svg` 拷贝到 `public`目录下。

### 5. 第一步完成！

如果步骤正确的话，此时再访问 `http://localhost:3000/`应该效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6752f40eba614c99a75c1e0e67cff120~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1736\&h=1132\&s=100291\&e=png\&b=f6f7fa)

是不是有原 Demo 的样子了？

## 数据请求

现在我们来处理数据的问题，正如之前所说，为了方便起见，我们使用 Redis 做数据库。简单介绍一下 Redis，它是一个高性能的 key-value  数据库，是现在最受欢迎的 NoSQL 数据库之一，常用于缓存、计数器、消息队列系统、排行榜等场景。

使用 Redis 很简单，一共分为三步：

### 1. 安装 Redis

macOS 安装 redis 很简单，按照[官网安装说明](https://redis.io/docs/install/install-redis/install-redis-on-mac-os/)，使用 Homebrew 安装即可：

```bash
brew install redis
```

Windows 安装略微复杂一点，因为我手边没有 Windows 电脑，就不提供安装方法了，教程很多。

### 2. 启动 Redis

运行以下命令，如果出现下图界面即表示运行成功：

```bash
redis-server
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd716fcce111422697241f8463989a52~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2022\&h=1094\&s=3147360\&e=png\&b=03080d)

### 3. 项目引入 Redis

在项目里使用 redis 的时候，我们借助 [ioredis](https://github.com/redis/ioredis) 这个库，安装 ioredis：

```bash
npm install ioredis
```

在根目录下新建一个 `lib`文件夹，在 `lib`下新建一个名为 `redis.js`的文件，代码如下：

```javascript
import Redis from 'ioredis'

const redis = new Redis()

const initialData = {
  "1702459181837": '{"title":"sunt aut","content":"quia et suscipit suscipit recusandae","updateTime":"2023-12-13T09:19:48.837Z"}',
  "1702459182837": '{"title":"qui est","content":"est rerum tempore vitae sequi sint","updateTime":"2023-12-13T09:19:48.837Z"}',
  "1702459188837": '{"title":"ea molestias","content":"et iusto sed quo iure","updateTime":"2023-12-13T09:19:48.837Z"}'
}

export async function getAllNotes() {
  const data = await redis.hgetall("notes");
  if (Object.keys(data).length == 0) {
    await redis.hset("notes", initialData);
  }
  return await redis.hgetall("notes")
}

export async function addNote(data) {
  const uuid = Date.now().toString();
  await redis.hset("notes", [uuid], data);
  return uuid
}

export async function updateNote(uuid, data) {
  await redis.hset("notes", [uuid], data);
}

export async function getNote(uuid) {
  return JSON.parse(await redis.hget("notes", uuid));
}

export async function delNote(uuid) {
  return redis.hdel("notes", uuid)
}

export default redis
```

这块代码并不复杂，我们导出了 5 个函数，表示 5 个用于前后端交互的接口，分别是：

1.  获取所有笔记的 getAllNotes，这里我们做了一个特殊处理，如果为空，就插入 3 条事先定义的笔记数据
2.  添加笔记的 addNote
3.  更新笔记的 updateNote
4.  获取笔记的 updateNote
5.  删除笔记的 delNote

其中我们使用了 ioredis 的 hash 结构（ioredis 提供了相关[写法示例](https://github.com/redis/ioredis/blob/main/examples/hash.js)和 [API 说明](https://redis.github.io/ioredis/classes/Redis.html)）。也就是说，我们在 redis 服务器中存储的数据大概长这样：

```javascript
{
  "1702459181837": '{"title":"sunt aut","content":"quia et suscipit suscipit recusandae","updateTime":"2023-12-13T09:19:48.837Z"}',
  "1702459182837": '{"title":"qui est","content":"est rerum tempore vitae sequi sint","updateTime":"2023-12-13T09:19:48.837Z"}',
  "1702459188837": '{"title":"ea molestias","content":"et iusto sed quo iure","updateTime":"2023-12-13T09:19:48.837Z"}'
}
```

使用 macOS 的同学可以再下载一个 [Medis](https://getmedis.com/)，用于查看 Redis 中的数据（当然此时 Redis 还没有写入这些数据）：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8aae8a72646348fdb715e742f1e3cf1e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2680\&h=1644\&s=638727\&e=png\&a=1\&b=252729)

其中，key 值用的是创建笔记时的时间戳，value 值是具体的笔记数据，分为 3 个字段，分别是 `title`、`content`、`updateTime`。

## Sidebar 组件

现在让我们用此数据接口来写左侧的笔记列表吧！

### 1. 笔记列表

修改 `components/Sidebar.js`：

```jsx
import React from 'react'
import Link from 'next/link'
import { getAllNotes } from '@/lib/redis';
import SidebarNoteList from '@/components/SidebarNoteList';

export default async function Sidebar() {
  const notes = await getAllNotes()
  return (
    <>
      <section className="col sidebar">
        <Link href={'/'} className="link--unstyled">
          <section className="sidebar-header">
            <img
              className="logo"
              src="/logo.svg"
              width="22px"
              height="20px"
              alt=""
              role="presentation"
              />
            <strong>React Notes</strong>
          </section>
        </Link>
        <section className="sidebar-menu" role="menubar">
          {/* SideSearchField */}
        </section>
        <nav>
          <SidebarNoteList notes={notes} />
        </nav>
      </section>
    </>
  )
}
```

在代码中，我们将笔记列表抽成了单独的 `components/SidebarNoteList.js`组件，代码如下：

```jsx
export default async function NoteList({ notes }) {

  const arr = Object.entries(notes);

  if (arr.length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return <ul className="notes-list">
    {arr.map(([noteId, note]) => {
    const { title, updateTime } = JSON.parse(note);
    return <li key={noteId}>
      <header className="sidebar-note-header">
        <strong>{title}</strong>
        <small>{updateTime}</small>
      </header>
    </li>
  })}
  </ul>
}
```

如果步骤正确的话，此时再访问 `http://localhost:3000/`应该效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9907e43c6f14b308a31d1ebddd11b66~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1746\&h=990\&s=139551\&e=png\&b=f6f7fa)

我们已经成功的获取了 Redis 数据库中的数据，然后服务端渲染到了页面上。

现在在 Medis 中应该已经可以查看到写入的数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1bd5a4a1c4d14aeea990ca4c239c6226~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2680\&h=1644\&s=638727\&e=png\&a=1\&b=252729)

现在你在 Medis 中修改下数据，`http://localhost:3000/`刷新后也会展示出来。

### 2. 时间处理库

现在你会发现，左侧笔记列表中的时间展示非常“难看”，为此我们需要一个将时间格式化的库，这里我们选择大家经常会用到的 [Day.js](https://dayjs.gitee.io/zh-CN/)，安装一下：

```bash
npm install dayjs
```

修改 `SidebarNoteList.js`：

```javascript
import dayjs from 'dayjs';

export default async function NoteList({ notes }) {

  const arr = Object.entries(notes);

  if (arr.length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return <ul className="notes-list">
    {arr.map(([noteId, note]) => {
      const { title, updateTime } = JSON.parse(note);
      return <li key={noteId}>
        <header className="sidebar-note-header">
          <strong>{title}</strong>
          <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>
        </header>
      </li>
    })}
  </ul>
}
```

时间效果展示如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/387c82dde3384009a47671aa2918ff38~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1740\&h=922\&s=126371\&e=png\&b=f6f7fa)

是不是好看多了？但其实效果并不重要，重要的是我们引用了 `day.js` 这个库。我们引入 `day.js` 的 SidebarNoteList 组件使用的是服务端渲染，这意味着 `day.js` 的代码并不会被打包到客户端的 bundle 中。我们查看开发者工具中的源代码：

![截屏2023-12-14 下午10.56.02.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b8254999ba64c4bad1ff63ef2c0c621~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2492\&h=1010\&s=207391\&e=png\&b=f6f7fa)

你会发现 node\_modules 并没有 day.js，但如果你现在在 SidebarNoteList 组件的顶部添加 `'use client'`，声明为客户端组件，你会发现立刻就多了 day.js：

![截屏2023-12-14 下午10.59.07.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/037b4091549a45bd9457361eced21579~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2494\&h=990\&s=210227\&e=png\&b=f6f7fa)

### 3. 最佳实践：多用服务端组件

这就是使用 React Server Compoent 的好处之一，服务端组件的代码不会打包到客户端的 bundle 中：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/588f2f2a57b545f3a247ffcd27a6aa81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1500\&h=573\&s=216155\&e=png\&b=1b1c24)

## 总结

那么今天的内容就结束了，本篇我们大致知道了要做的项目内容，并新建了 Next.js 项目，学会了用 Redis 做个简易的数据库，最后通过引入时间处理库，了解了使用 React Server Component 的一个优势。

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 Day1 分支：<https://github.com/mqyqingfeng/next-react-notes-demo/tree/day1>，直接使用的时候不要忘记在本地开启 Redis。

## 参考链接

1.  <https://github.com/reactjs/server-components-demo>
2.  <https://www.youtube.com/watch?v=TQQPAU21ZUw&t=15s&ab_channel=MetaOpenSource>
3.  <https://redis.io/docs/install/install-redis/install-redis-on-mac-os/>


## 38.实战篇 | React Notes | 侧边栏笔记列表

## 前言

本篇我们来实现 React Notes 的左侧侧边栏部分。

## SidebarNoteList

现在我们接着完善笔记列表，毕竟笔记列表这里还要实现展开和收回功能：

![展开收回.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf9b75b9b8df4e9784fa1107e527d0d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1144\&h=638\&s=90321\&e=gif\&f=18\&b=fefefe)

修改 `components/SidebarNoteList.js`代码：

```jsx
import SidebarNoteItem from '@/components/SidebarNoteItem';

export default async function NoteList({ notes }) {

  const arr = Object.entries(notes);

  if (arr.length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return <ul className="notes-list">
    {arr.map(([noteId, note]) => {
    return <li key={noteId}>
      <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />
    </li>
  })}
  </ul>
}
```

这里我们将具体的每条笔记抽离成单独的 `SidebarNoteItem` 组件，`components/SidebarNoteItem.js`代码如下：

```jsx
import dayjs from 'dayjs';
import SidebarNoteItemContent from '@/components/SidebarNoteItemContent';

export default function SidebarNoteItem({ noteId, note}) {

  const { title, content = '', updateTime } = note;
  return (
    <SidebarNoteItemContent
      id={noteId}
      title={note.title}
      expandedChildren={
        <p className="sidebar-note-excerpt">
          {content.substring(0, 20) || <i>(No content)</i>}
        </p>
      }>
      <header className="sidebar-note-header">
        <strong>{title}</strong>
        <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>
      </header>
    </SidebarNoteItemContent>
  );
}
```

这里我们又抽离了一个 `SidebarNoteItemContent` 组件，用来实现展开和收回功能，我们将笔记的标题和时间的 JSX 作为 children 传递给了 `SidebarNoteItemContent`，`components/SidebarNoteItemContent.js`代码如下：

```jsx
'use client';

import { useState, useRef, useEffect, useTransition } from 'react';
import { useRouter, usePathname } from 'next/navigation'

export default function SidebarNoteContent({
  id,
  title,
  children,
  expandedChildren,
}) {
  const router = useRouter()
  const pathname = usePathname()
  const selectedId = pathname?.split('/')[1] || null

  const [isPending] = useTransition()
  const [isExpanded, setIsExpanded] = useState(false)
  const isActive = id === selectedId

  // Animate after title is edited.
  const itemRef = useRef(null);
  const prevTitleRef = useRef(title);

  useEffect(() => {
    if (title !== prevTitleRef.current) {
      prevTitleRef.current = title;
      itemRef.current.classList.add('flash');
    }
  }, [title]);

  return (
    <div
      ref={itemRef}
      onAnimationEnd={() => {
        itemRef.current.classList.remove('flash');
      }}
      className={[
        'sidebar-note-list-item',
        isExpanded ? 'note-expanded' : '',
      ].join(' ')}>
      {children}
      <button
        className="sidebar-note-open"
        style={{
          backgroundColor: isPending
            ? 'var(--gray-80)'
            : isActive
              ? 'var(--tertiary-blue)'
              : '',
          border: isActive
            ? '1px solid var(--primary-border)'
            : '1px solid transparent',
        }}
        onClick={() => {
          const sidebarToggle = document.getElementById('sidebar-toggle')
          if (sidebarToggle) {
            sidebarToggle.checked = true
          }
          router.push(`/note/${id}`)
        }}>
        Open note for preview
      </button>
      <button
        className="sidebar-note-toggle-expand"
        onClick={(e) => {
          e.stopPropagation();
          setIsExpanded(!isExpanded);
        }}>
        {isExpanded ? (
          <img
            src="/chevron-down.svg"
            width="10px"
            height="10px"
            alt="Collapse"
          />
        ) : (
          <img src="/chevron-up.svg" width="10px" height="10px" alt="Expand" />
        )}
      </button>
      {isExpanded && expandedChildren}
    </div>
  );
}
```

这里 `SidebarNoteItemContent` 具体的实现其实并不重要，你只要知道这是一个客户端组件就行了。在这个客户端组件里我们用了 `useState` 来控制展开和收回的状态，然后添加了一些动画效果，仅此而已。如果步骤正确的话，此时的页面效果为：

![展开收回2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a50bf13df5640608bef62a9583fb01e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996\&h=565\&s=76691\&e=gif\&f=30\&b=f3f5f9)

我们成功的实现了组件的展开和收回功能！

## 服务端组件和客户端组件

现在让我们回顾下此时的侧边栏组件结构情况：

我们声明了一个 `Sidebar` 组件用于实现侧边栏，其中有一个子组件 `SidebarNoteList` 用于实现侧边栏的笔记列表部分，针对每一条笔记，我们抽离了一个 `SidebarNoteItem` 组件来实现，在 `SidebarNoteItem` 中，我们又抽离了一个名为 `SidebarNoteItemContent` 的客户端组件用于实现展开和收回功能，然后我们在 `SidebarNoteItem` 这个服务端组件中将笔记的标题和时间这段 JSX 作为 `children` 传递给 `SidebarNoteItemContent`。

这个时候你可能会有个疑问：为什么要这样做呢？为什么不直接把 `SidebarNoteItem` 声明为客户端组件，然后直接在这个组件里全部实现呢？还要用传递 `children` 这么复杂的方式？

### 使用指南

倒不着急回答这个问题。因为这段功能的实现涉及到我们开发 Next.js 项目常用的服务端组件和客户端组件导入，所以先让我们回顾下[相关的使用知识](https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-31)（这很重要，开发的时候要谨记）：

1.  **服务端组件可以导入客户端组件，但客户端组件并不能导入服务端组件**
2.  **从服务端组件到客户端组件传递的数据需要可序列化**，以刚才的例子为例：

```javascript
// components/SidebarNoteItem.js

export default function SidebarNoteItem({ noteId, note}) {
	// ...
  return (
    <SidebarNoteItemContent
      id={noteId}
      title={note.title}
			fun={() => {}}
      expandedChildren={
        <p className="sidebar-note-excerpt">
          {content.substring(0, 20) || <i>(No content)</i>}
        </p>
      }>
      <header className="sidebar-note-header">
        <strong>{title}</strong>
        <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>
      </header>
    </SidebarNoteItemContent>
  );
}
```

所谓可序列化，简单的理解就是 JSON.stringify() 这段数据不会出现错误，如果我们在这里传递一个函数 `fun={() => {}}`，就会出现错误提示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d143c66943f4e53a00efd1dd9d99be9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1908\&h=254\&s=56269\&e=png\&b=ffffff)

但 JSX 对象是可以正常传递的，正如这个例子中展示的那样。

3.  **但你可以将服务端组件以 props 的形式传给客户端组件**，其实刚才的实现里就展现了两种传递服务端组件的形式：

```jsx
// components/SidebarNoteItem.js

export default function SidebarNoteItem({ noteId, note}) {

  const { title, content = '', updateTime } = note;
  return (
    <SidebarNoteItemContent
      id={noteId}
      title={note.title}
      // 第一种方式
      expandedChildren={
        <p className="sidebar-note-excerpt">
          {content.substring(0, 20) || <i>(No content)</i>}
        </p>
      }>
      // 第二种方式
      <header className="sidebar-note-header">
        <strong>{title}</strong>
        <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>
      </header>
    </SidebarNoteItemContent>
  );
}
```

### 服务端组件特性

现在让我们重新审视一下 SidebarNoteItem 的代码：

```jsx
// components/SidebarNoteItem.js
import dayjs from 'dayjs';

import SidebarNoteItemContent from '@/components/SidebarNoteItemContent';

export default function SidebarNoteItem({ noteId, note}) {

  const { title, content = '', updateTime } = note;
  return (
    <SidebarNoteItemContent
      id={noteId}
      title={note.title}
      expandedChildren={
        <p className="sidebar-note-excerpt">
          {content.substring(0, 20) || <i>(No content)</i>}
        </p>
      }>
      <header className="sidebar-note-header">
        <strong>{title}</strong>
        <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>
      </header>
    </SidebarNoteItemContent>
  );
}
```

考验你是否认真学习了之前的知识到了！

在这段代码中，`SidebarNoteItem` 是一个服务端组件，在这个组件中我们引入了 dayjs 这个库，然而我们却是在 `SidebarNoteItemContent` 这个客户端组件中使用的 dayjs。请问最终客户端的 bundle 中是否会打包 dayjs 这个库？

关于这个结果，反正效果我们都实现了，直接去查看一下就知道了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69f96864c4734380b94668a814caf502~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2458\&h=1040\&s=261833\&e=png\&b=f5f6f9)

所以答案是不会。**在服务端组件中使用 JSX 作为传递给客户端组件的 prop，JSX 会先进行服务端组件渲染，再发送到客户端组件中**。也就是说，发送给客户端组件的并不是：

```html
<header className="sidebar-note-header">
  <strong>{title}</strong>
  <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>
</header>
```

而是编译后的如：

```html
<header class="sidebar-note-header">
  <strong>ea molestias</strong>
  <small>2023-12-13 05:19:48</small>
</header>
```

其实这里我们也完全可以把 header 抽离成一个 `SidebarNoteItemHeader` 服务端组件，这样效果会更明显：

新建 `/components/SidebarNoteItemHeader.js`，代码如下：

```javascript
import dayjs from 'dayjs';

export default function SidebarNoteItemHeader({title, updateTime}) {
  return (
      <header className="sidebar-note-header">
          <strong>{title}</strong>
          <small>{dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}</small>
      </header>
  );
}
```

修改 `SidebarNoteItem.js`文件代码为：

```jsx
import SidebarNoteItemContent from '@/components/SidebarNoteItemContent';
import SidebarNoteItemHeader from '@/components/SidebarNoteItemHeader';

export default function SidebarNoteItem({ noteId, note}) {

  const { title, content = '', updateTime } = note;
  return (
    <SidebarNoteItemContent
      id={noteId}
      title={note.title}
      expandedChildren={
        <p className="sidebar-note-excerpt">
          {content.substring(0, 20) || <i>(No content)</i>}
        </p>
      }>
        <SidebarNoteItemHeader title={title} updateTime={updateTime} />
    </SidebarNoteItemContent>
  );
}
```

现在我们查看下开发者工具中的的 Source 选项：

![截屏2023-12-15 下午8.45.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ffc4d5d0e140af8d20beddbaa9c904~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3098\&h=1174\&s=265892\&e=png\&b=f5f6f9)

你会发现 `components` 下并没有我们刚建立的 `SidebarNoteItemHeader` 组件，只有一个客户端组件 `SidebarNoteItemContent`，node\_modules 下也没有 dayjs（如果你把 `SidebarNoteItemHeader` 声明为客户端组件就有了）。

最后让我们查看下 localhost 这个文件的 HTML：

![截屏2023-12-15 下午4.06.39.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86f0f6b6a691489ab2c29574bf3aab0b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3458\&h=1668\&s=659769\&e=png\&b=2a2a2a)

传给客户端组件的 JSX 这些内容也会直接渲染到 HTML 中，当然这里跟客户端组件还是服务端组件无关，是客户端组件也会预渲染，只是提一下而已。

### 最佳实践：客户端组件下移

我们在 [《渲染篇 | 服务端组件和客户端组件》](https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-29)中讲到 **“尽可能将客户端组件在组件树中下移”**，这里就是一个很好的例子。我们本可以直接把 `SidebarNoteItem` 声明为客户端组件，然后直接在这个组件里全部实现，但是却抽离了一个名为 `SidebarNoteItemContent` 的客户端组件用于实现展开和收回功能。

`SidebarNoteItemContent` 的内容原本是 `SidebarNoteList` 的子组件，现在却是 `SidebarNoteItem` 的子组件。虽然在组件树中的位置下移了，但我们却因此避免了 dayjs 这个库被打包到客户端 bundle 中。在开发的时候，应该尽可能缩减客户端组件的范围。

## EditButton

`New` 和 `Edit` 按钮考虑到复用，我们单独抽离成一个 `EditButton`组件：

```javascript
// components/EditButton.js
import Link from 'next/link'

export default function EditButton({noteId, children}) {
  const isDraft = noteId == null;
  return (
    <Link href={`/note/edit/${noteId || ''}`} className="link--unstyled">
      <button
        className={[
          'edit-button',
          isDraft ? 'edit-button--solid' : 'edit-button--outline',
        ].join(' ')}
        role="menuitem">
        {children}
      </button>
    </Link>
  );
}
```

Sidebar 组件引入一下：

```javascript
// ...
import EditButton from '@/components/EditButton';

export default async function Sidebar() {
  const notes = await getAllNotes()
  return (
    <>
      	// ...
        <section className="sidebar-menu" role="menubar">
          <EditButton noteId={null}>New</EditButton>
        </section>
        <nav>
          <SidebarNoteList notes={notes} />
        </nav>
      </section>
    </>
  )
}

```

## Suspense

原 Demo 中当笔记列表加载的时候是有骨架图的效果的：

![suspense2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b9181f28f944267a85356b7c39fd02c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031\&h=642\&s=65695\&e=gif\&f=20\&b=f4f6f9)

这说明肯定用了 `Suspense`。因为我们现在将笔记列表数据的获取放在了顶层，所以直接为 `SidebarNoteList` 添加 `Suspense` 是没有效果的，我们需要将数据获取改为在 `SidebarNoteList` 组件内部。

修改`Sidebar.js` 代码如下：

```jsx
import React, { Suspense } from 'react'
import Link from 'next/link'

import SidebarNoteList from '@/components/SidebarNoteList';
import EditButton from '@/components/EditButton';
import NoteListSkeleton from '@/components/NoteListSkeleton';

// // 移除数据请求部分，为 SidebarNoteList 添加 Suspense 以及 fallback UI NoteListSkeleton
export default async function Sidebar() {

  return (
    <>
      <section className="col sidebar">
        <Link href={'/'} className="link--unstyled">
          <section className="sidebar-header">
            <img
              className="logo"
              src="/logo.svg"
              width="22px"
              height="20px"
              alt=""
              role="presentation"
              />
            <strong>React Notes</strong>
          </section>
        </Link>
        <section className="sidebar-menu" role="menubar">
          <EditButton noteId={null}>New</EditButton>
        </section>
        <nav>
          <Suspense fallback={<NoteListSkeleton />}>
            <SidebarNoteList />
          </Suspense>
        </nav>
      </section>
    </>
  )
}
```

添加 `/components/NoteListSkeleton.js`，代码如下：

```jsx
export default function NoteListSkeleton() {
  return (
    <div>
      <ul className="notes-list skeleton-container">
        <li className="v-stack">
          <div
            className="sidebar-note-list-item skeleton"
            style={{height: '5em'}}
          />
        </li>
        <li className="v-stack">
          <div
            className="sidebar-note-list-item skeleton"
            style={{height: '5em'}}
          />
        </li>
        <li className="v-stack">
          <div
            className="sidebar-note-list-item skeleton"
            style={{height: '5em'}}
          />
        </li>
      </ul>
    </div>
  );
}
```

`/components/SidebarNoteList.js`代码如下，为了让效果更加明显，我们添加了一个 sleep 函数：

```javascript
import SidebarNoteItem from '@/components/SidebarNoteItem';
import { getAllNotes } from '@/lib/redis';

export default async function NoteList() {
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  await sleep(10000);
  const notes = await getAllNotes()

  const arr = Object.entries(notes);

  if (arr.length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return <ul className="notes-list">
    {arr.map(([noteId, note]) => {
      return <li key={noteId}>
        <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />
      </li>
    })}
  </ul>
}
```

此时页面效果如下：

![suspense3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/585e8f43135e4cc3afa39336aba2ccba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031\&h=642\&s=80276\&e=gif\&f=36\&b=f3f5f9)

我们成功实现了骨架图效果！

那么问题来了，`SidebarNoteList` 用 `Suspense` 和不用 `Suspense`，具体有什么改变呢？比如，使用 `Suspense` 会带来新的请求吗？

我们可以自己测试一下，**答案是不会。** 之前是那 10 个请求，使用后还是那 10 个请求。

那么使用 `Suspense` 和不使用 `Suspense`，到底有什么差别呢？其实我们看下用和不用的效果就知道了。

我们把 sleep 的时间设置为 5s。这是不使用 Suspense 的效果，我们从掘金页面输入地址 `http://localhost:3000/`：

![use suspense.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9865b4976c54f31b5567b6f12493454~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031\&h=642\&s=171424\&e=gif\&f=21\&b=fdfdfd)

输入地址后，我们等待了大概 5s 后，页面突然完全展现。

这是使用 Suspense 的效果，我们还是从掘金页面输入地址 `http://localhost:3000/`：

![use suspense2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbd8d4e509114b15808f8964ecbbcf96~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031\&h=642\&s=269392\&e=gif\&f=52\&b=fdfdfd)

输入地址后，我们立刻就跳转到了页面，笔记列表部分等待了 5s 后，开始展现。除此之外，使用 Suspense，数据加载不会阻塞页面，也就是说在笔记列表还在加载的时候，用户依然可以与页面其他部分进行交互，比如点击 New 按钮新建笔记。

那么问题又来了，页面请求数没有变化，也没有新的请求，这些又都是服务端组件，数据请求都在服务端，到底谁等待了那 5s 呢，然后把数据返回的呢？

答案在于 `localhost` 这个 HTML 页面，查看网络请求，刚开始页面加载的时候，localhost 的 Time 为 126ms：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa17b32219a4193aa7fdccf62691b21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2788\&h=1244\&s=450882\&e=png\&b=292929)

加载完成后，localhost 的 Time 变成了 5s：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d53503d83c524dd980444d5e69ad3760~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2784\&h=1376\&s=509817\&e=png\&b=292929)

之所以这样，正如[《渲染篇 | Streaming 和 Edge Runtime》](https://juejin.cn/book/7307859898316881957/section/7309076865732640818)中介绍的那样，答案在于 HTML 是通过 stream 格式进行传输的，查看 HTML 文件的响应头：

![截屏2023-12-15 下午7.42.29.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/832e56f2810d4a6f9b384bf21737d8fd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2788\&h=1376\&s=472366\&e=png\&b=2b2b2b)

其 `Transfer-Encoding` 标头的值为 `chunked`，表示数据将以一系列分块的形式进行发送。HTML 首先收到骨架图的 HTML 进行渲染，再收到渲染完成的笔记列表 HTML 进行渲染，查看一下 localhost HTML 文件的返回：

```html
<!DOCTYPE html>
<html lang="en">
  <head>

  </head>
  <body>
    <div class="container">
      <div class="main">
        // ...
        <nav>
          <!--$?-->
          <template id="B:0"></template>
          <!--这里是骨架图 NoteListSkeleton 的 HTML-->
          <div>
            <ul class="notes-list skeleton-container">
              <li class="v-stack">
                <div class="sidebar-note-list-item skeleton" style="height:5em"></div>
              </li>
              <li class="v-stack">
                <div class="sidebar-note-list-item skeleton" style="height:5em"></div>
              </li>
              <li class="v-stack">
                <div class="sidebar-note-list-item skeleton" style="height:5em"></div>
              </li>
            </ul>
          </div>
          <!--/$-->
        </nav>
      </div>
    </div>
    // ...
    <div hidden id="S:0">
      <!--这里是笔记列表 SidebarNoteList 的 HTML-->
      <ul class="notes-list">
        <li>
          <div class="sidebar-note-list-item ">
            <header class="sidebar-note-header">
              <strong>ea molestias</strong>
              <small>2023-12-13 05:19:48</small>
            </header>
            <button class="sidebar-note-open" style="border:1px solid transparent">Open note for preview</button>
            <button class="sidebar-note-toggle-expand">
              <img src="/chevron-up.svg" width="10px" height="10px" alt="Expand"/>
            </button>
          </div>
        </li>
        <li>
          <div class="sidebar-note-list-item ">
            <header class="sidebar-note-header">
              <strong>qui est</strong>
              <small>2023-12-13 05:19:48</small>
            </header>
            <button class="sidebar-note-open" style="border:1px solid transparent">Open note for preview</button>
            <button class="sidebar-note-toggle-expand">
              <img src="/chevron-up.svg" width="10px" height="10px" alt="Expand"/>
            </button>
          </div>
        </li>
        <li>
          <div class="sidebar-note-list-item ">
            <header class="sidebar-note-header">
              <strong>sunt aut</strong>
              <small>2023-12-13 05:19:48</small>
            </header>
            <button class="sidebar-note-open" style="border:1px solid transparent">Open note for preview</button>
            <button class="sidebar-note-toggle-expand">
              <img src="/chevron-up.svg" width="10px" height="10px" alt="Expand"/>
            </button>
          </div>
        </li>
      </ul>
    </div>
    <script>
      $RC = function(b, c, e) {
         // ... 	
      }
      $RC("B:0", "S:0")
    </script>
  </body>
</html>

```

因为代码比较多，所以做了一点精简，你会发现在这个 HTML 里，骨架图的 HTML 和笔记列表的 HTML 都返回了，所以使用 Suspense 和 Streaming 不用担心会对 SEO 造成影响。

### 最佳实践：使用 Suspense

Suspense 的效果就是允许你推迟渲染某些内容，直到满足某些条件（例如数据加载完毕）。在开发 Next.js 项目的时候，有数据加载的地方多考虑是否可以使用 `Suspense` 或者 `loading.js`带来更好的体验。

## 总结

那么今天的内容就结束了，本篇我们完善了侧边栏笔记列表的效果，了解了在 Next.js 中使用服务端组件和客户端组件的注意事项，学习到了两个最佳实践：

1.  客户端组件下移
2.  使用 Suspense

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 Day2 分支：<https://github.com/mqyqingfeng/next-react-notes-demo/tree/day2>，直接使用的时候不要忘记在本地开启 Redis。


## 39.实战篇 | React Notes | 笔记预览界面

## 前言

本篇我们来实现右侧笔记预览部分。

## 笔记预览

当点击笔记的时候，可以查看该笔记的内容：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1376db7d8e4047c4bda9bf7c2dfca36f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2188\&h=1316\&s=237030\&e=png\&b=ffffff)

按照我们之前的设计，当点击左侧笔记列表的时候，会导航至对应的 `/note/xxxx`路由，所以我们再新建一个 `app/note/[id]/page.js`文件，代码如下：

```jsx
import Note from '@/components/Note'
import {getNote} from '@/lib/redis';

export default async function Page({ params }) {
  // 动态路由 获取笔记 id
  const noteId = params.id;
  const note = await getNote(noteId)

  // 为了让 Suspense 的效果更明显
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  await sleep(5000);

  if (note == null) {
    return (
      <div className="note--empty-state">
        <span className="note-text--empty-state">
          Click a note on the left to view something! 🥺
        </span>
      </div>
    )
  }

  return <Note noteId={noteId} note={note} />
}

```

还记得上篇总结的最佳实践吗？用到数据请求的地方，考虑一下是否需要用 `Suspense` 和 `loading.js`。这里就是一个很适合用 `loading.js` 的地方，我们再添加一个 `app/note/[id]/loading.js`文件，代码如下：

```javascript
export default function NoteSkeleton() {
  return (
    <div
      className="note skeleton-container"
      role="progressbar"
      aria-busy="true"
    >
      <div className="note-header">
        <div
          className="note-title skeleton"
          style={{ height: '3rem', width: '65%', marginInline: '12px 1em' }}
        />
        <div
          className="skeleton skeleton--button"
          style={{ width: '8em', height: '2.5em' }}
        />
      </div>
      <div className="note-preview">
        <div className="skeleton v-stack" style={{ height: '1.5em' }} />
        <div className="skeleton v-stack" style={{ height: '1.5em' }} />
        <div className="skeleton v-stack" style={{ height: '1.5em' }} />
        <div className="skeleton v-stack" style={{ height: '1.5em' }} />
        <div className="skeleton v-stack" style={{ height: '1.5em' }} />
      </div>
    </div>
  )
}
```

我们在 `page.js`中引入了` <Note>` 组件，`components/Note.js`的代码如下：

```jsx
import dayjs from 'dayjs';
import NotePreview from '@/components/NotePreview'
import EditButton from '@/components/EditButton'
export default function Note({ noteId, note }) {
  const { title, content, updateTime } = note

  return (
    <div className="note">
      <div className="note-header">
        <h1 className="note-title">{title}</h1>
        <div className="note-menu" role="menubar">
          <small className="note-updated-at" role="status">
            Last updated on {dayjs(updateTime).format('YYYY-MM-DD hh:mm:ss')}
          </small>
            <EditButton noteId={noteId}>Edit</EditButton>
        </div>
      </div>
      <NotePreview>{content}</NotePreview>
    </div>
  )
}
```

这里我们把预览的部分又单独抽离成了一个 `<NotePreview>` 组件，之所以抽离，是考虑到在编辑界面复用。`components/NotePreview.js`的代码如下：

```javascript
import {marked} from 'marked'
import sanitizeHtml from 'sanitize-html'

const allowedTags = sanitizeHtml.defaults.allowedTags.concat([
  'img',
  'h1',
  'h2',
  'h3'
])
const allowedAttributes = Object.assign(
  {},
  sanitizeHtml.defaults.allowedAttributes,
  {
    img: ['alt', 'src']
  }
)

export default function NotePreview({ children }) {
  return (
    <div className="note-preview">
      <div
        className="text-with-markdown"
        dangerouslySetInnerHTML={{
          __html: sanitizeHtml(marked(children || ''), {
            allowedTags,
            allowedAttributes
          })
        }}
      />
    </div>
  )
}

```

其中，[marked](https://www.npmjs.com/package/marked) 是一个把 markdown 转换为 HTML 的库，[sanitize-html](https://www.npmjs.com/package/sanitize-html) 用于清理 HTML，比如删除一些不良的写法，转义特殊字符等。因为用到了这两个库，我们还需要安装一下：

```bash
npm i marked sanitize-html
```

此时页面已经可以正常运行了，效果如下：

![笔记预览.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a67f7d6f5bac4059ae96c59d3689b0d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031\&h=642\&s=131947\&e=gif\&f=47\&b=f4f6f9)

## 原理解析

### RSC Payload

现在让我们多点击几次左侧的笔记列表，切换查看不同的笔记。你会发现，页面的地址虽然发生了变化，但页面并没有重新加载，但是页面的内容确实发生了变化，Next.js 是怎么实现的呢？

让我们查看下点击笔记时的请求（执行 `npm run start`时）：

![截屏2023-12-16 下午7.58.57.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e367cd4bb7b4b06a9fd94555461ac2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3610\&h=1678\&s=675860\&e=png\&b=fdfdfd)

点击笔记的时候，我们请求了对应路由的地址，比如我们点击第一篇笔记的时候，这篇笔记的 `noteId` 为 `1702459188837`，发出的请求地址就对应为 `http://localhost:3000/note/1702459188837?_rsc=9ehs5`，Chrome 标注这条请求的 Type 是 fetch，返回的数据为：

```javascript
3:I[5613,[],""]
5:I[1778,[],""]
4:["id","1702459188837","d"]
0:["S5DEOJMw4dANsj-nNd4RK",[["children","note",["note",{"children":[["id","1702459188837","d"],{"children":["__PAGE__",{}]}]}],["note",{"children":[["id","1702459188837","d"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","note","children","$4","children"],"loading":["$","div",null,{"className":"note skeleton-container","role":"progressbar","aria-busy":"true","children":[["$","div",null,{"className":"note-header","children":[["$","div",null,{"className":"note-title skeleton","style":{"height":"3rem","width":"65%","marginInline":"12px 1em"}}],["$","div",null,{"className":"skeleton skeleton--button","style":{"width":"8em","height":"2.5em"}}]]}],["$","div",null,{"className":"note-preview","children":[["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}]]}]]}],"loadingStyles":[],"loadingScripts":[],"hasLoading":true,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","note","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]],[null,"$L6"]]]]
6:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
1:null
7:I[5250,["250","static/chunks/250-3c648b94097e3c7b.js","156","static/chunks/app/note/%5Bid%5D/page-5070a024863ac55b.js"],""]
2:["$","div",null,{"className":"note","children":[["$","div",null,{"className":"note-header","children":[["$","h1",null,{"className":"note-title","children":"ea molestias"}],["$","div",null,{"className":"note-menu","role":"menubar","children":[["$","small",null,{"className":"note-updated-at","role":"status","children":["Last updated on ","2023-12-13 05:19:48"]}],["$","$L7",null,{"href":"/note/edit/1702459188837","className":"link--unstyled","children":["$","button",null,{"className":"edit-button edit-button--outline","role":"menuitem","children":"Edit"}]}]]}]]}],["$","div",null,{"className":"note-preview","children":["$","div",null,{"className":"text-with-markdown","dangerouslySetInnerHTML":{"__html":"<p>et iusto sed quo iure</p>\n"}}]}]]}]

```

注：如果你用 Chrome 查看数据的时候，发现无法加载响应数据，那换成其他浏览器如火狐试试。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e4946be63d4c19a24db13eb39ff43f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1428\&h=324\&s=31290\&e=png\&b=282828)

这个数据就被称为 `React Server Components Payload`，简称 `RSC Payload`，其实你看这个地址的参数`?rsc=xxxx`其实就暗示了它跟 RSC 相关。查看返回的数据 ，你会发现这个数据很奇怪，既不是我们常见的 HTML、XML，也不是什么其他格式，这就是 React 定义的一种特殊的格式。

还记得[《 缓存篇 | Caching》](https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-19)中讲到 RSC Payload 包含哪些信息吗：

1.  服务端组件的渲染结果
2.  客户端组件的占位位置和引用文件
3.  从服务端组件传给客户端组件的数据

比如以 `0:` 开头的那行，根据其中的内容，可以判断出渲染的是笔记加载时的骨架图。以 `2:`开头的那行，渲染的则是笔记的具体内容。

**使用这种格式的优势在于它针对流做了优化，数据是分行的，它们可以以流的形式逐行从服务端发送给客户端，客户端可以逐行解析 RSC Payload，渐进式渲染页面。**

比如客户端收到 `0:`开头的这行，于是开始渲染骨架图。收到 `7:`开头的这行，发现需要下载 `static/chunks/app/note/[id]/page-5070a024863ac55b.js`，于是开始请求该 JS 文件，查看刚才的请求，也确实请求了该文件。收到 `2:`开头的这行，于是开始渲染笔记的具体内容。

因为我们特地设置了请求时间大于 5s，所以 `2:`开头的那行数据返回的时候肯定比 `0:`晚了 `5s`以上，这条请求的时长也确实大于了 5s，这也应证了 RSC Payload 服务端是逐行返回，客户端是逐行解析、渐进式渲染的。

注：你可能发现，还有一个 404 的 RSC Payload 请求，它请求的地址是 `/note/edit/170245918883`，这是因为渲染出的 Edit 按钮用的是 Link 组件，Link 组件有预获取，所以触发了请求，但因为这个路由我们还没写，所以出现了 404 错误。其实跟本篇要讲的内容无关。

现在我们将 `http://localhost:3000/note/1702459188837?_rsc=9ehs5`这个地址在新标签页中打开，你会发现还是这个请求地址，返回的却是 HTML：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a2f596cd23a475c834da5116271c260~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3578\&h=1122\&s=553000\&e=png\&b=fdfdfd)

至于怎么实现的，想必你也想到了，两个请求虽然地址一样，但请求头不一样。这是返回 RSC Payload 的请求头：

![截屏2023-12-16 下午8.45.08.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9825f626460c464cb18f5a17dc736c6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1670\&h=1210\&s=369427\&e=png\&b=282828)

这是返回 HTML 的请求头：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee4c16e1e23b4ba8a19ffcd8249dfd31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2530\&h=948\&s=300784\&e=png\&b=292929)

那在这个 HTML 中又是怎么实现初始加载骨架图，然后 5s 后加载笔记数据的呢？

这节在上一篇已经讲过了。简单的来说，该 HTML 也是流式传输，会先后返回骨架图和笔记数据：

```html
<!DOCTYPE html>
<html lang="en">
    <body>
        <div class="container">
            <div class="main">
                <section class="col note-viewer">
                    <!-- 笔记加载时的骨架图 -->
                    <template id="B:1"></template>
                    <div class="note skeleton-container" role="progressbar" aria-busy="true">
                        <div class="note-header">
                            <div class="note-title skeleton" style="height:3rem;width:65%;margin-inline:12px 1em"></div>
                            <div class="skeleton skeleton--button" style="width:8em;height:2.5em"></div>
                        </div>
                        <div class="note-preview">
                            <div class="skeleton v-stack" style="height:1.5em"></div>
                            <div class="skeleton v-stack" style="height:1.5em"></div>
                            <div class="skeleton v-stack" style="height:1.5em"></div>
                            <div class="skeleton v-stack" style="height:1.5em"></div>
                            <div class="skeleton v-stack" style="height:1.5em"></div>
                        </div>
                    </div>
                    <!--/$-->
                </section>
            </div>
        </div>
      	// ...
        <div hidden id="S:1">
            <div class="note">
                <div class="note-header">
                    <h1 class="note-title">ea molestias</h1>
                    <div class="note-menu" role="menubar">
                        <small class="note-updated-at" role="status">Last updated on 
                        <!-- -->
                        2023-12-13 05:19:48</small>
                        <a class="link--unstyled" href="/note/edit/1702459188837">
                            <button class="edit-button edit-button--outline" role="menuitem">Edit</button>
                        </a>
                    </div>
                </div>
                <div class="note-preview">
                    <div class="text-with-markdown">
                        <p>et iusto sed quo iure</p>
                    </div>
                </div>
            </div>
        </div>
        <script>
            // 替换内容
            $RC = function(b, c, e) { // ... }
            $RC("B:1", "S:1")
        </script>
        // ...
    </body>
</html>

```

我们接着讲 RSC Payload，那客户端获取到 RSC Payload 后还干了什么呢？其实就是根据 RSC Payload 重新渲染组件树，修改 DOM。但使用 RSC Payload 的好处在于组件树中的状态依然会被保持，比如左侧笔记列表的展开和收回就是一种客户端状态，当你新增笔记、删除笔记时，虽然组件树被重新渲染，但是客户端的状态依然会继续保持了。

这也被认为是 SSR 和 RSC 的最大区别，其实现的关键就在于服务端组件没有被渲染成 HTML，而是一种特殊的格式（RSC Payload）。这里让我们再复习下 SSR（传统的 SSR，想想 Pages Router 下的 SSR 实现） 和 RSC 的区别：

1.  RSC 的代码不会发送到客户端，但传统 SSR 所有组件的代码都会被发送到客户端
2.  RSC 可以在组件树中任意位置获取后端，传统 SSR 只能在顶层（getServerSideProps）访问后端
3.  服务器组件可以重新获取，而不会丢失其树内的客户端状态

注：这里虽然比较了 SSR 和 RSC，但并不是说明两者是冲突的，其实 SSR 和 RSC 是互补关系，是可以一起使用的，Next.js 中两者就是一起使用的。

### 路由缓存

现在让我们再多点击几次左侧的笔记列表，切换查看不同的笔记，你会发现有一件奇怪的事情（这个 GIF 有 30 多秒）：

![路由缓存.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e1242d79fa149eb9dc99b75b1663b47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1031\&h=642\&s=628380\&e=gif\&f=223\&b=f3f6f9)

点击切换不同的笔记，你会发现同样一条笔记，有时会触发数据的重新请求（出现了骨架图），但有的时候又没有，但有的时候又会重新出现（又出现了骨架图），这是为什么吗？

这就是 Next.js 提供的客户端路由缓存功能，客户端会缓存 RSC Payload 数据，所以当点击笔记后很快再次点击，这时就会从缓存中获取数据，那么问题来了，缓存的失效逻辑还记得吗？具体会缓存多久呢？我们在[缓存篇](https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-20)中和大家讲过，回忆下基础知识：

路由缓存存放在浏览器的临时缓存中，有两个因素决定了路由缓存的持续时间：

*   **Session，缓存在导航期间会持续存在，当页面刷新的时候会被清除**
*   **自动失效期：单个路由段会在特定时长后自动失效，如果路由是静态渲染，持续 5 分钟，如果是动态渲染，持续 30s**

这个例子中因为我们用的是动态路由，是动态渲染，缓存持续 30s，所以首次点击笔记获取 RSC Payload 数据 30s 后再点击就会重新获取 RSC Payload。

小问题：以这个项目为例，如果点击笔记的时间算成 0s，因为请求时长大于 5s，假设 RSC Payload 在第 5s 完全返回，下次路由缓存失效重新获取的时间是大概在 30s 后还是 35s 后呢？

答案是 30s。以 RSC Payload 的返回时间为准，RSC Payload 是逐行返回的，所以点击的时候很快就有返回了。

## 总结

那么今天的内容就结束了，本篇的内容并不多，主要是通过笔记预览这个例子，在实际开发中加深对 RSC Payload 和路由缓存的理解。

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 Day3 分支：<https://github.com/mqyqingfeng/next-react-notes-demo/tree/day3>，直接使用的时候不要忘记在本地开启 Redis。


## 4.路由篇 | 链接与导航

## 前言

上篇我们介绍了如何定义路由，本篇我们讲讲如何在 Next.js 中实现链接和导航。

所谓“导航”，指的是使用 JavaScript 进行页面切换，通常会比浏览器默认的重新加载更快，因为在导航的时候，只会更新必要的组件，而不会重新加载整个页面。

在 Next.js 中，有 4 种方式可以实现路由导航：

1.  使用 `<Link>` 组件
2.  使用 `useRouter` Hook（客户端组件）
3.  使用 `redirect` 函数（服务端组件）
4.  使用浏览器原生 History API

## `<Link>`组件

Next.js 的`<Link>`组件是一个拓展了原生 HTML `<a>` 标签的内置组件，用来实现预获取（prefetching） 和客户端路由导航。这是 Next.js 中路由导航的主要和推荐方式。

#### 基础使用

基本的使用方式如下：

```javascript
import Link from 'next/link'
 
export default function Page() {
  return <Link href="/dashboard">Dashboard</Link>
}
```

#### 支持动态渲染

支持路由链接动态渲染：

```javascript
import Link from 'next/link'
 
export default function PostList({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>
          <Link href={`/blog/${post.slug}`}>{post.title}</Link>
        </li>
      ))}
    </ul>
  )
}
```

#### 获取当前路径名

如果需要对当前链接进行判断，你可以使用 [usePathname()](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-54) ，它会读取当前 URL 的路径名（pathname）。示例代码如下：

```javascript
'use client'
 
import { usePathname } from 'next/navigation'
import Link from 'next/link'

export function Navigation({ navLinks }) {
  const pathname = usePathname()
 
  return (
    <>
      {navLinks.map((link) => {
        const isActive = pathname === link.href
 
        return (
          <Link
            className={isActive ? 'text-blue' : 'text-black'}
            href={link.href}
            key={link.name}
          >
            {link.name}
          </Link>
        )
      })}
    </>
  )
}
```

#### 跳转行为设置

App Router 的默认行为是滚动到新路由的顶部，或者在前进后退导航时维持之前的滚动距离。

如果你想要禁用这个行为，你可以给 `<Link>` 组件传递一个 `scroll={false}`属性，或者在使用 `router.push`和 `router.replace`的时候，设置 `scroll: false`：

```javascript
// next/link
<Link href="/dashboard" scroll={false}>
  Dashboard
</Link>
```

```javascript
// useRouter
import { useRouter } from 'next/navigation'
 
const router = useRouter()
 
router.push('/dashboard', { scroll: false })
```

注：关于 `<Link>` 组件的具体用法，我们还会在[《组件篇 | Link 和 Script》](https://juejin.cn/book/7307859898316881957/section/7309077238333308937)中详细介绍。

## useRouter() hook

第二种方式是使用 useRouter，这是 Next.js 提供的用于更改路由的 hook。使用示例代码如下：

```javascript
'use client'
 
import { useRouter } from 'next/navigation'
 
export default function Page() {
  const router = useRouter()
 
  return (
    <button type="button" onClick={() => router.push('/dashboard')}>
      Dashboard
    </button>
  )
}
```

注意使用该 hook 需要在客户端组件中。（顶层的 `'use client'` 就是声明这是客户端组件）

注：关于 useRouter() hook 的具体用法，我们会在[《API 篇 | 常用函数与方法（上）》](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-58) 中详细介绍。

## redirect 函数

客户端组件使用 useRouter hook，服务端组件则可以直接使用 redirect 函数，这也是 Next.js 提供的 API，使用示例代码如下：

```javascript
import { redirect } from 'next/navigation'
 
async function fetchTeam(id) {
  const res = await fetch('https://...')
  if (!res.ok) return undefined
  return res.json()
}
 
export default async function Profile({ params }) {
  const team = await fetchTeam(params.id)
  if (!team) {
    redirect('/login')
  }
 
  // ...
}
```

注：关于 redirect() 函数的具体用法，我们会在[《API 篇 | 常用函数与方法（上）》](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-44) 中详细介绍。

## History API

也可以使用浏览器原生的 [window.history.pushState](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState) 和 [window.history.replaceState](https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState) 方法更新浏览器的历史记录堆栈。通常与 usePathname（获取路径名的 hook） 和 useSearchParams（获取页面参数的 hook） 一起使用。

比如用 pushState 对列表进行排序：

```javascript
'use client'
 
import { useSearchParams } from 'next/navigation'
 
export default function SortProducts() {
  const searchParams = useSearchParams()
 
  function updateSorting(sortOrder) {
    const params = new URLSearchParams(searchParams.toString())
    params.set('sort', sortOrder)
    window.history.pushState(null, '', `?${params.toString()}`)
  }
 
  return (
    <>
      <button onClick={() => updateSorting('asc')}>Sort Ascending</button>
      <button onClick={() => updateSorting('desc')}>Sort Descending</button>
    </>
  )
}
```

交互效果如下：

![history.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a3c63778eb945e4a5c3d95416b82f78~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=801\&h=395\&s=51251\&e=gif\&f=29\&b=fdfdfd)

replaceState 会替换浏览器历史堆栈的当前条目，替换后用户无法后退，比如切换应用的地域设置（国际化）：

```javascript
'use client'
 
import { usePathname } from 'next/navigation'
 
export default function LocaleSwitcher() {
  const pathname = usePathname()
 
  function switchLocale(locale) {
    // e.g. '/en/about' or '/fr/contact'
    const newPath = `/${locale}${pathname}`
    window.history.replaceState(null, '', newPath)
  }
 
  return (
    <>
      <button onClick={() => switchLocale('en')}>English</button>
      <button onClick={() => switchLocale('fr')}>French</button>
    </>
  )
}
```

## 总结

恭喜你，完成了本节内容的学习！

本篇我们介绍了 4 种实现导航的方式，但所涉及的具体概念如服务端组件、客户端组件、各种 hooks、函数方法等都未展开讲解，我们会在后续的文章中讲述。本篇可以作为概览，主要是为了方便大家写 Demo 的时候用到导航相关的内容。

## 参考链接

1.  <https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating>


## 40.实战篇 | React Notes | 笔记编辑界面

## 前言

本篇我们来实现右侧笔记编辑部分。

## 笔记编辑界面

当点击 `New` 按钮的时候进入编辑界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82008017d3144f4aaac6dc07821e69e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2936\&h=1328\&s=216062\&e=png\&b=ffffff)

当点击具体笔记的 `Edit` 按钮的时候进入该笔记的编辑页面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c9178953c194ef4938784ce2d58d184~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2938\&h=1332\&s=232949\&e=png\&b=ffffff)

回忆下之前的路由设计，当点击 `New` 的时候，导航至 `/note/edit`路由，当点击 `Edit` 的时候，导航至 `/note/edit/xxxx` 路由。

那么我们开始动手吧！

`/app/note/edit/page.js`代码如下：

```javascript
import NoteEditor from '@/components/NoteEditor'

export default async function EditPage() {
  return <NoteEditor note={null} initialTitle="Untitled" initialBody="" />
}
```

`/app/note/edit/loading.js`代码如下：

```javascript
export default function EditSkeleton() {
  return (
    <div
      className="note-editor skeleton-container"
      role="progressbar"
      aria-busy="true"
    >
      <div className="note-editor-form">
        <div className="skeleton v-stack" style={{ height: '3rem' }} />
        <div className="skeleton v-stack" style={{ height: '100%' }} />
      </div>
      <div className="note-editor-preview">
        <div className="note-editor-menu">
          <div
            className="skeleton skeleton--button"
            style={{ width: '8em', height: '2.5em' }}
          />
          <div
            className="skeleton skeleton--button"
            style={{ width: '8em', height: '2.5em', marginInline: '12px 0' }}
          />
        </div>
        <div
          className="note-title skeleton"
          style={{ height: '3rem', width: '65%', marginInline: '12px 1em' }}
        />
        <div className="note-preview">
          <div className="skeleton v-stack" style={{ height: '1.5em' }} />
          <div className="skeleton v-stack" style={{ height: '1.5em' }} />
          <div className="skeleton v-stack" style={{ height: '1.5em' }} />
          <div className="skeleton v-stack" style={{ height: '1.5em' }} />
          <div className="skeleton v-stack" style={{ height: '1.5em' }} />
        </div>
      </div>
    </div>
  )
}

```

你可能会问，同级的 `page.js` 又没有数据请求，添加 `loading.js` 有什么用？

同级的`page.js`确实没有请求，但 `loading.js`会将 `page.js` 和其 `children` 都包裹在 `<Suspense>` 中，所以 `/app/note/edit/[id]/page.js`中的请求也会触发该 `loading.js`。

`/app/note/edit/[id]/page.js`代码如下：

```javascript
import NoteEditor from '@/components/NoteEditor'
import {getNote} from '@/lib/redis';

export default async function EditPage({ params }) {
  const noteId = params.id;
  const note = await getNote(noteId)

  // 让效果更明显
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  await sleep(5000);

  if (note === null) {
    return (
      <div className="note--empty-state">
        <span className="note-text--empty-state">
          Click a note on the left to view something! 🥺
        </span>
      </div>
    )
  }

  return <NoteEditor noteId={noteId} initialTitle={note.title} initialBody={note.content} />
}

```

我们抽离了一个 `<NoteEditor>` 组件用于实现编辑功能，`/components/NoteEditor.js` 代码如下：

```jsx
'use client'

import { useState } from 'react'
import NotePreview from '@/components/NotePreview'
import { useFormStatus } from 'react-dom'

export default function NoteEditor({
  noteId,
  initialTitle,
  initialBody
}) {

  const { pending } = useFormStatus()
  const [title, setTitle] = useState(initialTitle)
  const [body, setBody] = useState(initialBody)
  const isDraft = !noteId

  return (
    <div className="note-editor">
      <form className="note-editor-form" autoComplete="off">
        <label className="offscreen" htmlFor="note-title-input">
          Enter a title for your note
        </label>
        <input
          id="note-title-input"
          type="text"
          value={title}
          onChange={(e) => {
            setTitle(e.target.value)
          }}
        />
        <label className="offscreen" htmlFor="note-body-input">
          Enter the body for your note
        </label>
        <textarea
          value={body}
          id="note-body-input"
          onChange={(e) => setBody(e.target.value)}
        />
      </form>
      <div className="note-editor-preview">
        <form className="note-editor-menu" role="menubar">
          <button
            className="note-editor-done"
            disabled={pending}
            type="submit"
            role="menuitem"
          >
            <img
              src="/checkmark.svg"
              width="14px"
              height="10px"
              alt=""
              role="presentation"
            />
            Done
          </button>
          {!isDraft && (
            <button
              className="note-editor-delete"
              disabled={pending}
              role="menuitem"
            >
              <img
                src="/cross.svg"
                width="10px"
                height="10px"
                alt=""
                role="presentation"
              />
              Delete
            </button>
          )}
        </form>
        <div className="label label--preview" role="status">
          Preview
        </div>
        <h1 className="note-title">{title}</h1>
        <NotePreview>{body}</NotePreview>
      </div>
    </div>
  )
}
```

因为需要控制输入框的状态，所以 `<NoteEditor>` 使用了客户端组件，我们在 `<NotePreview>` 中引用了 `<NotePreview>`组件，用于实现编辑时的实时预览功能。

此时编辑页面应该已经可以正常显示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebf9dbec4ee14be7a85e2a57809ad1d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2944\&h=1164\&s=230241\&e=png\&b=ffffff)

此时 `Done` 和 `Delete` 按钮还不能使用，这里我们使用 Server Actions 来实现。但实现之前，我们先看下目前的实现中一些要注意的点。

### 服务端组件和客户端组件

前面我们讲到关于服务端组件和客户端组件的使用指南，其中有一条：

> **服务端组件可以导入客户端组件，但客户端组件不能导入服务端组件**

但是这个例子中就很奇怪了。`<NoteEditor>` 是客户端组件，`<NotePreview>`是服务端组件，但我们却在 `<NoteEditor>` 中引用了 `<NotePreview>`组件，不是说不可以吗？怎么还成功渲染了！

这是一个初学者经常会遇到的误区。让我们回忆下[《渲染篇 | 服务端组件和客户端组件》](https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-19)中是如何定义客户端组件的：

我们会在文件顶部添加一个 `'use client'` 声明。但准确的说，`'use client'` 声明的是服务端和客户端组件之间的边界，这意味着，当你在文件中定义了一个 `'use client'`，导入的其他模块包括子组件，都会被视为客户端 bundle 的一部分。

**换句话说，所有组件都是服务器组件，除非它使用了 **`'use client'`** 指令，或者被导入到 **`'use client'`** 模块中。此时它们会被视为客户端组件。视为客户端组件，就意味着它的代码要被打包到客户端 bundle 中。**

比如这里的 `<NotePreview>`，它被导入到 `<NoteEditor>`这个客户端组件中，它就变成了客户端组件。变成客户端组件，意味着 `<NotePreview>`中的代码，包括用到的 `marked` 和 `sanitize-html`库也要被打包到客户端中，要知道，这两个库没压缩前可是有几百 kB 的。

所以我们才要将服务端组件通过 props 的形式传给客户端组件，当通过这种形式的时候，组件还是服务端组件，会在服务端执行渲染，代码也不会打包到客户端中。当然在这个例子中，我们就是需要在客户端渲染 markdown 文件，所以代码就是要打包到客户端中的，没有办法避免。

让我们查看下 `http://localhost:3000/note/1702459188837`此时的源代码：

![截屏2023-12-18 下午4.57.17.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a35c49c3e80844a3b3d3dca0a75f04c3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2864\&h=1368\&s=340452\&e=png\&b=fefefe)

预览的时候，我们虽然用了 `<NotePreview>` 这个组件，但是代码没有打包到客户端中。但是当我们打开 `http://localhost:3000/note/edit/1702459188837`：

![截屏2023-12-18 下午4.58.35.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34c359b68fcb40c191951848de16a26d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2860\&h=2028\&s=434270\&e=png\&b=fefefe)

你会发现，下载了客户端组件 `<NoteEditor>` 和 `<NotePreview>`，对应也使用了很多库。`page.js` 也变大了很多（424 kB）：

![截屏2023-12-18 下午5.02.22.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fa84b27070240afb30a1ae1f735fb0a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4174\&h=1284\&s=519073\&e=png\&b=fdfdfd)

最后再说说使用客户端组件时的一个注意事项，那就是不要使用 `async/await`，可能会出现报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aec6fbc3415411681f4b8dd184bc557~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1912\&h=180\&s=53835\&e=png\&b=ffffff)

## 笔记编辑和删除

当点击 `Done` 的时候，导航至对应的笔记预览页面 `/note/xxxx`。当点击 `Delete` 的时候，导航至首页。

正常开发笔记的增加、更新和删除功能，为了实现前后端交互，可能要写多个接口来实现，比如当点击删除的时候，调用删除接口，接口返回成功，前端跳转至首页。但既然我们都用了 Next.js 14 了，没必要这么麻烦，Server Actions 直接搞定，省的一个个写接口了。

修改 `/components/NoteEditor.js` 代码：

```javascript
'use client'

// ...
import { deleteNote, saveNote } from '../app/actions'

export default function NoteEditor({
  noteId,
  initialTitle,
  initialBody
}) {
	//...
  return (
    <div className="note-editor">
    	// ...
      <div className="note-editor-preview">
        <form className="note-editor-menu" role="menubar">
          <button
            className="note-editor-done"
            disabled={pending}
            type="submit"
            formAction={() => saveNote(noteId, title, body)}
            role="menuitem"
          >
            // ...
            Done
          </button>
          {!isDraft && (
            <button
              className="note-editor-delete"
              disabled={pending}
              formAction={() => deleteNote(noteId)}
              role="menuitem"
            >
              // ...
              Delete
            </button>
          )}
        </form>
      	// ...
      </div>
    </div>
  )
}

```

其中最为核心的代码就是：

```html
<form className="note-editor-menu" role="menubar">
  <button formAction={() => saveNote(noteId, title, body)}>
    Done
  </button>
  <button formAction={() => deleteNote(noteId)} >
    Delete
  </button>
</form>
```

`app/actions.js`的代码如下：

```javascript
'use server'

import { redirect } from 'next/navigation'
import {addNote, updateNote, delNote} from '@/lib/redis';

export async function saveNote(noteId, title, body) {
  
  const data = JSON.stringify({
    title,
    content: body,
    updateTime: new Date()
  })

  if (noteId) {
    updateNote(noteId, data)
    redirect(`/note/${noteId}`)
  } else {
    const res = await addNote(data)
    redirect(`/note/${res}`)
  }

}

export async function deleteNote(noteId) {
  delNote(noteId)
  redirect('/')
}
```

此时新增和删除看似可以“正常运行”了：

![添加文章.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a0645420e6d4a6884a5c07d5ea19d1e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158\&h=727\&s=114474\&e=gif\&f=33\&b=f3f5f9)

![删除文章.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1959b1e863248a9b121ff5f6d8acc0c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1158\&h=727\&s=101093\&e=gif\&f=29\&b=fefefe)

注：写这个 demo 的时候可能会遇到点了按钮没有反应，卡顿 5s 的情况，这是因为之前的 demo 里我们有在多个组件里写 sleep 5s，删除相应的代码即可。

## Server Actions

借助 Server Actions，我们很简单的就实现了笔记的新增和删除效果，但其实目前的代码中还有很多问题。

### 1. 完整路由缓存与 revalidate

比如当我们连续 2 次新增笔记时，观察左侧的笔记列表变化：

![多次新增出现问题.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87f86356225d48e7ae87830cb8189542~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1217\&h=679\&s=302944\&e=gif\&f=75\&b=f3f5f9)

笔记列表初始有 3 条，新增第 1 条笔记后，左侧的笔记列表显示 4 条，但当我们新增第 2 条笔记的时候，左侧的笔记列表又变成了 3 条，新增第 2 条笔记后，左侧的笔记列表显示 5 条。

如果你导航至首页 `/`，你会发现还是 3 条，而且哪怕你清空缓存并硬性重新加载，还是 3 条，这是为什么呢？

这就是[完整路由缓存](https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-13)。以 `/note/edit`为例，路由默认是静态渲染，也就是说，会在构建的时候，读取数据，然后将编译后的 HTML 和 RSC Payload 缓存，构建的时候，数据库里有 3 条数据，所以 HTML 中也只有 3 条数据，所以后续打开 `/note/edit`也都是 3 条数据。

还记得如何让完整路由缓存失效吗？

> 有两种方式可以使完整路由缓存失效：
>
> *   重新验证数据：重新验证数据缓存将使完整路由缓存失效，毕竟渲染输出依赖于数据
> *   重新部署：数据缓存是可以跨部署的，但完整路由缓存会在重新部署中被清除

此外，客户端路由缓存的失效也需要借助 revalidate：

> 有两种方法可以让路由缓存失效：
>
> *   在 Server Action 中：
>     *   通过 `revalidatePath` 或 `revalidateTag` 重新验证数据
>     *   使用 `cookies.set` 或者 `cookies.delete` 会使路由缓存失效
> *   调用 `router.refresh` 会使路由缓存失效并发起一个重新获取当前路由的请求

所以在进行数据处理的时候，一定要记得重新验证数据，也就是 [revalidatePath](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-12) 和 [revalidateTag](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-23)。现在我们修改下 `app/actions.js`：

```javascript
'use server'

import { redirect } from 'next/navigation'
import {addNote, updateNote, delNote} from '@/lib/redis';
import { revalidatePath } from 'next/cache';

export async function saveNote(noteId, title, body) {
  
  const data = JSON.stringify({
    title,
    content: body,
    updateTime: new Date()
  })

  if (noteId) {
    updateNote(noteId, data)
    revalidatePath('/', 'layout')
    redirect(`/note/${noteId}`)
  } else {
    const res = await addNote(data)
    revalidatePath('/', 'layout')
    redirect(`/note/${res}`)
  }

}

export async function deleteNote(noteId) {
  delNote(noteId)
  revalidatePath('/', 'layout')
  redirect('/')
}

```

这里我们简单粗暴了清除了所有缓存，此时新增、编辑、删除应该都运行正常了。

### 2. 实现原理

现在让我们来看看当我们点击 `Done` 按钮的时候做了什么？

我们先注释掉 `actions.js` 中的 `redirect`，这样当更新笔记的时候，不会发生重定向。然后我们编辑一条笔记，然后点击 `Done`，可以看到页面发送了一条 POST 请求：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c90b64cab4574e039d0217f8dd00698d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=996\&h=216\&s=33127\&e=png\&b=1a1a1c)

请求地址是当前页面，请求方法为 POST。请求内容正是我们传入的内容：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdff7b54fd374276a4506430c77bf71b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1094\&h=284\&s=46305\&e=png\&b=1a1a1c)

响应内容为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5a0c3bc78974f4d9528281d39d66927~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=844\&h=210\&s=35811\&e=png\&b=19191b)

如果我们不注释掉 `actions.js` 中的 `redirect`，然后我们编辑一条笔记，然后点击 `Done`，可以看到页面发送了一条 POST 请求：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0295a63c46c046988f6b5d7cc0c53249~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=908\&h=218\&s=32790\&e=png\&b=19191b)

因为有重定向，所以请求状态变成了 303。响应内容为：

```javascript
3:I[5613,[],""]
5:I[1778,[],""]
4:["id","1702459182837","d"]
0:["SN0qCiPbAaKKSAlQfIuYC",[[["",{"children":["note",{"children":[["id","1702459182837","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",{"children":["note",{"children":[["id","1702459182837","d"],{"children":["__PAGE__",{},["$L1","$L2",null]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","note","children","$4","children"],"loading":["$","div",null,{"className":"note skeleton-container","role":"progressbar","aria-busy":"true","children":[["$","div",null,{"className":"note-header","children":[["$","div",null,{"className":"note-title skeleton","style":{"height":"3rem","width":"65%","marginInline":"12px 1em"}}],["$","div",null,{"className":"skeleton skeleton--button","style":{"width":"8em","height":"2.5em"}}]]}],["$","div",null,{"className":"note-preview","children":[["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}],["$","div",null,{"className":"skeleton v-stack","style":{"height":"1.5em"}}]]}]]}],"loadingStyles":[],"loadingScripts":[],"hasLoading":true,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children","note","children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","styles":null}]]},[null,"$L6",null]],[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/10169c963ccea784.css","precedence":"next","crossOrigin":"$undefined"}]],"$L7"]]]]
9:I[5250,["250","static/chunks/250-3c648b94097e3c7b.js","156","static/chunks/app/note/%5Bid%5D/page-5070a024863ac55b.js"],""]
6:["$","html",null,{"lang":"en","children":["$","body",null,{"children":["$","div",null,{"className":"container","children":["$","div",null,{"className":"main","children":["$L8",["$","section",null,{"className":"col note-viewer","children":["$","$L3",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L5",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}]]}]}]}]}]
7:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
1:null
2:["$","div",null,{"className":"note","children":[["$","div",null,{"className":"note-header","children":[["$","h1",null,{"className":"note-title","children":"3qui est"}],["$","div",null,{"className":"note-menu","role":"menubar","children":[["$","small",null,{"className":"note-updated-at","role":"status","children":["Last updated on ","2023-12-19 05:33:09"]}],["$","$L9",null,{"href":"/note/edit/1702459182837","className":"link--unstyled","children":["$","button",null,{"className":"edit-button edit-button--outline","role":"menuitem","children":"Edit"}]}]]}]]}],["$","div",null,{"className":"note-preview","children":["$","div",null,{"className":"text-with-markdown","dangerouslySetInnerHTML":{"__html":"<p>est rerum tempore vitae sequi sint</p>\n"}}]}]]}]
a:"$Sreact.suspense"
8:["$","section",null,{"className":"col sidebar","children":[["$","$L9",null,{"href":"/","className":"link--unstyled","children":["$","section",null,{"className":"sidebar-header","children":[["$","img",null,{"className":"logo","src":"/logo.svg","width":"22px","height":"20px","alt":"","role":"presentation"}],["$","strong",null,{"children":"React Notes"}]]}]}],["$","section",null,{"className":"sidebar-menu","role":"menubar","children":["$","$L9",null,{"href":"/note/edit/","className":"link--unstyled","children":["$","button",null,{"className":"edit-button edit-button--solid","role":"menuitem","children":"New"}]}]}],["$","nav",null,{"children":["$","$a",null,{"fallback":["$","div",null,{"children":["$","ul",null,{"className":"notes-list skeleton-container","children":[["$","li",null,{"className":"v-stack","children":["$","div",null,{"className":"sidebar-note-list-item skeleton","style":{"height":"5em"}}]}],["$","li",null,{"className":"v-stack","children":["$","div",null,{"className":"sidebar-note-list-item skeleton","style":{"height":"5em"}}]}],["$","li",null,{"className":"v-stack","children":["$","div",null,{"className":"sidebar-note-list-item skeleton","style":{"height":"5em"}}]}]]}]}],"children":"$Lb"}]}]]}]
c:I[610,["250","static/chunks/250-3c648b94097e3c7b.js","185","static/chunks/app/layout-7bae744084688543.js"],""]
b:["$","ul",null,{"className":"notes-list","children":[["$","li","1702459182837",{"children":["$","$Lc",null,{"id":"1702459182837","title":"3qui est","expandedChildren":["$","p",null,{"className":"sidebar-note-excerpt","children":"est rerum tempore vi"}],"children":["$","header",null,{"className":"sidebar-note-header","children":[["$","strong",null,{"children":"3qui est"}],["$","small",null,{"children":"2023-12-19 05:33:09"}]]}]}]}],["$","li","1702459181837",{"children":["$","$Lc",null,{"id":"1702459181837","title":"sunt aut","expandedChildren":["$","p",null,{"className":"sidebar-note-excerpt","children":"quia et suscipit sus"}],"children":["$","header",null,{"className":"sidebar-note-header","children":[["$","strong",null,{"children":"sunt aut"}],["$","small",null,{"children":"2023-12-13 05:19:48"}]]}]}]}],["$","li","1702459188837",{"children":["$","$Lc",null,{"id":"1702459188837","title":"ea molestias","expandedChildren":["$","p",null,{"className":"sidebar-note-excerpt","children":"et iusto sed quo iur"}],"children":["$","header",null,{"className":"sidebar-note-header","children":[["$","strong",null,{"children":"ea molestias"}],["$","small",null,{"children":"2023-12-13 05:19:48"}]]}]}]}]]}]

```

此时重定向地址为 `/note/1702459182837`，从响应的内容中可以看出，其中包含了渲染后的笔记列表和此条笔记的具体内容。该内容也是流式加载的，所以内容会逐步渲染出来。比如我们把  `/note/[id]/page.js`的 `sleep` 设置为 10s，`/components/SidebarNoteList.js`的 sleep 设置为 3s，效果如下：

![ReactNotes更新流式渲染.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32e9a1987dc542a3a3fe1fe6f1e8a2c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1273\&h=673\&s=227282\&e=gif\&f=68\&b=fefefe)

点击后，左侧笔记列表 3s 后发生了变化，右侧笔记预览 10s 后发生了变化。

所以当提交表单的时候发生了什么呢？其实就是将数据以 POST 请求提交给当前页面，服务端根据 Server Actions 中的定义进行处理。Next.js 怎么实现的呢？其实就相当于替你写了原本用于交互的接口。

### 3. 渐进式增强

使用 Server Actions 的一大好处就是渐进式增强，也就是说，即便你禁用了 JavaScript，照样可以生效。现在让我们查看 `Done`和 `Delete`按钮的源码：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7499d601a5b4c0a9a0da2f9dfcfceaf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2740\&h=596\&s=305438\&e=png\&b=272727)

按钮的 `formaction` 属性变成了：

> javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you're trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"

这说明……代码写的有问题……

现在我们提交表单的代码为：

```html
<form className="note-editor-menu" role="menubar">
  <button formAction={() => saveNote(noteId, title, body)}>
    Done
  </button>
</form>
```

虽然这种写法也可以生效，但在禁用 JavaScript 的时候会失效，为了避免这个错误，最好是像下面这样写：

```html
<form className="note-editor-menu" role="menubar">
  <button formAction={saveNote}>
    Done
  </button>
</form>
```

那么 noteId 该如何传入呢？我们可以使用传统的隐藏 input：

```html
<input type="hidden" name="noteId" value={noteId} />
```

现在让我们重新写下 `components/NoteEditor.js` 的代码：

```jsx
'use client'

import { useState } from 'react'
import NotePreview from '@/components/NotePreview'
import { useFormStatus } from 'react-dom'
import { deleteNote, saveNote } from '../app/actions'

export default function NoteEditor({
  noteId,
  initialTitle,
  initialBody
}) {

  const { pending } = useFormStatus()
  const [title, setTitle] = useState(initialTitle)
  const [body, setBody] = useState(initialBody)
  const isDraft = !noteId

  return (
    <div className="note-editor">
      <form className="note-editor-form" autoComplete="off">
        <div className="note-editor-menu" role="menubar">
          <input type="hidden" name="noteId" value={noteId} />
          <button
            className="note-editor-done"
            disabled={pending}
            type="submit"
            formAction={saveNote}
            role="menuitem"
          >
            <img
              src="/checkmark.svg"
              width="14px"
              height="10px"
              alt=""
              role="presentation"
            />
            Done
          </button>
          {!isDraft && (
            <button
              className="note-editor-delete"
              disabled={pending}
              formAction={deleteNote}
              role="menuitem"
            >
              <img
                src="/cross.svg"
                width="10px"
                height="10px"
                alt=""
                role="presentation"
              />
              Delete
            </button>
          )}
        </div>
        <label className="offscreen" htmlFor="note-title-input">
          Enter a title for your note
        </label>
        <input
          id="note-title-input"
          type="text"
          name="title"
          value={title}
          onChange={(e) => {
            setTitle(e.target.value)
          }}
        />
        <label className="offscreen" htmlFor="note-body-input">
          Enter the body for your note
        </label>
        <textarea
          name="body"
          value={body}
          id="note-body-input"
          onChange={(e) => setBody(e.target.value)}
        />
      </form>
      <div className="note-editor-preview">
        <div className="label label--preview" role="status">
          Preview
        </div>
        <h1 className="note-title">{title}</h1>
        <NotePreview>{body}</NotePreview>
      </div>
    </div>
  )
}

```

`app/actions.js`的代码为：

```jsx
'use server'

import { redirect } from 'next/navigation'
import {addNote, updateNote, delNote} from '@/lib/redis';
import { revalidatePath } from 'next/cache';

export async function saveNote(formData) {

  const noteId = formData.get('noteId')

  const data = JSON.stringify({
    title: formData.get('title'),
    content: formData.get('body'),
    updateTime: new Date()
  })

  if (noteId) {
    updateNote(noteId, data)
    revalidatePath('/', 'layout')
    redirect(`/note/${noteId}`)
  } else {
    const res = await addNote(data)
    revalidatePath('/', 'layout')
    redirect(`/note/${res}`)
  }

}

export async function deleteNote(formData) {
  const noteId = formData.get('noteId')

  delNote(noteId)
  revalidatePath('/', 'layout')
  redirect('/')
}

```

此时再查看 `Done` 和 `Delete` 按钮元素：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6857c79c55a4225acec50821d46e9c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3592\&h=572\&s=297615\&e=png\&b=272727)

此时就没有刚才的错误信息了。现在让我们在开发者工具中禁用 JavaScript，你会发现表单依然能用：

![ReactNotes停用JS.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1576ca606e8940dd81e977ad10ea5c34~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1157\&h=660\&s=538328\&e=gif\&f=102\&b=fefefe)

当然在这个例子中，因为禁用了 JavaScript，所以左侧的笔记列表加载不出来，更改内容的时候右边也不会实时渲染，但至少表单提交成功了。

### 4. useFormState 与 useFormStatus

React 的 [useFormState](https://react.dev/reference/react-dom/hooks/useFormState) 和 [useFormStatus](useFormStatus) 非常适合搭配 Server Actions 使用。`useFormState` 用于根据 form action 的结果更新表单状态，`useFormStatus` 用于在提交表单时显示待处理状态。

比如使用 `useFormStatus` 实现表单提交时按钮的禁用效果：

```jsx
export default function NoteEditor() {
  const { pending } = useFormStatus()

  return (
    <button disabled={pending}> Done </button>
  )
}
```

又或者在提交的时候按钮的文字变成 `Saving`：

```javascript
export default function NoteEditor() {
  const { pending } = useFormStatus()

  return (
    <button> { pending ? 'Saving' : 'Done' } </button>
  )
}
```

注意使用 `useFormStatus` 的时候，建议将按钮抽离成单独的组件，在组件中使用 `useFormStatus`。

现在让我们修改下项目的效果，当点击 `Done` 的时候，不再重定向，而是出现 `Add Success!`提示，我们再加入 `useFormState`重写下 `components/NoteEditor.js` 的代码：

```jsx
'use client'

import { useState } from 'react'
import NotePreview from '@/components/NotePreview'
import { useFormState } from 'react-dom'
import { deleteNote, saveNote } from '../app/actions'
import SaveButton from '@/components/SaveButton'
import DeleteButton from '@/components/DeleteButton'

const initialState = {
  message: null,
}

export default function NoteEditor({
  noteId,
  initialTitle,
  initialBody
}) {

  const [saveState, saveFormAction] = useFormState(saveNote, initialState)
  const [delState, delFormAction] = useFormState(deleteNote, initialState)

  const [title, setTitle] = useState(initialTitle)
  const [body, setBody] = useState(initialBody)
  
  const isDraft = !noteId

  return (
    <div className="note-editor">
      <form className="note-editor-form" autoComplete="off">
        <div className="note-editor-menu" role="menubar">
          <input type="hidden" name="noteId" value={noteId} />
          <SaveButton formAction={saveFormAction} />
          <DeleteButton isDraft={isDraft} formAction={delFormAction} />
        </div>
        <div className="note-editor-menu">
          { saveState?.message }
        </div>
        <label className="offscreen" htmlFor="note-title-input">
          Enter a title for your note
        </label>
        <input
          id="note-title-input"
          type="text"
          name="title"
          value={title}
          onChange={(e) => {
            setTitle(e.target.value)
          }}
        />
        <label className="offscreen" htmlFor="note-body-input">
          Enter the body for your note
        </label>
        <textarea
          name="body"
          value={body}
          id="note-body-input"
          onChange={(e) => setBody(e.target.value)}
        />
      </form>
      <div className="note-editor-preview">
        <div className="label label--preview" role="status">
          Preview
        </div>
        <h1 className="note-title">{title}</h1>
        <NotePreview>{body}</NotePreview>
      </div>
    </div>
  )
}

```

我们将 Done 和 Delete 按钮抽离成了两个组件。

`components/SaveButton.js`代码如下：

```javascript
import { useFormStatus } from 'react-dom'

export default function EditButton({ formAction }) {
  const { pending } = useFormStatus()
  return (
    <button
      className="note-editor-done"
      type="submit"
      formAction={formAction}
      disabled={pending}
      role="menuitem"
    >
      <img
        src="/checkmark.svg"
        width="14px"
        height="10px"
        alt=""
        role="presentation"
      />
      {pending ? 'Saving' : 'Done'}
    </button>
  );
}
```

`components/DeleteButton.js`代码如下：

```javascript
import { useFormStatus } from 'react-dom'

export default function DeleteButton({ isDraft, formAction }) {
  const { pending } = useFormStatus()
  return !isDraft && (
      <button
        className="note-editor-delete"
        disabled={pending}
        formAction={formAction}
        role="menuitem"
      >
        <img
          src="/cross.svg"
          width="10px"
          height="10px"
          alt=""
          role="presentation"
        />
        Delete
      </button>
    )
}
```

`app/actions.js`的代码为：

```jsx
'use server'

import { redirect } from 'next/navigation'
import {addNote, updateNote, delNote} from '@/lib/redis';
import { revalidatePath } from 'next/cache';
const sleep = ms => new Promise(r => setTimeout(r, ms));

export async function saveNote(prevState, formData) {

  const noteId = formData.get('noteId')

  const data = JSON.stringify({
    title: formData.get('title'),
    content: formData.get('body'),
    updateTime: new Date()
  })

  // 为了让效果更明显
  await sleep(2000)

  if (noteId) {
    updateNote(noteId, data)
    revalidatePath('/', 'layout')
  } else {
    const res = await addNote(data)
    revalidatePath('/', 'layout')
  }
  return { message: `Add Success!` }
}

export async function deleteNote(prevState, formData) {
  const noteId = formData.get('noteId')
  delNote(noteId)
  revalidatePath('/', 'layout')
  redirect('/')
}

```

此时再点击 `Done` 按钮：

![ReactNotes-useForm.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/758a736d094747e9a0affeb44aa8067f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1157\&h=660\&s=117591\&e=gif\&f=33\&b=fefefe)
当点击 `Done` 按钮的时候，`Done` 和 `Delete` 按钮都出现了 disabled 样式（毕竟这两个按钮在一个表单内），2s 后，出现 Add Success! 提示。

### 5. 数据校验

如果需要对数据进行校验，Next.js 推荐使用 [zod](https://zod.dev/README_ZH)，我们使用  zod 修改下 `/app/actions.js`：

```javascript
'use server'

import { redirect } from 'next/navigation'
import {addNote, updateNote, delNote} from '@/lib/redis';
import { revalidatePath } from 'next/cache';
import { z } from "zod";

const schema = z.object({
  title: z.string(),
  content: z.string().min(1, '请填写内容').max(100, '字数最多 100')
});

const sleep = ms => new Promise(r => setTimeout(r, ms));

export async function saveNote(prevState, formData) {

  // 获取 noteId
  const noteId = formData.get('noteId')
  const data = {
    title: formData.get('title'),
    content: formData.get('body'),
    updateTime: new Date()
  }

  // 校验数据
  const validated = schema.safeParse(data)
  if (!validated.success) {
    return {
      errors: validated.error.issues,
    }
  }

  // 模拟请求时间
  await sleep(2000)

  // 更新数据库
  if (noteId) {
    await updateNote(noteId, JSON.stringify(data))
    revalidatePath('/', 'layout')
  } else {
    await addNote(JSON.stringify(data))
    revalidatePath('/', 'layout')
  }
  
  return { message: `Add Success!` }
}

export async function deleteNote(prevState, formData) {
  const noteId = formData.get('noteId')
  delNote(noteId)
  revalidatePath('/', 'layout')
  redirect('/')
}

```

`components/NoteEditor.js`代码如下：

```javascript
'use client'

import { useEffect, useRef, useState } from 'react'
import NotePreview from '@/components/NotePreview'
import { useFormState } from 'react-dom'
import { deleteNote, saveNote } from '../app/actions'
import SaveButton from '@/components/SaveButton'
import DeleteButton from '@/components/DeleteButton'

const initialState = {
  message: null,
}

export default function NoteEditor({
  noteId,
  initialTitle,
  initialBody
}) {

  const [saveState, saveFormAction] = useFormState(saveNote, initialState)
  const [delState, delFormAction] = useFormState(deleteNote, initialState)

  const [title, setTitle] = useState(initialTitle)
  const [body, setBody] = useState(initialBody)

  const isDraft = !noteId

  useEffect(() => {
    if (saveState.errors) {
      // 处理错误
      console.log(saveState.errors)
    }
  }, [saveState])

  return (
    <div className="note-editor">
      <form className="note-editor-form" autoComplete="off">
        <input type="hidden" name="noteId" value={noteId || ''} />
        <div className="note-editor-menu" role="menubar">
          <SaveButton formAction={saveFormAction} />
          <DeleteButton isDraft={isDraft} formAction={delFormAction} />
        </div>
        <div className="note-editor-menu">
          { saveState?.message }
          { saveState.errors && saveState.errors[0].message }
        </div>
        <label className="offscreen" htmlFor="note-title-input">
          Enter a title for your note
        </label>
        <input
          id="note-title-input"
          type="text"
          name="title"
          value={title}
          onChange={(e) => {
            setTitle(e.target.value)
          }}
        />
        <label className="offscreen" htmlFor="note-body-input">
          Enter the body for your note
        </label>
        <textarea
          name="body"
          value={body}
          id="note-body-input"
          onChange={(e) => setBody(e.target.value)}
        />
      </form>
      <div className="note-editor-preview">
        <div className="label label--preview" role="status">
          Preview
        </div>
        <h1 className="note-title">{title}</h1>
        <NotePreview>{body}</NotePreview>
      </div>
    </div>
  )
}

```

实现效果如下：

![ReactNotes-zod.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41d5ea8c54184771beafaac2f15af67f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1157\&h=672\&s=189476\&e=gif\&f=71\&b=f3f5f9)

### 6. 最佳实践：Server Actions

写 Server Actions 基本要注意的点就这些了，定义在 actions 的代码要注意：

1.  从 [formData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/FormData) 中获取提交的数据
2.  使用 [zod](https://zod.dev/README_ZH) 进行数据校验
3.  使用 [revalidate](https://juejin.cn/book/7307859898316881957/section/7309079586296791050#heading-12) 更新数据缓存
4.  返回合适的信息

定义表单的代码要注意：

1.  搭配使用 [useFormState](https://react.dev/reference/react-dom/hooks/useFormState) 和 [useFormStatus](useFormStatus)
2.  特殊数据使用隐藏 input 提交

## 总结

那么今天的内容就结束了，本篇我们完善了笔记的编辑效果，了解了客户端组件与服务端组件的划分以及在实战中使用 Server Actions，学习书写 Server Actions 时的注意事项和最佳实践。

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 Day 4 分支：<https://github.com/mqyqingfeng/next-react-notes-demo/tree/day4>，本篇的不同版本以不同的 commit 进行了提交，此外直接使用的时候不要忘记在本地开启 Redis。


## 41.实战篇 | React Notes | 笔记搜索

## 前言

本篇我们来实现 React Notes 这个 Demo 的最后一个功能——笔记的搜索功能。

## utils

目前我们在多个组件里都使用了 `sleep` 函数，用于模拟长时间请求。为了方便导入和使用，我们将其抽离到 `/lib/utils.js`代码如下：

```javascript
export const sleep = ms => new Promise(r => setTimeout(r, ms));
```

想要使用的时候直接导入即可：

```jsx
import {sleep} from '@/lib/utils'
```

## 笔记搜索

我们想要的效果是当在搜索框输入搜索文字的时候，URL 上添加对应的搜索参数，同时展示搜索后的笔记列表。当页面刷新的时候，如果有搜索参数，也会展示对应搜索后的笔记列表。效果如下：

现在让我们来实现吧。

### 搜索输入框

首先是 `components/Sidebar.js`导入搜索栏组件：

```javascript
import React, { Suspense } from 'react'
import Link from 'next/link'
// 导入组件
import SidebarSearchField from '@/components/SidebarSearchField';
import SidebarNoteList from '@/components/SidebarNoteList';
import EditButton from '@/components/EditButton';
import NoteListSkeleton from '@/components/NoteListSkeleton';

export default async function Sidebar() {
  return (
    <>
      <section className="col sidebar">
        <Link href={'/'} className="link--unstyled">
          <section className="sidebar-header">
            <img
              className="logo"
              src="/logo.svg"
              width="22px"
              height="20px"
              alt=""
              role="presentation"
            />
            <strong>React Notes</strong>
          </section>
        </Link>
        <section className="sidebar-menu" role="menubar">
          // tia
          <SidebarSearchField />
          <EditButton noteId={null}>New</EditButton>
        </section>
        <nav>
          <Suspense fallback={<NoteListSkeleton />}>
            <SidebarNoteList />
          </Suspense>
        </nav>
      </section>
    </>
  )
}
```

`components/SidebarSearchField.js`代码如下：

```jsx
'use client';

import { usePathname, useRouter } from 'next/navigation'
import { useTransition } from 'react'

function Spinner({active = true}) {
  return (
    <div
      className={['spinner', active && 'spinner--active'].join(' ')}
      role="progressbar"
      aria-busy={active ? 'true' : 'false'}
    />
  );
}

export default function SidebarSearchField() {
  const { replace } = useRouter()
  const pathname = usePathname()
  const [isPending, startTransition] = useTransition()

  function handleSearch(term) {
    const params = new URLSearchParams(window.location.search)
    if (term) {
      params.set('q', term)
    } else {
      params.delete('q')
    }

    startTransition(() => {
      replace(`${pathname}?${params.toString()}`)
    })
  }

  return (
    <div className="search" role="search">
      <label className="offscreen" htmlFor="sidebar-search-input">
        Search for a note by title
      </label>
      <input
        id="sidebar-search-input"
        placeholder="Search"
        type="text"
        onChange={(e) => handleSearch(e.target.value)}
      />
      <Spinner active={isPending} />
    </div>
  );
}
```

`<SidebarSearchField>` 是一个客户端组件，因为只有在客户端组件中才能使用 [useRouter](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-58) 和 [usePathname](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-54)。在组件中，我们使用了 React 的 [useTransition](https://react.dev/reference/react/useTransition) hook，非常适合在这种频繁非紧急的更新中使用，有效防止造成阻塞。随着用户的输入，我们会不停的 `replace` 当前的 URL，添加搜索参数。

此时效果如下：

![ReactNotes-搜索.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a46c403c924493aeef401752ac21a8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982\&h=617\&s=97973\&e=gif\&f=26\&b=f3f5f9)

### 笔记列表渲染

左侧的笔记列表需要根据网址上的搜索参数重新渲染，但其实这里并没有必要查询搜索接口，我们直接在客户端使用字符串的 [includes](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes) 方法判断即可。

#### 尝试 1

关键的问题在于获取网址参数。如果要获取参数，我们需要用到 [useSearchParams](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-68) hook，而这个 hook 需要在客户端组件中使用，我们尝试将 `SidebarNoteList` 声明为客户端组件：

```javascript
'use client'

import SidebarNoteItem from '@/components/SidebarNoteItem';
import { getAllNotes } from '@/lib/redis';
import {sleep} from '@/lib/utils'
import { useSearchParams } from 'next/navigation'

export default async function NoteList() {
  await sleep(3000);
  const notes = await getAllNotes()

  // 获取网页搜索参数
  const searchParams = useSearchParams()
  const searchText = searchParams.get('q')

  const arr = Object.entries(notes);

  if (arr.length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return <ul className="notes-list">
    {arr.map(([noteId, note]) => {
      const noteData = JSON.parse(note);
      // 判断笔记标题中是否包含搜索字符
      if (!searchText || (searchText && noteData.title.toLowerCase().includes(searchText.toLowerCase()))) {
        return <li key={noteId}>
              <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />
        </li>
      }
      return null
    })}
  </ul>
}
```

但是会报模块找不到错误：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f1c394871a24d83a0840cfabd9bdf76~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1320\&h=322\&s=66797\&e=png\&b=1f1f1f)

想想也是，毕竟我们在这个组件中用了 ioredis，原本应该在服务端运行，现在却被迫在客户端运行，可不是要罢工嘛……

#### 尝试 2

为了避免错误，我们应该再抽离一个客户端组件，数据获取依然放在 `SidebarNoteList` 中，获取参数渲染笔记列表放在子组件中，我们将该组件取名为 `SidebarNoteListFilter`。

`/components/SidebarNoteList.js`代码修改如下：

```javascript
import SidebarNoteListFilter from '@/components/SidebarNoteListFilter';
import { getAllNotes } from '@/lib/redis';
import { sleep } from '@/lib/utils'

export default async function NoteList() {
  await sleep(3000);
  const notes = await getAllNotes()

  if (Object.entries(notes).length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return <SidebarNoteListFilter notes = {notes} />
}
```

`/components/SidebarNoteListFilter.js`代码修改如下：

```javascript
'use client'

import SidebarNoteItem from '@/components/SidebarNoteItem';
import { useSearchParams } from 'next/navigation';

export default function SidebarNoteListFilter({notes}) {

  const searchParams = useSearchParams()
  const searchText = searchParams.get('q')

  return <ul className="notes-list">
    {Object.entries(notes).map(([noteId, note]) => {
      const noteData = JSON.parse(note);
      if (!searchText || (searchText && noteData.title.toLowerCase().includes(searchText.toLowerCase()))) {
        return <li key={noteId}>
              <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />
        </li>
      }
      return null
    })}
  </ul>
}
```

此时搜索功能可以正常运行了：

![ReactNotes-搜索1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e527f85bac1347bfb5e89731192d126f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982\&h=617\&s=306688\&e=gif\&f=76\&b=f3f5f9)

#### 尝试 3

搜索功能看似可以正常运行了，但是有个问题，让我们查看下此时的源代码：

![截屏2023-12-21 下午5.55.33.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8cb73005705c4abcb76493aba36ea153~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2880\&h=1212\&s=306172\&e=png\&b=f5f6f9)

你会发现，原本应该服务端渲染的 `<SidebarNoteItem>` 组件、`<SidebarNoteListHeader>` 组件此时都变成了客户端组件，而且 `<SidebarNoteListHeader>`中用到的 `dayjs` 也被打包到客户端 bundle 中。

我们在第二篇中辛辛苦苦抽离出 `SidebarNoteItemContent` 组件只为 `dayjs` 不被打包到客户端，现在因为实现搜索功能，都变成了客户端组件，功亏于溃，有什么方法可以避免 `dayjs`被打包到客户端呢？

注：其实 `dayjs`这个包并不大，打包到 bundle 中也没什么太大影响，但是想想之前的 `marked` 和 `sanitize-html`，它们却有几百 kB，这里想借这个例子来帮助大家思考如何避免不必要的代码被打包到 bundle 中。

让我们分析下问题，`dayjs` 为什么被打包到 bundle 中呢？因为 `SidebarNoteListHeader`被导入到客户端组件中，变成了客户端组件。我们其实应该通过之前讲过的 props 的形式，让 `SidebarNoteListHeader` 在服务端先渲染，然后再传给客户端组件。

惯用 React 的同学很容易想到使用 render props 的方式：

```jsx
<SidebarNoteList
  renderNoteList = {(searchText) => {
    return Object.entries(notes).map(([noteId, note]) => {
      const noteData = JSON.parse(note);
      if (!searchText || (searchText && noteData.title.toLowerCase().includes(searchText.toLowerCase()))) {
        return (
          <li key={noteId}>
            <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />
          </li>
        )
      }
      return null
    })
  }}>
</SidebarNoteList>
```

但是**从服务端组件到客户端组件传递的数据需要可序列化**，所以并不支持传入函数，使用这种方式是会报错的。

#### 尝试 4

总的解决思路还是在服务端组件中进行渲染，然后传给客户端组件。我们可以在 `SidebarNoteList.js` 中将所有的笔记列表渲染出来，然后在 `SidebarNoteListFilter.js` 中进行处理。尝试一版，修改 `/components/SidebarNoteList.js`代码如下：

```javascript
import SidebarNoteListFilter from '@/components/SidebarNoteListFilter';
import SidebarNoteItem from '@/components/SidebarNoteItem';
import { getAllNotes } from '@/lib/redis';
import { sleep } from '@/lib/utils';

export default async function NoteList() {

  await sleep(2000)
  const notes = await getAllNotes()

  if (Object.entries(notes).length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return (
    <SidebarNoteListFilter>
      {Object.entries(notes).map(([noteId, note]) => {
        return <SidebarNoteItem noteId={noteId} note={JSON.parse(note)} />
      })}
    </SidebarNoteListFilter>
  )
}
```

在这段代码中，`SidebarNoteItem` 会在服务端渲染后传给 `SidebarNoteListFilter`，因为 `SidebarNoteItem` 中引入了 `SidebarNoteItemHeader`，所以 `SidebarNoteItemHeader` 也会在服务端渲染，这样就避免了客户端打包 `dayjs`。

修改 `/components/SidebarNoteListFilter.js`代码如下：

```javascript
'use client'

import { useSearchParams } from 'next/navigation'
import { Children } from 'react';

export default function SidebarNoteList({ children }) {
  const searchParams = useSearchParams()
  const searchText = searchParams.get('q')
  return (
    <ul className="notes-list">
      {Children.map(children, (child, index) => {
        const title = child.props.title;
        if (!searchText || (searchText && title.toLowerCase().includes(searchText.toLowerCase()))) {
          return <li key={index}>{child}</li>
        }
        return null
      })}
    </ul>
  )
}

```

在这段代码中，我们使用了 React 的 `Children.map` 方法，在遍历的时候对标题进行了判断。

此时功能运行正常：

![ReactNotes-搜索2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c01ba92ffa44454f80d106df576a1bb1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=879\&h=593\&s=70424\&e=gif\&f=19\&b=f3f5f9)

客户端也不会打包 `dayjs`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a9ee9b2672f4d8cbcb3bddcc24ce608~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2522\&h=1184\&s=299642\&e=png\&b=f5f6f9)

#### 尝试 5

上面的代码还有一个小问题就是 [Children](https://react.dev/reference/react/Children) 方法过时了……

React 认为使用 Children 会削弱代码的健壮性，同时 React 也提供了[替代方案](https://react.dev/reference/react/Children#alternatives)，那就是改为接收对象数组作为 props。

想想也确实可以，如果是为了避免打包 dayjs，最核心的是将 dayjs 在服务端运行。我们在 `SidebarNoteList.js` 获取所有数据，然后把 header JSX 渲染好，再一起传给客户端组件`SidebarNoteListFilter.js`，在其中进行具体的判断处理。

修改 `/components/SidebarNoteList.js`代码如下：

```javascript
import SidebarNoteList from '@/components/SidebarNoteList';
import { getAllNotes } from '@/lib/redis';
import { sleep } from '@/lib/utils';
import SidebarNoteItemHeader from '@/components/SidebarNoteItemHeader';

export default async function NoteList() {

  await sleep(2000)
  const notes = await getAllNotes()

  if (Object.entries(notes).length == 0) {
    return <div className="notes-empty">
      {'No notes created yet!'}
    </div>
  }

  return (
    <SidebarNoteList notes = {
      Object.entries(notes).map(([noteId, note]) => {
        const noteData = JSON.parse(note)
        return {
          noteId,
          note: noteData,
          header: <SidebarNoteItemHeader title={noteData.title} updateTime={noteData.updateTime} />
        }
      })
    } />
  )
}
```

修改 `/components/SidebarNoteListFilter.js`代码如下：

```jsx
'use client'

import { useSearchParams } from 'next/navigation'
import SidebarNoteItemContent from '@/components/SidebarNoteItemContent';

export default function SidebarNoteList({ notes }) {
  const searchParams = useSearchParams()
  const searchText = searchParams.get('q')
  return (
    <ul className="notes-list">
      {notes.map(noteItem => {
        const {noteId, note, header} = noteItem;
        if (!searchText || (searchText && note.title.toLowerCase().includes(searchText.toLowerCase()))) {
          return (
            <SidebarNoteItemContent
              key={noteId}
              id={noteId}
              title={note.title}
              expandedChildren={
                <p className="sidebar-note-excerpt">
                  {note.content.substring(0, 20) || <i>(No content)</i>}
                </p>
              }>
                {header}
            </SidebarNoteItemContent>
          )
        }

        return null
      })}
    </ul>
  )
}

```

此时功能运行正常：

![ReactNotes-搜索2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9986f5f37fc54f5dbbd1252b0398fba8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=879\&h=593\&s=70424\&e=gif\&f=19\&b=f3f5f9)

客户端也不会打包 `dayjs`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b90b975193a4a48837a2e9bcd2125f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2522\&h=1184\&s=299642\&e=png\&b=f5f6f9)

## 总结

那么今天的内容就结束了，本篇的内容并不多，主要是实现搜索功能。至此，原 React Notes Demo 中的功能我们已经全部实现。

在 Next.js 中，使用 `usePathname`、`useRouter`、`useSearchParams` 等 hooks 都需要在客户端组件中，这就导致可能会打包不必要的代码到客户端 bundle 中，其解决的关键就是将组件尽可能运行在服务端，先在服务端渲染后再传给客户端组件。

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 Day 5 分支：

*   尝试 2 Demo 在 [day5](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day5) 分支
*   尝试 4 Demo 在 [day5-1](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day5-1) 分支
*   尝试 5 Demo 在 [day5-2](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day5-2) 分支

直接使用的时候不要忘记在本地开启 Redis。


## 42.实战篇 | React Notes | 国际化

## 前言

完成搜索功能后，原 React Notes Demo 的效果已经全部实现，然而这个项目才刚刚开始呢！我们会在这个笔记功能上添加各种需求，帮助大家解决实际开发中会遇到的一些问题。

现在我们的 React Notes 要走向国际化了，国际化最基本的有两件事情要做，一是路由的处理，二是文字的翻译，让我们来看看如何实现吧。

## 技术选项

Next.js 项目实现国际化，有三个目前主流的技术选型：[next-i18next](https://github.com/i18next/next-i18next)、[next-intl](https://github.com/amannn/next-intl)、[next-translate](https://github.com/aralroca/next-translate)，看下它们的 [npm trends](https://npmtrends.com/next-i18next-vs-next-intl-vs-next-translate)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/916ea891248343069ebe4db04e6bb765~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2704\&h=1542\&s=316065\&e=png\&b=fefefe)

可以看出，目前主要还是在使用 `next-i18next`。如果用的是 Pages Router，一般确实会搭配 `next-i18next`，但 Next.js v13 之后，App Router 带来了全新的开发方式，国际化的实现方式也截然不同了。

在 App Router 下，`next-i18next` 建议不需要再使用 next-i18next，直接使用 [i18next](https://github.com/i18next/i18next) 和 [react-i18next](https://github.com/i18next/react-i18next)。而 `next-intl` 和 `next-translate` 都紧跟 App Router 提出了自己的解决方案。本篇我们会讲解使用  `i18next`、`react-i18next` 和 使用 `next-intl` 两种方式。

## 第一种方式：react-i18next

### 1. 路由处理

现在让我们参照 [《路由篇 | 国际化》](https://juejin.cn/book/7307859898316881957/section/7308914342949290022)添加路由相关的代码。

在 `app`目录下添加一个名为 `[lng]` 的文件夹，将 `favicon.ico`以外的文件，移动到该文件夹下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77941656cbfb4e2cab6496b19857fe1a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1644\&h=368\&s=114831\&e=png\&b=1d1f21)

在根目录下添加一个 `config.js`文件用于自定义一些全局配置：

```javascript
export const locales = ['zh', 'en']
export const defaultLocale = 'zh'
```

在这个项目中，我们实现中文和英文两种语言，其他语言方法类似。默认是中文。

为了方便导入，我们修改根目录的 `jsconfig.json`设置路径别名：

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/actions": ["app/[lng]/actions.js"],
      "@/*": ["/*"]
    }
  }
}
```

此时如果要使用 `config.js`中的配置，只用：

```javascript
import { locales, defaultLocale } from '@/config.js'
```

在根目录下添加 `middleware.js`文件：

```javascript
// middleware.js
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'
import { locales, defaultLocale } from '@/config.js'

function getLocale(request) { 
  const headers = { 'accept-language': request.headers.get('accept-language') || '' };
  // 这里不能直接传入 request，有更简单的写法欢迎评论留言
  const languages = new Negotiator({ headers }).languages();

  return match(languages, locales, defaultLocale)
 }
 
export function middleware(request) {
  const { pathname } = request.nextUrl
  // 判断请求路径中是否已存在语言，已存在语言则跳过
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )
 
  if (pathnameHasLocale) return
 
  // 获取匹配的 locale
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // 重定向，如 /products 重定向到 /en-US/products
  return Response.redirect(request.nextUrl)
}
 
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
}

```

安装相应的库：

```bash
npm i @formatjs/intl-localematcher negotiator
```

因为移动了路径，此时可能会出现报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d35cfe077e8f4c3999885d65c6db012b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1176\&h=472\&s=121902\&e=png\&b=111111)

因为我们刚才已经顺便配置了 `actions` 的路径别名，修改 `components/NoteEditor.js`的代码为：

```javascript
// 修改前
import { deleteNote, saveNote } from '../app/actions'
// 修改后
import { deleteNote, saveNote } from '@/actions'
```

此时代码已经可以正常运行，访问 `http://localhost:3000/`会重定向到 `http://localhost:3000/zh`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f1464db3474b9895aa07b2eba5dbbb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2342\&h=1256\&s=185088\&e=png\&b=f5f6f9)

#### 1.1. 切换不同的语言

`middleware.js` 中的代码是根据浏览器的首选项设置来判断当前页面所用语言的，所以要测试不同的语言，我们在浏览器中打开 `chrome://settings/languages`，添加语言：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24fbcb954f3c43b28c1f602e45c9550b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1420\&h=578\&s=67421\&e=png\&b=27282b)

在顶部的语言即为首选语言，如果要测试英文，就将英文移动到顶部。

#### 1.2. public 图片的处理

此时我们发现，所有的图片都加载失败了。以左上角的 React 图标 `logo.svg` 为例，图片的请求地址原本为 `http://localhost:3000/logo.svg`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70d74f423c6d4db0a0bdd4552816ee5f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1560\&h=402\&s=109380\&e=png\&b=2c2c2c)

因为中间件，重定向为 `http://localhost:3000/zh/logo.svg`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65c66b476e664f10932b24ab69e55b44~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1544\&h=400\&s=109577\&e=png\&b=2b2b2b)

一种解决方法是在 `public`建立一个 `zh`文件夹，把图片都放到该文件夹下。不过这样每种语言都要建一个文件夹，图片也要重复拷贝一份，这就造成了没必要的重复。

一种解决方法是在中间件中判断，如果是 `public` 下的图片就不重定向，那怎么判断呢？

Next.js 的[官方示例代码](https://github.com/vercel/next.js/blob/canary/examples/app-dir-i18n-routing/middleware.ts)是让我们手动进行判断：

```javascript
export function middleware(request) {
  const { pathname } = request.nextUrl

  if (
    [
      '/manifest.json',
      '/favicon.ico',
      // Your other files in `public`
    ].includes(pathname)
  )
    return

  // ...
}
```

如果每张图片都要在代码中声明一遍，略微有些繁琐，也可以用正则判断来实现：

```javascript
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'
import { NextResponse } from 'next/server'
import { locales, defaultLocale } from '@/config.js'

const publicFile = /\.(.*)$/

function getLocale(request) { 
  const headers = { 'accept-language': request.headers.get('accept-language') || '' };
  // 这里不能直接传入 request，有更简单的写法欢迎评论留言
  const languages = new Negotiator({ headers }).languages();

  return match(languages, locales, defaultLocale)
 }
 
export function middleware(request) {
  const { pathname } = request.nextUrl
  // 判断请求路径中是否已存在语言，已存在语言则跳过
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )

  if (pathnameHasLocale) return

  // 如果是 public 文件，不重定向
  if (publicFile.test(pathname)) return
 
  // 获取匹配的 locale
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // 重定向，如 /products 重定向到 /en-US/products
  return Response.redirect(request.nextUrl)
}
 
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
}

```

在这段代码中，我们判断如果路径名以 `.xxx`结尾就视为在 `public` 中，因为我们常放在 `public` 下的就是各种图片文件，正好符合这种格式。

那如果个别图片就是需要根据语言自定义呢？比如《疯狂动物城》这部动漫中，电视节目主持人在不同的国家是不同的动物形象，中国是熊猫、澳大利亚是考拉、法国是驼鹿等，有的时候就是需要自定义：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5732405e3f94cdb9230e661b06f4cb6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=950&h=338&s=485476&e=png&b=f2e3dd)
我们可以建立一个特别处理的图片白名单 `excludeFile`：

```javascript
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'
import { NextResponse } from 'next/server'
import { locales, defaultLocale } from '@/config.js'

const publicFile = /\.(.*)$/
const excludeFile = ['logo.svg']

function getLocale(request) { 
  const headers = { 'accept-language': request.headers.get('accept-language') || '' };
  // 这里不能直接传入 request，有更简单的写法欢迎评论留言
  const languages = new Negotiator({ headers }).languages();

  return match(languages, locales, defaultLocale)
 }
 
export function middleware(request) {
  const { pathname } = request.nextUrl
  // 判断请求路径中是否已存在语言，已存在语言则跳过
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )

  if (pathnameHasLocale) return

  // 如果是 public 文件，不重定向
  if (publicFile.test(pathname) && excludeFile.indexOf(pathname.substr(1)) == -1) return
 
  // 获取匹配的 locale
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // 重定向，如 /products 重定向到 /en-US/products
  return Response.redirect(request.nextUrl)
}
 
export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
}

```

在这个例子中，我们将为 `logo.svg` 这张图片根据不同的语言设置不同的图片。

现在在我们 `public` 下建立一个 `en`文件夹和一个 `zh` 文件夹，然后将 `logo.svg` 复制到两个文件夹下，因为是 `svg`，所以我们可以直接编辑代码，替换其中的色值，比如 `zh` 下的 `logo.svg` 代码中的色值为 `#61dafb`（蓝色），`en` 下的 `logo.svg` 代码中的色值为 `#E53935`（红色）。

现在我们访问 `http://localhost:3000`，此时会重定向到 `http://localhost:3000/zh`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1d145d81b4f47f6b03f52e86dff3a87~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=678\&h=248\&s=27016\&e=png\&b=fefefe)

现在访问 `http://localhost:3000/en`，结果还是：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d8f1298930f44ffb44fd00c32b7ff43~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=830\&h=408\&s=44475\&e=png\&b=fefefe)

这是因为中间件中的 `getLocale` 的实现是根据浏览器的首选设置来判断的，当访问 `http://localhost:3000/logo.svg`的时候，此时会自动获取 locale，因为浏览器的首选语言设置还是中文，所以获取的结果还是 `zh`，于是重定向到 `http://localhost:3000/zh/logo.svg`。

只有在语言设置界面，将英语移动到顶部，访问 `http://localhost:3000`，重定向到 `http://localhost:3000/en`，此时才会显示红色的 logo：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcfff528b3f847b5bad083a15f1795b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=694\&h=256\&s=27816\&e=png\&b=fefefe)

#### 1.3. 默认语言不重定向

假如产品主要是在国内，少部分在国外，希望中文访问的时候，不发生重定向，该怎么实现呢？我们可以判断一下当是默认语言的时候，重定向改为重写：

```javascript
import { NextResponse } from 'next/server'

export function middleware(request) {
  // ...
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`
  // 默认语言不重定向
  if (locale == defaultLocale) {
    return NextResponse.rewrite(request.nextUrl)
  }
  // 重定向，如 /products 重定向到 /en-US/products
  return Response.redirect(request.nextUrl)
}
```

#### 1.4. 布局设置默认语言

目前我们根布局中的 `html` 的 `lang` 设置的还是 `en`，现在我们改为根据动态参数来设置 `lang` 属性：

```javascript
// app/[lng]/layout.js
import './style.css'
import Sidebar from '@/components/Sidebar'

export default async function RootLayout({
  children,
  params: {
    lng
  }
}) {

  return (
    <html lang={lng}>
      <body>
        <div className="container">
          <div className="main">
            <Sidebar />
            <section className="col note-viewer">{children}</section>
          </div>
        </div>
      </body>
    </html>
  )
}

```

除了布局，页面 `page.js` 也可以获取动态参数：

```javascript
// app/[lng]/page.js
export default async function Page({ params: { lng } }) {
  return (
    <div className="note--empty-state">
      <span className="note-text--empty-state">
        Click a {lng} note on the left to view something! 🥺
      </span>
    </div>
  )
}

```

#### 1.5. 生成静态路由

`generateStaticParams` 和动态路由一起使用，用于在构建时静态生成路由：

```javascript
// app/[lng]/layout.js
import './style.css'
import Sidebar from '@/components/Sidebar'
import { locales } from '@/config.js'

export async function generateStaticParams() {
  return locales.map((lng) => ({ lng }))
}

export default async function RootLayout({
  children,
  params: {
    lng
  }
}) {

  return (
    <html lang={lng}>
      <body>
        <div className="container">
          <div className="main">
            <Sidebar />
            <section className="col note-viewer">{children}</section>
          </div>
        </div>
      </body>
    </html>
  )
}

```

### 2. 文字的翻译

虽然文字的翻译实现，我们也可以参照 [《路由篇 | 国际化》](https://juejin.cn/book/7307859898316881957/section/7308914342949290022)中的介绍手动实现字典功能，但当项目复杂时，更适合使用 `i18next` 这样的库帮助我们开发。

#### 2.1. i18next

`i18next` 是一个用 JavaScript 编写的国际化框架，它实现的最主要的功能是字典翻译，最基本的一个例子：

```javascript
import i18next from 'i18next';

i18next.init({
  lng: 'en', 
  resources: {
    en: {
      translation: {
        "hello": "hello world"
      }
    },
    zh: {
      translation: {
        "hello": "你好"
      }
    }
  }
});

// 你好
console.log(i18next.t('hello', {lng: 'zh'}))
```

`i18next` 支持命名空间，这意味着原本需要将所有翻译内容写在一起的文件可以拆分成多个小文件，比如按页面进行拆分，基本使用方式如下：

```javascript
import i18next from 'i18next';

i18next.init({
  lng: 'en', 
  resources: {
    en: {
      translation: {
        "hello": "hello world"
      },
      profilePage: {
      	"save": "save"	
      }
    },
    zh: {
      translation: {
        "hello": "你好"
      },
      profilePage: {
        "save": "保存"
      }
    }
  }
});

// 保存
console.log(i18next.t('save', {lng: 'zh', ns: 'profilePage'}))
```

其中，`ns` 是命名空间 `namespace` 的缩写。

好了，i18next 就讲这些我们会用到的，更多内容欢迎参考 [i18next 文档](https://www.i18next.com/)。

#### 2.2. react-i18next

`react-i18next` 是 `i18next` 的一个插件，为了方便在 React 中使用。示意用法如下：

```javascript
import React from "react";
import i18n from "i18next";
import { useTranslation, initReactI18next } from "react-i18next";

i18n
  .use(initReactI18next)
  .init({
    resources: {
      en: {
        translation: {
          "Welcome to React": "Welcome to React and react-i18next"
        }
      }
    },
    lng: "en",
    fallbackLng: "en",
  });

// 使用
function App() {
  const { t } = useTranslation();
  return <h2>{t('Welcome to React')}</h2>;
}
```

此外我们还会用到：

[i18next-resources-to-backend](https://github.com/i18next/i18next-resources-to-backend)，因为将翻译内容定义在 JS 文件中并不方便，定义在多个 json 文件中更为合适，i18next-resources-to-backend 帮助我们读取 json 文件资源，生成字典。

[i18next-browser-languageDetector](https://github.com/i18next/i18next-browser-languageDetector)，在浏览器端自动检测语言

#### 2.3. 服务端组件使用

现在让我们来实现文字的翻译功能。安装会用到的库：

```bash
npm i i18next i18next-resources-to-backend react-i18next
```

创建 `app/i18n/index.js`文件，代码如下：

```javascript
import { createInstance } from 'i18next'
import resourcesToBackend from 'i18next-resources-to-backend'
import { initReactI18next } from 'react-i18next/initReactI18next'
import { locales, defaultLocale } from '@/config.js'

const initI18next = async (lng = defaultLocale, ns = 'basic') => {
  const i18nInstance = createInstance()
  await i18nInstance
    .use(initReactI18next)
    .use(resourcesToBackend((language, namespace) => import(`./locales/${language}/${namespace}.json`)))
    .init({
      // debug: true,
      supportedLngs: locales,
      fallbackLng: defaultLocale,
      lng,
      fallbackNS: 'basic',
      defaultNS: 'basic',
      ns
    })
  return i18nInstance
}

export async function useTranslation(lng, ns, options = {}) {
  const i18nextInstance = await initI18next(lng, ns)
  return {
    t: i18nextInstance.getFixedT(lng, Array.isArray(ns) ? ns[0] : ns, options.keyPrefix),
    i18n: i18nextInstance
  }
}
```

准备翻译文件：

```markdown
app                      
└─ i18n                  
   ├─ locales            
   │  ├─ en              
   │  │  └─ basic.json  
   │  └─ zh              
   │     └─ basic.json        
   └─ index.js                  
```

这里文件之所以叫 `basic.json`，是因为我们在 `init` 的时候传入的 `defaultNS` 是 `basic`，你可以随意命名，但要保持一致。

`en/basic.json`代码如下：

```javascript
{
  "new": "new",
  "initText": "Click a note on the left to view something! 🥺",
  "search": "search"
}
```

`zh/basic.json`代码如下：

```javascript
{
  "new": "新建",
  "initText": "点击左侧笔记查阅内容 🥺",
  "search": "搜索"
}
```

现在让我们开始应用，修改 `app/[lng]/page.js`：

```javascript
import { useTranslation } from "@/app/i18n/index.js"

export default async function Page({ params: { lng } }) {
  const { t } = await useTranslation(lng)
  return (
    <div className="note--empty-state">
      <span className="note-text--empty-state">
        {t('initText')}
      </span>
    </div>
  )
}

```

此时页面已经可以正常运行，访问 `http://localhost:3000/`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0043fa6cf6154c99ae8971e3b8a3c4e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2070\&h=1084\&s=164055\&e=png\&b=f5f6f9)

将首选语言设置为英文，访问 `http://localhost:3000/`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abd118bc5b354466b55727406491bbb2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2150\&h=1086\&s=175777\&e=png\&b=f5f6f9)

刚才修改的是页面，如果要修改组件中的文字怎么办？

将 `lng` 属性通过 props 传给组件即可。比如我们修改新建笔记的 `NEW` 按钮：

修改 `app/[lng]/layout.js`：

```javascript
import './style.css'
import Sidebar from '@/components/Sidebar'
import { locales } from '@/config.js'

export async function generateStaticParams() {
  return locales.map((lng) => ({ lng }))
}

export default async function RootLayout({
  children,
  params: {
    lng
  }
}) {
  return (
    <html lang={lng}>
      <body>
        <div className="container">
          <div className="main">
            <Sidebar lng={lng} />
            <section className="col note-viewer">{children}</section>
          </div>
        </div>
      </body>
    </html>
  )
}

```

修改 `/components/Sidebar.js`：

```jsx
import React, { Suspense } from 'react'
import Link from 'next/link'
import SidebarSearchField from '@/components/SidebarSearchField';
import SidebarNoteList from '@/components/SidebarNoteList';
import EditButton from '@/components/EditButton';
import NoteListSkeleton from '@/components/NoteListSkeleton';
import { useTranslation } from "@/app/i18n/index.js"

export default async function Sidebar({lng}) {
  const { t } = await useTranslation(lng)
  return (
    <>
      <section className="col sidebar">
        <Link href={'/'} className="link--unstyled">
          <section className="sidebar-header">
            <img
              className="logo"
              src="/logo.svg"
              width="22px"
              height="20px"
              alt=""
              role="presentation"
              />
            <strong>React Notes</strong>
          </section>
        </Link>
        <section className="sidebar-menu" role="menubar">
          <SidebarSearchField lng={lng} />
          <EditButton noteId={null}>{t('new')}</EditButton>
        </section>
        <nav>
          <Suspense fallback={<NoteListSkeleton />}>
            <SidebarNoteList />
          </Suspense>
        </nav>
      </section>
    </>
  )
}

```

此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dda15bbf8a84fc5a33791ee3d3306f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1974\&h=1192\&s=172209\&e=png\&b=f5f6f9)

可以看到，因为文字改为了 “新建”，导致样式发生了变化，这其实就是本地化中常遇到的问题。

一种解决方案是设计通用的样式，保持不同的文字样式一致。一种是根据不同的语言单独定义样式，比如我们可以为 button 添加一个 `edit-button-${lng}` 类名，然后设置单独的样式。又或者我们干脆改为使用更为通用的图标来实现，比如语雀的添加按钮就是一个 `+` 号：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f636b0df33b429f89539483bbb2f6eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=906\&h=100\&s=11551\&e=png\&b=f4f5f5)

这里为了简单解决这个问题，中文的时候我们不使用“新建” 这个词，而改为使用 `+`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b99b1f15b3964060ba6a1e512473b5a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2044\&h=1090\&s=161667\&e=png\&b=f5f6f9)

此外，因为在服务端组件中使用，翻译的内容会直接打包到 HTML 中，所以翻译文件并不会影响文件大小：

![截屏2023-12-29 下午5.55.49.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e45c2b75997b45f6a2d4d7e161967dc4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3664\&h=1124\&s=496499\&e=png\&b=2b2b2b)

#### 2.4. 语言切换器

现在让我们实现一个语言切换器，加深理解。

新建一个 `/components/Footer.js`，代码如下：

```javascript
import Link from 'next/link'
import { Trans } from 'react-i18next/TransWithoutContext'
import { locales } from '@/config.js'
import { useTranslation } from "@/app/i18n/index.js"

export const Footer = async ({ lng }) => {
  const { t } = await useTranslation(lng, 'footer')
  return (
    <footer style={{ margin: 20 }}>
      <Trans i18nKey="languageSwitcher" t={t}>
        Switch from <strong>{{lng}}</strong> to:{' '}
      </Trans>
      {locales.filter((l) => lng !== l).map((l, index) => {
        return (
          <span key={l}>
            {index > 0 && (' | ')}
            <Link href={`/${l}`}>
              {l}
            </Link>
          </span>
        )
      })}
    </footer>
  )
}
```

修改 `app/[lng]/layout.js`，引入该 Footer 组件：

```javascript
import './style.css'
import Sidebar from '@/components/Sidebar'
import { locales } from '@/config.js'
import { Footer } from '@/components/Footer'

export async function generateStaticParams() {
  return locales.map((lng) => ({ lng }))
}

export default async function RootLayout({
  children,
  params: {
    lng
  }
}) {
  return (
    <html lang={lng}>
      <body>
        <div className="container">
          <div className="main">
            <Sidebar lng={lng} />
            <section className="col note-viewer">{children}</section>
          </div>
          <Footer lng={lng} />
        </div>
      </body>
    </html>
  )
}

```

Footer 本身的内容需要做翻译，我们为其单独新建一个 json 翻译文件（其实也可以不建立，这里是为了演示拆分为多个 json 的场景）：

```javascript
i18n                  
├─ locales            
│  ├─ en              
│  │  ├─ basic.json   
│  │  └─ footer.json  
│  └─ zh              
│     ├─ basic.json   
│     └─ footer.json        
└─ index.js           

```

`en/basic.json`代码如下：

```javascript
{
  "languageSwitcher": "Switch from <1>{{lng}}</1> to: "
}
```

`zh/basic.json`代码如下：

```javascript
{
  "languageSwitcher": "语言从 <1>{{lng}}</1> 切换到: "
}
```

其中 `<1>{{lng}}</1>` 这样的写法看起来有些奇怪，其实都是 `react-i18next` 的用法，具体参考 [Trans 组件文档](https://react.i18next.com/latest/trans-component)。

此时效果如下：

![ReactNotes-语言切换器.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c8804eb3359417fb0ff6a1127fc3285~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=747\&h=550\&s=245828\&e=gif\&f=36\&b=f3f5f8)

#### 2.5. 客户端组件使用

如果要在客户端组件中怎么使用呢？之前讲过，客户端组件不支持 `async`，所以我们不能像在服务端组件中这样使用：

```javascript
import { useTranslation } from "@/app/i18n/index.js"

export const Footer = async ({ lng }) => {
  const { t } = await useTranslation(lng, 'footer')
  return // ...
}
```

所以我们需要一些调整，现在我们新建一个 `app/i18n/client.js`，代码如下：

```javascript
'use client'

import { useEffect, useState } from 'react'
import i18next from 'i18next'
import { initReactI18next, useTranslation as useTranslationOrg } from 'react-i18next'
import { useCookies } from 'react-cookie'
import resourcesToBackend from 'i18next-resources-to-backend'
import LanguageDetector from 'i18next-browser-languagedetector'
import { locales, defaultLocale } from '@/config.js'
export const cookieName = 'i18next'

const runsOnServerSide = typeof window === 'undefined'

i18next
  .use(initReactI18next)
  .use(LanguageDetector)
  .use(resourcesToBackend((language, namespace) => import(`./locales/${language}/${namespace}.json`)))
  .init({
    supportedLngs: locales,
    fallbackLng: defaultLocale,
    lng: defaultLocale,
    fallbackNS: 'basic',
    defaultNS: 'basic',
    ns: 'basic',
    lng: undefined,
    detection: {
      order: ['path', 'htmlTag', 'cookie', 'navigator'],
    },
    preload: runsOnServerSide ? locales : []
  })

export function useTranslation(lng, ns, options) {
  const [cookies, setCookie] = useCookies([cookieName])
  const ret = useTranslationOrg(ns, options)
  const { i18n } = ret
  if (runsOnServerSide && lng && i18n.resolvedLanguage !== lng) {
    i18n.changeLanguage(lng)
  } else {
    const [activeLng, setActiveLng] = useState(i18n.resolvedLanguage)
    useEffect(() => {
      if (activeLng === i18n.resolvedLanguage) return
      setActiveLng(i18n.resolvedLanguage)
    }, [activeLng, i18n.resolvedLanguage])
    useEffect(() => {
      if (!lng || i18n.resolvedLanguage === lng) return
      i18n.changeLanguage(lng)
    }, [lng, i18n])
    useEffect(() => {
      if (cookies.i18next === lng) return
      setCookie(cookieName, lng, { path: '/' })
    }, [lng, cookies.i18next])
  }
  return ret
}
```

安装用到的库：

```javascript
npm i react-cookie i18next-browser-languagedetector
```

现在我们修改下 `/components/SidebarSearchField.js`这个组件（这是个客户端组件）：

```javascript
'use client';

//...
import { useTranslation } from "@/app/i18n/client.js"

export default function SidebarSearchField({lng}) {
  const { t } = useTranslation(lng, 'basic')
  // ...

  return (
    <div className="search" role="search">
    	// ...
      <input
        id="sidebar-search-input"
        placeholder={t('search')}
        type="text"
      // ...
    </div>
  );
}
```

此时效果如下：

![ReactNotes-语言切换器带搜索.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c719a6d97bf4cee8155084d0ae5cb6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668\&h=607\&s=217126\&e=gif\&f=29\&b=f3f5f8)

当然在客户端组件中使用肯定是有代价的，如果不在客户端组件中使用，用到的库的代码并不会打包到客户端中：

![截屏2023-12-29 下午9.23.35.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/613423d8fadc4d57832c984e9492b6c6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2146\&h=1186\&s=247465\&e=png\&b=f4f5f8)

此时 `layout.js` 的大小为 123kB：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6743c4de32214bc983968278d8cff635~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3018\&h=1216\&s=397500\&e=png\&b=282828)

在客户端组件中使用后，用到的库会打包到客户端中：

![截屏2023-12-29 下午9.25.07.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aef324194ac4ab6af7fda9400b301ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2144\&h=1332\&s=292256\&e=png\&b=f4f5f8)

此时 `layout.js` 的大小为 229kB，整整增加了一倍：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd2c7e06fe5c44d89f6e74d1aa5c474c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3018\&h=1184\&s=413911\&e=png\&b=292929)

## 第二种方式：next-intl

用 `react-i18next` 的时候是不是感觉很繁琐？但这种方式自由度高，在理解代码的前提下，可以自由开发。当然你也可以使用 `next-intl`，配置和使用都会更便捷一些，让我们看看如何使用 `next-intl`：

### 1. 基础配置

安装 `next-intl`：

```bash
npm install next-intl
```

在 `app`目录下添加一个名为 `[locale]` 的文件夹，将 `favicon.ico`以外的文件，移动到该文件夹下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a8f40b43ef54ee78ec8c96fef15bf23~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1646\&h=414\&s=119823\&e=png\&b=1c1e20)

在根目录下添加一个 `config.js`文件用于自定义一些全局配置：

```javascript
export const locales = ['zh', 'en']
export const defaultLocale = 'zh'
```

为了方便导入，我们修改根目录的 `jsconfig.json`设置路径别名：

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/actions": ["app/[locale]/actions.js"],
      "@/*": ["/*"]
    }
  }
}
```

修改 `next.config.js`，代码如下：

```javascript
const withNextIntl = require('next-intl/plugin')();

const nextConfig = {}

module.exports = withNextIntl(nextConfig)
```

根目录下新建 `i18n.js`（该文件为约定文件名，默认需要叫这个，当然也可以修改），代码如下：

```javascript
import {notFound} from "next/navigation";
import {getRequestConfig} from 'next-intl/server';
import { locales } from '@/config.js'
 
export default getRequestConfig(async ({locale}) => {
  if (!locales.includes(locale)) notFound();
 
  return {
    messages: (await import(`./messages/${locale}.json`)).default
  };
});
```

根目录下新建 `middleware.js`，代码如下：

```javascript
import createMiddleware from 'next-intl/middleware';
import { locales, defaultLocale } from '@/config.js';

export default createMiddleware({
  locales,
  defaultLocale,
  // 默认语言不重定向
  localePrefix: 'as-needed'
});
 
export const config = {
  matcher: ['/((?!api|_next|_vercel|.*\\..*).*)']
};
```

### 2. 准备翻译文件

在根目录下新建名为 `message`的文件夹，新建 `en.json`，代码如下：

```javascript
{
  "Basic": {
    "new": "new",
    "initText": "Click a note on the left to view something! 🥺",
    "search": "search",
    "edit": "edit"
  }
}
```

新建 `zh.json`，代码如下：

```javascript
{
  "Basic": {
    "new": "+",
    "initText": "点击左侧笔记查阅内容 🥺",
    "search": "搜索",
    "edit": "编辑"
  }
}
```

### 3. 服务端组件使用

使用的时候，要注意区分是在 async 组件中还是非 async 组件中。

#### 3.1. 非 async 组件

当在非 async 组件中，以 `app/[lng]/page.js`为例：

```javascript
import {useTranslations} from 'next-intl';
export default function Page() {
  const t = useTranslations('Basic');
  return (
    <div className="note--empty-state">
      <span className="note-text--empty-state">
        {t('initText')}
      </span>
    </div>
  )
}
```

组件中也可以直接使用，以 `components/Sidebar.js`为例：

```javascript
// ...
import {useTranslations} from 'next-intl';

export default async function Sidebar() {
  const t = useTranslations('Basic');

  return (
    <>
      	// ...
        <section className="sidebar-menu" role="menubar">
          <SidebarSearchField />
          <EditButton noteId={null}>{t('new')}</EditButton>
        </section>
        // ...
      </section>
    </>
  )
}

```

#### 3.2. async 组件

如果是在 async 组件中使用，依然以 `app/[lng]/page.js`为例：

```javascript
import {getTranslations} from 'next-intl/server';

export default async function Page() {
  const t = await getTranslations('Basic');
  return (
    <div className="note--empty-state">
      <span className="note-text--empty-state">
        {t('initText')}
      </span>
    </div>
  )
}

```

在 async 组件中使用 `useTranslations` 会导致报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fe1f3ea87d24c849e663d52596b92e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1910\&h=254\&s=48039\&e=png\&b=ffffff)

### 4. 客户端组件使用

#### 4.1. 通过 props 传给客户端组件

如果要在客户端组件中使用，优先选择将翻译的内容通过 props 传给客户端组件，我们以 `/components/SidebarSearchField.js`为例：

修改 `/compoents/Sidebar.js`：

```javascript
// ...
import {useTranslations} from 'next-intl';

export default function Sidebar() {
  const t = useTranslations('Basic');
  // const messages = useMessages();
  return (
    <>
      <section className="col sidebar">
        // ...
        <section className="sidebar-menu" role="menubar">
          <SidebarSearchField search={t('search')} />
          <EditButton noteId={null}>{t('new')}</EditButton>
        </section>
        // ...
      </section>
    </>
  )
}

```

修改 `/compoents/SidebarSearchField.js`：

```javascript
'use client';

// ...
export default function SidebarSearchField({search}) {
  // ...
  return (
		<div className="search" role="search">
    	// ...
      <input
        id="sidebar-search-input"
        placeholder={search}
        type="text"
        onChange={(e) => handleSearch(e.target.value)}
      />
    </div>
  );
}
```

效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6585c1a3cca04582bc816c3b91d464d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1928\&h=1114\&s=163184\&e=png\&b=f5f6f9)

#### 4.2. 使用 NextIntlClientProvider

如果不能这样做，比如用到一些动态的值，那就需要用 `NextIntlClientProvider` 将组件包裹起来，还是以 `/components/SidebarSearchField.js`为例：

修改 `/compoents/Sidebar.js`：

```jsx
// ...
import { useTranslations, NextIntlClientProvider, useMessages} from 'next-intl';

export default function Sidebar() {
  const t = useTranslations('Basic');
  const messages = useMessages();
  return (
    <>
      <section className="col sidebar">
        // ...
        <section className="sidebar-menu" role="menubar">
          <NextIntlClientProvider
            messages={{
              Basic: messages.Basic
            }}
            >
            <SidebarSearchField />
          </NextIntlClientProvider>
          <EditButton noteId={null}>{t('new')}</EditButton>
        </section>
        // ...
      </section>
    </>
  )
}

```

修改 `/compoents/SidebarSearchField.js`：

```jsx
'use client';

// ...
import {useTranslations} from 'next-intl';

export default function SidebarSearchField() {
  const t = useTranslations('Basic');

  //...

  return (
    <div className="search" role="search">
      // ...
      <input
        id="sidebar-search-input"
        placeholder={t('search')}
        type="text"
        onChange={(e) => handleSearch(e.target.value)}
        />
      // ...
    </div>
  );
}
```

当然这样做也是有代价的，如果只是通过 props 传给客户端组件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07e1ee5f5a29438283395aef0d2548a0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3048\&h=1274\&s=320078\&e=png\&b=f4f6f9)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/854bf710976b44e384dbea593c36fcb0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3344\&h=1316\&s=414334\&e=png\&b=f3f5f8)

但改为使用 NextIntlClientProvider 后：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6051e73c43f2489e8fe777146977a7b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2848\&h=1362\&s=346660\&e=png\&b=f5f6f9)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c12ddfcd8acf45df9d5ebf99e77e9e62~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3340\&h=1328\&s=413543\&e=png\&b=f4f6f9)

由于打包到客户端的包更多了，`layout.js` 的大小从之前的 `131kB` 变成了 `239kB`。

关于 next-intl，更详细具体的用法参考其[官方文档](https://next-intl-docs.vercel.app/docs/getting-started/app-router)。

## 总结

那么今天的内容就结束了，本篇的代码已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 Day 6 分支：

*   react-i18next 实现在 [day6](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day6) 分支
*   next-intl 实现在 [day6-1](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day6-1) 分支


## 参考链接

1.  [i18next documentation](https://www.i18next.com/)
2.  [react-i18next documentation](https://react.i18next.com/)
3.  [i18n with Next.js 13/14 and app directory / App Router (an i18next guide)](https://locize.com/blog/next-app-dir-i18n/)
4.  <https://next-intl-docs.vercel.app/docs/getting-started/app-router>


## 43.实战篇 | React Notes | 文件上传

## 前言

本篇我们来实现文件上传功能。

为此我们实现这样一个需求：点击添加按钮，上传本地的 `.md`文件，读取文件内容，新建一条笔记。效果如下：

![ReactNotes-上传文件 3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3726dd4d9cf74407afc7b5f9d61facf7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074\&h=782\&s=306987\&e=gif\&f=25\&b=f3f5f9)

## 温故而知新

我们先回忆下文件上传功能，通常是用 `<input type="file">`，示例代码如下：

```html
<form method="post" enctype="multipart/form-data">
  <div>
    <label for="file">选择要上传的文件</label>
    <input type="file" id="file" name="file" multiple accept="image/*,.pdf" />
  </div>
  <div>
    <button>提交</button>
  </div>
</form>

```

其中 `<input type="file" >` 如果有附加属性 `multiple`，表示允许用户选择多个文件。如果有附加属性 `accept`表示支持的文件类型，这个例子中表示的是支持图片格式和 pdf 文件。

其中 `<form>` 添加了属性 `enctype` 用于指明提交表单的内容类型，可选的值有 3 个：

1.  `application/x-www-form-urlencoded`：所有字符在发送前都会被编码。空格会转换为“+”符号，特殊字符会转换为 ASCII 十六进制值，适用于普通的表单数据
2.  `multipart/form-data`：不对字符编码。如果表单中有上传文件，使用这个
3.  `text/plain`：发送数据时完全不进行任何编码。用的很少

因为 `<input type="file">` 默认的样式无法改变，通常会使用 `label` 标签关联，隐藏 input 标签：

```jsx
<form method="post" enctype="multipart/form-data">
  <div>
    <label for="file">Import .md File</label>
    <input type="file" id="file" name="file" multiple style={{ position : "absolute", clip: "rect(0 0 0 0)" }} />
  </div>
  <div>
    <button>提交</button>
  </div>
</form>
```

## 第一种方式：API 接口

现在让我们开始写吧！简单起见，我们的代码使用 `day5-2`分支的代码，也就是没有实现国际化之前的项目。

第一种实现方式是使用 API 接口，在客户端提交文件的时候，调用后端的接口进行处理。

实现提交文件功能，你需要监听 `<input type="file">` 的 `onChange` 事件或者是 `<button>` 的 `onClick` 事件，又或者是 `<form>` 的 `onSubmit` 事件，无论哪种，反正你需要写成客户端组件。

上传文件的入口，我们就写在笔记列表的下方：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e1ca785bcc42c7b77c25128feeff52~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1974\&h=1300\&s=173634\&e=png\&b=f5f6f9)

新建 `components/SidebarImport.js`，代码如下：

```javascript
'use client'

import React, { Suspense } from 'react'

export default function SidebarImport() {
  return (
    <form method="post" enctype="multipart/form-data">
      <div style={{ textAlign: "center" }}>
        <label for="file" style={{ cursor: 'pointer' }}>Import .md File</label>
        <input type="file" id="file" name="file" multiple style={{ position : "absolute", clip: "rect(0 0 0 0)" }} />
      </div>
    </form>
  )
}

```

在 `components/Sidebar.js`中导入该组件：

```javascript
// ...
import SidebarImport from '@/components/SidebarImport';

export default function Sidebar() {
	// ...
  return (
    <>
      <section className="col sidebar">
      	// ...
        <nav>
          <Suspense fallback={<NoteListSkeleton />}>
            <SidebarNoteList />
          </Suspense>
        </nav>
        <SidebarImport />
      </section>
    </>
  )
}

```

此时点击 `Import .md File` 已经能够正常调起文件选择框：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eb8aaa777864d03b59c6671a6400937~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1850\&h=1308\&s=427217\&e=png\&b=1f2123)

现在让我们来完善效果吧！

修改 `components/SidebarImport.js`，代码如下：

```javascript
'use client'

import React, { Suspense } from 'react'
import { useRouter } from 'next/navigation'

export default function SidebarImport() {
  const router = useRouter()

  const onChange = async (e) => {
    const fileInput = e.target;

    if (!fileInput.files || fileInput.files.length === 0) {
      console.warn("files list is empty");
      return;
    }

    const file = fileInput.files[0];

    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await fetch("/api/upload", {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        console.error("something went wrong");
        return;
      }

      const data = await response.json();
      router.push(`/note/${data.uid}`)

    } catch (error) {
      console.error("something went wrong");
    }

    // 重置 file input
    e.target.type = "text";
    e.target.type = "file";
  };


  return (
    <div style={{ textAlign: "center" }}>
      <label htmlFor="file" style={{ cursor: 'pointer' }}>Import .md File</label>
      <input type="file" id="file" name="file" style={{ position : "absolute", clip: "rect(0 0 0 0)" }} onChange={ onChange } accept=".md" />
    </div>
  )
}
```

在这段代码中，我们并没有用到 `<form>` 标签，而是直接直接监听了 `<input type="file">` 的 `onChange` 事件。当触发 onChange 事件的时候，我们构建了一个 [FormData](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData) 对象，将 [File](https://developer.mozilla.org/zh-CN/docs/Web/API/File) 对象添加进去。然后调用 `/api/upload`接口，将 formData 作为请求体传入。当数据成功返回时，跳转到生成的笔记地址。

这里的跳转我们用的是 [useRouter](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-58)。 [redirect](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-44) 只能用在服务端组件、路由处理程序、Server Actions。客户端手动跳转使用 [useRouter](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-58)。

新建 `app/api/upload/route.js`，代码如下：

```javascript
import { stat, mkdir, writeFile } from 'fs/promises'
import { join } from "path";
import { NextResponse } from 'next/server'
import { revalidatePath } from 'next/cache';
import mime from "mime";
import dayjs from 'dayjs';
import { addNote } from '@/lib/redis';

export async function POST(request) {

  // 获取 formData
  const formData = await request.formData()
  const file = formData.get('file')

  // 空值判断
  if (!file) {
    return NextResponse.json(
      { error: "File is required." },
      { status: 400 }
    );
  }

  // 写入文件
  const buffer = Buffer.from(await file.arrayBuffer());
  const relativeUploadDir = `/uploads/${dayjs().format("YY-MM-DD")}`;
  const uploadDir = join(process.cwd(), "public", relativeUploadDir);

  try {
    await stat(uploadDir);
  } catch (e) {
    if (e.code === "ENOENT") {
      await mkdir(uploadDir, { recursive: true });
    } else {
      console.error(e)
      return NextResponse.json(
        { error: "Something went wrong." },
        { status: 500 }
      );
    }
  }

  try {
    // 写入文件
    const uniqueSuffix = `${Math.random().toString(36).slice(-6)}`;
    const filename = file.name.replace(/\.[^/.]+$/, "")
    const uniqueFilename = `${filename}-${uniqueSuffix}.${mime.getExtension(file.type)}`;
    await writeFile(`${uploadDir}/${uniqueFilename}`, buffer);

    // 调用接口，写入数据库
    const res = await addNote(JSON.stringify({
      title: filename,
      content: buffer.toString('utf-8')
    }))

    // 清除缓存
    revalidatePath('/', 'layout')

    return NextResponse.json({ fileUrl: `${relativeUploadDir}/${uniqueFilename}`, uid: res });
  } catch (e) {
    console.error(e)
    return NextResponse.json(
      { error: "Something went wrong." },
      { status: 500 }
    );
  }
}
```

在这段代码中，我们使用了 [mime](https://www.npmjs.com/package/mime) 这个库，用于获取 MIME 类型信息。所谓 MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式，也就是我们常见的 `text/plain`、`image/jpeg`等。在这里我们是用它获取文件扩展名。别忘了安装这个库：

```javascript
npm i mime
```

我们通过 `await request.formData()`获取了提交的 `formData`。获取其中的 `File` 对象后，我们主要做了两件事情，一是将文件写入到 `public` 目录下，二是根据文件信息创建了笔记。最终接口返回文件地址和笔记 id。

为了方便写入，我们将其转为 Buffer 形式：`Buffer.from(await file.arrayBuffer())`，并通过 `writeFile` 写入文件。为了防止文件重复，我们根据日期创建文件夹，并生成了随机字符添加到文件名中。

然后我们通过 `buffer.toString('utf-8')` 获取了文件内容，调用之前 `redis.js` 导出的 `addNote` 方法添加笔记内容，然后清除数据缓存，返回了文件地址和笔记 ID。

现在应该可以正常运行了：

![ReactNotes-上传文件 1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83f3265e77f84784a192540006524336~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074\&h=782\&s=290182\&e=gif\&f=36\&b=f3f5f9)

虽然文件上传成功了，`public` 目录下也可以查看到这个文件，笔记也创建了，但是观察左侧的笔记列表，你会发现虽然页面跳转到对应的笔记，但是左侧的笔记列表并没有更新！

这是因为虽然我们在接口中使用了 `revalidatePath`，但是它并不能影响客户端本身的[路由缓存](https://juejin.cn/book/7307859898316881957/section/7309077169735958565#heading-18)。GitHub 上也有[讨论](https://github.com/vercel/next.js/discussions/54075)。还记得怎么清除路由缓存吗？

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dd688c7cc7c4672ad6893214f1cc348~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1552\&h=492\&s=134034\&e=png\&b=fffefe)

这里并不是在 Server Action 中，所以只能使用第二种方式，所以我们在 `router.push`后再加一句：

```javascript
router.push(`/note/${data.uid}`)
router.refresh()
```

当然也可以配合 `useTransition`使用：

```javascript
'use client'

import { useTransition } from 'react'

export default function SidebarImport() {
  const router = useRouter()
  const [isPending, startTransition] = useTransition();

  const onChange = async (e) => {
      // ...
      startTransition(() => router.push(`/note/${data.uid}`));
      startTransition(() => router.refresh());
    	// ...
  };

  return (
    	// ...
  )
}
```

现在就左侧的列表就可以正常更新了：

![ReactNotes-上传文件 2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa508ea7fb8e498da6f55612de2e6efb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074\&h=782\&s=340040\&e=gif\&f=28\&b=f3f5f9)

查看 `/api/upload` 接口的返回：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45dbe571ab7847c5ba193e829eb4e45d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1672\&h=702\&s=152298\&e=png\&b=282828)

因为我们将文件放在了 `public`下，所以直接访问 `http://localhost:3000/uploads/24-01-03/occaecati-4s2adp.md`即可查看文件内容：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3e6a3da9dcc488eaf44592073ff4b80~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1492\&h=510\&s=81079\&e=png\&b=181818)

在这个例子中，我们并没有用到这个 URL，如果在实际的开发中，你可以用这个 URL 展示缩略图等。

## 第二种方式：Server Actions

接下来我们用 Server Actions 重新实现这个需求，关于文件上传，官方也提供了[示例代码 server-actions-upload](https://github.com/vercel/next.js/tree/canary/examples/server-actions-upload) 可供参考。

一般使用 Server Actions 会用在 `<form>` 标签的 `action` 属性上，但这次我们是监听 `<input type="file">` 的 `onChange` 事件，所以我们就直接在 `onChange` 事件中调用 Server Actions，对应要使用客户端组件。

在 `components/Sidebar.js`中导入 `<SidebarImport>` 组件：

```javascript
// ...
import SidebarImport from '@/components/SidebarImport';

export default function Sidebar() {
	// ...
  return (
    <>
      <section className="col sidebar">
      	// ...
        <nav>
          <Suspense fallback={<NoteListSkeleton />}>
            <SidebarNoteList />
          </Suspense>
        </nav>
        <SidebarImport />
      </section>
    </>
  )
}

```

新建 `components/SidebarImport.js`，代码如下：

```javascript
'use client'

import React from 'react'
import { useRouter } from 'next/navigation'
import { importNote } from '@/actions'

export default function SidebarImport() {
  const router = useRouter()

  const onChange = async (e) => {
    const fileInput = e.target;

    if (!fileInput.files || fileInput.files.length === 0) {
      console.warn("files list is empty");
      return;
    }

    const file = fileInput.files[0];

    const formData = new FormData();
    formData.append("file", file);

    try {
      const data = await importNote(formData);
      router.push(`/note/${data.uid}`)

    } catch (error) {
      console.error("something went wrong");
    }

    // 重置 file input
    e.target.type = "text";
    e.target.type = "file";
  };


  return (
    <div style={{ textAlign: "center" }}>
      <label htmlFor="file" style={{ cursor: 'pointer' }}>Import .md File</label>
      <input type="file" id="file" name="file" style={{ position : "absolute", clip: "rect(0 0 0 0)" }} onChange={ onChange } accept=".md" />
    </div>
  )
}
```

为方便导入，更新 `jsconfig.json`：

```javascript
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/actions": ["app/actions.js"],
      "@/*": ["/*"]
    }
  }
}
```

在 `app/actions.js`添加 `importNote`方法：

```javascript
'use server'

// ...
import { stat, mkdir, writeFile } from 'fs/promises'
import { join } from "path";
import mime from "mime";
import dayjs from 'dayjs';

// ...
export async function importNote(formData) {
  const file = formData.get('file')

  // 空值判断
  if (!file) {
    return { error: "File is required." };
  }

  // 写入文件
  const buffer = Buffer.from(await file.arrayBuffer());
  const relativeUploadDir = `/uploads/${dayjs().format("YY-MM-DD")}`;
  const uploadDir = join(process.cwd(), "public", relativeUploadDir);

  try {
    await stat(uploadDir);
  } catch (e) {
    if (e.code === "ENOENT") {
      await mkdir(uploadDir, { recursive: true });
    } else {
      console.error(e)
      return { error: "Something went wrong." }
    }
  }

  try {
    // 写入文件
    const uniqueSuffix = `${Math.random().toString(36).slice(-6)}`;
    const filename = file.name.replace(/\.[^/.]+$/, "")
    const uniqueFilename = `${filename}-${uniqueSuffix}.${mime.getExtension(file.type)}`;
    await writeFile(`${uploadDir}/${uniqueFilename}`, buffer);

    // 调用接口，写入数据库
    const res = await addNote(JSON.stringify({
      title: filename,
      content: buffer.toString('utf-8')
    }))

    // 清除缓存
    revalidatePath('/', 'layout')

    return { fileUrl: `${relativeUploadDir}/${uniqueFilename}`, uid: res }
  } catch (e) {
    console.error(e)
    return { error: "Something went wrong." }
  }
}
```

此时页面跟第一种方式一样正常运行：

![ReactNotes-上传文件 3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2a108c3c0ed4dfaa47ba39ebc87aa8a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074\&h=782\&s=306987\&e=gif\&f=25\&b=f3f5f9)

因为在  Server Actions 中调用 revalidatePath 会清除路由缓存，所以我们也不需要再调用 `router.refresh()`。

在这个例子中，我们是在 onChange 事件中调用的 Server Action，使用这种方式对应会丢失渐进式增强，也就是说如果禁用 JS，就无法正常提交了。

如果有提交按钮，写法上会略有改变，我们试着写一下：

修改 `components/SidebarImport.js`：

```jsx
'use client'

import { useRef } from 'react'
import { useFormStatus } from 'react-dom'
import { useRouter } from 'next/navigation'
import { importNote } from '@/actions'

function Submit() {
  const { pending } = useFormStatus()
  return <button disabled={pending}>{pending ? 'Submitting' : 'Submit'}</button>
}

export default function SidebarImport() {
  const router = useRouter()
  const formRef = useRef(null)

  async function upload(formData) {

    const file = formData.get('file');
    if (!file) {
      console.warn("files list is empty");
      return;
    }

    try {
      const data = await importNote(formData);
      router.push(`/note/${data.uid}`)

    } catch (error) {
      console.error("something went wrong");
    }

    // 重置 file input
    formRef.current?.reset()
  };


  return (
    <form style={{ textAlign: "center" }} action={upload} ref={formRef}>
      <label htmlFor="file" style={{ cursor: 'pointer' }}>Import .md File</label>
      <input type="file" id="file" name="file" accept=".md" />
      <div><Submit /></div>
    </form>
  )
}
```

`actions.js`中的代码不用改，效果如下：

![ReactNotes-上传文件 4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6f8c62bcd414d4893a41f2a404b613a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1074\&h=782\&s=322492\&e=gif\&f=45\&b=f3f5f9)

## 总结

那么今天的内容就结束了，本篇主要是围绕上传文件功能，帮助大家熟悉如何处理表单中的文件数据以及如何写接口（route.js）和 Server Actions（actions.js）。在实际的开发中，上传文件往往会更复杂，比如缩略图、文件队列、进度条、大文件上传等，但也脱离不了这两种最基本的开发方式。

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 Day 7 分支：

*   第一种方式 在 [day7](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day7) 分支
*   第二种方式 在 [day7-1](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day7-1) 分支
*   第二种方式带提交按钮 在 [day7-2](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day7-2) 分支

直接使用的时候不要忘记在本地开启 Redis。

## 参考链接

1.  [\<input type=“file”\> - HTML（超文本标记语言） | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/input/file#accept)
2.  [HTMLFormElement: enctype property - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype)
3.  <https://developer.mozilla.org/zh-CN/docs/Web/API/File>
4.  [Building a File Uploader from scratch with Next.js app directory](https://codersteps.com/articles/building-a-file-uploader-from-scratch-with-next-js-app-directory)
5.  [How to upload a file in Next.js 13+ App Directory with No libraries](https://ethanmick.com/how-to-upload-a-file-in-next-js-13-app-directory/)
6.  [Next.js V13: revalidate not triggering after router.push](https://stackoverflow.com/questions/76395110/next-js-v13-revalidate-not-triggering-after-router-push)
7.  <https://github.com/vercel/next.js/discussions/54075>


## 44.实战篇 | React Notes | next-auth

## 前言

本篇我们来讲解 Authentication。先介绍下 Authentication 相关的名词：

**Authentication**：

> 身份验证（英语：Authentication）又称“认证”、“鉴权”，是指通过一定的手段，完成对用户身份的确认。

**Authorization**：

> 授权（英语：Authorization）是指根据用户提供的身份凭证，生成权限实体，并为之授予相应的权限。

**OAuth (Open Authorization)**：

> 开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。
>
> OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。

举个例子，你自己开发了一个图片网站，自己开发登陆注册功能，用户登录后展示该用户的私有图片，这是 Authentication。你使用第三方网站认证用户身份，比如谷歌登录，让第三方网站提供用户身份认证，这是“认证”服务，也是 Authentication。

而 OAuth 是第三方网站允许你直接操作它的用户数据，比如你接入谷歌相册，你不会知道用户的谷歌账号的密码，但谷歌会给你一个 token，这个 token 决定了你能拥有的权限，比如可以读取谷歌相册里的图片，同步到自己的网站中，这属于"授权"服务（Authorization）。

在 Next.js 项目中，主流的支持 App Router 的 Authentication 解决方案有：

*   [NextAuth.js](https://next-auth.js.org/configuration/nextjs#in-app-router)
*   [Clerk](https://clerk.com/docs/quickstarts/nextjs)
*   [Auth0](https://github.com/auth0/nextjs-auth0#app-router)
*   [Stytch](https://stytch.com/docs/example-apps/frontend/nextjs)
*   [Kinde](https://kinde.com/docs/developer-tools/nextjs-sdk/)

这是它们的 [npm trends](https://npmtrends.com/@auth0/nextjs-auth0-vs-@clerk/nextjs-vs-@stytch/nextjs-vs-next-auth)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57141fc0f0fd4fcb96325eae28aa6e8e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2692\&h=1778\&s=388064\&e=png\&b=fefefe)

可以看出 `next-auth` 目前是最多人的选择。

可能会有一些同学提到 [Supabase](https://supabase.com/)，Supabase 是一个开源的后端即服务（BaaS）平台，它提供了数据库、身份验证、实时数据和文件存储等功能。它可以搭配 NextAuth.js、Clerk 等使用。

## 需求

我们来实现这样一个需求：

接入 GitHub 第三方登录。页面顶部出现登录和退出登录选项，点击登录的时候，跳转 GitHub 授权登录，登录完成后显示用户名和退出登录选项，点击退出登录即退出登录。效果图如下：

![ReactNotes-Auth5.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75dd5fd116814ad18bdd3484bd9bd29c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=897\&h=747\&s=214715\&e=gif\&f=56\&b=f3f5f9)

## next-auth

借助 `next-auth`，其实代码一点也不复杂，让我们来实现吧！

### 1. GitHub 申请 OAuth 应用

在 GitHub 申请 [OAuth 应用](https://github.com/settings/applications/new)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4658f547cd0a4ef09dddd04967d5e346~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1092\&h=804\&s=125059\&e=png\&b=0e1116)

因为目前在本地开发，所以 Homepage URL 填写 `http://localhost:3000`。`Authorization callback URL`填写 `http://localhost:3000/api/auth/callback/github`，具体它的处理逻辑会由 `next-auth` 来实现。

新建后，点击 `Generate a new client secret`按钮，生成 `Client secret`，注意生成的时候， `Client secret`只能看到一次，所以需要及时保存下来，刷新了页面就查不到了。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98706b6cc0fe4df68de97a68286dddae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1582\&h=610\&s=94006\&e=png\&b=0e1116)

### 2. 设置环境变量

获取到 GitHub Client ID 和 GitHub secrets 后，为了防止信息泄露，将其放入到环境变量中。详细信息参考 《[配置篇 | 环境变量、路径别名与 src 目录》](https://juejin.cn/book/7307859898316881957/section/7309078454316564507)。

现在我们在**项目根目录**下建立一个 `.env` 文件：

```javascript
AUTH_GITHUB_ID=aac6f92981918fc75c31
AUTH_GITHUB_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxxx
AUTH_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxxx
```

注意这里的环境变量名，在 `next-auth` v4 中可以自定义，v5 改为自动推断的方式，所以约定就是使用这些名字，具体参考 [next-auth v5 文档](https://authjs.dev/reference/nextjs#environment-variable-inferrence)。

其中 `AUTH_SECRET` 是一个随机字符串，用于加密 tokens 和邮件验证哈希值，保证安全性。你可以执行：`openssl rand -base64 32` 或者打开 <https://generate-secret.vercel.app/32> 获取一个随机值。

### 3. 添加 API 路由

安装 `next-auth`：

```bash
npm install next-auth@beta
```

注意这里安装的是 `next-auth@beta`，也就是目前正在处于 beta 阶段的 `next-auth`v5，我写的时候用的具体版本是 `5.0.0-beta.4`。

根目录下新建 `auth.js`，代码如下：

```javascript
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
export const { handlers, auth, signIn, signOut } = NextAuth({ providers: [ GitHub ] })
```

为了方便导入，修改 `jsconfig.json`：

```javascript
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/actions": ["app/actions.js"],
      "@/*": ["/*"],
      "auth": ["./auth"]
    }
  }
}
```

新建 `/app/api/auth/[...nextauth]/route.js`，代码如下：

```javascript
import { handlers } from "auth"
export const { GET, POST } = handlers
```

### 4. 服务端组件获取  session

在 `app/layout.js`中引入一个 `<Header>` 组件：

```javascript
import './style.css'
import Sidebar from '@/components/Sidebar'
import Header from '@/components/Header'

export default async function RootLayout({
  children
}) {

  return (
    <html lang="en">
      <body>
        <div className="container">
          <Header />
          <div className="main">
            <Sidebar />
            <section className="col note-viewer">{children}</section>
          </div>
        </div>
      </body>
    </html>
  )
}
```

新建 `components/Header.js`，代码如下：

```jsx
import { signIn, signOut, auth } from "auth"

function SignIn({
  provider,
  ...props
}) {
  return (
    <form
      action={async () => {
        "use server"
        await signIn(provider)
      }}
    >
      <button {...props}>Sign In</button>
    </form>
  )
}

function SignOut(props) {
  return (
    <form
      action={async () => {
        "use server"
        await signOut()
      }}
    >
      <button {...props}>
        Sign Out
      </button>
    </form>
  )
}

export default async function Header() {
  const session = await auth()
  return (
    <header style={{ display: "flex", "justifyContent": "space-around" }}>
      {
        session?.user
          ? <span style={{ display: "flex", "alignItems": "center" }}>{session?.user.name}<SignOut /></span>
          : <SignIn />
      }
    </header>
  )
}
```

现在 GitHub 登陆授权就已经实现了，效果如下：

![ReactNotes-Auth5.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9ef79b76ef14b6ba0dff114a12fe6ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=897\&h=747\&s=214715\&e=gif\&f=56\&b=f3f5f9)

如果登陆的时候报如下错误：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a441d6ccd4ea45ab94df9b8dd8b6d7e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1612\&h=352\&s=84714\&e=png\&b=1e1e1e)

可能是因为网络原因，把代理设置为全局模式试试。

### 5. 原理解析

你可能会惊讶，三方登录这么简单的吗？其实还是稍微有点复杂的，只是 `next-auth` 都替你做好了而已。

当你创建了 `/app/api/auth/[...nextauth]/route.js`时，以下这些路由就都由 next-auth 创建并处理了：

*   GET/api/auth/signin
*   POST/api/auth/signin/:provider
*   GET/POST/api/auth/callback/:provider
*   GET/api/auth/signout
*   POST/api/auth/signout
*   GET/api/auth/session
*   GET/api/auth/csrf
*   GET/api/auth/providers

这些路由有的处理登录，有的是处理退出登录，有的是处理三方登录回调……有的路由你可以直接在浏览器中访问：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ff1b6f7b42b404cb391850db269824f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2416\&h=242\&s=76788\&e=png\&b=1e1e1e)

当用户点击 `SignIn` 按钮的时候，跳转到 `locahost:3000/api/auth/signin`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/298fbeb5aaa44295820ef7403ceffe98~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1872\&h=1162\&s=101823\&e=png\&b=ededed)

这个页面根据你提供的 providers 选项而生成，在这里我们只配置了 GitHub 登陆，所以显得有点简陋。但如果配置齐全的话，效果可以如下（当然具体样式也支持自定义，详细请参考文档）：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e519913905244a26b1d5de45d8dc5920~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=429\&h=430\&s=23873\&e=png\&b=fefefe)

这里我们以 GitHub 的 OAuth 为例，当我们点击 `Sign in with Github`，查看对应的元素：

![截屏2024-01-04 下午8.49.35.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dafefb97f0e142358dac5a6aa9a43d51~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2626\&h=956\&s=308067\&e=png\&b=2a2a2a)

你会发现这是一个表单提交，提交地址为 `http://localhost:3000/api/auth/signin/github`，请求方法为 POST，`next-auth` 会根据 `auth.js` 提供的选项计算 GitHub 登陆所需的值如 `client_id`（AUTH\_GITHUB\_ID）、scopes（权限范围） 等，然后拼接跳转到 `https://github.com/login`，也就是我们登录 GitHub 的页面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc4c9b8071a4a548edb93f9aa1495c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2392\&h=1434\&s=188991\&e=png\&b=0f1217)

此时的地址为：

```jsx
https://github.com/login?client_id=aac6f92981918fc75c31&return_to=%2Flogin%2Foauth%2Fauthorize%3Fclient_id%3Daac6f92981918fc75c31%26code_challenge%3DVTZmNV47SyxgplMwziDvW0kgxNwV3WsJPnlr6yf7TDI%26code_challenge_method%3DS256%26redirect_uri%3Dhttp%253A%252F%252Flocalhost%253A3000%252Fapi%252Fauth%252Fcallback%252Fgithub%26response_type%3Dcode%26scope%3Dread%253Auser%2Buser%253Aemail
```

我们解码一下：

```javascript
https://github.com/login?
client_id=aac6f92981918fc75c31
&return_to=/login/oauth/authorize?client_id=aac6f92981918fc75c31
&code_challenge=VTZmNV47SyxgplMwziDvW0kgxNwV3WsJPnlr6yf7TDI
&code_challenge_method=S256
&redirect_uri=http://localhost:3000/api/auth/callback/github&response_type=code&scope=read:user user:email
```

当我们填写密码登录后，会跳转到`github.com/login/oauth/authorize`上：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6cb208958b44531950914b9bdc30100~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2412\&h=476\&s=99347\&e=png\&b=fefefe)

当我们在 GitHub 完成授权后，GitHub 会重定向到我们之前在 OAuth App 中设置的`Authorization callback URL`也就是 `http://localhost:3000/api/auth/callback/github`，其中网址参数中会包含临时 code。临时 code 会在 10 分钟后过期。

在 `http://localhost:3000/api/auth/callback/github`这个路由下，next-auth 会获取临时 code，POST 请求 `https://github.com/login/oauth/access_token`获取 `access_token`，用此 token 可以获取用户信息，next-auth 会生成 session token 并且存储 session。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ef6eca8fc22484792e8d3a4852f8267~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3036\&h=1298\&s=440895\&e=png\&b=fefefe)

这一切本来需要由开发者自己开发，但借助 `next-auth`，几乎不用写多少代码就全部实现了。

### 6. 客户端组件获取  session

现在让我们回归到 `next-auth` 的具体用法，如果是客户端组件需要获取 session 数据，该怎么实现呢？

为了演示用法，我们新建一个 `/client`路由，并在 `<Header>` 组件中添加链接，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16814cd8beb04284b499ff14e6a162b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2044\&h=1372\&s=210144\&e=png\&b=f5f6f9)

修改 `components/Header.js`，代码如下：

```javascript
import { signIn, signOut } from "auth"
import { auth } from "auth"
import Link from 'next/link'

function SignIn({
  provider,
  ...props
}) {
  return (
    <form
      action={async () => {
        "use server"
        await signIn(provider)
      }}
    >
      <button {...props}>Sign In</button>
    </form>
  )
}

function SignOut(props) {
  return (
    <form
      action={async () => {
        "use server"
        await signOut()
      }}
    >
      <button {...props}>
        Sign Out
      </button>
    </form>
  )
}

export default async function Header() {
  const session = await auth()
  return (
    <header style={{display: "flex", "justifyContent": "space-around"}}>
        <Link href="/client">Client Side Component</Link>
        {
          !session?.user ? <SignIn /> : <span style={{display: "flex", "alignItems": "center"}}>{session?.user.name}   <SignOut /></span>
        }
    </header>
  )
}
```

此时页面样式如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c610fa7f48264e2a85026a1790f673d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2044\&h=1372\&s=210144\&e=png\&b=f5f6f9)

新建 `app/client/page.js`，代码如下：

```javascript
import { auth } from "auth"
import ClientComponent from "@/components/ClientComponent"
import { SessionProvider } from "next-auth/react"

export default async function ClientPage() {
  const session = await auth()
  if (session?.user) {
    // 选择需要的信息传给客户端，避免敏感信息泄露
    session.user = {
      name: session.user.name,
      email: session.user.email,
      image: session.user.image,
    }
  }

  return (
    <SessionProvider session={session}>
      <ClientComponent />
    </SessionProvider>
  )
}
```

新建 `components/ClientComponent.js`，代码如下：

```javascript
"use client"

import { useSession } from "next-auth/react"

export default function ClientExample() {
  const { data: session, status } = useSession()
  return (
    <div>
      {status === "loading" ? (
        <div>Loading...</div>
      ) : <pre>{JSON.stringify(session, null, 2)}</pre>}
    </div>
  )
}
```

此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88af6a46afa54b8bb0577458dbe65ef0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1976\&h=1324\&s=231372\&e=png\&b=f3f4f7)

### 7. 保护部分页面

如果部分页面需要登录状态才能访问该怎么办呢？比如这个笔记系统谁都可以查看，但要想编辑，就需要先登录，该怎么实现呢？

你可以使用中间件，新建 `middleware.js`，代码如下：

```javascript
export { auth as middleware } from "auth"

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
}
```

核心的判断逻辑在 `auth.js`中，使用 [callbacks.authorized](https://authjs.dev/reference/nextjs#authorized) 回调函数：

```javascript
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
export const { handlers, auth, signIn, signOut } = NextAuth({ providers: [ GitHub ],
  callbacks: {
    authorized({ request, auth }) {
      const { pathname } = request.nextUrl
      if (pathname.startsWith("/note/edit")) return !!auth
      return true
    },
  }
})
```

在中间件中，我们判断路由地址，如果以 `/note/edit` 开头，就判断 auth 是否存在，如果返回 true，则正常跳转，如果返回 false，则自动会重定向到登录页面，效果如下：

![ReactNotes-Auth6.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d75ebefcccb245e2a52c33d3015ca04a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1216\&h=803\&s=354463\&e=gif\&f=55\&b=fefefe)

如果不通过中间件，也可以直接在页面或组件中进行判断。比如如果是服务端组件，可以像现在的例子中那样，通过对 `auth()`返回的 session 进行判断，根据 `session.user` 是否存在来区分登录和未登录状态。如果是在客户端组件，可以通过 `useSession()` 返回的 `status` 来判断，比如修改 `components/Header.js`代码如下：

```javascript
"use client"

import { useSession } from "next-auth/react"

export default function Page() {
  const { data: session, status } = useSession()

  if (status === "loading") {
    return <p>Loading...</p>
  }

  if (status === "unauthenticated") {
    return <p>Access Denied</p>
  }

  return (
    <pre>{JSON.stringify(session, null, 2)}</pre>
  )
}
```

### 8. 自定义登陆逻辑

现在我不想要三方登录，我想要自己实现登陆页面行不行，`next-auth` 也可以帮助你实现！这就是 [Credentials Provider](https://authjs.dev/guides/providers/credentials)。

为了模拟用户注册和登录，我们在 `lib/redis.js` 中新增一个 `addUser` 和 `getUser` 方法：

```javascript
export async function addUser(username, password) {
  await redis.hset("users", [username], password);
  return {
    name: username,
    username
  }
}

export async function getUser(username, password) {
  const passwordFromDB = await redis.hget("users", username);
  if (!passwordFromDB) return 0;
  if (passwordFromDB !== password) return 1
  return {
    name: username,
    username
  } 
}
```

现在修改 `auth.js`，代码如下：

```javascript
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
import CredentialsProvider from "next-auth/providers/credentials";
import { addUser, getUser } from "@/lib/redis";

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers:
    [CredentialsProvider({
      // 显示按钮文案 (e.g. "Sign in with...")
      name: "密码登录",
      // `credentials` 用于渲染登录页面表单
      credentials: {
        username: { label: "邮箱", type: "text", placeholder: "输入您的邮箱" },
        password: { label: "密码", type: "password", placeholder: "输入您的密码" }
      },
      // 处理从用户收到的认证信息
      async authorize(credentials, req) {
        // 默认情况下不对用户输入进行验证，确保使用 Zod 这样的库进行验证
        let user = null

        // 登陆信息验证
        user = await getUser(credentials.username, credentials.password)

        // 密码错误
        if (user === 1) return null

        // 用户注册
        if (user === 0) {
          user = await addUser(credentials.username, credentials.password)
        }

        if (!user) {
          throw new Error("User was not found and could not be created.")
        }

        return user
      }
    }), GitHub],
  callbacks: {
    authorized({ request, auth }) {
      const { pathname } = request.nextUrl
      if (pathname.startsWith("/note/edit")) return !!auth
      return true
    },
  }
})
```

此时效果如下：

![ReactNotes-Auth7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fc2afefd104b938e097cbc8f102159~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1216\&h=803\&s=285245\&e=gif\&f=75\&b=f5f7fb)

`next-auth` 根据我们传入的 `credentials` 选项渲染登录页面，并且使用 `authorize` 函数处理登录逻辑。在这个例子中，如果用户不存在，就注册一个用户，如果用户名不正确，则提示错误。

注意：写这个例子的时候要删除 `middleware.js`，这是因为我们在代码中使用了 ioredis，ioredis 需要运行在 Nodejs Runtime，而 next.js 的 middleware 目前只能运行在 Edge Runtime。

### 9. 自定义登陆页面

如果项目用在国外，都是英文倒也可以接受，但如果用在国内，这种“Sign in With 密码登录”的文案可真让人想吐槽，我如果要完全自定义登陆页面呢？next-auth 提供了 [pages 选项](https://authjs.dev/guides/basics/pages)，修改 `auth.js`：

```javascript
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
import CredentialsProvider from "next-auth/providers/credentials";
import { addUser, getUser } from "@/lib/redis";

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers:
    [// ...],
  pages: {
    signIn: '/auth/signin'
  },
  callbacks: {
    authorized({ request, auth }) {
      const { pathname } = request.nextUrl
      if (pathname.startsWith("/note/edit")) return !!auth
      return true
    },
  }
})
```

新建 `app/auth/signin/page.js`，代码如下：

```javascript
'use client'

export default async function SignIn() {
  const response = await fetch('http://localhost:3000/api/auth/csrf');
  const {csrfToken} = await response.json()
  return (
    <form method="post" action="/api/auth/callback/credentials">
      <input type="hidden" name="csrfToken" value={csrfToken} />
      <label>
        Username
        <input name="username" type="text" />
      </label>
      <label>
        Password
        <input name="password" type="password" />
      </label>
      <button type="submit">Sign in</button>
    </form>
  )
}
```

此时效果如下：

![ReactNotes-Auth8.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e9a0bee9e624fcfa7063eb06e7f186c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1081\&h=822\&s=120592\&e=gif\&f=45\&b=f3f5f9)

## 总结

那么今天的内容就结束了，本篇实现了 GitHub 授权登录和自定义登陆功能。这里用的是正处于 beta 阶段的 next-auth v5，v5 目前还有一些问题没有解决，文档也略显草率。实际项目开发的时候，还是推荐使用稳定版本的 v4。此外，Clerk 和 Supabase 也都是不错的选择，推荐使用。

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 [Day 8](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day8) 分支。直接使用的时候不要忘记在本地开启 Redis。

## 参考链接

1.  [OAuth authentication | Auth.js](https://authjs.dev/getting-started/providers/oauth-tutorial)
2.  <https://docs.github.com/zh/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps>


## 45.实战篇 | React Notes | Strapi

## 前言

先说说 CMS，所谓 CMS，Content Management System，中文译为内容管理系统。

> 内容管理系统的定义可以很狭窄，通常是指门户或商业网站的发布和管理系统；定义也可以很宽泛，个人网站系统也可归入其中。Wiki 也是一种内容管理系统，Blog 也算是一种内容管理系统。

比如常用于搭建博客的 Wordpress 就是一个知名的内容管理系统。

这些年来，headless CMS 也流行了起来。所谓 headless CMS，简单的来说，CMS 不再负责内容的展现，只提供内容存储库以及 API，这使得开发人员可以自定义展示内容，虽然带来了一定的工作量，但也让开发更加灵活自由。

今天要讲的 [Strapi](https://strapi.io/) 就是基于 Node.js 实现的 Headless CMS。借助 Strapi，不需要手动编写后端接口，通过可视化的界面就能直接创建  Restful API。

在实际开发项目的时候，这样做的好处就是 —— 快！而在那么多 Headless CMS 中选择 Strapi，是因为它应该是 [GitHub 上 star 最多](https://github.com/strapi/strapi)（58k）的 Headless CMS，用的人也比较多。

对于一些简单的项目，相比于从零开始搭建，不如直接使用像 Strapi 这样的工具，快速构建出项目！

## Strapi

现在让我们来使用 Strapi，执行以下命令构建本地项目：

```javascript
npx create-strapi-app@latest next-react-notes-strapi
```

### 1. 数据库选择

Strapi 会让你进行一些自定义选择，比如数据库，Strapi 支持的数据库有：

| 数据库        | 最小版本  | 推荐版本 |
| ---------- | ----- | ---- |
| MySQL      | 5.7.8 | 8.0  |
| MariaDB    | 10.3  | 10.6 |
| PostgreSQL | 11.0  | 14.0 |
| SQLite     | 3     | 3    |

不过目前 Strapi v4 并不支持 MongoDB，所以这里我们选择比较常用的 MySQL。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d11df2129e44a6cbc0d61070c224f2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1142\&h=358\&s=452090\&e=png\&b=03080d)

MySQL 数据库相关的设置如 name、Host、Port、Username 等，如果不知道，现在都可以默认，以后还可以改。

### 2. 安装常见问题

安装的时候可能会遇到一些问题，比如 Strapi 要求 node 版本大于 18，小于等于 20。如果版本不符合，可以通过 [nvm](https://github.com/nvm-sh/nvm) 管理和切换 node 版本。

安装的时候可能会在安装 sharp 这个库的时候报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/959ab6cd99a04552a2a8d3b06c3f0674~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1676\&h=554\&s=1434578\&e=png\&b=02070c)

如果出现这种报错，打开电脑`~/.npmrc`这个文件，添加如下配置：

```javascript
sharp_binary_host=https://npm.taobao.org/mirrors/sharp
sharp_libvips_binary_host=https://npm.taobao.org/mirrors/sharp-libvips
```

如果成功安装，会显示项目的可用脚本命令：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9cdc708a882409bb62a9520dfaf823b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1344\&h=702\&s=1375545\&e=png\&b=02070c)

## MySQL

当然现在运行 `npm run develop`也会报错，因为 MySQL 数据库相关的内容还没有设置，这里我们从安装到设置从头讲一遍。

### 1. 安装

首先是安装 mysql 包，下载地址：<https://dev.mysql.com/downloads/mysql/>

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d4e5bea641e48c3b2b69c7856168bb7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1904\&h=1132\&s=218346\&e=png\&b=fcfdfd)

因为我个人的电脑是 macOS，所以讲一下 macOS 安装时会遇到的一些问题。

首先是选择合适的下载包。Strapi 推荐 8.0 版本，所以优先选择 8.0.xx 版本。

查看“关于本机”，如果处理器是 Intel ，选择带 `x86`的包，如果芯片是 Apple M1，选择带 `ARM`的包。

此外还要注意苹果系统的版本，下载包的名字包含了支持的 OS 系统版本。比如你的系统是 macOS 11，安装支持 macOS 13 的包，会出现报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c828c3ea7124ad78ecc094ce85ed734~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1426\&h=208\&s=565809\&e=png\&b=0e1820)

如果系统是 macOS 11，可以选择 8.0.28 版本：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fab79811467f40fba3898eb9c124139e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3148\&h=918\&s=219536\&e=png\&b=fcfcfc)

安装的过程中需要设置下 root 用户的密码，记住这个密码就行。

安装完成后，可以在“系统偏好设置”中查看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ceffae31214ead92cdc48d78be7bc6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1316\&h=1008\&s=426043\&e=png\&b=e7e8e7)

点击进入 MySQL 界面，点击 `Start MySQL Server`即可启动 MySQL：

![截屏2024-01-16 下午1.30.21.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5a1a1eb04514095bbaf3220657d9b72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1336\&h=1124\&s=259559\&e=png\&b=eeeeed)

### 2. 配置环境变量

查看当前 Shell：

```bash
echo $SHELL
```

如果是 `/bin/bash`，说明用的是 bash，如果是 `/bin/zsh`，说明用的是 zsh。

如果是 `bash`：

```bash
# 1. 更改
vim ~/.bash_profile
# 2. 添加
export PATH=${PATH}:/usr/local/mysql/bin
# 3. 更新
source ~/.bash_profile
```

如果是 `zsh`：

```javascript
# 1. 更改
vim ~/.zshrc
# 2. 添加
export PATH=${PATH}:/usr/local/mysql/bin
# 3. 更新
source ~/.zshrc
```

此时在命令行中输入：

```bash
mysql -u root -p
```

输入安装时设置的密码，即可成功进入 MySQL CLI：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/878e8dc3529f44cba4a21e278e8fc469~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1120\&h=514\&s=1049302\&e=png\&b=0e1921)

### 3. 数据库配置

来都来了，那就顺便创建下会用到的数据库，执行：

```javascript
CREATE DATABASE strapi
```

别忘了在末尾带个 `\g`表示命令结束，这里我们创建了一个名为 strapi 的数据库：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05ceb4dedb71440d8ceb754015f16199~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=530\&h=78\&s=85832\&e=png\&b=1c1b18)

然后我们查看下 root 用户用到的 authentication 插件。因为 MySQL 8.0.x 默认的是 `chaching_sha2_password`，但是 Strapi 需要是 `mysql_native_password`，运行：

```javascript
SELECT user, plugin FROM mysql.user WHERE user IN ('root')
```

如果是 `caching_sha2_password`，运行：

```bash
ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'admin'
```

注意其中 `admin` 表示设置的新密码，如果在这里修改，会影响你运行 `mysql -u root -p`时输入的密码。再运行：

```bash
FLUSH PRIVILEGES
```

此时再运行以下命令查看 pulgin：

```bash
SELECT user, plugin FROM mysql.user WHERE user IN ('root')
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8584758b445747e388db42466506436c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1260\&h=734\&s=1515168\&e=png\&b=171a19)

### 4. 运行 Strapi 项目

现在我们已经获得了数据库的相关信息，也做好了准备，进入上节安装的 Strapi 项目目录，打开根目录的 `.env`文件，像下面这样填入数据库信息：

```javascript
# Database
DATABASE_CLIENT=mysql
DATABASE_HOST=127.0.0.1
DATABASE_PORT=3306
DATABASE_NAME=strapi
DATABASE_USERNAME=root
DATABASE_PASSWORD=admin
DATABASE_SSL=false
```

MySQL 数据库默认就是 3306 端口，所以不需要修改。数据库名称选择 `CREATE DATABASE xxxxxx`时填入的名字，用户名为 root，密码为运行 `ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'xxxxx'` 时填写的密码，这里是 `admin`。

此时再运行 `npm run develop`，应该就能正常运行起来：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a8b43baa144e428cda042171cc000e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2232\&h=1504\&s=311227\&e=png\&b=393939)

**这个安装过程可能会遇到很多问题，我也不能面面俱到，欢迎大家留言分享自己遇到的问题和解决方法，帮助后来的学习者。**

## Strapi 创建接口

如果你成功运行，应该会打开此页面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68eff31660d740a7b5026bfeb013e850~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1776\&h=2286\&s=309415\&e=png\&b=ffffff)

这里的信息用于 Strapi 认证，所有的数据也都存储在本地的数据库里。所以这里随便填，但是得记住，以后可能会用到。

填写完后进入主界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5a5b4494ebf40ad8755f005cccdb914~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3074\&h=1984\&s=587145\&e=png\&b=ffffff)

### 1. 设置中文

为了方便使用，我们先把界面的中文设置了，打开 `src/admin/app.example.js`，重命名为`app.js`，在其中取消掉 `'zh-Hans'`的注释：

```javascript
const config = {
  locales: [
    // 'ar',
    // 'fr',
    // 'cs',
    // 'de',
    // 'dk',
    // 'es',
    // 'he',
    // 'id',
    // 'it',
    // 'ja',
    // 'ko',
    // 'ms',
    // 'nl',
    // 'no',
    // 'pl',
    // 'pt-BR',
    // 'pt',
    // 'ru',
    // 'sk',
    // 'sv',
    // 'th',
    // 'tr',
    // 'uk',
    // 'vi',
    'zh-Hans',
    // 'zh',
  ],
};

const bootstrap = (app) => {
  console.log(app);
};

export default {
  config,
  bootstrap,
};

```

然后点击左下角的用户名 -> Profile，拉到最下面，选择`中文（简体）`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce6070334c8b489392267c50e6a06f67~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2620\&h=608\&s=111605\&e=png\&b=ffffff)

保存后，主界面即改为中文：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4793c52d9df8470b83bedadc002861ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3266\&h=2240\&s=581579\&e=png\&b=ffffff)

说真的，这中文翻译也就那样吧……我个人感觉还不如用英文。

### 2. 创建 REST API

现在我们来创建接口吧！

#### 2.1. 建表

首先打开 `Content-Type Builder`，这里有三种类型可以选择：

1.  `COLLECTION TYPES`：管理多个条目的内容类型
2.  `SINGLE TYPES`：管理一个条目的内容类型
3.  `COMPONENTS`：一种可用于 `COLLECTION TYPES`和 `SINGLE TYPES` 的数据结构

简单的来说，`COLLECTION TYPES` 就是我们常说的数据库里的“表”，可以有多条数据。`SINGLE TYPES`只能管理一条数据，可用于全局配置。`COMPONENTS` 表示一种数据结构，它可以在其他类型中复用。比如你可以创建一个名为 SEO 的组件，负责管理标题、描述等字段。然后你可以在 Article 和 Product 这两个 COLLECTION TYPES 中复用这个组件，而不用重新一一建立。

这里我们选择 `COLLECTION TYPES`，建立一个名为 Note 的集合类型，它对应的单数 ID 为 note，复数 ID 为 notes，这些是自动生成的，用于生成我们的接口地址。此步骤相当于建表。

## ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f801937b7254a2f8283807e4da55e2e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3266\&h=2240\&s=533603\&e=png\&b=e3e3e8)

然后就是添加各种字段，对应为表建立各种字段：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1dfa8d505564aac93d5c83dd76d1258~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3266\&h=2240\&s=453588\&e=png\&b=f5f5f9)

#### 2.2. 填充数据

回到 `Content Manager`，选择 `Note`这个集合类型，然后点击 `Create new entry`，这步就是让你填充一些数据。我们象征性的填充一些数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/179b0a4d02e642a893379f8c57ef015a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=505573\&e=png\&b=f6f6f9)

#### 2.3. 生成 token

打开 `Settings` -> `API Tokens`，点击 `Create new API Token`，生成 API Token，该 Token 决定了权限范围和使用时间。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7a03e4190dd420c8f27091d8f21b0f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3284\&h=2266\&s=622566\&e=png\&b=f1f1f6)

生成之后，获取接口数据的时候就需要带上这个 token：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1ec7f121ed14a52bb377013dcfc15ec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3284\&h=2266\&s=762387\&e=png\&b=e1e1e5)

#### 2.4. REST 接口

现在接口就已经生成了，对于一个 COLLECTION TYPE，Strapi 对应会生成这些接口，我们以这里的 Note COLLECTION TYPE 为例：

| 方法     | URL                           | 示例           | 作用     |
| ------ | ----------------------------- | ------------ | ------ |
| GET    | /api/:pluralApiIds            | /api/notes   | 获取条目列表 |
| POST   | /api/:pluralApiId             | /api/notes   | 创建条目   |
| GET    | /api/:pluralApiId/:documentId | /api/notes/1 | 获取单个条目 |
| PUT    | /api/:pluralApiId/:documentId | /api/notes/1 | 更新单个条目 |
| DELETE | /api/:pluralApiId/:documentId | /api/notes/1 | 删除单个条目 |

注意这里用到的都是复数 ID。如果是 SINGLE TYPES，生成的接口会用到单数 ID：

| 方法     | URL                 | 作用      |
| ------ | ------------------- | ------- |
| GET    | /api/:singularApiId | 获取条目    |
| PUT    | /api/:singularApiId | 更新/创建条目 |
| DELETE | /api/:singularApiId | 删除一个条目  |

现在你可以用 POSTMAN + Token 试试获取 notes 的数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bfcb46716e84566843a3cf96c6c6f00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2910\&h=2134\&s=562341\&e=png\&b=fcfcfc)

如果你不带 token 获取就会出现 403 错误：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99f5793c07904a7aa651431472ee7214~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2842\&h=870\&s=177998\&e=png\&b=fbfbfb)

#### 2.5. 取消授权

那你可能会想：“好麻烦，我调用个接口，还要用 token，能不能不用 token，至少获取列表和获取条目不需要？”。当然也是可以的，我们点击 `Settings`-> `Roles`，选择 `Public`角色进行编辑：

![截屏2024-01-16 下午9.10.58.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0369b0a67df4bc3864649348b03d475~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=518408\&e=png\&b=f6f6f9)

勾选 Note 这个集合类型中的 `find` 和 `findOne`，表示 `/api/notes`和 `/api/note/1`不再需要鉴权。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bac92fdbc5644609cad2422eaae1a21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=681416\&e=png\&b=f1f1f6)

现在我们已经可以直接获取数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/627ebd72ec86428f951fce98eb7d11d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2868\&h=1402\&s=365057\&e=png\&b=fdfdfd)

#### 2.6. Marketplace

现在 Note 我们已经创建了 `title` 和 `content` 这两个字段，创建和修改时间，Strapi 会自动返回，就不需要单独建立字段了。我们还需要一个 uid 用作文章的 slug，跳转到具体文章的时候，用 slug 作为其地址的一部分。

虽然文档自身也会返回 id，但这个 id 是递增的，不太适合作为 slug。Strapi 也有默认的 UID 字段：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a092ad205f04afe94a190481d599670~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=630908\&e=png\&b=e2e2e7)

但这个 UID 生成的字符串是 `note`、`note-1`、`note-2`这种。我们希望是一个多位的随机数字字符串。该如何实现呢？

这就要说到 Strapi 强大的插件功能了，我们打开 Marketplace，搜索 `uuid`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd612a1a1f84f51850ee81047e27ede~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=567136\&e=png\&b=f6f6f9)

我们选择 Advanced UUId 这个插件，查看用法后，在项目里运行：

```javascript
npm install strapi-advanced-uuid
```

安装后重启项目，即可在添加字段中的 CUSTOM 选项中查看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44d77927f9334b7a89c9c74c405203dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=510919\&e=png\&b=e1e1e6)

我们建立一个名为 slug 的 UUID 类型，UUID format 表示这个 uuid 的格式，我们填写 `^[0-9]{8}$`表示随机的 8 位数字字符串。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fba7747138f44a159ce9e8f94b16d5df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=522331\&e=png\&b=e2e2e7)

我们就可以通过该字段添加随机的 uid 数据：

![截屏2024-01-16 下午10.05.56.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01c474ba9e0448a2be03a645364d265f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3860\&h=2238\&s=457820\&e=png\&b=f6f6f9)

## Next.js 项目替换 redis

目前我们的 Next.js 项目使用的是 redis 作为临时数据库，现在改为调用接口来获取数据吧。

新建 `lib/strapi.js`，代码如下：

```javascript
export async function getAllNotes() {
  const response = await fetch(`http://localhost:1337/api/notes`)
  const data = await response.json();

  const res = {};

  data.data.forEach(({id, attributes: {title, content, slug, updatedAt}}) => {
    res[slug] = JSON.stringify({
      title,
      content,
      updateTime: updatedAt
    })
  })

  return res
}

export async function addNote(data) {
  const response = await fetch(`http://localhost:1337/api/notes`, {
    method: 'POST',
    headers: {
      Authorization: 'bearer 80985bb38cf749e5568e51c637d796c69c7a6b1e820152a1d144369d9b1568b26eae1070a42f06f691febb07a5134b0a5a00e24e69c298b50414f28c3299ead4b05b9f876883020868c5769a726ae5ca02ef31b2a5786efbccfe041b7131e609eb56680a60e38a973dae25d26d1e4ac56e7651d4d1c6a4e1fe7f68999dbb4eed',
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      data: JSON.parse(data)
    })
  })
  const res = await response.json();
  return res.data.attributes.slug
}

export async function updateNote(uuid, data) {
  const {id} = await getNote(uuid);
  const response = await fetch(`http://localhost:1337/api/notes/${id}`, {
    method: 'PUT',
    headers: {
      Authorization: 'bearer 80985bb38cf749e5568e51c637d796c69c7a6b1e820152a1d144369d9b1568b26eae1070a42f06f691febb07a5134b0a5a00e24e69c298b50414f28c3299ead4b05b9f876883020868c5769a726ae5ca02ef31b2a5786efbccfe041b7131e609eb56680a60e38a973dae25d26d1e4ac56e7651d4d1c6a4e1fe7f68999dbb4eed',
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      data: JSON.parse(data)
    })
  })
  const res = await response.json()
}

export async function getNote(uuid) {
  const response = await fetch(`http://localhost:1337/api/notes?filters[slug][$eq]=${uuid}`)
  const data = await response.json();
  return {
    title: data.data[0].attributes.title,
    content: data.data[0].attributes.content,
    updateTime: data.data[0].attributes.updatedAt,
    id: data.data[0].id
  }
}

export async function delNote(uuid) {
  const {id} = await getNote(uuid);
  const response = await fetch(`http://localhost:1337/api/notes/${id}`, {
    method: 'DELETE',
    headers: {
      Authorization: 'bearer 80985bb38cf749e5568e51c637d796c69c7a6b1e820152a1d144369d9b1568b26eae1070a42f06f691febb07a5134b0a5a00e24e69c298b50414f28c3299ead4b05b9f876883020868c5769a726ae5ca02ef31b2a5786efbccfe041b7131e609eb56680a60e38a973dae25d26d1e4ac56e7651d4d1c6a4e1fe7f68999dbb4eed',
      "Content-Type": "application/json"
    }
  })
  const res = await response.json()
}

```

在这段代码中，为了减少代码改动的范围，我们按照了之前使用 redis 的数据结构返回了数据。这样你只需将以前的导入代码 `@/lib/redis`改为 `@/lib/strapi`即可直接使用。这里为了演示，代码写的健壮性不够，比如没有错误捕获，没有空值判断，真实的项目开发中请勿这样写。

在这段代码中，`getNote` 函数中，我们使用了 `http://localhost:1337/api/notes?filters[slug][$eq]=${uuid}`来获取具体的笔记，因为我们没有使用 strapi 自带的 documentId，而是 slug 作为唯一 id。Strapi 也是支持 Filtering 的功能的，这段代码就演示了其用法。当然 Strapi 的强大功能不止这些，具体使用的时候，参考 [Strapi REST 文档](https://docs.strapi.io/dev-docs/api/rest)。

将 `@/lib/redis`都改为 `@/lib/strapi`后，项目正常运行：

![ReactNotes-Auth9.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76e4c8d9f270451ba3348bc7abc11aba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1523\&h=886\&s=1223330\&e=gif\&f=199\&b=f5f7fb)

但数据库已经从 redis 替换为了 mysql，而且我们可以通过 Strapi 快捷的查看到数据库中的数据。

## 总结

那么今天的内容就结束了，本篇主要是为大家介绍 Strapi 以及如何连接 MySQL 数据库，借助 Strapi 的可视化界面，可以快速创建 REST 接口，非常适合在一些接口并不用复杂的项目中使用。

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 [Day 9](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day9) 分支。直接使用的时候不要忘记在本地开启 Redis。

## 参考

1.  [Welcome to the Strapi Developer Docs! | Strapi Documentation](https://docs.strapi.io/dev-docs/intro)
2.  [Configuring MySQL on your Strapi project](https://strapi.io/blog/configuring-strapi-mysql-database)
3.  <https://github.com/strapi/strapi>


## 46.实战篇 | React Notes | Prisma

## 前言

### 1. ORM

我们先从 ORM（Object Relational Mapping） 开始说起，中文译为“**对象关系映射**”。简单的来说，就是用操作对象的方式操作数据库。

比如我们用 SQL 查询数据：

```javascript
SELECT * FROM users WHERE name = 'yayu';
```

如果使用 ORM 库（ORM 是一种技术，有很多实现 ORM 的库，Prisma 是其中一个），查询语句可以改为：

```javascript
var orm = require('orm-library');
var user = orm("users").where({ name: 'yayu' });
```

这里我们虚构了一个 `orm-library`库，语言用的是 JavaScript。所以 ORM 的好处就在于你可以用自己喜欢的语言来操作数据库，只要有对应的 ORM 库支持。

除此之外，ORM 对数据库进行了抽象，你可以以很低的成本更换数据库比如从 PostgreSQL 切换为 MySQL。通常 ORM 库还会支持一些高级的功能，方便开发者使用。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5509d68433344089315e112f94ea333~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1300\&h=616\&s=54627\&e=png\&a=1\&b=a0afc1)

### 2. 技术选型

在 Node.js 下，常用的 ORM 库有 [Prisma](https://www.prisma.io/docs/orm)、[Sequelize](https://sequelize.org/docs/v6/)、[TypeORM](https://typeorm.io/)、[Drizzle](https://orm.drizzle.team/)。[Mongoose](https://mongoosejs.com/) 也是一种 ORM，但它是基于 Node.js 和 MongoDB 的 ORM 库，而像前面提到的这些 ORM 库都是支持多种数据库的。

让我们看看它们的 [npm trends](https://npmtrends.com/drizzle-orm-vs-mongoose-vs-prisma-vs-sequelize-vs-typeorm)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48daaffba91245369e3788064a0ca1bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2644\&h=1864\&s=483553\&e=png\&b=fefefe)

其中 Sequelize 是老牌的 ORM 库，但是对 TypeScript 支持不佳，后来有了 TypeORM，对 TypeScript 支持更好，但是 TypeORM 更新维护比较慢，后被对 TypeScript 支持更佳、开发体验更好的 Prisma 超越。

Mongoose 也是老牌的 ORM 库，专注于 MongoDB 数据库。Drizzle 是这一两年才发布的小鲜肉，正在茁壮成长，目前版本还在 0.x.x。

此外，多数 ORM 库只支持关系型数据库。所以如果你用 MongoDB 这种非关系型数据库，那在这里面能选的也就只有 Prisma 和 Mongoose 了。

有一个[关于 ORM 库的调查](https://stateofdb.com/orms)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf4255494a794bcaa56b3adc483a3bc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1540\&h=1870\&s=247853\&e=png\&b=fcfcfc)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3f5417fb79f463daee774b9d4675664~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1570\&h=1808\&s=352400\&e=png\&b=faf5f4)

此项调查包含了多个语言的 ORM，比如 Django 是 Python 的，Eloquent 是 PHP 的。所以在 Node.js 中，目前使用度和满意度最高的就是 Prisma、Drizzle、Mongoose 了。

在实际的项目开发中，理论上应该选择使用度更高、版本相对稳定的库。简而言之，初学者推荐用 Prisma。如果你用 MongoDB，可以选择 Mongoose。

数据库我们继续选择 MySQL，常用的数据库也就是 Postgres、MongoDB、MySQL、Redis 了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5cf8651c19a459ca174bdbf5a258bdf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1544\&h=1318\&s=197405\&e=png\&b=fbfbfb)

## MySQL

MySQL 的安装我们已经在上篇[《实战篇 | React Notes | Strapi》](https://juejin.cn/book/7307859898316881957/section/7321635703136206874#heading-4)中讲过，就不重复赘述了。

MySQL GUI 工具可以使用 Navicat，方便查看和操作数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f188a67ac7c42028f51f43713d6889b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2480\&h=1760\&s=786549\&e=png\&b=ebeded)

当然就本篇的内容而言，不使用 GUI 工具也没有任何关系。

## Prisma 介绍

现在让我们正式的介绍下 Prisma 吧。按照官方的介绍，它是下一代的 Node.js 和 TypeScript ORM：

> Next-generation Node.js and TypeScript ORM

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3d0f42939e446379f421cd2060bf816~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2056\&h=580\&s=251981\&e=png\&b=ffffff)

它的优势在于：

> Prisma unlocks a new level of developer experience when working with databases thanks to its intuitive data model, automated migrations, type-safety & auto-completion.

简单的来说，就是开发体验更好：直观的数据模型、自动化迁移、类型安全、自动补全。

比如你可以在 `schema.prisma`这个文件（Prisma 自定义的一种文件格式）中定义数据模型，就像这样：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ff3d18e19e411792c3b999a58d1fa1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1620\&h=796\&s=483085\&e=png\&b=26292f)

其中`model Post` 映射了数据库中的 Post 表，id、title、content、published 映射了表中的字段，字段后面的 Int、String 等表示字段类型，再后面的 @id、@default，这些是属性，我们稍后再讲。

当你需要操作数据库时，Prisma 提供了 Prisma Client：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6827d49c0736496486bbefdd558b63cd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1592\&h=788\&s=537495\&e=png\&b=26292f)

Prisma 同时提供了 Prisma Migrate，这是 Prisma 的迁移系统。比如当你在 `schema.prisma`更改了数据模型，命令行运行 `npx prisma migrate dev`，prisma 就会根据你定义的数据模型，修改数据库。

Prisma 还提供了 Prisma Studio，这是 Prisma 提供的查看和编辑数据库数据的 GUI 工具。不同于 Navicat 这样的软件，Prisma Studio 的开启方式是在命令行运行 `npx prisma studio`，它会打开一个网页，展示数据库中的数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c4591f1fb4f41ff976498d04eff1641~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2008\&h=696\&s=437919\&e=png\&b=fef9f8)
Prisma 目前支持的语言和数据库有：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2533ccdb81c47e5a8ba6f212191e42a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2542\&h=384\&s=70800\&e=png\&b=ffffff)

好了，Prisma 的大致介绍就这些。**Prisma Client**、**Prisma Migrate**、**Prisma Studio** 就是 Prisma 的主要组成部分了。接下来让我们在实战中具体体会吧！

## Prisma 使用

### 1. 创建文件

项目根目录安装 `prisma`作为开发依赖：

```javascript
npm install prisma --save-dev
```

安装后运行：

```javascript
npx prisma init
```

这一步会：

1.  创建一个 `prisma`文件夹，其中包含一个 `schema.prisma`文件，这就是定义数据模型的地方
2.  创建一个`.env`文件，用于定义环境变量（如数据库地址）

### 2. 连接 MySQL 数据库

修改 `prisma/schema.prisma`：

```javascript
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
```

修改 `.env` 中的 `DATABASE_URL`，此 URL 规则如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0adc8da75fcc4bbfbbb87ce941f05840~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1300\&h=208\&s=68342\&e=png\&a=1\&b=fee8c8)

按照此规则，我们的地址应该修改为：

```bash
DATABASE_URL="mysql://root:admin@localhost:3306/notes"
```

其中 `notes` 为我们的数据库名称。目前这个数据库我们在 MySQL 中还没有建立，所以我们来建一个。

一种方法是使用 MySQL GUI 工具，右键直接建立一个名为 `notes` 的数据库。

一种方法是使用命令行：

```javascript
# 访问数据库
mysql -u root -p
# 创建数据库
CREATE DATABASE notes;
```

![1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/384a10db8ad548cda44f8071918de948~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1408\&h=738\&s=129347\&e=png\&b=1f1f1f)

执行 `npx prisma db pull`，如果出现以下提示即表示连接成功：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea302d794a5048ea9eb408cf5762d79f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1874\&h=656\&s=151411\&e=png\&b=1e1e1e)

注：虽然是报错信息，显示数据库为空，但说明至少连接上了数据库。如果数据库不存在，就是另外一个报错了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f076886ec2ba4ea3b48d50dc6e6655e8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1866\&h=672\&s=147633\&e=png\&b=1e1e1e)

### 3. 定义数据模型

现在我们来定义数据模型，数据模型需要与数据库保持一致。我们有两种方式使其保持一致：

1.  手动修改数据模型，然后运行 `npx prisma migrate dev`修改数据库，使其保持一致
2.  手动修改数据库，然后运行 `npx prisma db pull`修改数据模型，使其保持一致

现在我们修改下 `prisma/schema.prisma`：

```javascript
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id       String @id @default(uuid())
  username String
  password String
  notes    Note[]
}

model Note {
  id        String   @id @default(cuid())
  title     String   @db.VarChar(255)
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
}

```

运行 `npx prisma migrate dev`，然后给这次 migrate 起一个名字（这个名字无所谓，一个标识而已）：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6700867aa0f4ee9a62e109a1b763ada~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1532\&h=620\&s=117541\&e=png\&b=1e1e1e)

再次查看数据库，User 表、Note 表和其中的字段都已建立：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c37065a8ede4d21918a6a2239be0e49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2208\&h=1242\&s=372326\&e=png\&b=232323)

这个 Prisma schema 同步数据库的过程，就被称之为 **migration**。每次迁移，都会生成一个迁移文件，存放在 `prisma/migrations`下。

现在我们直接修改数据库，比如在 Note 表添加一个 `content` 字段：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2705bed438b484b959bc4ecf98e8762~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2208\&h=1242\&s=400391\&e=png\&b=282a2c)

然后运行 `npx prisma db pull`，Prisma 会自动在 `prisma/schema.prisma` 中同步该字段：

```javascript
model Note {
	// ...
  content   String?  @db.VarChar(255)
	// ...
}
```

这个从数据库推导出 Prisma schema 的过程就叫做 **Introspection**，中文译为“内省”，指通过检查数据库的结构和元数据来了解数据库本身的特性和信息。

> Introspection is the process of getting the metadata of the database, such as object names, types of columns, and source code

不过注意使用 `npx prisma db pull`的时候，还要再搭配使用 `prisma generate`更新 Prisma Client 后，你才能正确的通过 Prisma Client 操作数据库：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66d1f1bf27164639935a13ee77c9bba5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1300\&h=579\&s=143193\&e=png\&a=1\&b=e0f6f9)

### 4. 语法高亮与自动格式化

多说一句：schema.prisma 因为是 Prisma 自定义的文件格式，所以文件默认无语法高亮，使用 VSCode 的同学可以下载 Prisma 这个插件以支持该文件语法高亮：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07708e260b2f4aed83198f04149dc5e4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2076\&h=420\&s=104237\&e=png\&b=1e1e1e)

安装该插件后，还可以打开 `settings.json`，添加 prisma 文件的自动格式化：

![截屏2024-01-18 下午8.08.04.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7e1519a747845bb95e475196e2059f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1622\&h=912\&s=180151\&e=png\&b=1f1f1f)

效果如下：

![ReactNotes-prisma2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2797be54e4a64636bbfef9b0eac06250~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=666\&h=518\&s=47338\&e=gif\&f=8\&b=1f1f1f)

当然如果你不设置，也可以在根目录运行 `npx prisma format`格式化该文件。

### 5. Prisma Client

安装 `@prisma/client`：

```bash
npm install @prisma/client
```

现在让我们回到我们的项目需求上，因为目前并没有做权限控制，所以创建的笔记谁都可以查看、创建或编辑。如果我们希望用户登录后才能查看、新增、编辑自己的笔记呢？效果图如下：

![ReactNotes-prisma3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/217973beae98461994ea896abca2b1bc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1050\&h=672\&s=382538\&e=gif\&f=110\&b=f8fafb)

让我们开始实现吧！

`schema.prisma`的代码为：

```javascript
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id       String @id @default(uuid())
  username String
  password String
  notes    Note[]
}

model Note {
  id        String   @id @default(cuid())
  title     String   @db.VarChar(255)
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
}

```

注意：如果修改了 schema，运行 `npx prisma migrate dev`，将修改同步数据库，migrate 会自动更新 Prisma Client，所以无须再运行 `prisma generate`。

因为要实现鉴权，所以要结合 `next-auth`，修改 `auth.js`：

```javascript
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
import CredentialsProvider from "next-auth/providers/credentials";
import { addUser, getUser } from "@/lib/prisma";

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers:[CredentialsProvider({
    // 显示按钮文案 (e.g. "Sign in with...")
    name: "密码登录",
    // `credentials` 用于渲染登录页面表单
    credentials: {
      username: { label: "账号", type: "text", placeholder: "输入您的账号" },
      password: { label: "密码", type: "password", placeholder: "输入您的密码" }
    },
    // 处理从用户收到的认证信息
    async authorize(credentials, req) {
      // 默认情况下不对用户输入进行验证，确保使用 Zod 这样的库进行验证
      let user = null

      // 登陆信息验证
      user = await getUser(credentials.username, credentials.password)

      // 密码错误
      if (user === 1) return null

      // 用户注册
      if (user === 0) {
        user = await addUser(credentials.username, credentials.password)
      }

      if (!user) {
        throw new Error("User was not found and could not be created.")
      }

      return user
    }
  }), GitHub],
  pages: {
    signIn: '/auth/signin'
  },
  callbacks: {
    authorized({ request, auth }) {
      const { pathname } = request.nextUrl
      if (pathname.startsWith("/note/edit")) return !!auth
      return true
    },
    async jwt({ token, user, account }) {
      if (account && account.type === "credentials" && user) {
        token.userId = user.userId;
      }
      return token;
    },
    async session({ session, token }) {
      session.user.userId = token.userId;
      return session;
    }
  }
})
```

新建 `middleware.js`，代码如下：

```javascript
export { auth as middleware } from "auth"

export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
}
```

使用 `middleware.js` 是为了实现新建和编辑时跳转到登录页面。

新建 `lib/prisma.js`，代码如下：

```javascript
import { PrismaClient } from '@prisma/client'
import { auth } from "auth"

const globalForPrisma = global;

export const prisma = globalForPrisma.prisma || new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

export async function getAllNotes() {
  const session = await auth()
  if (session == null) return [];
  // 查找登录用户的笔记
  const notes = await prisma.note.findMany({
    where: {
      authorId: session?.user?.userId
    }
  })
  // 构造返回数据
  const res = {};
  notes.forEach(({title, content, id, updatedAt}) => {
    res[id] = JSON.stringify({
      title,
      content,
      updateTime: updatedAt
    })
  })
  return res
}

export async function addNote(data) {
  const session = await auth()
  const result = await prisma.note.create({
    data: {
      title: JSON.parse(data).title,
      content: JSON.parse(data).content,
      author: { connect: { id: session?.user?.userId } },
    }
  })

  return result.id
}

export async function updateNote(uuid, data) {
  const parsedData = JSON.parse(data);
  await prisma.note.update({
    where: {
      id: uuid
    },
    data: {
      title: parsedData.title,
      content: parsedData.content
    }
  })
}

export async function getNote(uuid) {
  const session = await auth()
  if (session == null) return;
  const {title, content, updateTime, id} = await prisma.note.findFirst({
    where: {
      id: uuid
    }
  })

  return {
    title,
    content,
    updateTime,
    id
  }
}

export async function delNote(uuid) {
  await prisma.note.delete({
    where: {
      id: uuid
    }
  })
}

export async function addUser(username, password) {
  const user = await prisma.user.create({
    data: {
      username,
      password,
      notes: {
        create: []
      }
    }
  })

  return {
    name: username,
    username,
    userId: user.id
  }
}

export async function getUser(username, password) {
  const user = await prisma.user.findFirst({
    where: {
      username
    },
    include: {
      notes: true
    }
  })
  if (!user) return 0;
  if (user.password !== password) return 1
  return {
    name: username,
    username,
    userId: user.id
  } 
}

export default prisma
```

在这段代码中，我们使用了 `const prisma = globalForPrisma.prisma || new PrismaClient()`这种方式，这是为了避免开发环境下建立多个 Prisma Client 实例导致问题，详细参考[此篇说明](https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices)。

在这段代码中，我们演示了如何增删改查数据库。注意我们获取 Note 表的时候，要使用小写的 `prisma.note` 获取。Prisma Client 具体 API 的用法可以参考 [Prisma Client API reference](https://www.prisma.io/docs/orm/reference/prisma-client-reference)，当然下节我会带大家过一遍 API。

然后我们将上篇的 `@/lib/strapi`或者之前的 `@/lib/redis` 统一替换为 `@/lib/prisma`。此时效果已经实现：

![ReactNotes-prisma3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d695b173cf948c8b85225227706bdad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1050\&h=672\&s=382538\&e=gif\&f=110\&b=f8fafb)

### 6. Prisma Studio

在根目录运行 `npx prisma studio`，它会打开一个网页：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c64a4fdf1264eae91ed12c7f6e42ce3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2502\&h=528\&s=109475\&e=png\&b=ffffff)

你可以在这个页面查看和编辑数据库中的数据。

## Prisma 深入了解

Prisma 的基本使用就这些内容，Prisma 的官方文档写得很好，再深入的部分其实看文档即可，所以我们这里讲讲作为初学者，接下来要学习的一些内容。

### 1. Prisma schema

首先是数据模型的书写，举个例子：

```javascript
model Post {
  id  Int @id @default(autoincrement())
}
```

模型的每个字段，包含：

1.  [字段名称](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields)
2.  [字段类型](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#model-fields)
3.  （可选）[类型修饰符](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#type-modifiers)（type modifiers）
4.  （可选）[属性](https://www.prisma.io/docs/orm/prisma-schema/data-model/models#defining-attributes)（attributes）

#### 1.1. 字段类型

其中，字段类型有 `String`、`Boolean`、`Int`、`BigInt`、`Float`、`Decimal`（存储精确小数值）、`DateTime`、`Json`、`Bytes`（存储文件）、`Unsupported`。字段类型还可以是数据库底层数据类型，通过 `@db.` 描述，比如 `@db.VarChar(255)`, varchar 正是 MySQL 支持的底层数据类型。

#### 1.2. 类型修饰符

类型修饰符有两个：

1.  `[]` 表示字段是数组
2.  `?` 表示字段可选

```javascript
model User {
  name String?
  favoriteColors String[]
}
```

目前 Prisma 不支持可选数组，也就是这两个类型修饰符不能同时用。如果你有需要，那就创建数据的时候创建一个空数组。

#### 1.3. 属性

再后面的 `@id @default(autoincrement())` 这些就都是属性了。属性的作用是修改字段或块（model）的行为，影响字段的属性用 `@` 作为前缀，影响块的属性用 `@@`作为前缀，举个例子：

```javascript
model User {
  id        Int    @id @default(autoincrement())
  firstName String @map("first_name")
  @@map("users")
}
```

在这个例子中，`map`的作用是映射：

*   `@map("first_name")` 表示`firstName` 字段映射数据库中的 `first_name` 字段
*   `@@map("users")`表示 `User` 映射数据库的中的 `users` 表

具体影响字段的属性有：

1.  [@id](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id)（设置主键 `PRIMARY KEY`）
2.  [@default](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#default)（设置字段默认值）
3.  [@unique](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique)（唯一约束，表示该字段值唯一，设置后可以用 `findUnique` 来查找）
4.  [@relation](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#relation)（设置外键 `FOREIGN KEY`/ `REFERENCES`，用于建立表与表之间的关联，很重要的概念，下节会具体讲）
5.  [@map](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map)（映射数据库中的字段）
6.  [@updatedAt](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#updatedat)（自动存储记录更新的时间）
7.  [@ignore](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#ignore)（该字段会被忽略，不会生成到 Prisma Client 中）

影响块的属性有：

1.  [@@id](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#id-1)：相当于关系型数据库中复合主键

```javascript
model User {
  firstName String
  lastName  String
  email     String  @unique
  isAdmin   Boolean @default(false)

  @@id([firstName, lastName])
}
```

firstName 和 lastName 共同组成主键，允许 firstName 或 lastName 单独重复，但不能一起重复。

当创建的时候，字段需要都创建：

```javascript
const user = await prisma.user.create({
  data: {
    firstName: 'Alice',
    lastName: 'Smith',
  },
})
```

查询的时候，使用生成的复合 id （firstName\_lastName）进行查询：

```javascript
const user = await prisma.user.findUnique({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

2.  [@@unique](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#unique-1)：复合唯一约束

定义：

```javascript
model User {
  id        Int     @default(autoincrement())
  firstName String
  lastName  String
  isAdmin   Boolean @default(false)

  @@unique([firstName, lastName])
}
```

查询：

```javascript
const user = await prisma.user.findUnique({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith'
    },
  },
})
```

3.  [@@index](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#index)：创建数据库索引

可以创建多列索引：

```javascript
model Post {
  id      Int     @id @default(autoincrement())
  title   String
  content String?

  @@index([title, content])
}
```

4.  [@@map](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#map-1)：映射数据库表名
5.  [@@ignore](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#ignore-1)：忽略此模型
6.  [@@schema](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#schema)：在支持 multiSchema 的时候使用，比如搭配 supabase，为 model 添加授权相关的字段`@@schema("auth")`

#### 1.4. 属性函数

让我们再看下这个例子：

```javascript
model User {
  id        Int    @id @default(autoincrement())
}
```

`@default` 中的 `autoincrement()` 被称为属性函数。属性函数有：

1.  [auto()](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#auto)：由数据库自动生成，只用于 Mongodb 数据库（因为 Mongodb 的 \_id 是自动生成的）：

```javascript
model User {
  id   String  @id @default(auto()) @map("_id") @db.ObjectId
}
```

2.  [autoincrement()](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#autoincrement)：自动增长，只用于关系型数据库：

```javascript
model User {
  id   Int    @id @default(autoincrement())
  name String
}
```

3.  [cuid()](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#cuid)：基于 [cuid ](https://github.com/paralleldrive/cuid)规范生成唯一标识符，适用于浏览器环境中（示例：tz4a98xxat96iws9zmbrgj3a）
4.  [uuid()](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#uuid)：基于 [uuid](https://en.wikipedia.org/wiki/Universally_unique_identifier) 规范生成唯一标识符（示例：9c5b94b1-35ad-49bb-b118-8e8fc24abf80）
5.  [now()](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#now)：创建记录的时间戳
6.  [dbgenerated()](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#dbgenerated)：无法在 Prisma schema 中表示的默认值（如 random()）

除此之外，还有一个 [enum](https://www.prisma.io/docs/orm/reference/prisma-schema-reference#enum) 类型，很好理解，使用示例如下：

```javascript
enum Role {
  USER
  ADMIN
}

model User {
  id   Int  @id @default(autoincrement())
  role Role @default(USER)
}
```

### 2. Relations

关系（relation）是指 Prisma schema 中的两个 model 建立连接。建立连接的方式是通过主键（PRIMARY KEY，简写 PK）和外键（FOREIGN KEY，简写 FK）。

所谓主键，指的是数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的键，换句话说，主键是关系表中记录的唯一标识，也就是我们添加 `@id`属性的字段。

所谓外键，指的是指向其他表的主键的键，用于建立两张表的关联性。Prisma 用 `@relation`属性来建立关系。

#### 2.1. 建立关联

以我们的项目为例，一张 User 表、一张 Note 表。因为一个作者可以写多篇笔记，所以 User 和 Note 的关系为一对多：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c41c69f6a426433bb0c40df39b068b63~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1042\&h=434\&s=66071\&e=png\&a=1\&b=ffffff)
如果我们要建立两个表之间的关系，写法如下：

    model User {
      id       String @id @default(uuid())
      notes    Note[]
    }

    model Note {
      id        String   @id @default(cuid())
      author    User     @relation(fields: [authorId], references: [id])
      authorId  String
    }

Note 的 author 字段指向 User，其中 `@relation(fields: [authorId], references: [id])`表示 Note 的 authorId 字段与 User 的 id 字段建立关系，**也就是这两个字段的值应该是一致的**。

像我们的项目的 schema 为：

```javascript
model User {
  id       String @id @default(uuid())
  username String
  password String
  notes    Note[]
}

model Note {
  id        String   @id @default(cuid())
  title     String   @db.VarChar(255)
  content   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
}
```

#### 2.2. 创建记录

当你通过 `@relation` 建立了 User 表和 Note 表的关联后，你可以更便捷的进行一些操作，比如创建嵌套的记录：

```javascript
  const user = await prisma.user.create({
    data: {
      username,
      password,
      notes: {
        create: [
          {title: '1', content: '1'},
          {title: '2', content: '2'}
        ]
      }
    }
  })
```

此时 Note 表中也会有两条记录，并且两条记录的 authorId 会自动设置为刚创建的 user 记录的 id。

#### 2.3. 查询记录

当你查询 User 表的信息，可以返回 Note 表中的信息。当你通过以下代码查询时：

```javascript
const user = await prisma.user.findFirst({
  where: {
    username: '1'
  },
  include: {
    notes: true
  }
})
console.log(user)
```

打印的信息为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9c8febd4a2340e89dfb4aceb754d867~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1032\&h=788\&s=123620\&e=png\&b=1e1e1e)

#### 2.4. connect

不过使用关系的时候，要注意及时关联。比如当你创建了一条 note 时，要关联到对应的 user 中，为此你需要使用 [connect](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect) 嵌套查询语法：

```javascript
  const result = await prisma.note.create({
    data: {
      title: '1',
      content: '2',
      author: { 
        connect: { 
          id: '1895c437'
      	} 
      },
    }
  })
```

Prisma 会自动设置该 note 的 authorId 为 `'1895c437'`，并且关联到 id 为 `'1895c437'` 的 user 上，这样当你通过 prisma.user 查询的时候，也会出现该 note 信息。

也可以从 prisma.user 更新关联：

```javascript
const updateAuthor = await prisma.user.update({
  where: {
    id: '1895c437',
  },
  data: {
    notes: {
      connect: {
        id: 'clrkpshqd0004aa0occr5a2qq',
      },
    },
  },
})
```

Prisma 会查询 id 为 `'1895c437'` 的用户，然后将 id 为 `clrkpshqd0004aa0occr5a2qq` 的 note 的 authorId 改为 `'1895c437'`，并建立两者的关联。

除了像这样一对多的关系，还有[一对一](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/one-to-one-relations)，[多对多](https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations)的关系，详细请查阅文档。

### 3. Prisma Client

学习 Prisma Client，也就是学习具体如何操作数据库。完整的 API 参考 [Prisma Client API reference](https://www.prisma.io/docs/orm/reference/prisma-client-reference)。

#### 3.1. 查询函数

查询函数有：

1.  增：`create()`、`createMany()`
2.  删：`delete()`、`deleteMany()`
3.  改：`update()`、`upsert()`（找不到就创建）、`updateMany()`
4.  查：`findUnique()`(需要有 @unique 属性)、`findUniqueOrThrow()`（找不到就报错）、`findFirst()`（找第一个）、`findFirstOrThrow()`（找不到就报错）、`findMany()`
5.  其他：`count()`、`aggregate()`（聚合）、`groupBy()`

#### 3.2. 查询参数

其查询参数除了 `where` 用于条件查找之外，还有：

1.  `include` 用于定义返回的结果中包含的关系
2.  `select` 用于选择返回的字段
3.  `orderBy` 用于排序
4.  `distinct` 用于去重

```javascript
const usersWithPosts = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  include: {
    posts: {
      select: {
        title: true,
      },
      orderBy: {
        title: 'asc',
      },
    },
  },
})
```

在这个例子中：

1.  返回所有的 User 记录，记录按 email 升序排列
2.  对于每条记录，返回嵌套的 posts 信息，按 title 升序排列后，只返回 title 字段

简单的来说，就是返回所有用户的基本信息和文章标题数据。一个示例结果如下：

```json
[
  {
    "id": 2,
    "email": "alice@prisma.io",
    "name": "Alice",
    "posts": [
      {
        "title": "Watch the talks from Prisma Day 2019"
      }
    ]
  },
  {
    "id": 3,
    "email": "ariadne@prisma.io",
    "name": "Ariadne",
    "posts": [
      {
        "title": "How to connect to a SQLite database"
      },
      {
        "title": "My first day at Prisma"
      }
    ]
  },
  {
    "id": 1,
    "email": "bob@prisma.io",
    "name": "Bob",
    "posts": [
      {
        "title": "Follow Prisma on Twitter"
      },
      {
        "title": "Subscribe to GraphQL Weekly for community news "
      }
    ]
  }
]
```

#### 3.3. 嵌套查询

在嵌套查询里，有：[create](https://www.prisma.io/docs/orm/reference/prisma-client-reference#create-1)、[createMany](https://www.prisma.io/docs/orm/reference/prisma-client-reference#createmany-1)、[set](set)、[connect](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connect)、[connectOrCreate](https://www.prisma.io/docs/orm/reference/prisma-client-reference#connectorcreate)、[disconnect](https://www.prisma.io/docs/orm/reference/prisma-client-reference#disconnect)、[update](https://www.prisma.io/docs/orm/reference/prisma-client-reference#update-1)、[upsert](https://www.prisma.io/docs/orm/reference/prisma-client-reference#upsert-1)、[delete](https://www.prisma.io/docs/orm/reference/prisma-client-reference#delete-1)、[updateMany](updateMany)、[deleteMany](https://www.prisma.io/docs/orm/reference/prisma-client-reference#deletemany-1)，也就是如何处理关系表中的数据，示例代码如下：

```javascript
  const user = await prisma.user.create({
    data: {
      username,
      password,
      notes: {
        create: [
          {title: '1', content: '1'},
          {title: '2', content: '2'}
        ]
      }
    }
  })
```

在这段代码中，创建一条 user 记录的同时，也创建了两条 note 记录并进行了关联。其他方法的作用也是类似。

#### 3.4. 筛选条件

筛选条件支持 [equals](https://www.prisma.io/docs/orm/reference/prisma-client-reference#equals)、[not](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not)、[in](https://www.prisma.io/docs/orm/reference/prisma-client-reference#in)、[notIn](https://www.prisma.io/docs/orm/reference/prisma-client-reference#notin)、[lt](https://www.prisma.io/docs/orm/reference/prisma-client-reference#lt)、[lte](https://www.prisma.io/docs/orm/reference/prisma-client-reference#lte)、[gt](https://www.prisma.io/docs/orm/reference/prisma-client-reference#gt)、[gte](https://www.prisma.io/docs/orm/reference/prisma-client-reference#gte)、[contains](https://www.prisma.io/docs/orm/reference/prisma-client-reference#contains)、[search](https://www.prisma.io/docs/orm/reference/prisma-client-reference#search)、[mode](https://www.prisma.io/docs/orm/reference/prisma-client-reference#mode)、[startsWith](https://www.prisma.io/docs/orm/reference/prisma-client-reference#startswith)、[endsWith](https://www.prisma.io/docs/orm/reference/prisma-client-reference#endswith)、[AND](https://www.prisma.io/docs/orm/reference/prisma-client-reference#and)、[OR](https://www.prisma.io/docs/orm/reference/prisma-client-reference#or)、[NOT](https://www.prisma.io/docs/orm/reference/prisma-client-reference#not-1)。举个简单的例子：

```javascript
const result = await prisma.user.findMany({
  where: {
    name: {
      equals: 'Eleanor',
    },
  },
})
```

这段代码的含义是查询 `name` 等于 `'Eleanor'` 的记录。

举个复杂一点的例子：

```javascript
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
    AND: {
      published: false,
    },
  },
})
```

`OR` 实现“或”语句，`AND` 实现 “并”语句，这段代码的意思是找出 `title` 包含 `Prisma` 或者 `database` 并且 `published` 为 `false` 的记录。

#### 3.5. Relation filters

最后还有 Relation filters，有 [some](https://www.prisma.io/docs/orm/reference/prisma-client-reference#some)、[every](https://www.prisma.io/docs/orm/reference/prisma-client-reference#every)、[none](https://www.prisma.io/docs/orm/reference/prisma-client-reference#none)、[is](https://www.prisma.io/docs/orm/reference/prisma-client-reference#is)、[isNot](https://www.prisma.io/docs/orm/reference/prisma-client-reference#isnot)，举个例子：

```javascript
const result = await prisma.user.findMany({
  where: {
    post: {
      some: {
        content: {
          contains: "Prisma"
        }
      }
    }
  }
}
```

这段代码的含义是获取文章中包含 Prisma 文字的 user 记录。

```javascript
const result = await prisma.post.findMany({
  where: {
    user: {
        is: {
          name: "yayu"
        },
    }
  }
}
```

这段代码的含义是获取用户名为 "yayu" 的 post 记录。

### 4. Prisma Cli

最后再学习下 Prsima 的命令，运行：

```bash
npx prisma --help
```

可以查看到有哪些命令：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1624d47ff0d842f880c4398f73b7621f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1718\&h=686\&s=125478\&e=png\&b=1e1e1e)

其中：

| `npx prisma init`     | 初始化 Prisma           | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#init)       |
| --------------------- | -------------------- | ---------------------------------------------------------------------------------- |
| `npx prisma generate` | 生成 Prisma Client     | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#generate)   |
| `npx prisma studio`   | 开启 Prisma Studio     | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#studio)     |
| `npx prisma validate` | 检验 Prisma schema 文件  | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#validate)   |
| `npx prisma format`   | 格式化 Prisma Scheam 文件 | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#format)     |
| `npx prisma version`  | 展示 Prisma 版本信息       | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#version--v) |
| `npx prisma debug`    | 展示 Prisma debug 信息   | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#debug)      |

稍微有点复杂的是 `db` 和 `migrate` 命令：

| `npx prisma db pull`    | 连接数据库，同步到数据模型    | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-pull)    |
| ----------------------- | ---------------- | ---------------------------------------------------------------------------------- |
| `npx prisma db push`    | 数据模型同步到数据库       | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-push)    |
| `npx prisma db seed`    | 给数据库填充点数据        | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-seed)    |
| `npx prisma db execute` | 与数据库交互，执行 SQL 语句 | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#db-execute) |

| `npx prisma migrate dev`     | 仅在开发环境下使用，迁移数据库                                                                                                                             | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-dev)     |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| `npx prisma migrate reset`   | 仅在开发环境下使用，重置数据库                                                                                                                             | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-reset)   |
| `npx prisma migrate deploy`  | 常用于正式环境，将迁移文件更新到生产环境后，执行该命令，会应用所有尚未迁移过的文件                                                                                                   | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-deploy)  |
| `npx prisma migrate resolve` | 当 migrate 失败时用于回滚，详细参考  [Failed migration](https://www.prisma.io/docs/orm/prisma-migrate/workflows/patching-and-hotfixing#failed-migration) | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-resolve) |
| `npx prisma migrate status`  | 当前的迁移状态，哪些迁移已应用，哪些迁移尚未应用                                                                                                                    | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-status)  |
| `npx prisma migrate diff`    | 比较两个数据库 schema source 的差异                                                                                                                   | [API 链接](https://www.prisma.io/docs/orm/reference/prisma-cli-reference#migrate-diff)    |

## 总结

Prisma 最主要的就是这些内容了。本篇主要是为大家介绍 ORM 和 Prisma。Prisma 是非常常见的搭配 Next.js 项目的技术选型，我们后面的实战项目还会继续用到 Prisma，就让我们在不断的实践中加深理解吧！

本篇的代码我已经上传到[代码仓库](https://github.com/mqyqingfeng/next-react-notes-demo/tree/main)的 [Day 10](https://github.com/mqyqingfeng/next-react-notes-demo/tree/day10) 分支，使用的时候不要忘记在本地开启 MySQL。

## 参考链接

1.  [What is Prisma? (Overview)](https://www.prisma.io/docs/orm/overview/introduction/what-is-prisma)
2.  <https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a>
3.  <https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases-node-mysql>


## 47.实战篇 | React Notes | 服务器部署

## 前言

假设我们的项目做完了，现在该部署上线了。你有两个方向可以选择：

1.  部署到 Vercel
2.  部署到自己的服务器

因为网络原因，国内无法直接访问 Vercel 。假如你要部署到自己的服务器，你有三种选择：

1.  使用 Node.js Server
2.  使用 Docker Image
3.  使用[静态导出](https://juejin.cn/book/7307859898316881957/section/7309078383263989786)

其中使用 Node.js Server，也就是我们目前开发的这种方式，主要步骤是将代码部署到服务器上，然后运行`npm run start` 启动 Node.js Server，适用于全栈项目。使用 Docker Image 的方式我们会在下篇文章讲到。静态导出适用于纯前端项目，在本地构建导出后，将构建的内容部署到服务器上。

本篇我们讲讲如何以 Node.js Server 的方式部署到自己的服务器上。我们先从买一个服务器开始说起。

## 服务器

### 买个服务器

现在我们买个服务器，这里我们以目前市场占有率第一的**阿里云服务器**为例，购买可以参考 [《一篇从购买服务器到部署博客代码的详细教程》](https://juejin.cn/post/7049692191110725645)。

假设我们已经买完了，得到了一个全新的服务器：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e35d54585ec64acb8af889c439d5ad31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3520\&h=458\&s=145669\&e=png\&b=fdfdfd)

注：当然你也可以重置一个服务器，此过程叫做“云服务器初始化”，是指将云服务器恢复到最初创建的状态，类似手机的恢复出厂设置。因为阿里云服务器数据是保存在云盘上的，所以这个过程也叫做**重新初始化云盘**，具体操作参考阿里云文档[《重新初始化系统盘》](https://www.alibabacloud.com/help/zh/ecs/user-guide/re-initialize-a-system-disk)。

### 获取登录密码

首先要做的应该是重置密码。根据阿里云文档的[《重置密码操作说明》](https://help.aliyun.com/zh/ecs/user-guide/reset-the-logon-password-of-an-instance)，重置一下密码，否则我们无法登陆服务器。

### 登陆服务器

获取密码后，我们尝试用命令行的方式登陆服务器：

```bash
# 语法：ssh 用户名@<实例的固定公网IP或EIP>

# 示例：
ssh root@39.100.83.124

# 输入实例登录密码
# 如果出现 Welcome to Alibaba Cloud Elastic Compute Service ! 表示成功连接到实例。
```

效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f956cbaa925499f88bb55c20c1a682a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1136\&h=292\&s=473278\&e=png\&b=0e0e0f)

当重新登陆的时候，又要输入一次密码，为了能够免密码登陆，我们配置下公钥：

```bash
# 在本地起一个终端，获取本地公钥
cat ~/.ssh/id_rsa.pub

# 登陆服务器，将获取的公钥写入服务器的 authorized_keys
echo "这里修改为你的公钥内容" >> ~/.ssh/authorized_keys
```

这样我们再次登陆的时候就不需要输入密码了。注意，我们写入的是 `~` 目录里，这就意味着如果我们切换了用户，是需要再按照这个方式重新配置一遍的。

登陆后如果我们一段时间没有操作，再操作的时候就会断开连接。为了长时间保持 SSH 会话连接不断开，需要设置下心跳以保持连接，运行：

```bash
vim /etc/ssh/sshd_config
```

添加配置项：

```bash
ClientAliveInterval 600      
ClientAliveCountMax 10
TCPKeepAlive yes
```

`ClientAliveInterval 600` 表示 每 600 秒发送一次请求， 从而保持连接。`ClientAliveCountMax 10` 表示服务器发出请求后客户端没有响应的次数达到 10 次，就自动断开连接。所以无响应的 SSH 客户端将在大约 600 x 10 = 6000 秒后断开连接。

重启 sshd 服务，使配置生效：

```bash
systemctl restart sshd
```

### 装个宝塔

各种环境（Nginx、Redis、MySQL 等）慢慢装其实也可以，但这里为了简单起见，我们直接装个[宝塔](https://www.bt.cn/new/index.html)。宝塔是一款简单好用的 Linux/Windows 服务器运维管理面板。使用宝塔，我们可以快捷的安装环境、查看文件、修改配置等。

登录服务器后，运行脚本：

```javascript
if [ -f /usr/bin/curl ];then curl -sSO https://download.bt.cn/install/install_panel.sh;else wget -O install_panel.sh https://download.bt.cn/install/install_panel.sh;fi;bash install_panel.sh ed8484bec
```

这里我们用的是万能安装脚本，适用于不确定使用哪个 Linux 系统版本的情况。其他脚本内容请参考[宝塔的安装说明](https://www.bt.cn/new/download.html)。

安装的时候需要输入一个 `y`进行确认：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f29367c79054c21b22f352f4242f6cc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1522\&h=582\&s=1295657\&e=png\&b=0e0d0f)

然后就是等待安装，大概 1 到 2 分钟左右会安装完。安装成功后，你会看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4103959480d14e57bcf43705e667fd50~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=956\&h=506\&s=764090\&e=png\&b=05121b)

**及时保存这些信息。** 出于安全考虑，宝塔使用的端口号是随机生成的端口号，从上图中可以看出，这次端口号开在了 14913，为了能够正常访问，需要在云服务器 ECS 的安全组中开启此端口号。

打开[服务器控制台](https://ecs.console.aliyun.com/securityGroup/region)：

![截屏2024-01-22 下午5.51.15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f06288cba4543b0bdc64eda5dc31b1f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3608\&h=1072\&s=242664\&e=png\&b=ffffff)

添加此端口号，我们顺便把后面会用到的 `3000`（项目开启在 3000 端口）、`80`（HTTP 默认端口）、`443`（HTTPS 默认端口）顺便也都开启了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8457fc67bfe448d6a027cf6e07e99783~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4378\&h=652\&s=210613\&e=png\&b=ffffff)

然后打开宝塔给出的外网面板地址，因默认启用自签证书 https 加密访问，浏览器将提示不安全，点击【高级】-【继续访问】或【接受风险并继续】访问。

然后输入命令行中给出的用户名和密码。第一次登录还需要勾选同意协议，并绑定宝塔账号。绑定后，会进入到宝塔的主界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93fa7e5a69084858b1c19a32dad3842e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3354\&h=1188\&s=236606\&e=png\&b=fdfdfd)

### Nginx、MySQL 与 Node

首次登录宝塔的时候，宝塔会给出**推荐安装套件**提示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4c7b05bdae04f1ea1035fbed1eb2e51~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2038\&h=1196\&s=237876\&e=png\&b=fefdfd)

当然你也可以在**软件商店**中一一安装：

![截屏2024-01-22 下午9.28.34.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c81033641414cb68ea1a37d9003f334~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3434\&h=1768\&s=702044\&e=png\&b=fcfafa)

这里我们至少需要把 Nginx 和 MySQL 安装了，至于 FTP、PHP、phpMyAdmin 则视个人情况选择。（我是直接在推荐的时候把 LNMP 都极速安装了。虽说是极速，安装还是需要一会的……）

然后安装 Node 环境。点击宝塔左侧的网站选项，打开 Node 项目，安装 Node 版本管理器：

![截屏2024-01-22 下午7.03.04.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4976c2596327444d842a9384868aefc4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3548\&h=560\&s=163610\&e=png\&b=fafafa)

如果列表中给出的 Node.js 版本比较老，你可以点击右侧的“更新版本列表”，选择一个合适的版本进行安装，这里我选择的是最新的稳定版 v20.11.0，选择后等待安装成功（安装的时候也会自动安装 PM2 模块）：

![截屏2024-01-23 下午2.48.45.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2589c2d7dcb24064a5463744f42ad453~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1876\&h=1486\&s=364174\&e=png\&b=fefefe)

注意安装完成后，图中的 **“命令行版本”** 要选择上，如果不选择的话，我们登录服务器，不会有 node 命令，也就是运行 node 相关的命令会报错。

### FTP

如果你安装了 FTP，可以使用 [FileZilla](https://filezilla-project.org/download.php) 这个 FTP 软件查看、编辑、上传、下载文件。Finder 虽然也可以连接 FTP 服务器，但无法上传、编辑、删除文件，功能有限。使用 FTP，首先要做一番配置：

打开[服务器控制台-安全组](https://ecs.console.aliyun.com/securityGroup/region)：

![截屏2024-01-22 下午5.51.15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/257d228592ce4b33972129b2c3d2ed00~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3608\&h=1072\&s=242664\&e=png\&b=ffffff)

添加 `20`、`21` 和 `39000-40000` 范围端口：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfbd717b0bd74b789d660552d993a90b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4406\&h=576\&s=178865\&e=png\&b=ffffff)

在宝塔的 **“安全”** 面板里也把这些端口添加一遍：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c3488328db4969ab55c77bf1407ae0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=5090\&h=1178\&s=431318\&e=png\&b=fdfdfd)

注：阿里云服务器的端口范围写法为 `39000/40000`，宝塔里的端口范围写法为 `39000-40000`，略有不同。

然后在 **“软件商店”** 中修改 PureFTPd 的设置：

![截屏2024-01-24 下午4.19.05.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/003490728cea4ccebfeba3102da6f2b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=5104\&h=1448\&s=657220\&e=png\&b=fdfbfb)

在“配置修改”里，搜索 `ForcePassiveIP`，然后将其值更改为服务器的 IP：

![截屏2024-01-24 下午4.21.44.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b8e1eca0cc44e1292d42cb73b43c61d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1438\&h=1354\&s=205246\&e=png\&b=f9f9f9)

回到宝塔的“FTP”界面，点击“添加 FTP”，添加一个用户名和密码，根目录设置为 `/www/wwwroot`，这是宝塔的默认建站目录，我们也会把项目的代码放到这个目录下。

![截屏2024-01-24 下午4.24.10.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a025106c5d9457599e4af8b56efb6be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2542\&h=1164\&s=226791\&e=png\&b=7c7c7c)

添加用户后，点击查看快速连接，根据提示使用 FTP 工具连接即可：

![截屏2024-01-24 下午4.26.31.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/205aa66c7711497d8cc3a0ddfea861c8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2632\&h=1460\&s=432004\&e=png\&b=7b7b7b)

成功连接后的效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cac2e403a9b24a66a3bd328cbc0e5ec4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2384\&h=1844\&s=601806\&e=png\&b=f9f9f9)

## 域名

### 买个域名

现在我们买个域名，购买域名可以参考[《一篇域名从购买到备案到解析的详细教程》](https://juejin.cn/post/7052257775270756366)。

假设我们已经购买并备案好了。在[阿里云域名控制台](https://dc.console.aliyun.com/next/index#/domain-list/all)可以查到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eb1ddd96e354327876b864cbb4e4502~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2048\&h=120\&s=38405\&e=png\&b=ffffff)

### 解析域名

现在我们把域名解析到我们的服务器地址上。点击左边的“解析”按钮，然后点击“添加记录”：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b581842b3f94816ad08190607b2d8f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512\&h=1170\&s=140885\&e=png\&b=fefefe)

这里我们用的是二级域名 `notes.yayujs.com`，记录值填写我们购买的服务器地址。添加后，应该很快就会生效。

### SSL 证书

阿里云提供免费的 SSL 证书（很多网站都提供的），最近证书的有效期从之前的 1 年改为了目前的 3 个月，虽然有些麻烦，但也能凑合着用。

参考[《VuePress 博客优化之开启 HTTPS》](https://juejin.cn/post/7051902149826969608)，搞一份免费证书：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eec3e1e0b0d74cbaba60954d07783c5b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4658\&h=990\&s=313958\&e=png\&b=ffffff)

点击“下载”，服务器类型选择 nginx，点击“下载”，会下载证书文件，包含一个 `.pem`文件，一个 `.key` 文件。

这两个文件留着备用，后面开启 HTTPS 会用到。

## 部署 Next.js 项目

### 本地检查

现在我们尝试部署我们的项目，首先要保证自己的项目本身没有问题。所以我们在本地先 `npm run build`，然后 `npm run start`检查一下运行。为了简单起见，我们可以在脚本里再添加一个 `prod`命令，修改 `package.json`：

```javascript
{
  "name": "next-react-notes-demo",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    // ...
    "prod": "next build && next start"
  },
  "dependencies": {
    // ...
  },
  "devDependencies": {
    // ...
  }
}

```

当运行 `npm run prod`的时候，就会先构建后运行，省的每次都要手动执行两个命令。

现在我们在本地运行生产版本，发现新建笔记的时候会报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbe19724f69d4214b5f5cf639b658c3e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1846\&h=184\&s=77726\&e=png\&b=1f1f1f)

在生产版本中，`next-auth` 并不认为 `localhost:3000`是值得信任的 Host，使用 `next-auth` 正常部署网站时，需要将 `NEXTAUTH_URL` 环境变量设置为网站的规范 URL：

    NEXTAUTH_URL=https://example.com

如果开发的时候确实没有正式的地址，可以在 `auth.js`中强行设置 `trustHost`。修改 `auth.js`，添加 `trustHost: true`配置项：

```javascript
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"
import CredentialsProvider from "next-auth/providers/credentials";
import { addUser, getUser } from "@/lib/prisma";

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers:[// ... ],
  pages: {
    signIn: '/auth/signin'
  },
  callbacks: {
  	// ...
  },
  trustHost: true
})
```

这样再运行 `npm run prod`的时候，就不会有 auth 报错了。不过我们既然已经有了域名，可以在根目录新建一个 `.env.production`文件，设置生产环境的 `NEXTAUTH_URL`：

```bash
AUTH_URL=https://notes.yayujs.com
```

这样部署线上的时候就不会报 untrustedHost 错误了。

注：next-auth v5 里，`AUTH_URL` 是 `NEXTAUTH_URL` 的别名。

### 创建 Git 项目

本地运行没啥问题，我们就可以把项目代码提交到服务器上。虽然可以连接服务器直接上传代码，但为了以后每次提交方便，我们在服务器上创建一个裸仓，这样每次更新代码，Git 提交到远程，服务器上的代码就会自动更新，这样使用起来更加方便。

登陆服务器，运行 `yum install git`，安装 Git，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1a0458b4515433692705fc2d15d72c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1020\&h=720\&s=384739\&e=png\&b=4c4c4c)

安装后，运行：

```bash
# 1. 进入目录，这是宝塔的默认建站目录
cd /www/wwwroot
# 2. 建个仓库文件夹
mkdir notes.git && cd notes.git
# 3. 创建裸仓库
git init --bare .
```

这个时候我们就获得了一个服务器上的仓库地址：

```javascript
root@39.100.83.124:/www/wwwroot/notes.git
```

这里我们使用 `git init --bare` 初始化仓库，它与我们常使用的 `git init` 初始化的仓库不一样，你可以理解为它专门用来创建远程仓库，这种仓库只包括 git 版本控制相关的文件，不含项目源文件，所以我们需要借助一个 hooks，在有代码提交到该仓库的时候，将提交的代码迁移到其他目录，这里我们在 `notes.git` 同级目录下创建了一个 `notes` 文件夹，用于存放提交的源代码文件：

```bash
# 1. 进入 hooks 目录
cd hooks

# 2. 创建并编辑 post-receive 文件
vim post-receive

# 3. 这里是 post-receive 写入的内容,注意根据自己的实际情况修改
#!/bin/bash
git --work-tree=/www/wwwroot/notes checkout -f

# 4. 赋予执行权限
chmod +x post-receive

# 5. 退出目录到 notes.git 同级目录并创建项目目录
cd ../../ && mkdir notes

```

如果顺利的话，现在在本地打开我们的 React Notes 项目， `commit` 提交代码后，运行：

```bash
git push -f root@39.100.83.124:/www/wwwroot/notes.git master
```

以后每次修改代码、提交代码后，运行这行，代码就会自动更新到服务器上。

此时服务端的 `notes` 文件夹应该有我们提交的代码了，我们可以通过宝塔的“文件”查看：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1939cca819444a6a49d62f6a3c8debf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3094\&h=1186\&s=336458\&e=png\&b=fcfcfc)

### MySQL 与 Prisma

目前服务器上的 MySQL 数据库还没有设置，我们直接在宝塔添加一个 MySQL 数据库：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92d52ef5d0b94e418edb21d86e409f11~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2110\&h=1240\&s=326260\&e=png\&b=aaaaaa)

这里我们创建了一个名为 `notes` 的数据库，用户名自动设置为 `notes`，你不能更改为 `root`。设置后你可以以 `notes` 用户加密码的方式访问这个数据库。这样我们写在 `env`中 `DATABASE_URL` 就要修改为：

```javascript
DATABASE_URL="mysql://notes:WKNSjB3DeNB4xYje@localhost:3306/notes"
```

当然，我们也可以改 `root` 密码，把 `root` 密码改为 `admin`，这样连代码都不用改了……

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdb91fab55ac460bab38a716b0a967f7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2352\&h=1028\&s=283549\&e=png\&b=ababab)

当然处于安全的角度考虑，最好还是使用 notes 用户。项目根目录新建一个 `.env.development`文件，代码如下：

```javascript
DATABASE_URL="mysql://root:admin@localhost:3306/notes"
```

`.env` 中设置线上的 DATABASE\_URL：

```javascript
// ...

DATABASE_URL="mysql://notes:i54f8znxfy2wh3w3@localhost:3306/notes"
```

还记得服务器代码修改的流程吗？本地代码修改后，正常运行 `git add`、`git commit` 命令后，运行：

```javascript
git push -f root@39.100.83.124:/www/wwwroot/notes.git master
```

服务器代码就会发生改变，你可以通过宝塔的“文件”面板或者 FTP 工具查看服务器上的文件。

因为我们代码中还使用了 Prisma，目前 MySQL 数据库只是新建了数据库，但没有同步数据模型，所以我们登录服务器进入项目目录：

```bash
# 1. 进入项目目录
cd /www/wwwroot/notes
# 2. 安装依赖
npm install
```

如果 `npm install` 有网络问题，可以设置 npm 镜像：

```javascript
# 设置成 npm 镜像
npm config set registry https://registry.npmmirror.com
# 改回来
npm config set registry https://registry.npmjs.org/
```

这个时候我们执行 prisma 相关的命令，我们先运行 `npx prisma -v` 试试，大概率会出现这个错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83bbaf8c241a42da8e4d9e393ea80a60~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1320\&h=172\&s=58726\&e=png\&b=4c4c4c)

如果出现这个错误，运行：

```bash
# 1. 编辑环境变量
vim ~/.bashrc
# 2. 添加环境变量
export PRISMA_ENGINES_MIRROR=https://registry.npmmirror.com/-/binary/prisma
# 3. 保存退出后运行
source ~/.bashrc
```

然后再次运行 `npx prisma -v`试试：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6d24ea75974232a37feaf0260acddb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1330\&h=584\&s=134792\&e=png\&b=4d4d4d)

这说明 prisma 已经可以正常使用了。此时我们的数据模型要同步数据库。

如果你把迁移时生成的 `prisma/migrations`下的文件也都提交了，那你可以在服务器上运行：

```bash
npx prisma migrate deploy
```

正常部署效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16086df0746e4cce978ab3d0ea88f4a5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=918\&h=596\&s=961230\&e=png\&b=0d171f)

然后运行 `npx prisma generate`初始化 Prisma Client：

```javascript
npx prisma generate
```

如果你没有提交，反正也是初始化，你可以运行：

```bash
npx prisma migrate dev
```

此时通过 Prisma，MySQL 的数据表也设置完毕。

### 开启项目

现在我们运行 `npm run prod`试试，应该能顺利的运行在 3000 端口：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32347ba92c52447f9eb18aeafc9c5466~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=952\&h=954\&s=1594889\&e=png\&b=0e1820)

然后这个时候访问 `http://39.100.83.124:3000/`可能还打不开，因为 3000 端口还没有开启，先在宝塔的“安全”面板上开启：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a55688027b014edbab5326f2aed7dd66~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3816\&h=958\&s=216602\&e=png\&b=fefefe)

我们之前只是在阿里云 ECS 的安全组中开启了 `3000`（项目开启在 3000 端口）、`80`（HTTP 默认端口）、`443`（HTTPS 默认端口），这里需要在宝塔里也开启一遍。

此时打开 `http://39.100.83.124:3000/` 应该能正常访问了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f72e8d7d82204a3e8bc10a2ebb28a7cf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1688\&h=1196\&s=149929\&e=png\&b=f5f6f9)

不过点击 `Sign In` 的时候还会报错，不着急，我们慢慢解决，先学习点基础知识。

### Screen 命令

现在我们先在服务器上关掉项目的 node 程序。如果 ssh 还在保持连接，会话还在，那直接 `control + c` 也就断开了。但如果 ssh 断开了连接，恢复之前的会话就有些麻烦了。搞不好还要先强行关闭 3000 端口：

```bash
# 1. 获取端口进程 PID
lsof -i:3000
# 2. 关闭 PID
kill -9 xxxx
```

这个时候就要说到 Screen 了。Screen 是 Linux 下的一个多重视窗管理程序。拥有多窗口、会话恢复、会话共享等功能。所谓会话恢复，对于远程登录的用户，即使连接中断，用户也不会失去对已经打开的命令行会话的控制。只用登录到服务器，运行 `screen -r`即可恢复会话。

登陆服务器，安装 Screen：

```bash
yum install screen
```

Screen 的命令并不多，简单介绍下常用到的：

Screen 的状态分为两种：Attached（前台运行） 和 Detached（后台运行）。

通过 `screen -S xxx`可以新建一个会话，并进入 Attached 状态。如果该程序要长期运行，但你要暂时离开该会话，`Control + A Control + D`，该会话就会进入 Detached 状态。当你再登陆进来的时候，可以通过 `screen -ls`查看有哪些会话，然后通过 `screen -r xxxx`恢复会话，将会话从 Detached 状态转为 Attached 状态。

如果你要进入 Attached 的会话，你需要先通过 `screen -d xxxx`，将其状态转为 `Detached`，才能通过 `screen -r xxxx` 进入会话。这个过程也可以合并成 `screen -d -r xxxx`一个命令。

如果你要删除某个 screen，运行 `screen -S xxxx -X quit`。

### PM2 命令

[PM2](https://pm2.keymetrics.io/) 是部署 node 项目常用的一个工具。正常我们要安装 pm2 这个模块，但我们在宝塔装 Node.js 版本管理器的时候，宝塔已经为我们安装了 PM2 模块，所以登陆服务器，直接就有 pm2 命令了，不信你运行 `pm2 -v`试试。

PM2 是一个 Node.js 进程管理器，使用 PM2，可以实现性能监控、自动重启、负载均衡等。让我们看下常用的命令吧：

```bash
# 启动
pm2 start app.js
# 声明一个名字
pm2 start app.js --name app_name
# 监听文件变化
pm2 start python-app.py --watch

# 列表
pm2 list
# 监控
pm2 monit

# 重载
pm2 reload app_name
# 重启
pm2 restart app_name
# 停止
pm2 stop app_name
# 删除
pm2 delete app_name
```

我们来看这样一个命令：

```javascript
pm2 start npm --watch --name notes -- run prod
```

这个命令的意思是以 pm2 开启 `npm run prod`脚本命令，此进程命名为 notes，并监听文件变化。

### 配置 Nginx 和 HTTPS

现在回到我们的项目上。在宝塔的“网站”面板中添加 Node 项目，相关配置如图：

![截屏2024-01-24 下午8.17.54.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/436a9d9f02fc428da2778dee409b957b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2804\&h=1922\&s=464654\&e=png\&b=a8a8a8)

添加成功后：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3faedbe5a26141b0924733f0f4ddcf31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4704\&h=412\&s=134405\&e=png\&b=fcfcfc)

此时宝塔已经为我们的项目做好了 Nginx 配置，可以在设置中查看：

![截屏2024-01-24 下午8.26.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d092c3d4c091444aa0f015170eef1b17~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2814\&h=1778\&s=628252\&e=png\&b=e9e9e9)

宝塔做的 Nginx 配置为监听 `notes.yayujs.com` 的 `80`端口，然后代理到 `http://127.0.0.1:3000`。

我们在 Screen 中运行我们的 Next.js 项目吧：

```bash
# 1. 登陆服务器
screen -S notes
# 2. 进入程序目录
cd /www/wwwroot/notes
# 3. 运行脚本
pm2 start npm --watch --name notes -- run prod
```

稍等一会，等待编译构建完成，我们再访问 `http://notes.yayujs.com/`应该可以正常运行了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b979a9506ba641c99872f4524323d24e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2308\&h=866\&s=118073\&e=png\&b=f5f7fa)

但是当我们点击 `Sign In`的时候，依然会报错。服务器上的报错为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b4f4a29901645eea47d82ce474e3e69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1724\&h=118\&s=295724\&e=png\&b=03070c)

之所以会有这个报错，是因为我们的 Nginx 配置中 `x-forwarded-host`标头带了端口号，在宝塔上修改 Nginx 配置，把下图中标示的 `$server_port` 去除即可。

![截屏2024-01-24 下午8.37.31.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85a332d95da34e10adca1c85ea043ef5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1702\&h=1558\&s=407041\&e=png\&b=fcfcfc)

`Ctrl+S` 保存后，Nginx 配置就会自动生效。此时再访问 `http://notes.yayujs.com/`，点击 `Sign In`，虽然还是报错，但至少不报刚才那个错了……哈哈哈哈

现在让我么来解决 HTTPS 的问题吧。点击 Node 项目的“未部署”按钮：

![截屏2024-01-24 下午8.42.08.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca948408de724a838431a421d4550f85~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2968\&h=1910\&s=499021\&e=png\&b=a9a9a9)
还记得之前在阿里云服务器上下载的 `.key` 和 `.pem`文件吗？用编辑器打开这两个文件，将这两个文件中的内容复制到这两个输入框中，然后点击“保存并启用证书”。宝塔会自动更新 Nginx 配置：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c7092f89b24612ae5ed10e76c634b1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1790\&h=630\&s=173760\&e=png\&b=fbfbfb)

可以看到，Nginx 配置更新，监听 HTTPS 的 443 端口，代理到 3000 端口。

此时访问 `https://notes.yayujs.com/`，依然可以正常访问，不仅如此，点击 `"Sign In"` 也能正常登录了，项目运行正常：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad8ccb48f17e49fabb629da9ffed322c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2594\&h=858\&s=143887\&e=png\&b=ffffff)

此外，因为我们使用的是 pm2 运行的项目，并设置了监听文件变化，所以当你通过 `git push -f root@39.100.83.124:/www/wwwroot/notes.git master`推送代码到服务器的时候，因为文件变化，pm2 会自动重启该应用。

### 宝塔 Nginx

关于宝塔的 Nginx，我们多说一点，了解就行，以防万一用到。

正常我们登陆服务器直接安装 Nginx，比如参考[《一篇从购买服务器到部署博客代码的详细教程》](https://juejin.cn/post/7049692191110725645)中的方式，Nginx 的配置文件是放在 `/etc/nginx`目录下的。但是宝塔装的 Nginx 并没有放在该目录下。

此外，因为宝塔面板内有些包是未托管到服务器 systemd 包管理内的，所以 systemctl 是无法正常使用的。也就是说，使用 `systemctl status nginx.service`这种命令是无法准确判断 nginx 状态的，当然也无法重启重载等。

宝塔的 Nginx 安装在了 `/www/server/nginx`，配置文件在 `/www/server/nginx/conf/nginx.conf`，其内容可以通过目录直接查找，也可以在 Nginx 的设置中查看：

![截屏2024-01-24 下午9.05.10.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ab8ddb8e5914ca8a3487bc9d6373fb5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2960\&h=1834\&s=662986\&e=png\&b=d0cfcf)

这是 nginx 的主配置文件，在这个文件中底部有一句：

```bash
 include /www/server/panel/vhost/nginx/*.conf;
```

打开此目录：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dfaa4edc53e4cc68b06b9d99194ecc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2628\&h=706\&s=161436\&e=png\&b=fbfbfb)

这其实就是我们具体项目的 Nginx 配置，可以在具体项目的设置里查看：

![截屏2024-01-24 下午8.26.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed87ea0b25e340f79668b030ba92f179~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2814\&h=1778\&s=628252\&e=png\&b=e9e9e9)

如果你要操作宝塔的 Nginx 配置，可以在命令行中运行：

```bash
# 启动
/etc/init.d/nginx start

# 停止
/etc/init.d/nginx stop

# 重启
/etc/init.d/nginx restart

# 重载
/etc/init.d/nginx reload
```

## 参考链接

1.  <https://juejin.cn/post/7049692191110725645>
2.  <https://authjs.dev/getting-started/providers/oauth-tutorial#setting-up-nextauth_url>


## 48.实战篇 | React Notes | Docker 快速入门

## 前言

假设我们的项目做完了，现在该部署上线了。因为项目用到了 MySQL 等技术，我需要在服务器上也安装一遍环境。这……好麻烦……

假如我把代码提交到 GitHub，其他同学为了查看效果，也要把环境安装一遍。这……好麻烦……

有没有更简单的解决方案？

这就要说到 Docker 了。Docker 应该是目前最流行的容器解决方案。Docker 会把项目和项目的依赖，包括运行环境等，都打包到一个文件中。运行这个文件，会生成一个虚拟容器，我们的项目就在这个虚拟容器里运行。

这样当在服务器或者其他电脑上运行的时候，不需要直接运行项目代码，而是运行包含环境的打包文件，这样就避免了再次安装环境的困扰。

## 理解 Docker

现在让我们开始学习 Docker 吧！

**Docker 有三个核心概念：镜像（Image）、容器（Container） 和仓库（Repository）。**

Docker 会把应用程序及其依赖，都打包在名为镜像（Image）的文件中。Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

而镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，**镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8399c2442b8452a96cf7aa85f7e11b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=652\&h=404\&s=43261\&e=png\&b=ffffff)

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。

在本地制作好镜像后，我们可以将镜像推送到远程仓库（Repository）。仓库分为公开仓库和私有仓库，最大的公开仓库是 Docker 的官方仓库 [Docker Hub](https://hub.docker.com/)。这一点跟 Git 就很相似了，最大的 Git 公开仓库是 GitHub。

## 使用 Docker

安装 Docker 最快捷的方式就是使用 Docker 客户端了。下载 Docker：<https://docs.docker.com/get-docker/>

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ffa048dfed341ccaaaa1f56880812f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1440\&h=680\&s=204191\&e=png\&b=d9eaf9)

下载安装完成后，本地应该就有 `docker` 命令了，运行 `docker -v`试试。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/644fc92d1682472790e4a76fda52ee16~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=574\&h=72\&s=46170\&e=png\&b=0b041a)

国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，可用的加速器可以参考：<https://gist.github.com/y0ngb1n/7e8f16af3242c7815e7ca2f0833d3ea6>。操作方式如下：

![截屏2024-01-30 16.06.39.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f1c1e8ea88f4286abc93b70aa16be32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2506\&h=1534\&s=433320\&e=png\&b=f8f8f9)

添加代码如下（这是我目前在用的，如果构建或者拉取的时候因为网络原因失败，就参考上面的文档更换新的加速器）：

```javascript
{
  // ...
  "max-concurrent-downloads": 2,
  "max-download-attempts": 10,
  "registry-mirrors": [
      "https://dockerproxy.com",
      "https://docker.mirrors.ustc.edu.cn",
      "https://docker.nju.edu.cn"
  ]
  // ...
}
```

## 入门 Docker

没有用过 Docker 的同学，让我们开始一个 30 分钟速度入门教程吧：

本地创建一个新的 Next.js 项目，运行：

```bash
npx create-next-app@latest
```

效果如下（这里怎么选都行，项目能正常运行就行）：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/facae27227084f78a2d8260cf714139f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082\&h=400\&s=777895\&e=png\&b=17272d)

根目录新建 `.dockerignore`，写入：

```bash
Dockerfile
.dockerignore
node_modules
npm-debug.log
README.md
.next
docker
.git
```

作用类似于 `.gitignore`，排除不必要的文件和目录，以便在构建 Docker 镜像时，减小镜像大小并提高构建效率。

根目录新建 `Dockerfile`，写入：

```javascript
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install --registry=https://registry.npmmirror.com && npm run build
CMD npm start
EXPOSE 3000
```

`Dockerfile` 是一个文本文件，用于定制镜像文件。其内的每一行都是一句指令（Instruction）。完整的指令和其含义可以参考 [Dockerfile reference](https://docs.docker.com/engine/reference/builder/#dockerfile-reference)。这里简单说说用到的指令：

`FROM` 用于指定基础镜像。所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。

在 [Docker Hub](https://hub.docker.com/search?q=\&type=image\&image_filter=official)上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 [nginx](https://hub.docker.com/_/nginx/)、[redis](https://hub.docker.com/_/redis/)、[mongo](https://hub.docker.com/_/mongo/)、[mysql](https://hub.docker.com/_/mysql/)、[httpd](https://hub.docker.com/_/httpd/)、[php](https://hub.docker.com/_/php/)、[tomcat](https://hub.docker.com/_/tomcat/)等；也有一些方便开发、构建、运行各种语言应用的镜像，如 [node](https://hub.docker.com/_/node)、[openjdk](https://hub.docker.com/_/openjdk/)、[python](https://hub.docker.com/_/python/)、[ruby](https://hub.docker.com/_/ruby/)、[golang](https://hub.docker.com/_/golang/)等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。

这里我们选择了 `node:18-alpine` 这个镜像，node 完整的镜像版本和标签可以查看 [Docker Hub node](https://hub.docker.com/_/node)。这里之所以选择了 `18-alpine` 是参考了 [Next.js 的官方 Docker 示例代码](https://github.com/vercel/next.js/tree/canary/examples/with-docker)。

`WORKDIR`用于指定 Docker 的工作目录。如该目录不存在，WORKDIR 会帮你建立目录。

`COPY` 用于将文件拷贝到 Docker。第一个点表示源路径，第二个点表示目标路径。目标路径可以是容器内的绝对路径，也可以是相对于工作目录的相对路径，而工作目录可以用 `WORKDIR` 指令来指定。所以这个指令的意思就是简单粗暴的将当前目录的所有文件拷贝到 `/app`下。

`RUN` 用于执行命令行命令。这里我们安装了项目依赖。

`CMD` 用于指定容器启动命令。RUN 可以有多个，在镜像构建阶段执行。CMD 只能有一个，在容器启动后执行。前面说到，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。

`EXPOSE` 用于声明容器运行时提供服务的端口。不过这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。但可以帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。

进入项目根目录，运行命令，构建镜像文件：

```javascript
docker image build -t next-docker-learn-demo:0.0.1 .
```

`-t` 参数用来指定镜像文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是 `latest`。最后面还有一个 `.`，用于指定上下文路径。

多说一句：

1.  `docker build` 看似是在本地构建，其实是在服务端，也就是在 Docker 引擎中构建的，所以构建的时候需要加速器
2.  为了能够让服务端知道本地文件的位置，就需要指定上下文路径（也就是最后的 `.`），Docker 会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件

举个例子，如果在 Dockerfile 中这么写：`COPY ./package.json /app/`。这并不是要复制执行 `docker build `命令所在的目录下的 `package.json`，也不是复制 `Dockerfile` 所在目录下的 `package.json`，而是复制指定的上下文路径下的 `package.json`。

总结一下就是：构建不要浪。把 Dockerfile 写在项目根目录下，将所需的文件也都拷贝在根目录下，指定项目根目录为上下文路径。

构建效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/836cc4b8e4b54f888006d1412a92e8bf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2548\&h=996\&s=2560425\&e=png\&b=120620)

构建了 2 分多钟吧。如果出现网络问题，关闭代理试试。构建完成后，可以在 Docker 客户端中查看：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60c4c3fae339406ea4ed765391aa0317~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2226\&h=1200\&s=315728\&e=png\&b=f8f8f9)

也可以在本地执行 `docker images` 查看镜像列表：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5cdaaff86ad64e73a95fc879730230d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1250\&h=108\&s=121056\&e=png\&b=060211)

现在有了镜像，我们开启一个容器运行我们的项目：

```javascript
docker run -p 4000:3000 next-docker-learn-demo:0.0.1
```

`-p` 用于指定端口映射，这里的意思是将容器的 `3000` 端口映射到主机的 `4000` 端口，此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f381f7b10aea4180bb7cf3329d8e3a07~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1354\&h=342\&s=511507\&e=png\&b=210b2a)

容器里项目正常运行，开在了容器的 3000 端口，映射到本地的 4000 端口，所以我们在本地打开 <http://localhost:4000/>，此时正常访问项目：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/57e1badcbd3f47ccb8681ae116392ff6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2298\&h=1492\&s=457684\&e=png\&b=050505)

查看 Docker 客户端：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8420d57ffbd547f180873e4ffcf7b618~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2376\&h=1200\&s=354186\&e=png\&b=13171b)

我们可以对启动的容器进行启动、停止、删除等操作：

```bash
# 容器列表
docker container ls
# 停止容器
docker container stop container-id
# 启动容器
docker container start container-id
# 重启容器
docker container restart container-id
# 删除容器
docker container rm container-id
```

当然也可以直接在客户端中操作。

现在你已经有了一个镜像。就像 npm 包发布到 npm 上，你也可以将镜像发布到 Docker Hub。

首先去 <https://hub.docker.com/> 注册一个账户，当然你也可以在使用客户端的时候注册登录账号。运行 `docker login`，因为我已经在 Docker 客户端登录，执行效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82c77e2b6eb34117b20d9c63c9177797~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=684\&h=110\&s=102922\&e=png\&b=200e2a)

使用 `dcoker image tag` 标记本地镜像，将其归入某一仓库，运行：

```bash
# 格式如下：
# docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]
# 其中 yayu007 是我的 Docker Hub 账户名
docker image tag next-docker-learn-demo:0.0.1 yayu007/next-docker-learn-demo:0.0.1
```

\`
推送到 Docker Hub：

```bash
# 格式如下：
# docker image push [OPTIONS] NAME[:TAG]
docker image push yayu007/next-docker-learn-demo:0.0.1
```

效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ee85bd9805e4e5996780784cda97d10~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1524\&h=346\&s=596020\&e=png\&b=180725)

发布完毕后，你可以在 Docker 客户端的 Images 下的 Hub 选项栏中查到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45e6c3f790be46c78091d7f3a830fdb8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2744\&h=1200\&s=334441\&e=png\&b=14191d)

对应的链接为：<https://hub.docker.com/layers/yayu007/next-docker-learn-demo/0.0.1/images/sha256:50b1b7cf09b4147ef60c14cd2297bbad441c1be8b55cd10a0e06be1e87cc9bb6>

推送到 Docker Hub 后，其他人就可以直接拉取我的镜像文件：

```bash
docker image pull yayu007/next-docker-learn-demo:0.0.1
```

然后运行 `docker run` 开启项目：

```bash
docker run -p 4000:3000 next-docker-learn-demo:0.0.1
```

## 入门 Docker Compose

实际开发中，肯定不会只用到 Next.js，还会用到 Nginx、Redis、MySQL 等环境。这里我们以 React Notes 的 day1 代码为例，演示如何开启并使用多个容器。

### 本地运行

下载我们的 day1 分支代码：

```bash
git clone -b day1 git@github.com:mqyqingfeng/next-react-notes-demo.git
```

大家还记得 day1 实现的效果吗？我们本地运行以下代码：

```bash
cd next-react-notes-demo && npm i && npm run dev
```

因为 day1 代码需要开启 redis 服务，所以另起一个命令行运行：

```bash
redis-server
```

等 Redis 服务成功开启，此时打开 <http://localhost:3000/>，页面正常访问：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3dc782394f143489bcbcf4a5ddd9ae7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1800\&h=1188\&s=159776\&e=png\&b=f6f7fa)

左侧笔记列表的标题和时间取自于 Redis 数据库，说明代码运行正常。

### Redis 容器化

现在我们把 Redis 改为容器运行。先在刚才开启 redis-server 的窗口按 `Ctrl + C` 退出 Redis 服务，然后拉取 [redis](https://hub.docker.com/_/redis/) 镜像：

```bash
docker pull redis
```

当我们不带标签的时候，默认拉取的是 `redis:latest`。

镜像拉取完毕后，开启容器：

```bash
docker run -p 6379:6379 redis redis-server
```

这里我们将 Redis 开启的 6379 端口映射到本地的 6379 端口，替换掉了刚才在本地开启的 redis-server，所以此时访问 <http://localhost:3000/>，页面依然正常运行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4a64bb905434da4864ab373a8f0cfa5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1800\&h=1188\&s=160248\&e=png\&b=f6f7fa)

### Next 项目容器化

现在我们将 Next.js 项目改为容器运行。前面我们讲过：

> 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。

所以 Next.js 容器与 Redis 容器是相互隔离的。为此，我们需要实现容器互联。Docker 推荐将容器加入自定义的 Docker 网络的方式来连接多个容器。

创建一个自定义的网络：

```bash
docker network create -d bridge react-notes
```

`-d` 参数指定 Docker 网络类型，有 `bridge`、`overlay`。其中 `overlay` 网络类型用于 [Swarm mode](https://yeasy.gitbook.io/docker_practice/swarm_mode)。`react-notes` 为我们的自定义网络的名字。运行效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8298da7ba3fc46f793886a0d57cf341d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=936\&h=68\&s=90247\&e=png\&b=160723)

我们在 Docker 客户端暂停或者删除之前开启的 Redis 容器，然后命令行运行一个新的 Redis 容器并连接到新建的 `react-notes` 网络：

```bash
docker run -p 6379:6379 --network react-notes redis redis-server
```

然后运行 `docker network inspect`查找 redis 容器的 IP 地址：

```bash
docker network inspect react-notes
```

![截屏2024-01-31 18.14.21.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96b61d96c252405da826a935ed810daf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1550\&h=1332\&s=1978503\&e=png\&b=0f051d)

修改 `lib/redis.js`如下：

```bash
// ...
const redis = new Redis({
  host: '172.19.0.2'
})
// ...
```

项目根目录新建 `Dockerfile`，代码如下：

```bash
FROM node:18-alpine
WORKDIR /app
COPY . .
RUN npm install --registry=https://registry.npmmirror.com
CMD  npm run build && npm start
EXPOSE 3000
```

创建项目镜像：

```bash
docker image build -t next-react-notes-demo:0.0.1 .
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd2b8c1d6b1f4285840e2df9d83bfcc0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1298\&h=716\&s=791104\&e=png\&b=080316)

运行项目容器并添加到 react-notes 网络中：

```bash
docker run -p 4000:3000 --network react-notes next-react-notes-demo:0.0.1
```

等 Redis 服务成功开启，此时打开 <http://localhost:4000/>，页面正常访问：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dc213b7f08a420194f40efa926e9153~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2448\&h=1602\&s=207315\&e=png\&b=f5f7fa)

### Docker Compose

如果让我们像这样一个个管理容器，着实有点麻烦，Docker 提供了 [Docker Compose](https://github.com/docker/compose?tab=readme-ov-file#docker-compose-v2) 用于容器的管理。使用 Compose，你只需要通过一个单独的 `docker-compose.yml`文件就可以定义一组相关联的应用容器。

Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。本地运行 `docker-compose --version`试试：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b9f6bf964bb4ba0822c5045d0f75883~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=790\&h=68\&s=72461\&e=png\&b=110620)

现在我们使用 Docker Compose 重新运行这个项目。项目根目录新建 `docker-compose.yml`文件，代码如下：

```javascript
version: '3.8'
services:

  redis:
    image: redis
    ports:
      - '6379:6379'
    command: redis-server
    
  nextapp:
    build: .
    ports:
     - '4000:3000'
    depends_on:
      - redis
```

模板文件的各种指令含义可以参考 [《Compose 模板文件》](https://yeasy.gitbook.io/docker_practice/compose/compose_file)。

上节创建的 `Dockerfile` 代码保持不变。修改 `lib/redis.js`：

```javascript
// ...
const redis = new Redis({
  host: 'redis'
})
// ...
```

最后根目录运行：

```bash
docker-compose up
```

运行这个命令，它会尝试自动完成包括构建镜像、（重新）创建服务、启动服务，并关联服务相关容器的一系列操作。大部分时候都可以直接通过该命令来启动一个项目。此时应该可以正常运行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d00e54ef1734251bb487a7cc8371e95~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2448\&h=1602\&s=207315\&e=png\&b=f5f7fa)

## 数据持久化

### Redis

现在我们已经用 Docker Compose 开启了一个 Redis 容器，但其中 Redis 的数据并不是持久的，一旦容器删除，数据也就丢失了。因为 day1 分支的代码还没有实现增删查改功能，所以我们使用 `docker exec` 进入容器进行操作：

```bash
# 查看 redis 容器的 container id
docker container ls
# 进入 redis 容器
docker exec -it b0a18 bash
```

其中 `-it`是 `-i` 和 `-t` 一起使用，用于开启一个交互模式的终端。如果出现这样的报错：

> OCI runtime exec failed: exec failed: unable to start container process: exec: "bash": executable file not found in \$PATH: unknown

可以改为使用 `docker exec -it b0a18 sh`试试。

当然最简单的方式还是使用客户端：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85928ea7bf3749fcb5e9a846e01dcccb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2236\&h=1512\&s=307557\&e=png\&b=000000)

使用哪种方式都行，现在我们进入容器删除一条数据：

```bash
# 开启 cli
redis-cli
# 查看 keys
keys *
# 查看 notes 数据
hgetAll notes
# 删除一条数据
hdel notes 1702459181837
# 再次查看数据
hgetAll notes
```

操作效果如下：

![截屏2024-02-01 23.14.56.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/223e0f10aa96453f83d84c13670900d0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2588\&h=802\&s=1725016\&e=png\&b=220d3b)

现在我们已经删除了一条数据，不过打开 `http://localhost:4000/`，你会发现左侧的笔记列表数据不会有任何变化，这是 Next.js 编译的缘故，在 Next.js 编译页面的时候数据库有三条，所以我们重新编译一下 Next.js 项目试试。

先按 Ctrl + C 退出 Cli 界面，然后 Ctrl + A Ctrl + D 退出交互终端。运行：

```bash
# 查看 Next.js 项目的 container id
docker container ls
# 重启容器
docker container restart 74776b12c032
```

交互效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/981d4a9f54d04e328d9c7469147d2cb6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2298\&h=212\&s=377368\&e=png\&b=200c3d)

现在重新打开 <http://localhost:4000/>，数据确实少了一条：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b692c94901d642508f99bb3d88365b81~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2024\&h=1194\&s=160003\&e=png\&b=f6f7fa)

然后我们删了所有容器，再重新开一个：

```bash
# 停止并删除所有容器
docker-compose down
# 运行容器
docker-compose up
```

交互效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85402ed4aae6432daad5de6a9ed1bfeb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1656\&h=722\&s=1081845\&e=png\&b=1f0c3b)

现在重新打开 <http://localhost:4000/>，页面又恢复到了初始生成的三条，也就是说，操作的数据全丢了，一切又从头开始了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ee1b30ea2b74ce4bcef61a6de6cac21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2022\&h=1192\&s=165176\&e=png\&b=f6f7fa)

所以我们需要数据持久化。那么怎么实现数据持久化呢？

我们将容器里的数据库数据同步到主机的文件中不就可以了吗？Docker 提供了名为数据卷（volumes）的功能，它会将数据存在主机文件系统的某个区域，该区域由 Docker 来进行管理，其他非 Docker 程序不要乱动其中的数据。

现在我们在项目的根目录下建立一个名为 `redis`的文件夹，在其中再建立一个名为 `data`的文件夹存放数据。修改 `docker-compose.yml`如下：

```yaml
version: '3.8'
services:

  redis:
    image: redis
    ports:
      - '6379:6379'
    command: redis-server
    volumes:
      - ./redis/data:/data
    
  nextapp:
    build: .
    ports:
     - '4000:3000'
    depends_on:
      - redis
```

其中`./redis/data:/data`表示将一个地址为 `./redis/data`的 volume 挂载到 Redis 容器的 `/data`目录。这个目录正是 Redis 存放数据的地方。镜像中的被指定为挂载点的目录中的文件会复制到数据卷中。

现在我们删除掉之前的镜像，再重新构建的镜像，因为数据做了持久化，再重复一遍刚才的操作再次打开地址的时候，数据还会是之前的两条。

`/redis/data`会在运行 `docker-compose down` 的时候产生一个 `dump.rdb`文件。这个文件是二进制文件，正是 Redis 数据的全量备份。运行 `docker-compose up` 的时候，redis 又会读取加载这个文件，由此实现了数据持久化。

注：为什么是 `dump.rdb` 这个文件就要说到 Redis 的持久化机制了。Redis 的持久化机制有两种，一种是 RDB（Redis Database），一种是 AOF（Append Only File）。简单的理解：RDB 是一次快照，AOF 是连续增量备份。默认是 RDB，开启 Redis 容器时的 `--appendonly` 参数开启的正是 AOF。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18f0a49cc00547f087e496ecb1a57def~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1236\&h=386\&s=73936\&e=png\&a=1\&b=2c242f)

### 数据卷

目前我们是随便指定了一个目录作为数据卷，其实 Docker 本身就提供了创建数据卷的方法：

```bash
docker volume create my-vol
```

查看数据卷：

```bash
docker volume ls
```

该数据卷其实也对应了主机的一个位置，运行：

```bash
docker volume inspect my-vol
```

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4de46ceda7a4a10ba60ccb1e96dda98~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=942\&h=416\&s=302499\&e=png\&b=260d3f)

可以看出，创建的数据卷的地址为 `/var/lib/docker/volumes/my-vol/_data`。

我们先看下如何在 `docker-compose.yml` 文件中使用：

```bash
version: '3.8'

volumes:
  redis-data:

services:

  redis:
    image: redis
    ports:
      - '6379:6379'
    command: redis-server
    volumes:
      - redis-data:/data
    
  nextapp:
    build: .
    ports:
     - '4000:3000'
    depends_on:
      - redis
```

其中：

```bash
volumes:
  redis-data:
```

用来创建名为 `redis-data` 的数据卷，使用 `- redis-data:/data`挂载到容器。

我们删除掉之前的镜像，重新构建镜像文件。其实也不用像刚才那样删除容器再开启容器，之前只是为了帮助大家学习一些操作命令，其实把 redis 容器重启一下就会产生备份数据。

那这次数据卷对应的本机的位置在哪里呢？

刚才演示创建的 `my-vol`的地址在 `/var/lib/docker/volumes/my-vol/_data`，那 `redis-data` 的地址应该在 `/var/lib/docker/volumes/redis-data/_data`，我们试着 inspect 一下。

你会发现，发现找不到 `redis-data` 这个卷，其实是因为名字写错了，完整的名字应该是 `next-react-notes-demo_redis-data`，中间用下划线连接：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ddb46f339e04d4c92d601939b1cc42e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1348\&h=654\&s=760592\&e=png\&b=30103d)

但 MacOS 下打开这个地址，你会发现并没有这个目录。这是因为 Docker 放在了虚拟机（VM）里，我们运行：

```bash
# 开启容器
docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh
# 进入目录
cd /var/lib/docker/volumes
# 查看文件
ls
# 再进入相关的目录
cd next-react-notes-demo_redis-data/_data
# ls
```

交互效果如下：

![截屏2024-02-02 11.00.33.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e893391babc47488005859ee6670444~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1360\&h=1026\&s=1439957\&e=png\&b=2b0f3d)

### Redis 配置

Docker 中使用 Redis 都已经介绍了这么多，来都来了，我们再介绍一下 redis 容器如何使用 redis 配置文件。

首先搞一个配置文件，有两种方式：

1.  打开 <https://redis.io/docs/management/config/> 保存一个对应版本的 `redis.conf`文件

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ecf9df3696945cdb1c9ee66ba0d0f48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2688\&h=1322\&s=683964\&e=png\&b=ffffff)

注：不知道你的 Redis 版本？就是你拉取 Redis 镜像的那个版本，默认是 `latest`，目前是 `7.2.4`，可以在 [Docker Hub Redis](https://hub.docker.com/_/redis) 中查看。此外容器启动的时候也会显示版本：

![截屏2024-02-02 11.34.37.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6286dbd13ab7431eae82d25b72d9fe71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2266\&h=632\&s=209589\&e=png\&b=f6f6f7)

进入容器使用 `redis-cli`输入 `info`命令也行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/911c4d32deac4193a008b77650a8bfe0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2732\&h=676\&s=186078\&e=png\&b=f7f7f8)

2.  下载 redis 压缩包，地址为：<http://www.redis.cn/download.html>  或者 <https://download.redis.io/releases/>，下载后解压会在项目根目录看到一个 `redis.conf`文件

将这个配置文件放到项目根目录 `/redis`下（放其他位置也行）。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/239fce35598a4aa791b2e194af033d9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1234\&h=376\&s=66974\&e=png\&a=1\&b=fefefe)

修改 `redis.confg`，因为下载的文件是默认配置项，用在容器时，需要修改一些：

```bash
# 这句要注释掉，127.0.0.1 是本机 IP，只能容器内部使用 redis，因为需要外部连接，所以注释掉
# bind 127.0.0.1 ::1

# 默认情况下，Redis 不作为守护进程运行
daemonize no

# 关闭保护模式，会阻止外部连接
# protected-mode yes
```

还有些其他的（视情况选择）：

```bash
# 开启 AOF 持久化
appendonly yes
# 开启密码，注释表示不需要密码
# requirepass foobared

# 指定 redis 最大内存
maxmemory 500mb
# 当内存到达上限，使用 LRU 算法删除部分 key，释放空间
maxmemory-policy volatile-lru
```

修改 `docker-compose.yml`：

```bash
version: '3.8'

volumes:
  redis-data:

services:

  redis:
    image: redis
    ports:
      - '6379:6379'
    command: redis-server /etc/redis/redis.conf
    volumes:
      - redis-data:/data
      - ./redis:/etc/redis
    
  nextapp:
    build: .
    ports:
     - '4000:3000'
    depends_on:
      - redis
```

删除之前的容器，重新构建镜像运行，查看 Redis 容器日志：

之前是：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95a6303bb39b4b97aa1d22b5d0591960~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2156\&h=306\&s=141346\&e=png\&b=ffffff)

会变成：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9412538163c240f4a431eb765277c768~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2004\&h=120\&s=57922\&e=png\&b=ffffff)

此外容器启动的时候如果有这个 warning：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6a98346d4f64f2ea41b7b30298b4cb3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2192\&h=162\&s=78455\&e=png\&b=ffffff)

可以参考 <https://github.com/docker-library/redis/issues/346> 和 <https://github.com/nextcloud/all-in-one/discussions/1731> 修复这个 warning。

## 总结

那么今天的内容就结束了，本篇以 Docker 部署一个简单的带 redis 数据库的 Next.js 项目为例，带大家熟悉 Docker 和 Docker Compose 的常用命令，以及如何做数据持久化。熟悉 Docker 的同学就请直接进入下篇实战篇吧！

## 参考链接

1.  <https://yeasy.gitbook.io/docker_practice/>
2.  <https://dunwu.github.io/linux-tutorial/docker/>
3.  <https://github.com/docker-library/redis/issues/45>
4.  <https://redis.io/docs/management/persistence/>
5.  <https://hub.docker.com/_/redis>


## 49.实战篇 | React Notes | Docker 部署

## 前言

本篇我们讲解使用 Docker 部署我们的 Next.js 项目。

## Docker 直接部署

如果只是把项目部署上去，其实并不复杂。我给大家一个简单的、用于理解学习、演示核心要点的示例：

### 下载代码

我们以 Day11 分支的代码为例，此时我们的代码中使用了 Prisma + MySQL。

下载我们的 day11 分支代码：

```bash
git clone -b day11 git@github.com:mqyqingfeng/next-react-notes-demo.git
```

先本地运行一下，验证代码无问题：

```bash
# 注意本地开启 MySQL 后运行：
npm i && npm run dev
```

### 构建镜像

项目根目录新建 `.dockerignore`文件，代码如下：

```bash
Dockerfile
.dockerignore
node_modules
npm-debug.log
README.md
.next
docker
.git
```

项目根目录新建 `Dockerfile`，代码如下：

```bash
FROM node:18-alpine

WORKDIR /app

COPY . .

RUN npm install --registry=https://registry.npmmirror.com

RUN npx prisma generate

RUN chmod +x /startup.sh

EXPOSE 3000

ENTRYPOINT ["/startup.sh"]
```

注意：这里的镜像构建指令并不复杂，相信大家有[《实战篇 | React Notes | Docker 快速入门》](https://juejin.cn/book/7307859898316881957/section/7330567768579637299)的基础，都很容易理解。关于最后一句指令，我们并没有使用 `CMD`，而是 `ENTRYPOINT`，两者作用类似。使用 `ENTRYPOINT`，我们将执行内容放到了脚本文件 `startup.sh`中。

项目根目录新建 `startup.sh`文件，代码如下：

```bash
#!/bin/sh

MIGRATION_STATUS=$(npx prisma migrate status)

if echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then
    echo "No migrations needed."
else
    echo "Running migrations..."
    npx prisma migrate deploy
fi

npm run build && npm run start
```

执行的内容并不复杂，主要是因为我们使用了 Prisma，所以需要运行 `prisma generate`和`prisma migrate deploy`。`prisma generate`我们已经放到了构建指令中，`prisma migrate deploy`我们放到了运行脚本中。

项目根目录新建 `docker-compose.yml`文件，代码如下：

```bash
version: "3.9"

networks:
  react-notes:
    driver: bridge

services:

  mysql:
    image: mysql:8.0
    container_name: mysql
    command: --default-authentication-plugin=caching_sha2_password
    restart: unless-stopped
    environment:
      - MYSQL_ROOT_PASSWORD=admin
      - MYSQL_DATABASE=notes
      - MYSQL_USER=notes
      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR
    ports:
      - '3306:3306'
    healthcheck:
      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']
      interval: 5s
      timeout: 2s
      retries: 20
    networks:
      - react-notes

  next-app:
    container_name: next-app
    build:
      context: .
    restart: always
    ports:
      - 3000:3000
    networks:
      - react-notes
    depends_on:
      mysql:
        condition: service_healthy
```

在这段代码中，这里我们声明了 `mysql`的容器名为 `mysql`，并建立了一个名为 `notes` 的 MySQL 用户，对应修改根目录的 `env`文件为：

```bash
DATABASE_URL="mysql://notes:cpZfriEBbmJjWeiR@mysql:3306/notes"
```

稍微复杂一点的是 `healthcheck`，这是为了保证  mysql 完全运行后才运行 `next-app`。我们可以看到 `next-app`的 `depends_on` 里有 `mysql`，依赖的条件是 `service_healthy`，也就是说 `mysql` 的 `healthcheck` 要先通过才会运行 `next-app`。

### 服务器运行

服务器安装 Docker 和 Docker Compose，我是直接用宝塔安装了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f10eeac0383c46b88e4f5fc28a1f2741~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2964\&h=1008\&s=218772\&e=png\&b=fdfdfd)

注：安装的速度不算快，大概等待了 20 分钟。服务器直接安装可以参考：[《安装Docker并使用（Linux）》](https://help.aliyun.com/zh/ecs/use-cases/deploy-and-use-docker-on-alibaba-cloud-linux-2-instances)。

然后把代码推送到服务器，注意如果服务器已经开启了 MySQL，先关闭 MySQL。最后命令行进入服务器项目目录，运行 `docker compose up`，我们就成功的将项目运行在了服务器的 `3000` 端口。

如果参照过[《实战篇 | React Notes | 服务器部署》](https://juejin.cn/book/7307859898316881957/section/7309114747482275850)，因为已经设置过 Nginx，所以会将域名 `notes.yayujs.com`代理到 3000 端口，所以直接访问：<https://notes.yayujs.com/> 就会生效：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fdba5c3d57441179604541ff1baa46b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2314\&h=1420\&s=215361\&e=png\&b=f5f6f9)

如果你没有设置过，宝塔里也支持容器快捷的设置反向代理、绑定到具体的域名上：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f36725e335a434bbb8af55c85526e7d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3748\&h=1864\&s=503814\&e=png\&b=7c7c7c)

## Docker 本地开发

现在我们非常随意的就用 Docker 把代码部署到了服务器上。但是这样的方法只能说——又不是不能用……

问题依然很多，比如用了数据库却没有做数据持久化、Next.js 项目没有开启 `standalone` 输出模式，Docker 的镜像构建太过随意导致构建包很大等等……

实际上，选择用 Docker 选择的是一种开发方式。也就是说，不是在本地开发完了项目，最后用 Docker 部署一下，而是在本地开发项目的时候，就已经开始使用 Docker 了。

所以学习本篇不要着急，我们从头开始说起。

### 下载代码

先说说日常开发项目怎么使用 Docker。我们依然以 Day11 分支的代码为例，此时我们的代码中用了 Prisma + MySQL。

下载我们的 day11 分支代码：

```bash
git clone -b day11 git@github.com:mqyqingfeng/next-react-notes-demo.git
```

老规矩，先本地运行一下，验证代码无问题：

```bash
# 注意要在本地开启 MySQL 后运行：
npm i && npm run dev
```

### `.dockerignore`

项目根目录新建 `.dockerignore`文件，代码如下：

```bash
Dockerfile
.dockerignore
node_modules
npm-debug.log
README.md
.next
docker
.git
```

### `dev.Dockerfile`

项目根目录新建 `dev.Dockerfile`，代码如下：

```bash
FROM node:18-alpine

# RUN apt-get update -y
# RUN apt-get install -y openssl

WORKDIR /app

COPY . .

RUN npm i --registry=https://registry.npmmirror.com;

RUN chmod +x /app/dev.startup.sh

ENTRYPOINT ["sh", "/app/dev.startup.sh"]
```

在这段代码中：

我们新建的是 `dev.Dockerfile`，但跟 Next.js 的 `.env.development`不同的是，`.env.development` Next.js 是会自动读取的，但 Docker 并不会自动读取 `dev.Dockerfile`，所以名字其实可以乱取，我们只是为了方便区分不同环境的 Dockerfile。（PS：Docker 其实也支持[开发环境](https://docs.docker.com/desktop/dev-environments/)，不过目前处于开发停滞状态）

再解释下代码的含义。`RUN apt-get`这两句是为了避免出现类似于下面这样的错误提示（如果你遇到了这个问题的话，参考此 [GitHub Issue](https://github.com/prisma/prisma/issues/19729)，没有遇到就不用写了）：

> Prisma Client could not locate the Query Engine for runtime "debian-openssl-1.1.x".
>
> This happened because Prisma Client was generated for "debian-openssl-3.0.x", but the actual deployment required "debian-openssl-1.1.x".
>
> Add "debian-openssl-1.1.x" to `binaryTargets` in the "schema.prisma" file and run `prisma generate` after saving it:

然后指定工作目录，拷贝所有文件、安装依赖包、给脚本文件添加运行权限。最后用 ENTRYPOINT 指定了容器启动脚本。因为我们用了 Prisma，脚本内容比较多，所以单独使用了一个脚本文件。

### dev.startup.sh

项目根目录新建 `dev.startup.sh`文件，代码如下：

```bash
#!/bin/sh

MIGRATION_STATUS=$(npx prisma migrate status)

if echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then
    echo "No migrations needed."
else
    echo "Running migrations..."
    npx prisma migrate deploy
fi

npx prisma generate

if [ -f yarn.lock ]; then 
    yarn dev;
elif [ -f package-lock.json ]; then 
    npm run dev;
elif [ -f pnpm-lock.yaml ]; then 
    pnpm dev;
else 
    npm run dev;
fi
```

这段代码并不复杂，一是  Prisma 相关处理，二是运行 `npm run dev`开启开发模式。你可能会问，`prisma generate`怎么又放到了脚本里执行？之前不是放在镜像构建指令里吗？其实这里放哪里都可以的。（但是线上部署的时候因为开启了 standalone 输出模式只能放在构建指令中）

### dev.docker-compose.yml

项目根目录新建 `dev.docker-compose.yml` 文件，代码如下：

```bash
version: "3.8"

networks:
  react-notes-dev:
    driver: bridge

services:
  next-app-dev:
    container_name: next-app
    build:
      context: .
      dockerfile: dev.Dockerfile
    env_file:
      - .env
      - .env.development
    volumes:
      - .:/app
    restart: always
    ports:
      - 3000:3000
    networks:
      - react-notes-dev
    depends_on:
      mysql:
        condition: service_healthy
      
  mysql:
    image: mysql:8.0
    container_name: next-app-mysql
    command: --default-authentication-plugin=caching_sha2_password
    restart: unless-stopped
    # volumes:
    #   - ./docker/data/mysql/:/var/lib/mysql/
    environment:
      - MYSQL_ROOT_PASSWORD=admin
      - MYSQL_DATABASE=notes
      - MYSQL_USER=notes
      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR
    ports:
      - '3306:3306'
    healthcheck:
      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']
      interval: 5s
      timeout: 2s
      retries: 20
    networks:
      - react-notes-dev
```

这段代码也很好理解，注意 `next-app` 的数据卷，因为我们将项目的所有内容都挂载到工作目录 `/app` 下，当我们修改项目文件时，Docker 里运行的项目也会正常发生修改，所以即便使用了 Docker 也继续支持热更新。

根目录的 `.env.development`文件对应修改为：

```bash
DATABASE_URL="mysql://notes:cpZfriEBbmJjWeiR@next-app-mysql:3306/notes"
```

此时运行 `docker compose -f dev.docker-compose.yml up`，本地访问 `http://localhost:3000/`应该已经可以正常运行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64220caad6f3443ab4cc10d16bf4832a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2066\&h=1402\&s=190810\&e=png\&b=f6f7fa)

### host

使用 `next-auth` 的时候，如果部署到线上环境，可能需要额外设置一下 `AUTH_URL`。对于初学者而言，又有可能忘记这件事情，于是明明在本地运行没有问题，但发布到线上后就出现了问题……干脆我们本地开发的时候就直接使用线上域名进行开发！

我们设想的开发方式是本地浏览器访问 `https://notes.yayujs.com`就会进入我们本地启用的页面。为此你需要修改主机的 `host`:

```bash
# 修改 host 文件
vim /etc/hosts

# 添加如下：
127.0.0.1 notes.yayujs.com
```

其实修改 host 并不算复杂，但是发布到线上又需要注释掉对应的域名才能查看效果，开发本地又需要解开注释才能查看效果。一来二去也就麻烦了，为此你可以使用 [SwitchHosts](https://switchhosts.vercel.app/zh) 这个软件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc729867964240c0a7454d949b6c148a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=960\&s=75890\&e=png\&b=ffffff)

借助 SwitchHosts 这个软件，你可以轻松切换 host。

注意：如果切换 host 后，浏览器没有成功解析，你可以进行这样一些尝试：

有可能是浏览器做了 DNS 缓存或其他处理。浏览器打开 `chrome://net-internals/#sockets`，点击 `Flush Socket Pools`。注意 Flush 的是当前窗口里的所有页面。

有可能是使用了代理导致。这个时候就需要将你的域名放到代理的排除名单里。我们以 ClashX 为例，打开 `~/.config/clash`，添加一个名为 `proxyIgnoreList.plist`的文件，代码如下：

    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <array>
        <string>192.168.0.0/16</string>
        <string>10.0.0.0/8</string>
        <string>172.16.0.0/12</string>
        <string>127.0.0.1</string>
        <string>localhost</string>
        <string>*.local</string>
        <string>http://notes.yayujs.com</string>
        <string>https://notes.yayujs.com</string>
    </array>
    </plist>

在 `<string>`标签中添加要排除的域名，然后重启 ClashX 即可。

设置 host 后，此时访问 <http://notes.yayujs.com:3000/>：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/898c1187d9d048d5bd903979b0ab77f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2066\&h=1402\&s=195133\&e=png\&b=f6f7fa)

注：此时也只是能正常访问首页，功能比如登录还有问题

### nginx

我们的目标是本地访问 `https://notes.yayujs.com`的时候可以进入我们的开发页面，通过 switchHosts 关闭相关 host 的时候，访问 `https://notes.yayujs.com`则会进入我们的线上部署页面。为此我们需要用到 nginx 镜像。

修改 `dev.docker-compose.yml` 文件，完整代码如下：

```bash
version: "3.8"

networks:
  react-notes-dev:
    driver: bridge

services:
  next-app-dev:
    container_name: next-app
    build:
      context: .
      dockerfile: dev.Dockerfile
    env_file:
      - .env
      - .env.development
    volumes:
      - .:/app
    restart: always
    ports:
      - 3000:3000
    networks:
      - react-notes-dev
    depends_on:
      mysql:
        condition: service_healthy
      
  mysql:
    image: mysql:8.0
    container_name: next-app-mysql
    command: --default-authentication-plugin=caching_sha2_password
    restart: unless-stopped
    # volumes:
    #   - ./docker/data/mysql/:/var/lib/mysql/
    environment:
      - MYSQL_ROOT_PASSWORD=admin
      - MYSQL_DATABASE=notes
      - MYSQL_USER=notes
      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR
    ports:
      - '3306:3306'
    healthcheck:
      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']
      interval: 5s
      timeout: 2s
      retries: 20
    networks:
      - react-notes-dev

  nginx:
    image: nginx
    container_name: next-app-nginx
    volumes:
      - ./docker/nginx.conf:/etc/nginx/nginx.conf
      - ./docker/ssl/notes.yayujs.com.key:/etc/nginx/ssl/notes.yayujs.com.key
      - ./docker/ssl/notes.yayujs.com.pem:/etc/nginx/ssl/notes.yayujs.com.pem
    ports:
      - 80:80
      - 443:443
    restart: always
    networks:
      - react-notes-dev
    depends_on:
      - next-app-dev
```

项目根目录新建 `docker`文件夹，然后新建 `nginx.conf`，代码如下：

```javascript
events {
    worker_connections   1000;
}
http {
    include /etc/nginx/mime.types;
    upstream nextjs_upstream {
        server next-app:3000;
    }
    server {
        listen 80;
        listen 443 ssl;
        server_name  notes.yayujs.com;

        ssl_certificate /etc/nginx/ssl/notes.yayujs.com.pem;
        ssl_certificate_key /etc/nginx/ssl/notes.yayujs.com.key;
        ssl_session_timeout 5m;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;
        ssl_prefer_server_ciphers on;
        
        gzip on;
        gzip_proxied any;
        gzip_comp_level 4;
        gzip_types text/css application/javascript image/svg+xml;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;

        location / {
          proxy_pass http://nextjs_upstream;
          proxy_set_header Host $host;
          proxy_set_header X-Real-IP $remote_addr;
          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header REMOTE-HOST $remote_addr;
          add_header X-Cache $upstream_cache_status;
          proxy_set_header X-Host $host;
          proxy_set_header X-Scheme $scheme;
          proxy_connect_timeout 30s;
          proxy_read_timeout 86400s;
          proxy_send_timeout 30s;
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection "upgrade";
        }
    }
}
```

同时在 `docker`目录下新建 `ssl`文件夹，然后放入开启 https 会用到的 key 和 pem 文件。

注：按理说这些再加上设置 AUTH\_URL 就够了，但是因为用的是 next-auth v5 beta 版本，目前还不算稳定，如果不使用 AUTH\_URL，点击 `signIn` 的时候跳转地址的 callbackUrl 会设置为 `localhost:3000`，如果添加 `AUTH_URL`，会出现报错：

> TypeError: next\_dist\_server\_web\_exports\_next\_request\_\_WEBPACK\_IMPORTED\_MODULE\_0\_\_ is not a constructor

根据这个 [GitHub Issue](https://github.com/nextauthjs/next-auth/issues/9922) 的描述，此问题会由 Next.js 修复，但目前还没有发布到稳定版。对此我的处理方式是在 `next-auth` 的 `redirects` 回调函数中做一层处理，修改 `auth.js`：

```javascript
import NextAuth from "next-auth"
// import GitHub from "next-auth/providers/github"
import CredentialsProvider from "next-auth/providers/credentials";
import { addUser, getUser } from "@/lib/prisma";

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers:[CredentialsProvider({
    // 显示按钮文案 (e.g. "Sign in with...")
    name: "密码登录",
    // `credentials` 用于渲染登录页面表单
    credentials: {
      username: { label: "账号", type: "text", placeholder: "输入您的账号" },
      password: { label: "密码", type: "password", placeholder: "输入您的密码" }
    },
    // 处理从用户收到的认证信息
    async authorize(credentials, req) {
      // 默认情况下不对用户输入进行验证，确保使用 Zod 这样的库进行验证
      let user = null

      // 登陆信息验证
      user = await getUser(credentials.username, credentials.password)

      // 密码错误
      if (user === 1) return null

      // 用户注册
      if (user === 0) {
        user = await addUser(credentials.username, credentials.password)
      }

      if (!user) {
        throw new Error("User was not found and could not be created.")
      }

      return user
    }
  })],
  pages: {
    signIn: '/auth/signin'
  },
  callbacks: {
    authorized({ request, auth }) {
      const { pathname } = request.nextUrl
      if (pathname.startsWith("/note/edit")) return !!auth
      return true
    },
    async jwt({ token, user, account }) {
      if (account && account.type === "credentials" && user) {
        token.userId = user.userId;
      }
      return token;
    },
    async session({ session, token }) {
      if (token.userId) {
        session.user.userId = token.userId
      }
      return session;
    },
    async redirect({ url, baseUrl }) {
      if (url.startsWith("/")) return `${baseUrl}${url}`
      else if (new URL(url).origin === baseUrl) return url
      if (baseUrl.indexOf(":3000") > -1) return url
      return baseUrl
    }
  },
  trustHost: true
})
```

运行：

```bash
# 删除掉之前的容器
docker compose -f dev.docker-compose.yml down
# 重新构建镜像
docker compose -f dev.docker-compose.yml up --build
```

本地访问 <https://notes.yayujs.com>，此时应该可以正常运行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cf6f360baeb42759c2d47975f13281b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2724\&h=924\&s=179622\&e=png\&b=f6f7fa)

那么问题来了，如果我切换了 host，我如何知道浏览器打开的地址访问的是线上还是本地呢？

方法有很多种，一种简单的方式是查看页面请求头，如果是本地：

![截屏2024-02-20 16.39.06.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77dd7483d4054df58655b1acf09c310a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2844\&h=986\&s=383087\&e=png\&b=fefefe)

如果是线上：

![截屏2024-02-20 16.40.20.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0876cedc756343d0b886c5c68d9cbad8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2834\&h=950\&s=397105\&e=png\&b=fefefe)

如果切换后没有生效，就参照上节讲的两种方式试试。

至此我们就用 Docker 搭建了一个开发环境，我们的目标是：

1.  提供一个一致的开发环境，不用在每台主机上都配置一遍
2.  模拟复制一个线上环境，不用担心漏掉某些配置
3.  正常本地开发 Next.js 项目的功能如热更新继续支持，能够实时查看效果

## Docker 生产部署

接下来我们看看生产部署的时候要做些什么。

其实主要就两件事情，一是编译和运行生产版本，二是减少镜像大小，毕竟我们开发时构建的镜像包都快有 1G 了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1b08af1f74a4adea1bb5b1a66b9aba9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2556\&h=234\&s=54098\&e=png\&b=f9f9fa)

这谁能忍？（其实我能忍，但为了显得我精益求精、既要又要还要，我们还是努力优化一下……）

减少镜像的大小，主要是开启 Next.js 项目的 standalone 模式，然后优化镜像构建。

注：关于 standalone 输出模式的介绍可以查看[《API 篇 | next.config.js（下）》](https://juejin.cn/book/7307859898316881957/section/7309079467967414310)

那就让我们开始吧。

修改 `next.config.js`，开启 standalone 输出模式，代码如下：

```javascript
const nextConfig = {
  output: 'standalone'
}
module.exports = nextConfig
```

项目根目录新建 `prod.Dockerfile`，代码如下：

```dockerfile
FROM node:18-alpine AS base

FROM base AS builder

WORKDIR /app

COPY . .

RUN npm i --registry=https://registry.npmmirror.com;

RUN npx prisma generate

RUN npm run build;

FROM base AS runner

WORKDIR /app

COPY --from=builder /app/public ./public

COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

ENV NEXT_TELEMETRY_DISABLED 1

COPY prisma ./prisma/
COPY prod.startup.sh ./prod.startup.sh
RUN chmod +x /app/prod.startup.sh

ENTRYPOINT ["sh", "/app/prod.startup.sh"]
```

项目根目录新建 `prod.startup.sh`，代码如下：

```bash
#!/bin/sh

MIGRATION_STATUS=$(npx prisma migrate status)

if echo "$MIGRATION_STATUS" | grep -q "Database schema is up to date"; then
    echo "No migrations needed."
else
    echo "Running migrations..."
    npx prisma migrate deploy
fi

node server.js
```

项目根目录新建 `prod.docker-compose.yml`，代码如下：

```yaml
version: "3.8"

networks:
  react-notes-prod:
    driver: bridge

services:
  next-app-prod:
    container_name: next-app
    build:
      context: .
      dockerfile: prod.Dockerfile
    env_file:
      - .env
      - .env.production
    restart: always
    ports:
      - 3000:3000
    networks:
      - react-notes-prod
    depends_on:
      mysql:
        condition: service_healthy
      
  mysql:
    image: mysql:8.0
    container_name: next-app-mysql
    command: --default-authentication-plugin=caching_sha2_password
    restart: unless-stopped
    # volumes:
    #   - ./docker/data/mysql/:/var/lib/mysql/
    environment:
      - MYSQL_ROOT_PASSWORD=admin
      - MYSQL_DATABASE=notes
      - MYSQL_USER=notes
      - MYSQL_PASSWORD=cpZfriEBbmJjWeiR
    ports:
      - '3306:3306'
    healthcheck:
      test: ['CMD', 'mysqladmin', 'ping', '-h127.0.0.1', '-P3306']
      interval: 5s
      timeout: 2s
      retries: 20
    networks:
      - react-notes-prod

  nginx:
    image: nginx
    container_name: next-app-nginx
    volumes:
      - ./docker/nginx.conf:/etc/nginx/nginx.conf
      - ./docker/ssl/notes.yayujs.com.key:/etc/nginx/ssl/notes.yayujs.com.key
      - ./docker/ssl/notes.yayujs.com.pem:/etc/nginx/ssl/notes.yayujs.com.pem
    ports:
      - 80:80
      - 443:443
    restart: always
    networks:
      - react-notes-prod
    depends_on:
      - next-app-prod
```

修改 `.env`：

```bash
DATABASE_URL="mysql://notes:cpZfriEBbmJjWeiR@next-app-mysql:3306/notes"
```

修改 `.env.production`：

```bash
# 注释掉 AUTH_URL，因为会导致报错，预计会在 Next.js v14.1.1 版本修复
# AUTH_URL=https://notes.yayujs.com
```

因为容器名不能重复，我们删除掉之前用于开发模式的容器：

```bash
docker compose -f dev.docker-compose.yml down
```

然后构建镜像并运行生产模式的容器：

```javascript
docker compose -f prod.docker-compose.yml up
```

此时本地应该可以正常访问：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51c8e657d9ad47bf8d85b9d8cb9d983a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1974\&h=1088\&s=153185\&e=png\&b=f5f6f9)

查看镜像大小：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e7b556b89144e2690b4c5cdcf535655~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2210\&h=220\&s=52964\&e=png\&b=161b1f)

镜像从之前的 830M 优化到了现在的 169M，可喜可贺！（懒得继续优化了……）

部署到线上的方式也很简单：

将代码推送到服务器上，然后登陆服务器，进入到项目根目录，运行相同的命令：

```bash
docker compose -f prod.docker-compose.yml up
```

如果参照[《实战篇 | React Notes | 服务器部署》](https://juejin.cn/book/7307859898316881957/section/7309114747482275850)在宝塔设置过 Node 项目，记得删除 Node 项目或者修改对应的 Nginx 配置，否则可能会因为端口占用影响容器运行。

现在我们又一次用 Docker 把代码部署到了服务器上，还做了不少优化，但是这样的方法只能说——勉强能用……

大问题基本解决，小问题依然很多：比如还是没有解决数据库持久化问题，不过这个比较简单，参考上篇 [《实战篇 | React Notes | Docker 快速入门》](https://juejin.cn/book/7307859898316881957/section/7330567768579637299)即可自己创建数据卷。如果大家在实际的开发中用到 Redis，比如用 Redis 做数据缓存，也可以参考《实战篇 | React Notes | Docker 快速入门》中的 Docker Compose 配置。

比如目前我们虽然构建了两个镜像，但因为容器名不能重复，所以我们运行本地或者线上的时候，都要删除掉之前的容器再重新开一个容器，如果分别建立两个容器，Nginx 配置需要做两份或者改为读取环境变量的方式，这又要做一点配置工作。此外流程上还可以借助 Jenkins 实现 CI/CD，优化开发流程……

总之任重而道远。Docker 会用就好用，不会用的时候要踩一堆坑，我们慢慢讲解。后面的项目我们会继续用 Docker 作为基本的开发方式。

本篇项目源码：<https://github.com/mqyqingfeng/next-react-notes-demo/tree/day12>

## 参考链接

1.  <https://stackoverflow.com/questions/76698529/how-to-update-the-prisma-in-a-production-docker-instance>
2.  <https://github.com/vercel/next.js/blob/canary/examples/with-docker-compose/next-app/dev.Dockerfile>
3.  <https://github.com/prisma/prisma/blob/main/docker/docker-compose.yml>
4.  <https://github.com/prisma/prisma-examples/blob/latest/databases/mongodb/docker-compose.yml>
5.  <https://github.com/nextauthjs/next-auth/issues/9922>
6.  <https://gist.github.com/malteneuss/a7fafae22ea81e778654f72c16fe58d3>
7.  <https://www.prisma.io/docs/orm/prisma-client/setup-and-configuration/generating-prisma-client>


## 5.路由篇 | 动态路由、路由组、平行路由和拦截路由

## 前言

实际项目开发的时候，有的路由场景会比较复杂，比如数据库里的文章有很多，我们不可能一一去定义路由，此时该怎么办？组织代码的时候，有的路由是用于移动端，有的路由是用于 PC 端，该如何组织代码？如何有条件的渲染页面，比如未授权的时候显示登录页？如何让同一个路由根据不同的场景展示不同的内容？

本篇我们会一一解决这些问题，在此篇，你将会感受到 App Router 强大的路由功能。

## 1. 动态路由（Dynamic Routes）

有的时候，你并不能提前知道路由的地址，就比如根据 URL 中的 id 参数展示该 id 对应的文章内容，文章那么多，我们不可能一一定义路由，这个时候就需要用到动态路由。

### 1.1. \[folderName]

使用动态路由，你需要将文件夹的名字用方括号括住，比如 `[id]`、`[slug]`。这个路由的名字会作为 `params` prop 传给**布局**、 **页面**、 **[路由处理程序](https://juejin.cn/book/7307859898316881957/section/7308914343129645065#heading-4)** 以及 **[generateMetadata](https://juejin.cn/book/7307859898316881957/section/7309079119902277669#heading-3)** 函数。

举个例子，我们在 `app/blog` 目录下新建一个名为 `[slug]` 的文件夹，在该文件夹新建一个 `page.js` 文件，代码如下：

```javascript
// app/blog/[slug]/page.js
export default function Page({ params }) {
  return <div>My Post: {params.slug}</div>
}
```

效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88ee11229ac6473682f4f4344a34a285~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=690\\&h=208\\&s=24236\\&e=png\\&b=000000" width="400" />

当你访问 `/blog/a`的时候，`params` 的值为 `{ slug: 'a' }`。

当你访问 `/blog/yayu`的时候，`params` 的值为 `{ slug: 'yayu' }`。

以此类推。

### 1.2. \[...folderName]

在命名文件夹的时候，如果你在方括号内添加省略号，比如 `[...folderName]`，这表示捕获所有后面所有的路由片段。

也就是说，`app/shop/[...slug]/page.js`会匹配 `/shop/clothes`，也会匹配 `/shop/clothes/tops`、`/shop/clothes/tops/t-shirts`等等。

举个例子，`app/shop/[...slug]/page.js`的代码如下：

```javascript
// app/shop/[...slug]/page.js
export default function Page({ params }) {
  return <div>My Shop: {JSON.stringify(params)}</div>
}
```

效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90e8b8aa9599485b99832890b9895ac4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=726\&h=206\&s=28238\&e=png\&b=000000" width="400" />

当你访问 `/shop/a`的时候，`params` 的值为 `{ slug: ['a'] }`。

当你访问 `/shop/a/b`的时候，`params` 的值为 `{ slug: ['a', 'b'] }`。

当你访问 `/shop/a/b/c`的时候，`params` 的值为 `{ slug: ['a', 'b', 'c'] }`。

以此类推。

### 1.3. \[\[...folderName]]

**在命名文件夹的时候，如果你在双方括号内添加省略号，比如 `[[...folderName]]`，这表示可选的捕获所有后面所有的路由片段。**

也就是说，`app/shop/[[...slug]]/page.js`会匹配 `/shop`，也会匹配 `/shop/clothes`、 `/shop/clothes/tops`、`/shop/clothes/tops/t-shirts`等等。

它与上一种的区别就在于，不带参数的路由也会被匹配（就比如 `/shop`）

举个例子，`app/shop/[[...slug]]/page.js`的代码如下：

```javascript
// app/shop/[[...slug]]/page.js
export default function Page({ params }) {
  return <div>My Shop: {JSON.stringify(params)}</div>
}
```

效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788b14ff953e4ecaac29c87301406ec9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=702\&h=210\&s=22349\&e=png\&b=000000" width="400" />


当你访问 `/shop`的时候，params 的值为 `{}`。

当你访问 `/shop/a`的时候，params 的值为 `{ slug: ['a'] }`。

当你访问 `/shop/a/b`的时候，params 的值为 `{ slug: ['a', 'b'] }`。

当你访问 `/shop/a/b/c`的时候，params 的值为 `{ slug: ['a', 'b', 'c'] }`。

以此类推。

## 2. 路由组（Route groups）

在 `app`目录下，文件夹名称通常会被映射到 URL 中，但你可以将文件夹标记为路由组，阻止文件夹名称被映射到 URL 中。

使用路由组，你可以将路由和项目文件按照逻辑进行分组，但不会影响 URL 路径结构。路由组可用于比如：

1.  按站点、意图、团队等将路由分组
2.  在同一层级中创建多个布局，甚至是创建多个根布局

那么该如何标记呢？把文件夹用括号括住就可以了，就比如 `(dashboard)`。

举些例子：

### 2.1. 按逻辑分组

**将路由按逻辑分组，但不影响 URL 路径：**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f171f5820742ba9a017c99b15a3fd7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=930\&s=471042\&e=png\&b=171717)

你会发现，最终的 URL 中省略了带括号的文件夹（上图中的`(marketing)`和`(shop)`）。

### 2.2. 创建不同布局

**借助路由组，即便在同一层级，也可以创建不同的布局：**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4039b04e7b244f13aeaa4eca7482fd48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=930\&s=466548\&e=png\&b=171717)

在这个例子中，`/account` 、`/cart`、`/checkout` 都在同一层级。但是 `/account`和 `/cart`使用的是 `/app/(shop)/layout.js`布局和`app/layout.js`布局，`/checkout`使用的是 `app/layout.js`

### 2.3. 创建多个根布局

**创建多个根布局：**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab457a10df414024bfcc33dad6d7641d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=687\&s=335556\&e=png\&b=151515)

创建多个根布局，你需要删除掉 `app/layout.js` 文件，然后在每组都创建一个 `layout.js`文件。创建的时候要注意，因为是根布局，所以要有 `<html>` 和 `<body>` 标签。

这个功能很实用，比如你将前台购买页面和后台管理页面都放在一个项目里，一个 C 端，一个 B 端，两个项目的布局肯定不一样，借助路由组，就可以轻松实现区分。

再多说几点：

1.  路由组的命名除了用于组织之外并无特殊意义。它们不会影响 URL 路径。
2.  注意不要解析为相同的 URL 路径。举个例子，因为路由组不影响 URL 路径，所以  `(marketing)/about/page.js`和 `(shop)/about/page.js`都会解析为 `/about`，这会导致报错。
3.  创建多个根布局的时候，因为删除了顶层的 `app/layout.js`文件，访问 `/`会报错，所以`app/page.js`需要定义在其中一个路由组中。
4.  跨根布局导航会导致页面完全重新加载，就比如使用 `app/(shop)/layout.js`根布局的 `/cart` 跳转到使用 `app/(marketing)/layout.js`根布局的 `/blog` 会导致页面重新加载（full page load）。

注：当定义多个根布局的时候，使用 `app/not-found.js`会出现问题。具体参考 [《Next.js v14 如何为多个根布局自定义不同的 404 页面？竟然还有些麻烦！欢迎探讨》](https://juejin.cn/post/7351321244125265930)

## 3. 平行路由（Parallel Routes）

平行路由可以使你在同一个布局中同时或者有条件的渲染一个或者多个页面（类似于 Vue 的插槽功能）。

### 3.1. 用途 1：条件渲染

举个例子，在后台管理页面，需要同时展示团队（team）和数据分析（analytics）页面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23506139d1874086bc21c20fcd1cd644~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=952\&s=465044\&e=png\&b=1a1a1a)

平行路由的使用方式是将文件夹以 `@`作为开头进行命名，比如在上图中就定义了两个插槽 `@team` 和 `@analytics`。

插槽会作为 props 传给共享的父布局。在上图中，`app/layout.js` 从 props 中获取了 `@team` 和 `@analytics` 两个插槽的内容，并将其与 children 并行渲染：

```js
// app/layout.js
// 这里我们用了 ES6 的解构，写法更简洁一点
export default function Layout({ children, team, analytics }) {
  return (
    <>
      {children}
      {team}
      {analytics}
    </>
  )
}
```

注：从这张图也可以看出，`children` prop 其实就是一个隐式的插槽，`/app/page.js`相当于 `app/@children/page.js`。

除了让它们同时展示，你也可以根据条件判断展示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/660a626f4ce242c7bcedfdff35f1e97b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=898\&s=459919\&e=png\&b=1b1b1b)

在这个例子中，先在布局中获取用户的登录状态，如果登录，显示 dashboard 页面，没有登录，显示 login 页面。这样做的一大好处就在于代码完全分离。

### 3.2. 用途 2：独立路由处理

**平行路由可以让你为每个路由定义独立的错误处理和加载界面：**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/822568ec41e9487d9eb1cd2606eb7fce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=1218\&s=559780\&e=png\&b=1d1d1d)

### 3.3. 用途 3：子导航

注意我们描述 team 和 analytics 时依然用的是“页面”这个说法，因为它们就像书写正常的页面一样使用 page.js。除此之外，它们也能像正常的页面一样，添加子页面，比如我们在 `@analytics` 下添加两个子页面：`/page-views` and `/visitors`：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/807415e0a664410d889e6b89eb71f3bb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600&h=768&s=380486&e=png&b=161616)

平行路由跟路由组一样，不会影响 URL，所以 `/@analytics/page-views/page.js` 对应的地址是 `/page-views`，`/@analytics/visitors/page.js` 对应的地址是 `/visitors`，你可以导航至这些路由：

```js
// app/layout.js
import Link from "next/link";

export default function RootLayout({ children, analytics }) {
  return (
    <html>
      <body>
        <nav>
          <Link href="/">Home</Link>
          <br />
          <Link href="/page-views">Page Views</Link>
          <br />
          <Link href="/visitors">Visitors</Link>
        </nav>
        <h1>root layout</h1>
        {analytics}
        {children}
      </body>
    </html>
  );
}

```
当导航至这些子页面的时候，子页面的内容会取代 `/@analytics/page.js` 以 props 的形式注入到布局中，效果如下：

![parallel-routers.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/934de8f668044072ae2436527ce3aeee~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1104&h=517&s=75895&e=gif&f=28&b=191919)

线上查看代码和效果：[CodeSandbox Parallel Routes](https://codesandbox.io/p/devbox/parallel-routes-vg2lw3?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt4etrxk00073b6hve8nzgfn%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt4etrxj00023b6hbh7tjkti%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt4etrxj00043b6h3xt2fybf%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt4etrxj00063b6hk3nfgk8s%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt4etrxj00023b6hbh7tjkti%2522%253A%257B%2522id%2522%253A%2522clt4etrxj00023b6hbh7tjkti%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522clt4etrxj00063b6hk3nfgk8s%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4etrxj00053b6hvo4o5bbu%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252F%2522%257D%255D%252C%2522id%2522%253A%2522clt4etrxj00063b6hk3nfgk8s%2522%252C%2522activeTabId%2522%253A%2522clt4etrxj00053b6hvo4o5bbu%2522%257D%252C%2522clt4etrxj00043b6h3xt2fybf%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt4etrxj00033b6hkff9eafm%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt4etrxj00043b6h3xt2fybf%2522%252C%2522activeTabId%2522%253A%2522clt4etrxj00033b6hkff9eafm%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)

这也就是说，每个插槽都可以有自己独立的导航和状态管理，就像一个小型应用一样。这种特性适合于构建复杂的应用如 dashboard。

最后，让我们总结一下使用平行路由的优势：

1. 使用平行路由可以将单个布局拆分为多个插槽，使代码更易于管理，尤其适用于团队协作的时候
2. 每个插槽都可以定义自己的加载界面和错误状态，比如某个插槽加载速度比较慢，那就可以加一个加载效果，加载期间，也不会影响其他插槽的渲染和交互。当出现错误的时候，也只会在具体的插槽上出现错误提示，而不会影响页面其他部分，有效改善用户体验
3. 每个插槽都可以有自己独立的导航和状态管理，这使得插槽的功能更加丰富，比如在上面的例子中，我们在 `@analytics` 插槽下又建了查看页面 PV 的 `/page-views`、查看访客的 `/visitors`，使得同一个插槽区域可以根据路由显示不同的内容

那你可能要问了，我就不使用平行路由，我就完全使用拆分组件的形式，加载状态和错误状态全都自己处理，子路由也统统自己处理，可不可以？

当然是可以的，只要不嫌麻烦的话……

**注意：使用平行路由的时候，热加载有可能会出现错误。如果出现了让你匪夷所思的情况，重新运行 npm run dev 或者构建生产版本查看效果**

### 3.4. default.js

为了让大家更好的理解平行路由，我们写一个示例代码。项目结构如下：

```javascript
app
├─ @analytics
│   └─ page-views
│   │    └─ page.js
│   └─ visitors
│   │     └─ page.js
│   └─ page.js
├─ @team
│  └─ page.js
├─ layout.js
└─ page.js
```

其中 `app/layout.js`代码如下：

```jsx
import Link from "next/link";
import "./globals.css";

export default function RootLayout({ children, team, analytics }) {
  return (
    <html>
      <body className="p-6">
        <div className="p-10 mb-6 bg-sky-600 text-white rounded-xl">
          Parallel Routes Examples
        </div>
        <nav className="flex items-center justify-center gap-10 text-blue-600 mb-6">
          <Link href="/">Home</Link>
          <Link href="/page-views">Page Views</Link>
          <Link href="/visitors">Visitors</Link>
        </nav>
        <div className="flex gap-6">
          {team}
          {analytics}
        </div>
        {children}
      </body>
    </html>
  );
}
```
注意：这里我们为了样式好看，使用了 Tailwind CSS，使用方式参考 《[样式篇 | Tailwind CSS、CSS-in-JS 与 Sass](https://juejin.cn/book/7307859898316881957/section/7309076792760303654#heading-5)》。对于不熟悉的同学，照样拷贝代码即可，顶多样式不生效，但并不影响这里的逻辑。

`app/page.js`代码如下：

```jsx
export default function Page() {
  return (
    <div className="p-10 mt-6 bg-sky-600 text-white rounded-xl">
      Hello, App!
    </div>
  );
}
```

`app/@analytics/page.js`代码如下：

```javascript
export default function Page() {
    return <div className="h-60 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">Hello, Analytics!</div>
}
```

`app/@analytics/page-views/page.js`代码如下：

```javascript
export default function Page() {
    return <div className="h-60 flex-1 rounded-xl bg-indigo-600 text-white flex items-center justify-center">Hello, Analytics Page Views!</div>
}
```

`app/@analytics/visitors/page.js`代码如下：

```javascript
export default function Page() {
    return <div className="h-60 flex-1 rounded-xl bg-indigo-700 text-white flex items-center justify-center">Hello, Analytics Visitors!</div>
}
```

`app/@team/page.js`代码如下：

```jsx
export default function Page() {
    return <div className="h-60 flex-1 rounded-xl bg-sky-500 text-white flex items-center justify-center">Hello, Team!</div>
}
```

其实各个 `page.js` 代码差异不大，主要是做了一点样式和文字区分。

此时访问 `/`，效果如下：


![parallel-routers-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03bf7c7e81bc444283375b880e052a39~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=932&s=81994&e=gif&f=21&b=191919)

到这里其实还只是上节例子的样式美化版。现在，点击 `Visitors` 链接导航至 `/visitors` 路由，然后刷新页面，此时你会发现，页面出现了 404 错误：


![parallel-routers-2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73952768f78c47eea8a04ead5db4d09d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=932&s=127439&e=gif&f=67&b=191919)

这是为什么呢？为什么我们从首页导航至 `/visitors` 的时候可以正常显示？而直接进入 `/visitors` 就会出现 404 错误呢？

先说说为什么从首页导航至 `/visitors` 的时候可以正常显示？这是因为 Next.js 默认会追踪每个插槽的状态，具体插槽中显示的内容其实跟导航的类型有关：

* 如果是软导航（Soft Navigation，比如通过 `<Link />` 标签），在导航时，Next.js 将执行部分渲染，更改插槽的内容，如果它们与当前 URL 不匹配，维持之前的状态
* 如果是硬导航（Hard Navigation，比如浏览器刷新页面），因为 Next.js 无法确定与当前 URL 不匹配的插槽的状态，所以会渲染 404 错误

简单的来说，访问 `/visitors` 本身就会造成插槽内容与当前 URL 不匹配，按理说要渲染 404 错误，但是在软导航的时候，为了更好的用户体验，如果 URL 不匹配，Next.js 会继续保持该插槽之前的状态，而不渲染 404 错误。

那么问题又来了？不是写了 `app/@analytics/visitors/page.js` 吗？怎么会不匹配呢？对于 `@analytics` 而言，确实是匹配的，但是对于 `@team` 和 `children` 就不匹配了！

也就是说，当你访问 `/visitors` 的时候，读取的不仅仅是 `app/@analytics/visitors/page.js`，还有 `app/@team/visitors/page.js` 和 `app/visitors/page.js`。不信我们新建这两个文件测试一下。

新建 `app/@team/visitors/page.js`，代码如下：

```js
export default function Page() {
    return <div className="h-60 flex-1 rounded-xl bg-indigo-700 text-white flex items-center justify-center">Hello, Team Visitors!</div>
}
```

新建 `app/visitors/page.js`，代码如下：

```javascript
export default function Page() {
  return (
    <div className="p-10 mt-6 bg-sky-600 text-white rounded-xl">
      Hello, App Visitors!
    </div>
  );
}
```

此时再访问 `/visitors`，刷新一下页面试试，效果如下：


![parallel-routers-3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b50998f8e8d64f6c8d1ca6ca106c5f64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1518&h=932&s=134590&e=gif&f=62&b=191919)

> 1. 线上效果：[CodeSandbox Parallel Routes Slot](https://codesandbox.io/p/devbox/parallel-routes-slot-gjyc7y?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt5a2jx700073b6h8sdhy13i%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt5a2jx600023b6h0guni4v9%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt5a2jx700043b6h261hqftc%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt5a2jx700063b6hujk33tpm%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B40%252C60%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt5a2jx600023b6h0guni4v9%2522%253A%257B%2522id%2522%253A%2522clt5a2jx600023b6h0guni4v9%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522clt5a2jx700063b6hujk33tpm%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt5a2jx700053b6h614uvyna%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fvisitors%2522%257D%255D%252C%2522id%2522%253A%2522clt5a2jx700063b6hujk33tpm%2522%252C%2522activeTabId%2522%253A%2522clt5a2jx700053b6h614uvyna%2522%257D%252C%2522clt5a2jx700043b6h261hqftc%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt5a2jx700033b6hk6jghx9f%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt5a2jx700043b6h261hqftc%2522%252C%2522activeTabId%2522%253A%2522clt5a2jx700033b6hk6jghx9f%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/next-parallel-2>
> 3. 下载代码：`git clone -b next-parallel-2 git@github.com:mqyqingfeng/next-app-demo.git`

那么问题又来了，如果我在某一个插槽里新建了一个路由，我难道还要在其他插槽里也新建这个路由吗？这岂不是很麻烦？

为了解决这个问题，Next.js 提供了 default.js。当发生硬导航的时候，Next.js 会为不匹配的插槽呈现 default.js 中定义的内容，如果 default.js 没有定义，再渲染 404 错误。

现在删除 `app/@team/visitors/page.js` 和 `app/visitors/page.js`，改用 default.js：

新建 `app/@team/default.js`，代码如下：

```js
export default function Page() {
    return <div className="h-60 flex-1 rounded-xl bg-indigo-700 text-white flex items-center justify-center">Hello, Team Default!</div>
}
```

新建 `app/default.js`，代码如下：

```js
export default function Page() {
  return (
    <div className="p-10 mt-6 bg-sky-600 text-white rounded-xl">
      Hello, App Default!
    </div>
  );
}
```

此时效果如下：

![parallel-routers-4.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04a4460dc66b4ecabbd5117198fe5039~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1786&h=861&s=242849&e=gif&f=48&b=101010)

> 1. 线上效果：[CodeSandbox Parallel Routes Default](https://codesandbox.io/p/devbox/parallel-routes-slot-default-6xf2fl?layout=%257B%2522sidebarPanel%2522%253A%2522EXPLORER%2522%252C%2522rootPanelGroup%2522%253A%257B%2522direction%2522%253A%2522horizontal%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522id%2522%253A%2522ROOT_LAYOUT%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522UNKNOWN%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522clt5ik79y00073b6hf3l3fzbg%2522%252C%2522sizes%2522%253A%255B70%252C30%255D%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522EDITOR%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522EDITOR%2522%252C%2522id%2522%253A%2522clt5ik79y00023b6hn97lfg2a%2522%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522direction%2522%253A%2522horizontal%2522%252C%2522id%2522%253A%2522SHELLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522SHELLS%2522%252C%2522id%2522%253A%2522clt5ik79y00043b6h22zpnrac%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%257D%252C%257B%2522type%2522%253A%2522PANEL_GROUP%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522direction%2522%253A%2522vertical%2522%252C%2522id%2522%253A%2522DEVTOOLS%2522%252C%2522panels%2522%253A%255B%257B%2522type%2522%253A%2522PANEL%2522%252C%2522contentType%2522%253A%2522DEVTOOLS%2522%252C%2522id%2522%253A%2522clt5ik79y00063b6h4xgmbxtp%2522%257D%255D%252C%2522sizes%2522%253A%255B100%255D%257D%255D%252C%2522sizes%2522%253A%255B50%252C50%255D%257D%252C%2522tabbedPanels%2522%253A%257B%2522clt5ik79y00023b6hn97lfg2a%2522%253A%257B%2522id%2522%253A%2522clt5ik79y00023b6hn97lfg2a%2522%252C%2522tabs%2522%253A%255B%255D%257D%252C%2522clt5ik79y00063b6h4xgmbxtp%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt5ik79y00053b6hh4drcmyn%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_PORT%2522%252C%2522taskId%2522%253A%2522dev%2522%252C%2522port%2522%253A3000%252C%2522path%2522%253A%2522%252Fvisitors%2522%257D%255D%252C%2522id%2522%253A%2522clt5ik79y00063b6h4xgmbxtp%2522%252C%2522activeTabId%2522%253A%2522clt5ik79y00053b6hh4drcmyn%2522%257D%252C%2522clt5ik79y00043b6h22zpnrac%2522%253A%257B%2522tabs%2522%253A%255B%257B%2522id%2522%253A%2522clt5ik79y00033b6h3hj0kx19%2522%252C%2522mode%2522%253A%2522permanent%2522%252C%2522type%2522%253A%2522TASK_LOG%2522%252C%2522taskId%2522%253A%2522dev%2522%257D%255D%252C%2522id%2522%253A%2522clt5ik79y00043b6h22zpnrac%2522%252C%2522activeTabId%2522%253A%2522clt5ik79y00033b6h3hj0kx19%2522%257D%257D%252C%2522showDevtools%2522%253Atrue%252C%2522showShells%2522%253Atrue%252C%2522showSidebar%2522%253Atrue%252C%2522sidebarPanelSize%2522%253A15%257D)
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/next-parallel-3>
> 3. 下载代码：`git clone -b next-parallel-3 git@github.com:mqyqingfeng/next-app-demo.git`

## 4. 拦截路由（Intercepting Routes）

拦截路由允许你在当前路由拦截其他路由地址并在当前路由中展示内容。

### 4.1 效果展示

让我们直接看个案例，打开 [dribbble.com](https://dribbble.com/) 这个网站，你可以看到很多美图：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dec9df9082c74c2eb82df134572f764f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2738\&h=1504\&s=3417194\&e=png\&b=fcfafa)

现在点击任意一张图片：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8991033e34074f4d83c9e48403193d6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2746\&h=2126\&s=3229103\&e=png\&b=f9f0ee)

此时页面弹出了一层 Modal，Modal 中展示了该图片的具体内容。如果你想要查看其他图片，点击右上角的关闭按钮，关掉 Modal 即可继续浏览。值得注意的是，此时路由地址也发生了变化，它变成了这张图片的具体地址。如果你喜欢这张图片，直接复制当前的地址分享给朋友即可。

而当你的朋友打开时，其实不需要再以 Modal 的形式展现，直接展示这张图片的具体内容即可。现在刷新下该页面，你会发现页面的样式不同了：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cc41d1bffa44ea59fb4372729d376ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2774\&h=2256\&s=3254329\&e=png\&b=f9f1f0)

在这个样式里没有 Modal，就是展示这张图片的内容。

同样一个路由地址，却展示了不同的内容。这就是拦截路由的效果。如果你在 `dribbble.com` 想要访问 `dribbble.com/shots/xxxxx`，此时会拦截 `dribbble.com/shots/xxxxx` 这个路由地址，以 Modal 的形式展现。而当直接访问 `dribbble.com/shots/xxxxx` 时，则是原本的样式。

示意图如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc1bf827eb0549eebc4e9232e9f5b40f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=617\&s=243096\&e=png\&b=1e1e1e)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5a196f02498491aa4eb342238e77955~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=604\&s=280419\&e=png\&b=191919)

这是另一个拦截路由的 Demo 演示：<https://nextjs-app-route-interception.vercel.app/>

了解了拦截路由的效果，让我们再思考下使用拦截路由的意义是什么。

简单的来说，就是希望用户继续停留在重要的页面上。比如上述例子中的图片流页面，开发者肯定是希望用户能够持续在图片流页面浏览，如果点击一张图片就跳转出去，会打断用户的浏览体验，如果点击只展示一个 Modal，分享操作又会变得麻烦一点。拦截路由正好可以实现这样一种平衡。又比如任务列表页面，点击其中一项任务，弹出 Modal 让你能够编辑此任务，同时又可以方便的分享任务内容。

### 4.2 实现方式

那么这个效果该如何实现呢？在 Next.js 中，实现拦截路由需要你在命名文件夹的时候以 `(..)` 开头，其中：

*   `(.)` 表示匹配同一层级
*   `(..)` 表示匹配上一层级
*   `(..)(..)` 表示匹配上上层级。
*   `(...)` 表示匹配根目录

但是要注意的是，这个匹配的是路由的层级而不是文件夹路径的层级，就比如路由组、平行路由这些不会影响 URL 的文件夹就不会被计算层级。

看个例子：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/731ab39e379e40ffadd2119cdc843e1d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=930\&s=465834\&e=png\&b=161616)

`/feed/(..)photo`对应的路由是 `/feed/photo`，要拦截的路由是 `/photo`，两者只差了一个层级，所以使用 `(..)`。

### 4.3 示例代码

我们写个 demo 来实现这个效果，目录结构如下：

```javascript
app
├─ layout.js
├─ page.js
├─ data.js
├─ default.js
├─ @modal
│  ├─ default.js
│  └─ (.)photo
│     └─ [id]
│        └─ page.js
└─ photo
   └─ [id]
      └─ page.js
```

虽然涉及的文件很多，但每个文件的代码都很简单。

先 Mock 一下图片的数据，`app/data.js`代码如下：

```javascript
export const photos = [
  { id: "1", src: "http://placekitten.com/210/210" },
  { id: "2", src: "http://placekitten.com/330/330" },
  { id: "3", src: "http://placekitten.com/220/220" },
  { id: "4", src: "http://placekitten.com/240/240" },
  { id: "5", src: "http://placekitten.com/250/250" },
  { id: "6", src: "http://placekitten.com/300/300" },
  { id: "7", src: "http://placekitten.com/500/500" },
];
```

`app/page.js`代码如下：

```javascript
import Link from "next/link";
import { photos } from "./data";

export default function Home() {
  return (
    <main className="flex flex-row flex-wrap">
      {photos.map(({ id, src }) => (
        <Link key={id} href={`/photo/${id}`}>
          <img width="200" src={src} className="m-1" />
        </Link>
      ))}
    </main>
  );
}
```

`app/layout.js` 代码如下：

```javascript
import "./globals.css";

export default function Layout({ children, modal }) {
  return (
    <html>
      <body>
        {children}
        {modal}
      </body>
    </html>
  );
}
```

此时访问 `/`，效果如下：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7656b3c2eef549f5b5ac13e15649edfc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2174&h=1020&s=1634063&e=png&b=f9f6f6)

现在我们再来实现下单独访问图片地址时的效果，新建 `app/photo/[id]/page.js`，代码如下：

```javascript
import { photos } from "../../data";

export default function PhotoPage({ params: { id } }) {
  const photo = photos.find((p) => p.id === id);
  return <img className="block w-1/4 mx-auto mt-10" src={photo.src} />;
}
```

访问 `/photo/6`，效果如下：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d75c00958d4b4fc989a5c3c669dfbcac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1890&h=810&s=392046&e=png&b=fdfdfd)


现在我们开始实现拦截路由，为了和单独访问图片地址时的样式区分，我们声明另一种样式效果。`app/@modal/(.)photo/[id]/page.js` 代码如下：

```javascript
import { photos } from "../../../data";

export default function PhotoModal({ params: { id } }) {
  const photo = photos.find((p) => p.id === id)
  return (
    <div className="flex h-60 justify-center items-center fixed bottom-0 bg-slate-300 w-full">
      <img className="w-52" src={photo.src} />
    </div>
  )
}
```

因为用到了平行路由，所以我们需要设置 default.js。`app/default.js` 和 `app/@modal/default.js`的代码都是：

```javascript
export default function Default() {
  return null
}
```

最终的效果如下：

![intercepting-routers-5.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a60151ea58a24313aca456e9aa90814a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1787&h=951&s=1190960&e=gif&f=80&b=171717)

你可以看到，在 `/`路由下，访问 `/photo/5`，路由会被拦截，并使用 `@modal/(.)photo/[id]/page.js` 的样式。

> 1. 线上查看代码和效果：[CodeSandbox Intercepting Routes](https://codesandbox.io/p/devbox/intercepting-routes-6ngfhx)
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/Intercepting-Routes>
> 3. 下载代码：`git clone -b Intercepting-Routes git@github.com:mqyqingfeng/next-app-demo.git`

## 小结

恭喜你，完成了本节内容的学习！

这一节我们介绍了动态路由、路由组、平行路由、拦截路由，它们的共同特点就需要对文件名进行修饰。其中动态路由用来处理动态的链接，路由组用来组织代码，平行路由和拦截路由则是处理实际开发中会遇到的场景问题。平行路由和拦截路由初次理解的时候可能会有些难度，但只要你跟着文章中的 demo 手敲一遍，相信你一定能够快速理解和掌握！

## 参考链接

1.  [Routing: Dynamic Routes](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes)
2.  [Routing: Route Groups](https://nextjs.org/docs/app/building-your-application/routing/route-groups)
3.  [Routing: Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes)
4.  [Routing: Intercepting Routes](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes)


## 50.实战篇 | React Notes | Vercel 部署

## 前言

本篇我们讲解如何用 Vercel 部署我们的 Next.js 项目。

## Vercel 公司

Vercel 既是一个产品也是一家公司。我们就先说说 Vercel 这家公司的故事。

Vercel 是由 Guillermo Rauch 创立的云服务公司，它的前身是 2015 年 Guillermo 创立的 Zeit，2020 年才更名为 Vercel。

Zeit 于 2016 年推出了核心产品 now，用于帮助开发者快速将应用部署到云端。因为在那个时候，云部署还并未像现在这样便利，now 将域名解析、证书、缓存等服务都做到产品内部，让用户能够一键部署，节省时间精力。

2016 年也正是前后端分离架构开始流行的时候，虽然前后端分离带来了前端的“繁荣”，但也带来了诸如 SEO 等问题。于是很多开发者开始设计 SSR 框架，Guillermo 也看到了这一问题（以及问题背后的机遇），创建了 Next.js，一个基于 React （当时正火）的 SSR 框架。在之后的这些年里，Next.js 持续深耕运营，如大家所见，Next.js 目前已成为 React 领域里的明星项目。

Next.js 的成功也带动了 Vercel 的发展，Vercel 也深度集成了 Next.js，这使得 Next.js 项目的开发者会更倾向于使用 Vercel 进行部署。2021 年，Vercel 完成了 1.5 亿美元的 D 轮融资。目前估值已经达到了 25 亿美金。

除此之外，Vercel 被人津津乐道的是它挖了不少业界大佬，如：

*   Sebastian Markbage：原 React 团队 Tech Lead
*   Rich Harries：sveltejs 作者 & rollup 核心贡献者
*   Donny：swc 作者
*   Tobias Koppers：webpack 作者
*   Alexander Akait：webpack 核心贡献者 & prettier 贡献者
*   Jared Palme：Turborepo 创始人
*   ……

目前 Next.js 依然由 Vercel 来维护，再加上全明星的开发团队，未来可期。

## Vercel 产品

接下来我们说说 Vercel 这个产品，根据[官网](https://vercel.com/)的介绍：

> **Vercel is the Frontend Cloud**. Build, scale, and secure a faster, personalized web.

简单来说，Vercel 是一个网站托管平台，部署体验好。

具体来说，有以下这些功能特点：

1.  **部署方便**：一键部署，可以快速将前端应用程序、静态网站、API 等部署到 CDN 上，支持自定义域名、HTTPS、数据监控等，与 Git 集成，支持自动化部署，当提交了新的代码时会自动构建并部署
2.  **性能与拓展性**：支持多个框架的部署，并利用缓存、路由、边缘网络提供最佳性能和高流量处理能力
3.  **Serverless 函数**：可以轻松构建和部署无服务器函数和 API，无需关心服务器的维护和扩展
4.  **团队协作**：支持团队协作功能，并与 GitHub、Gitlab 等平台无缝集成

不过国内因为一些原因，Vercel 部署的网站无法直接访问，使用 Vercel 部署的项目更适合用于出海。

## 使用 Vercel

使用 Vercel 部署自然需要一个账号，注册地址：<https://vercel.com/signup>，建议使用 GitHub 账号登陆，这样可以方便部署自己在 GitHub 上的项目。

### 部署纯前端项目

现在让我们部署一个纯前端项目来熟悉下基本流程吧！

#### 导入项目

Vercel 支持导入 Git 项目或者使用 Vercel 提供的[现成模板](https://vercel.com/templates/next.js)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf35df3ed9c048a797a70bbe96cb0a5d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2542\&h=1462\&s=387890\&e=png\&b=fbfbfb)

点击上图左侧的 `Install` 按钮，会授权 Vercel 读取和写入 GitHub 的仓库和 Git 信息，可用于自动化部署。

这里我选择了自己账号下的 [next-app-demo](https://github.com/mqyqingfeng/next-app-demo/tree/Intercepting-Routes) 项目，这是我们小册基础篇的 Demo：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c9d0601d1ab4665a3dd9f0eb2f192c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1288\&h=436\&s=49428\&e=png\&b=ffffff)

如果你也想试着部署这个项目，可以选择 `Import Third-Party Git Repository`，然后输入地址：

```bash
https://github.com/mqyqingfeng/next-app-demo/tree/Intercepting-Routes
```

Vercel 会让你在 Git 平台创建一个对应仓库方便后续修改和部署，按照 Vercel 指示操作即可。

#### 部署项目

进入部署页面后，因为我们的代码比较简单，不需要额外的填写，直接点击 `Deploy`即可：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d882d4ff5e034aa488f64c3a1690fe7f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2570\&h=1234\&s=187517\&e=png\&b=fdfdfd)

当部署完成后会进入以下页面：
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/264b623b5b7d4c0f9002f3dfaaac0a1d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2542\&h=1312\&s=319764\&e=png\&b=fdfdfd)

在 `Dashboard` 页面点击 `Visit` 按钮即可访问部署后的效果：

![截屏2024-02-22 14.51.58.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c66d3c68c2547d0b68dae439f379f9e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2526\&h=1214\&s=209845\&e=png\&b=fcfcfc)

像我这次的部署地址为：<https://next-app-demo-ebon.vercel.app/>，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/663c1dc3abe141e2891034916e62eb1b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=974\&h=778\&s=449225\&e=png\&b=fcfbfb)

此外，当你推送代码到这个分支的时候，Vercel 会自动进行部署。如果出现错误，你也可以选择右上角的 `Instant Rollback` 进行回滚。

#### 自定义域名

如果我们想要使用自定义的域名呢？首先你要有一个自己的域名，域名购买和备案可以参考[《一篇域名从购买到备案到解析的详细教程》](https://juejin.cn/post/7052257775270756366)。

假设你已经有了域名，比如我有了 `yayujs.com` 这个域名，我希望将 `nextdemo.yayujs.com`这个域名解析到 Vercel 部署的地址。打开[域名控制台](https://dc.console.aliyun.com/next/index?#/domain-list/all)（我是在万网买的域名，所以这里链接的地址是阿里云域名控制台），选择对应的域名，点击“解析”。

根据 [Vercel 官方文档域名添加](https://vercel.com/docs/getting-started-with-vercel/use-existing)的介绍：

> If the domain is in use by another Vercel account, you will need to verify access to the domain, with a TXT record
>
> If you're using an Apex domain (e.g. example.com), you will need to configure it with an A record
>
> If you're using a Subdomain (e.g. docs.example.com), you will need to configure it with a CNAME record

也就是说，如果是根域，就配置 A 记录，如果是子域，就配置 CNAME 记录。这里因为配置的是子域，所以选择的 `CNAME`，配置如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cee37d6923d843bc8102529c7e5be483~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1544\&h=1310\&s=154178\&e=png\&b=fefefe)

其中记录值填写我们项目部署的域名。

最后在 Vercel 的设置中添加设置的域名：

![截屏2024-02-22 15.58.59.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec577534bd874525a2c18c953cff53eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2648\&h=1604\&s=339531\&e=png\&b=fcfcfc)

效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/483aa9a44ecf47d8bdbdeb5bf79d5747~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1376\&h=788\&s=525860\&e=png\&b=f9f8f8)

#### 国内访问

Vercel 直接部署的域名是无法访问的，我们可以通过 <https://tool.chinaz.com/dnsce> 检测我们的域名：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/663cd28706d14cbca823661d9f8d2624~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2382\&h=1412\&s=479495\&e=png\&b=ffffff)

如何让国内用户也可以访问呢？可以修改我们的域名解析：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56d66933aa7742ad8d7d90c722ebf74d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1478\&h=912\&s=119377\&e=png\&b=fdfdfd)

如果用的 A 记录，记录值为 `76.223.126.88`

如果用的 CNAME，记录值为 `cname-china.vercel-dns.com`

过一小段时间后，再次检测：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/062aea92b711468aa2457fbc3ac8d3dc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2388\&h=1414\&s=474913\&e=png\&b=ffffff)

注：不过有的时候还是会无法访问，国内还是建议用自己的服务器

### 部署 Next.js + Redis 项目

我们以 React Notes 的 day1 项目为例，此时我们代码中使用了 Next.js 和 Redis，我们看下如何部署。

#### 下载项目

下载我们的 day1 分支代码：

```bash
git clone -b day1 git@github.com:mqyqingfeng/next-react-notes-demo.git
```

大家还记得 day1 实现的效果吗？我们本地运行以下代码：

```bash
cd next-react-notes-demo && npm i && npm run dev
```

因为 day1 代码需要开启 redis 服务，所以另起一个命令行运行：

```bash
redis-server
```

等 Redis 服务成功开启，此时打开 <http://localhost:3000/>，页面正常访问：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aecafd1ac7af48b4a6d33d7055f77836~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1800\&h=1188\&s=159776\&e=png\&b=f6f7fa)

左侧笔记列表的标题和时间取自于 Redis 数据库，说明代码运行正常。

#### Vercel Cli

Vercel 提供了 [Vercel Cli](https://vercel.com/docs/cli) 用于命令行部署 Next.js 项目，全局安装 `vercel` 命令：

```bash
npm i -g vercel
```

安装完成后，运行以下命令，检查是否成功安装：

```bash
vercel --version
```

效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d8e34ebb8c741bf906f6fc768ec60be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=940\&h=250\&s=259613\&e=png\&b=100828)

进入我们的项目根目录，目前在 day1 分支，因为 day1 分支的代码不准备再改动，所以我们切换出一个新的分支用于部署：

```bash
git checkout -b vercel-redis
```

项目根目录运行：

```bash
vercel
```

首次在项目中运行 `vercel` 时，Vercel CLI 需要知道要将项目部署到哪里。所以会有一系列的操作提示，这些操作会让你验证身份、在 Vercel 上创建项目，进行构建部署等等。交互效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c5e20b9b20a405da4d51a7035e2915d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2512\&h=928\&s=2530776\&e=png\&b=150a2c)

此步会在项目构建部署的时候出错，因为我们的项目中用了 Redis，但此时并没有开启 Redis，所以运行 `npm run build` 会失败。

既然会失败，其实也没有必要部署这一次。如果你只是希望在 Vercel 上创建一个项目并进行关联，那就运行 `vercel git connect`，等需要部署的时候再运行 `vercel deploy`。交互效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f574b35404904a40a27226f7ff22d074~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1812\&h=688\&s=1407799\&e=png\&b=1a0826)

#### 创建数据库

通过刚才的步骤建立一个项目后，在 Vercel 平台进入创建的项目，选择 `Storage` 选项，这里展示了 Vercel 目前支持的四种数据库：

![截屏2024-02-22 21.06.15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdec3506c5f048199d209a1dddf99b65~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2648\&h=1526\&s=281587\&e=png\&b=090909)

分别是：

*   Vercel KV：基于 Redis 的解决方案，适用于 Key/Value 和 JSON 数据，由 Upstash 提供支持
*   Vercel Postgres：基于 PostgreSQL 的解决方案，轻量关系型数据库，由 Neon 提供支持
*   Vercel Blob：提供文件存储解决方案，由 Cloudflare R2 提供支持
*   Edge Config：全局数据存储，能在 Edge Server 读取，适用于频繁读取但少有改动的配置

这里我们选择 `KV`，点击 `Create`，地区选择默认的即可（选择其他的还会提示你跟项目部署的地区不一致）：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8dee83de51e2491589d450c3109fd3d8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1288\&h=1046\&s=122381\&e=png\&b=090909)

继续点击 Connect：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2697bbede7af4d0c8c1a7ae8c1dfd25c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1230\&h=882\&s=95077\&e=png\&b=090909)

现在可以看到我们创建的 Redis 数据库的地址，Vercel 也贴心的提供了接下来要做的事情：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1431b7228aed4d7b966ab02603980da9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2568\&h=2166\&s=404114\&e=png\&b=040404)

我们解释下这些要做的事情：

1.  Connect to a project：将已有的 Vercel 项目与该数据库进行关联，刚才已经点击了 Connect ，所以不需要再点了。Connect 后，Vercel 会为项目自动添加数据库相关的环境变量：

![截屏2024-02-22 21.46.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e4f600a27ef4ec4abbe89563bd56b8a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2620\&h=1486\&s=322777\&e=png\&b=060606)

2.  Pull your latest environment variables：Vercel 提示让你在本地运行 `vercel env pull .env.development.local`，它的作用是在本地创建一个名为 `.env.development.local`的文件，自动写入上图中的这些环境变量的值，方便你在本地直接使用

3.  Install our package：为方便用户操作数据库，Vercel 提供了自己的库 `@vercel/kv`，具体 API 参考 <https://vercel.com/docs/storage/vercel-kv/kv-reference>

如果一开始就确定用 Vercel 部署，那最好使用 `@vercel-kv`，不过我们用到的 redis API 也比较简单，使用 `ioredis` 也是可以的。现在已经有了 redis 数据库的地址，我们修改下 `/lib/redis.js`：

```javascript
const redis = new Redis(process.env.REDIS_URL)
```

修改 `.env.development.local`，添加如下代码：

```bash
REDIS_URL="rediss://default:xxxxxxxxxxxxxx@xxxxxxxxxxx:33605"
```

我们做的修改就是复制原本的 `KV_URL` 将 `redis://xxxx`改为 `rediss://xxxx`，加个 `s` 表示建立 SSL 连接。

此时本地已经可以成功运行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5731fb10adb34fb4ad4384ce9d929c6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2152\&h=870\&s=149285\&e=png\&b=f3f5f8)

现在我们将代码进行提交（注意 `.env.development.local` 顾名思义，不用提交）：

```bash
git status
git add .
git commit -m "update redis.js"
git push origin vercel-redis
```

提交到 GitHub 后，Vercel 会自动进行部署。但此时部署会失败：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5190ff4c06848b4885f190f966a435b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2488\&h=212\&s=48370\&e=png\&b=fcfcfc)

因为服务端的环境变量还没有建立，我们在该 Vercel 项目上添加一个新的环境变量 `REDIS_URL`：

![截屏2024-02-23 16.50.54.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4164e588c26f461b8b196cfb0a701087~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2610\&h=1106\&s=238575\&e=png\&b=fafafa)

然后重新部署，点击 Redeploy：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e928b9a6f2524bbcbb8e4a9a930866b7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2512\&h=490\&s=98355\&e=png\&b=fafafa)

此次应该会成功部署：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05a7358894cc4e89ab581cec5d1dc9a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2488\&h=876\&s=179613\&e=png\&b=fcfcfc)

#### Preview 与 Production

此时我们已经成功的部署了一个 Next.js + Redis 的项目。在后续的发布中，有一点要注意，那就是 Preview 与 Production 环境的区别。

现在我们用的是 `vercel-redis` 分支，当第一次推送的时候，Vercel 会将其内容部署到生产环境，但是比如你修改了一些内容，然后再次推送到 `vercel-redis` 分支，Vercel 会进行自动化部署，但会放在 Preview 环境中：

![截屏2024-02-23 17.11.29.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45f4c3301d1f4780af4c03913e3e3793~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2486\&h=516\&s=123483\&e=png\&b=fefefe)

这是因为 Vercel 默认将 main / master 分支用于生产环境，只有当你推送代码到 main/master 分支的时候，才会进行生产部署，推送到其他分支就是 Preview 环境。这很好，可以进行多个版本的开发预览。但如果你就是想要指定如 `vercel-redis` 分支作为生产环境部署，可以在 Settings 中修改：

![截屏2024-02-23 17.16.03.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffdc1f4578ec4993b1230e15f36a2bec~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2500\&h=904\&s=221569\&e=png\&b=fdfdfd)

此时再推送到 `vercel-redis` 分支就会进行生产部署。

### 部署 Next.js + 关系型数据库 + Prisma 项目

通过前面的示例，想必你已经对 Vercel 平台的使用有所了解，那就来正式部署我们的项目吧。

#### 下载项目

依然选用我们的 day11 分支代码。此时我们的技术选型是 Next.js + MySQL + Prisma。

下载我们的 day11 分支代码：

```bash
git clone -b day11 git@github.com:mqyqingfeng/next-react-notes-demo.git
```

老规矩，先本地运行一下，验证代码无问题：

```bash
# 注意要在本地开启 MySQL 后运行：
npm i && npm run dev
```

正如大家在上节看到，Vercel 是没有提供 MySQL 数据库的，关系型数据库只有 Vercel Postgres。如果确定用 MySQL 数据库，那可以使用搭配使用 [PlanetScale](https://planetscale.com/)，它是一个 MySQL 云数据库。如果用 Mongodb，则通常会搭配 [MongoDB Atlas](https://www.mongodb.com/zh-cn/cloud/atlas/lp/try4) 云数据库。所以对于我们的项目，部署有两种选择：

1.  改用 Vercel 提供的 Vercel Postgres，也就是改用 PostgreSQL 数据库
2.  使用 PlanetScale 云 MySQL 数据库

从技术选型的角度来讲，如果我知道最终用 Vercel 进行部署，我可能一开始就会选择用 PostgreSQL 数据库。

从钱的角度来讲，Vercel 的免费版只支持一个 PostgreSQL 数据库，且有 256MB 和每月 60h 计算时间的限制。PlanetScale 的免费版则是 5 GB 存储空间，10 亿行读取次数每月，1000 万行写入每月。更推荐用 PlanetScale。

从学习的角度来讲，就让我们顺便学习一下 Prisma 和 PostgreSQL 如何搭配使用吧！

所以我们改用 PostgreSQL 数据库（其实两种方式操作差不多）。所幸我们的项目用了 Prisma，切换的成本并不高。让我们看看如何实现吧！

#### 切换数据库

进入项目目录，运行 `vercel git connect`在 Vercel 平台上建立关联项目：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/074d143c410041d5938db059fab77d95~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1742\&h=654\&s=905671\&e=png\&b=210c3b)

建立项目后，选择 `Storage`选项，建立一个 Vercel Postgres 数据库，最终获得该数据库地址为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38f7c208f1034cd399971130020c920b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2518\&h=534\&s=123013\&e=png\&b=050505)

拷贝上图 `.env.local` 选项中的环境变量，将其写入 `.env`文件：

![截屏2024-02-26 17.50.19.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/312398e56ea44f9ba905d038579a4b45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2508\&h=812\&s=171128\&e=png\&b=fefefe)
注：为什么不运行 `vercel env pull .env`呢？因为这会强行覆盖 `.env` 文件。为什么不写入其他文件如 `.env.local`呢？因为 prisma 默认读取的是 `.env` 文件中的环境变量。为了简单起见选择手动拷贝的方式。

修改 `prisma/schema.prisma`文件：

```javascript
datasource db {
  provider = "postgresql"
  url = env("POSTGRES_PRISMA_URL")
}
```

运行 `npx prisma db push`，将数据模型同步数据库。

现在，让我们在本地再次运行 `npm run dev`校验数据库切换是否有问题：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d6eb327e186495da24a4546643aa71c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2308\&h=962\&s=174814\&e=png\&b=f4f5f9)

#### 部署线上

修改 `package.json`，代码如下：

```javascript
{
  "scripts": {
    "dev": "npx prisma generate && next dev",
    "build": "npx prisma generate && npx prisma db push && next build"
  }
}

```

修改 `.env.production`：

```bash
# 注释掉 AUTH_URL，v5 之后默认不需要了，但比如用了代理的时候依然需要
# AUTH_URL=https://notes.yayujs.com
```

因为使用了 next-auth，在 Vercel 项目的环境变量中需要添加 `AUTH_SECRET`：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/386071fb2bbf49c78a496a685bc578dd~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3294\&h=498\&s=114358\&e=png\&b=060606)

目前我们还在 day11 分支，切换为新的 `vercel-postgres`分支，然后将代码提交到远程的 `vercel-postgres`分支，因为是首次部署，所以会部署到生产版本，交互效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7950eac2d0e4e7e9a2e602b49745e71~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1362\&h=720\&s=863478\&e=png\&b=1c0b3a)

Vercel 自动部署后，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91e7606056aa464585d892e44b571f64~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2490\&h=1142\&s=174342\&e=png\&b=f6f7fa)

部署后的项目源码：<https://github.com/mqyqingfeng/next-react-notes-demo/tree/vercel-postgres>

## 参考链接

1.  <https://juejin.cn/post/7057333396359348255>
2.  <https://www.zhihu.com/question/506210785/answer/2347889174>
3.  <https://vercel.com/>
4.  <https://lastrev.com/blog/introduction-to-vercel-a-beginners-guide>
5.  <https://github.com/vercel/examples/tree/main/storage/postgres-prisma>

>


## 51.实战篇 | 博客 | 快速实现

## 前言

我叫冴羽，我要写一个博客。

原因无他，踏入江湖多年，写了那么多篇文章，讲过那么多鸡汤，至今还没有自己的技术博客。

倒不是没尝试过，而是每次热情都消耗在了搭建博客上。真到一篇一篇写博客内容的时候，立刻就蔫了。

于是我告诉自己，铁打的平台，流水的作者。

不对！愿当流水，流水不争先，争的是滔滔不绝。

十年过去了，我还没有自己的技术博客……

我后悔了，我要写一个博客。

## 为什么

使用平台有很多好处，有流量、有氛围、有反馈。做的好，还能挣点小钱。

自建博客没有这些好处，但自由。文字自由、形式自由。好吧，也就这么点好处了……

说到底为什么要建立自己的博客呢？

1.  展示。展示自己的技术、展示自己的作品、展示自己的思考，作为互联网交流的名片，找工作、找对象。
2.  分享。分享自己的原创文章。虽然一开始籍籍无名，没有什么流量，但万一我笔耕不辍，十年磨剑，终成大佬呢！
3.  赚钱。等有流量了再说吧

那行吧！建！

## 怎么做

从头建吗？自己设计产品、自己构思 UI、自己开发，自己运维？即使有 AI 辅助，也太累了。我又不是要找工作，写个博客还可以充当项目经历，感觉没必要。

半自建？相关技术选型琳琅满目：WordPress、Gitbook、Hexo、VuePress、Docusaurus、Nextra、Docsify、mdBook、NextBook……一时间都不知道如何选择。

且让我捋捋：

1.  WordPress：老牌 CMS 框架，插件众多，背后技术选型为 PHP + MySQL
2.  [Gitbook](https://www.gitbook.com/)：方便与 GitHub 集成，支持 Markdown 格式编写文档，现在转向商业，不建议用
3.  [Hexo](https://hexo.io/zh-cn/)：快速、简洁且高效的博客 Node.js 框架，主题、插件众多，支持 Markdown
4.  [VuePress](https://vuepress.vuejs.org/zh/)：基于 Vue 的静态网站生成器，本质将 Markdown 编译为 HTML。
    1.  网站参考：[VuePress](https://vuepress.vuejs.org/zh/)、[TypeScript 中文](https://ts.yayujs.com/)
5.  [Docusaurus](https://docusaurus.io/)：Facebook 开源的建站工具，基于 React，本质也是将 Markdown 编译为 HTML。
    1.  网站参考：[Redux](https://react-redux.js.org/)、[Create React App](https://create-react-app.dev/)、[Prettier](https://prettier.io/)
6.  [Docsify](https://docsify.js.org/#/)：不同于构建的时候将 MD 编译为 HTML，Docsify 是运行时，不是静态网站生成器，不适合搜索引擎优化
7.  [Nextra](https://nextra.site/)：基于 Next.js 的静态网站生成器，目前还不支持 App Router
8.  [mdBook](https://github.com/rust-lang/mdBook)：你可以理解为 Rust 版的 Gitbook
9.  [NextBook](https://next-book.vercel.app/intro)：你可以理解为 Next.js 版的 Gitbook，更适合于技术书籍或文档的风格样式
    1.  网站参考：[NextBook](https://next-book.vercel.app/reference/markdown)

说是博客，其实这很多都偏向于建立文档网站。

如果是建立文档网站，我个人的建议是，如果你会 Vue，推荐使用 VuePress 或 VitePress，如果你会 React，推荐使用 Docusaurus。当然这些技术选型本身并不难，也可以根据自己喜欢的样式进行选择。

至于我们的博客项目，我们都不选择。

毕竟我们做的是博客，博客的一大目的在于展示自己，比如嵌入自己的作品、做一个简历页、添加广告位等等，所以需要更高的灵活度。使用这些工具虽然可以快速构建出一个文档站点，但有些内容自定义会变得特别麻烦。

所以我们还是以写项目的形式做这个博客。

但我也不想从 Next.js 的脚手架开始做起来……有没有做好的半成品可以让我直接用呢……

## 经验：多找找前人栽的树

遇到这种情况:

### 1. 找找 Vercel 模板

首先到 Vercel 的[模板页面](https://vercel.com/templates?search=blog)看看。比如以“Blog”作为关键词进行搜索，你会发现有不少现成的模板：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f2339947ba646cea993739d8a4bb39b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3126\&h=2420\&s=1428809\&e=png\&b=030303)

每个模板都提供了 Demo 和源码地址，看看样式、相关技术选型是否满足你的需求。

### 2. 找找 GitHub

然后到 GitHub，比如以 Next.js + Blog 作为关键词进行搜索，按照匹配度、Stars 等进行排序，看看是否有合适的项目。

### 3. 找找技术网站

最后除了 Google 直接搜索，还可以到各大技术网站比如 [Medium](https://medium.com/)、[Dev.to](https://dev.to/)、[Hacker News](https://news.ycombinator.com/news)、[Indie Hackers](https://www.indiehackers.com/)，搜索相关内容。

至于国内的技术网站，想必大家都很熟了，就不多说了。

当然，各种 AI 工具用起来也很不错。

比如我就找到了一篇不错的文章：[28 Open-source Free Next.js Blog Templates Starters](https://medevel.com/28-next-js-blog-starter/)，其中有不少不错的博客模板，可以参考。

最终选了这样一个模板：<https://github.com/timlrx/tailwind-nextjs-starter-blog>

主要有以下这些原因：

1.  Next.js、Tailwind CSS Blog start template，作为项目初始模板，接下来正常使用 Next.js 开发即可，保证了项目最大灵活度
2.  GitHub 7k Star，依然在持续维护中
3.  支持 MDX、支持 dark 主题
4.  SEO 友好、移动端友好、代码轻量

初期博客不会有什么流量，购买服务器进行部署，性价比太低。干脆直接用 Vercel 部署，然后使用自定义域名。这样需要花费的就只是一个域名钱。

## 快速开始

### 1. Vercel 部署

这个 GitHub 仓库也有对应的 Vercel 模板：[Tailwind CSS Blog](https://vercel.com/templates/next.js/tailwind-css-starter-blog)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/568dd9e466ff4b7b825590899366591c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3164\&h=1870\&s=378453\&e=png\&b=fcfcfc)

点击 Create，部署完成后自动跳转到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd22c602b18b42b5b50192a476ac2d6d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3150\&h=1490\&s=530832\&e=png\&b=fdfdfd)

点击左侧的预览图片，查看部署效果：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70302755950e448085d87073ae9292e0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2792\&h=1792\&s=334228\&e=png\&b=ffffff)

### 2. 添加自定义域名

添加自定义域名，并保证国内能够正常访问，参考[《实战篇 | React Notes | Vercel 部署》](https://juejin.cn/book/7307859898316881957/section/7309114840307400714#heading-8)，比如我设置的域名为 [yayujs.com](https://yayujs.com)

### 3. 下载代码

找到仓库的 GitHub 地址，下载到本地：

```bash
# 替换为自己的仓库地址
git clone git@github.com:mqyqingfeng/yayujs-blog.git

# 进入仓库，替换为自己的项目地址
cd yayujs-blog

# 安装依赖项并启动
npm i && npm run dev
```

打开 <http://localhost:3000/>，查看效果：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1060f29b90b47789f5e0e68e9f46749~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3156\&h=1798\&s=346254\&e=png\&b=ffffff)

### 4. 修改代码

#### 4.1. 修改站点信息

首先修改 `/data/siteMetadata.js`，这里存放的是站点相关的信息，会被多个地方用到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20b227e1aa924d5d84aaf53f639a5e35~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1904\&h=786\&s=215298\&e=png\&b=1e1e1e)

修改后，可以发现主页展示的内容和 HTML 元数据都发生了变化：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de98327fe8a2448f99d9adf77c92e7d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3820\&h=1942\&s=1407874\&e=png\&b=ffffff)

#### 4.2. 修改 logo

![截屏2024-04-30 17.24.03.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7bb166a7bb34a70926e29564c5799c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2322\&h=232\&s=50385\&e=png\&b=ffffff)

这个就是我们的 logo，对应的图片位置是 `/data/logo.svg`，可以直接替换。

如果你想直接用图片，比如添加一张图片 `/data/logo.png`，还需要修改 `/components/Header.tsx`，修改后的代码如下：

```javascript
import Logo from '@/data/logo.png'
import Image from 'next/image'

const Header = () => {
  return (
    <header className="flex items-center justify-between py-10">
      <div>
        <Link href="/" aria-label={siteMetadata.headerTitle}>
          <div className="flex items-center justify-between">
            <div className="mr-3">
              <Image src={Logo} alt="logo" width="50" />
            </div>
            // ...
          </div>
        </Link>
      </div>
      // ...
    </header>
  )
}

export default Header

```

修改的主要内容就是将原来的`<Logo>` 改为 `<Image src={Logo} alt="logo" width="50" />`。

此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cfe2458f494493b844e0f0ab21e435f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2352\&h=392\&s=92090\&e=png\&b=ffffff)

#### 4.3. 修改导航栏信息

右侧导航栏的信息在 `/data/headerNavLinks.ts`，根据自己的需求修改即可。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8892b302d0440bb8d986a23a72391f3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2328\&h=448\&s=96268\&e=png\&b=ffffff)

#### 4.4. 修改主页样式

这里的内容看着有些奇怪：
![截屏2024-04-30 17.37.42.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7fbee7ccad5454fbd74e47677375845~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2354\&h=758\&s=140953\&e=png\&b=ffffff)
对应的代码地址为 `app/Main.tsx`，根据自己的需求修改即可。我直接注释掉了，修改后的效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcae0fc8d2644738836e1f4ee760edba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2322\&h=544\&s=123951\&e=png\&b=ffffff)

#### 4.5. 添加一篇文章

博客的文章都以 mdx 格式存在 `/data/blog`下，Next.js 会根据这些内容自动生成博客列表。我们在 `/data/blog`下新建 `nextjs-10-common-mistaks.mdx`，代码如下：

```markdown
---
title: '使用 Next.js App Router 常犯的 10 个错误'
date: '2024-04-30'
tags: ['next-js']
summary: '这里总结了使用 App Router 常犯的 10 个错误，快来查漏补缺，看看自己犯过几个错误吧！'
---

## 前言

最近我看了 Vercel 的产品 VP Lee Robinson 的 Youtube 视频，作为一名前端开发工程师，他分享了很多 Next.js 相关的课程视频，其中就有一条他总结的《Next.js App Router 常犯的 10 个错误》的视频，我觉得非常有意义，所以记录下了这 10 个常犯错误的内容，从我自己的角度为大家介绍下这 10 个错误。
```

`---`包裹的内容是文章的元数据，其中 title 和 date 是必须的，其他可选，具体还有哪些可以参考官网的[介绍](https://github.com/timlrx/tailwind-nextjs-starter-blog?tab=readme-ov-file#frontmatter)。

但是与使用 VuePress 这类工具不同，因为是自己的项目，其实属性和具体如何使用都可以自定义。

此时首页效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/762c50c3af1842ebaf2005d5e949b948~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2302\&h=1588\&s=278219\&e=png\&b=ffffff)
PS：Read more 按钮的文案也是在 `/app/Main.tsx`进行修改。

#### 4.6. 修改作者信息

点进这篇新增的文章，查看具体内容：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c795c63e4a334929b523a9394d8b8d47~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2488\&h=2048\&s=465070\&e=png\&b=ffffff)

你会发现，作者信息不太对。因为我们并没有在 Frontmatter 中设置作者信息，所以它会走到默认的作者信息。修改 `/data/authors/default.mdx`，设置默认作者信息，用于展示作者信息和设置文章页面的元数据：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17c09ee15c01401885bc5fe16c24e30f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3616\&h=590\&s=199726\&e=png\&b=1f1f1f)

修改 `/layouts/PostLayout.tsx`，大概在第 74 行左右，将 twitter 改为使用 github：

```jsx
<dl className="whitespace-nowrap text-sm font-medium leading-5">
  <dt className="sr-only">Name</dt>
  <dd className="text-gray-900 dark:text-gray-100">{author.name}</dd>
  <dt className="sr-only">GitHub</dt>
  <dd>
    {author.github && (
  <Link
    href={author.github}
    className="text-primary-500 hover:text-primary-600 dark:hover:text-primary-400"
    >
    {author.github
      .replace('https://github.com/', '@')
    }
  </Link>
)}
  </dd>
</dl>
```

此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f002530b26c24315a09b17f17091092d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2464\&h=820\&s=165669\&e=png\&b=ffffff)

#### 4.7. 修改项目信息

打开 <http://localhost:3000/projects>，可以查看到预设的项目信息：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32fcf35bfb34b7c9e08261c7ea69837~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2730\&h=2112\&s=1800132\&e=png\&b=ffffff)

修改位置在 `/data/projectsData.ts`，根据自己的需要进行修改即可。

#### 4.8. 修改布局

文章页面支持三种布局格式：

1.  PostLayout：默认选项，两列内容，一列文章元数据，一列文章内容
2.  PostSimple： PostLayout 的简化版，没有文章元数据
3.  PostBanner：文章带 banner

具体使用方式在文章的 Frontmatter 中设置：

```javascript
---
layout: PostSimple 
---
```

### 5. 部署新代码

修改完成后，将代码提交到远程 GitHub，Vercel 会自动进行部署。

不过提交之前，先本地运行 `npm run build`试试看能不能编译成功（因为构建的时候还会做一些检查）。

## 总结

使用这个模板，我们至少节省了这些工作：

1.  实现博客列表和博客文章，渲染 MDX，支持高级 MD 语法如数学
2.  SEO 优化、文章标签功能
3.  实现 light 和 dark 主题
4.  移动端友好，响应式设计
5.  脚手架的设置如 prettier、husky

至于博客剩下的地方，当成正常的 Next.js 项目进行开发即可。

那行，我们的第二个项目——博客项目就实现了！完结！撒花！🎉

……

……

……

等等，如此实现好像太随意了些……

这倒也是，不过，实战就是这样，谁没事天天造轮子呢。做产品也是这样，遇到新的东西，快速纳为己用，将其改造为自己的产品壁垒。

不过为了能够帮助大家理解其原理，我们还是从 Next.js 最基本的脚手架开始做起，往现在的技术方案靠近（也不一定）。明白其原理，你才能自由定制想要的功能或模板，有一天为后人栽树。


## 52.实战篇 | 博客 | Contentlayer

## 前言

本篇开始，我们使用 Next.js 官方脚手架从零实现一个博客项目。那就让我们直接开始吧！

## 初始化项目

运行 `npx create-next-app@latest`新建项目，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a5d98371d704edf93ca9fb41caa6e4d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1642\&h=560\&s=161378\&e=png\&b=1e1e1e)

运行以下命令安装依赖项并开启开发模式：

```bash
cd next-blog && npm i && npm run dev
```

打开 <http://localhost:3000/>，检查页面是否正常运行：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19663be53ebc47af94606b37909a823d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2586\&h=1028\&s=321812\&e=png\&b=070707)

## 如何处理 MDX

博客的一大组成部分是文章，技术同学写文章大多使用 Markdown。哪怕像我写在语雀，也会导出成 Markdown 格式，然后发在掘金……

### 本地 mdx

我们在 [《配置篇 | MDX》](https://juejin.cn/book/7307859898316881957/section/7309078575934930994)讲了如何借助 `@next/mdx` 处理 Markdown 的超集 MDX。当配置完毕后，将原本的 page.js 替换为 page.mdx：

```javascript
  your-project
  ├── app
  │   └── my-mdx-page
  │       └── page.mdx
  └── package.json
```

这样当你访问 `/my-mdx-page`路由的时候，就会打开渲染后的 mdx 内容。

但是这样做的问题在于：如果我要上传一篇文章，我还需要手动新建一个文件夹用于它的路由地址，这属实有点麻烦。

### 远程 mdx

为了简化这个步骤，我们通常会新建一个存放所有文章的文件夹，然后使用动态路由，动态读取对应的文章。

我们试着写一下。先安装一个处理 MDX 的库：

```javascript
npm i next-mdx-remote
```

涉及的文件和目录如下：

```javascript
next-blog              
├─ app                 
│  ├─ posts            
│  │  └─ [id]          
│  │     └─ page.js         
└─ posts               
   └─ first.mdx        
```

新建 `app/posts/[id]/page.js`，代码如下：

```javascript
import { compileMDX } from 'next-mdx-remote/rsc'
import { readFile } from 'node:fs/promises';
import path from 'path';

async function getMDXContent(name) {
  try {
    const filePath = path.join(process.cwd(), '/posts/', `${name}.mdx`)
    const contents = await readFile(filePath, { encoding: 'utf8' });
    return await compileMDX({ source: contents, options: { parseFrontmatter: true }})
  } catch (err) {
    return null
  }
}

export async function generateMetadata({ params, searchParams }, parent) {
  const res = await getMDXContent(params.id);
  if (!res) return { title: ''}
  const { frontmatter } = res;
  return { title: frontmatter.title }
}

export default async function Home({ params }) {
  const res = await getMDXContent(params.id);
  if (!res) return <h1>Page not Found!</h1>
  const {content, frontmatter} = res;

  return (
    <>
      {content}
    </>
  )
}
```

新建 `/posts/first.mdx`，代码如下：

```javascript
---
title: Hello World Article
---

# Hello World!

this is content
```

此时打开 <http://localhost:3000/posts/first>，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9475f274e7a040d6a9026facb1acbed1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2578\&h=726\&s=277984\&e=png\&b=ffffff)

可以看到：MDX 内容成功渲染，且使用 Frontmatter 实现了页面的元数据设置。

但是这样做还是有些问题：

1.  没有构建优化。页面请求的时候才读取对应的 MDX 内容进行渲染，过程并没有做优化，比如提前进行编译
2.  没有类型定义。比如 Frontmatter，代码中用的是 title，但在 MDX 中写作了 tilte，但并不会出现构建错误或提示（相信这种拼写错误大家一般不会犯，更多出现的是 tags 和 tag 这种）
3.  没有实时刷新。比如修改 `first.mdx`，页面内容并不会自动刷新
4.  内容没有被缓存。每次都是重新读取页面内容并渲染。

### Contentlayer

这就是为什么我们需要 Contentlayer。

Contentlayer，顾名思义，内容层。它会将内容转为数据，这样我们就可以在任意组件导入内容，就像我们导入其他库一样。

“将内容转为数据”听起来有些抽象，其实很简单，其本质是监听文件改变，将原本的 md、mdx 等文档内容转为 js、json 等格式，其中包含文档的各种信息，就比如将这样一个名为 `first.mdx` 的文档：

```markdown
---
title: Hello World Article
date: 2014-05-01
---

# Hello, World!
```

转为这样一个 js 文件：

```javascript
{
    title: 'Hello World Article',
    date: '2014-05-01T00:00:00.000Z',
    body: {
      raw: "...",
      code: "var Component=(()=>{var m=Object.create ..."
    },
    _id: 'first.mdx',
    _raw: {
      sourceFilePath: 'first.mdx',
      sourceFileName: 'first.mdx',
      sourceFileDir: '.',
      contentType: 'mdx',
      flattenedPath: 'first'
    }
  }
```

当在组件中使用的时候，不需要再读取原本的 mdx 文件内容，而是导入这个编译后的 js 文件即可。

可能听起来还是有些抽象，还是让我们在实战中体会它的作用吧。

#### 安装设置

尝试安装 next-contentlayer：

```javascript
npm i next-contentlayer
```

如果出现版本不兼容错误：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96375486c4594b0e86c9e414e1d3732e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1808\&h=880\&s=242734\&e=png\&b=1d1d1d)

修改 package.json，添加以下代码再进行安装：

```javascript
{
  // ...
  "overrides": {
    "next-contentlayer": {
      "next": "$next"
    }
  }
}

```

顺便再安装一些后续会用到的库：

```javascript
npm i dayjs rehype-prism-plus remark-gfm@3.0.1
```

其中：

1.  [dayjs](https://day.js.org/zh-CN/) 用于处理时间展示
2.  [rehype-prism-plus](https://www.npmjs.com/package/rehype-prism-plus) 用于处理语法高亮
3.  [remark-gfm](https://github.com/remarkjs/remark-gfm) 用于扩展 Markdown 语法

修改 `next.config.mjs`，完整代码如下：

```javascript
import { withContentlayer } from 'next-contentlayer'
export default withContentlayer({})
```

修改 `jsconfig.json`，完整代码如下：

```javascript
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "contentlayer/generated": ["./.contentlayer/generated"],
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.js",
    "**/*.js",
    "**/*.jsx",
    ".next/types/**/*.js",
    ".contentlayer/generated"
  ]
}
```

修改 `.gitignore` 文件，添加如下代码：

```bash
# contentlayer
.contentlayer
```

.contentlayer 存放的正是 md、mdx 编译后的文件，这些并不需要提交到远程仓库。

#### 定义内容 Schema

根目录新建 `contentlayer.config.ts`，代码如下：

```javascript
import { defineDocumentType, makeSource } from 'contentlayer/source-files'
import remarkGfm from 'remark-gfm'
import rehypePrismPlus from 'rehype-prism-plus'

export const Post = defineDocumentType(() => ({
  name: 'Post',
  filePathPattern: `**/*.mdx`,
  contentType: 'mdx',
  fields: {
    title: { type: 'string', required: true },
    date: { type: 'date', required: true },
  },
  computedFields: {
    url: { type: 'string', resolve: (post) => `/posts/${post._raw.flattenedPath}` },
  },
}))

export default makeSource({ 
  contentDirPath: 'posts', 
  documentTypes: [Post],
  mdx: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [[rehypePrismPlus, { defaultLanguage: 'js', ignoreMissing: true }],],
  }
})
```

在这段代码中，makeSource 定义了 markdown 文档所在的位置和用到的插件，defineDocumentType 定义了 Frontmatter 的字段类型，比如我们的文档需要定义 title 和 date 两个字段，两个字段都是必须的，如果缺失某些字段，会有错误提示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b4e0c6557641e482eb5a50c872a947~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1794\&h=446\&s=73684\&e=png\&b=1e1e1e)

如果使用了未定义的字段，也会出现错误提示：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1c7cb4cb2f4b06a1980a01705b0161~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1798\&h=378\&s=63805\&e=png\&b=1e1e1e)

#### 添加站点代码

修改 `/posts/first.mdx`，代码如下：

````javascript
---
title: Hello World Article
date: 2014-05-01
---

# Hello, World!

**这是一段加粗文字**

~~这是一段删除文字~~

```js {1,3-4} showLineNumbers
function fancyAlert(arg) {
  if (arg) {
    $.facebox({ div: '#foo' })
  }
}
````

````

新建 `/app/posts/page.js`，代码如下：

```jsx
import Link from 'next/link'
import { allPosts } from 'contentlayer/generated'
import dayjs from "dayjs";

function PostCard(post) {
  return (
    <div className="mb-8">
      <h2 className="mb-1 text-xl">
        <Link href={post.url} className="text-blue-700 hover:text-blue-900 dark:text-blue-400">
          {post.title}
        </Link>
      </h2>
      <time dateTime={post.date} className="mb-2 block text-xs text-gray-600">
        {dayjs(post.date).format('DD/MM/YYYY')}
      </time>
    </div>
  )
}

export default function Home() {
  return (
    <div className="mx-auto max-w-xl py-8">
      <h1 className="mb-8 text-center text-2xl font-black">My Blog List</h1>
      {allPosts.map((post, idx) => (
      <PostCard key={idx} {...post} />
    ))}
    </div>
  )
}
````

在这段代码中，我们从 `'contentlayer/generated'`中导出了 allPosts 变量，这有点让人奇怪，allPosts 到底是哪里定义的呢？

前面我们说过 contentlayer 的本质是实时编译，将 md 文档编译成普通的 js 文件，编译后的内容存放在项目根目录下的 `.contentlayer`文件夹中。

我们在 `contentlayer.config.ts` 中定义了一个名为 Post 的文档类型，对应的所有数据就是 all + 它的复数形式，也就是 allPosts。

再举个例子，如果定义的文档类型名称为 Page，对应的所有文档数据则为 allPages，它本质上一个包含所有导入 JSON 文档的数组。让我们打印下 allPosts 看一下具体的结构：

```javascript
[
  {
    title: 'Hello World Article',
    date: '2014-05-01T00:00:00.000Z',
    body: {
      raw: "...",
      code: "var Component=(()=>{var m=Object.create ..."
    },
    _id: 'first.mdx',
    _raw: {
      sourceFilePath: 'first.mdx',
      sourceFileName: 'first.mdx',
      sourceFileDir: '.',
      contentType: 'mdx',
      flattenedPath: 'first'
    },
    type: 'Post',
    url: '/posts/first'
  },
  {
    title: 'Hello Earth Article',
    date: '2014-05-02T00:00:00.000Z',
    body: {
      raw: "...",
      code: "..."
    },
    _id: 'second.mdx',
    _raw: {
      sourceFilePath: 'second.mdx',
      sourceFileName: 'second.mdx',
      sourceFileDir: '.',
      contentType: 'mdx',
      flattenedPath: 'second'
    },
    type: 'Post',
    url: '/posts/second'
  }
]
```

allPosts 是一个数组，每一个元素包含了该文档的所有 FontMatter 字段以及文档的原内容（body.raw）和编译后的内容（body.code）。

此时浏览器效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aacd2066dcb941de8b8ebf5c19db8bbf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2072\&h=970\&s=111563\&e=png\&b=ffffff)

修改 `app/posts/[id]/page.js`，代码如下：

```jsx
import { allPosts } from 'contentlayer/generated'
import { useMDXComponent } from 'next-contentlayer/hooks'
import { notFound } from 'next/navigation'
import dayjs from "dayjs";

export async function generateStaticParams() {
  return allPosts.map((post) => ({
    id: post._raw.flattenedPath,
  }))
}
export const generateMetadata = ({ params }) => {
  const post = allPosts.find((post) => post._raw.flattenedPath === params.id)
  if (!post) throw new Error(`Post not found for id: ${params.id}`)
  return { title: post.title }
}

const Page = ({ params }) => {
  const post = allPosts.find((post) => post._raw.flattenedPath === params.id)
  if (!post) notFound()
  const MDXContent = useMDXComponent(post.body.code)

  return (
    <article className="mx-auto max-w-xl py-8">
      <div className="mb-8 text-center">
        <time dateTime={post.date} className="mb-1 text-xs text-gray-600">
          {dayjs(post.date).format('DD/MM/YYYY')}
        </time>
        <h1 className="text-3xl font-bold">{post.title}</h1>
      </div>
      <MDXContent />
    </article>
  )
}

export default Page
```

因为我们使用了 rehypePrismPlus 作为代码的样式插件，它会将代码编译成带类名的 html：

![截屏2024-05-06 17.42.36.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1b2f467c4c24cea8396055290d9837c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2778\&h=1448\&s=528800\&e=png\&b=ffffff)

但因为我们的代码并没有定义这些类名的样式，所以我们还需要添加下样式。

修改 `app/global.css`，添加代码如下：

```javascript
pre {
  overflow-x: auto;
}

/**
 * Inspired by gatsby remark prism - https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs/
 * 1. Make the element just wide enough to fit its content.
 * 2. Always fill the visible space in .code-highlight.
 */
.code-highlight {
  float: left; /* 1 */
  min-width: 100%; /* 2 */
}

.code-line {
  display: block;
  padding-left: 16px;
  padding-right: 16px;
  margin-left: -16px;
  margin-right: -16px;
  border-left: 4px solid rgba(0, 0, 0, 0); /* Set placeholder for highlight accent border color to transparent */
}

.code-line.inserted {
  background-color: rgba(16, 185, 129, 0.2); /* Set inserted line (+) color */
}

.code-line.deleted {
  background-color: rgba(239, 68, 68, 0.2); /* Set deleted line (-) color */
}

.highlight-line {
  margin-left: -16px;
  margin-right: -16px;
  background-color: rgba(55, 65, 81, 0.5); /* Set highlight bg color */
  border-left: 4px solid rgb(59, 130, 246); /* Set highlight accent border color */
}

.line-number::before {
  display: inline-block;
  width: 1rem;
  text-align: right;
  margin-right: 16px;
  margin-left: -8px;
  color: rgb(156, 163, 175); /* Line number color */
  content: attr(line);
}
```

这些样式是为了代码块显示行号等信息。

至于代码的样式，到 [Prism themes](https://github.com/PrismJS/prism-themes) 选择一个你喜欢的样式，然后拷贝其 CSS 文件。比如我选择的是普通的 VSCode Dark 样式，地址为：<https://github.com/PrismJS/prism-themes/blob/master/themes/prism-vsc-dark-plus.css>

将这段代码也拷贝到 `app/global.css`中，最后的效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adc0d6fc6dcc4798b037a301379c336c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2784\&h=1332\&s=528833\&e=png\&b=fefefe)

## Tailwind CSS

让我们真的写一篇文章试试，实际渲染后的效果为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/357772bb33f9410a9ca6426ba6e0292d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3764\&h=1276\&s=655597\&e=png\&b=272727)

虽然对应的 HTML 标签渲染都是正确的，但因为 Tailwind CSS 默认会将所有元素的样式重置，所以最后的效果并不算“好看”。

不过 Tailwind.css 官方提供了 [Tailwind CSS Typography](https://github.com/tailwindlabs/tailwindcss-typography) 插件用于设置样式的默认值。安装：

```javascript
npm install -D @tailwindcss/typography @tailwindcss/forms
```

修改 `tailwind.config.js`，完整代码如下：

```javascript
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    './data/**/*.mdx',
  ],
  darkMode: 'class',
  theme: {
    extend: {
      lineHeight: {
        11: '2.75rem',
        12: '3rem',
        13: '3.25rem',
        14: '3.5rem',
      },
      typography: ({ theme }) => ({
        DEFAULT: {
          css: {
            a: {
              color: theme('colors.primary.500'),
              '&:hover': {
                color: `${theme('colors.primary.600')}`,
              },
              code: { color: theme('colors.primary.400') },
            },
            'h1,h2': {
              fontWeight: '700',
              letterSpacing: theme('letterSpacing.tight'),
            },
            h3: {
              fontWeight: '600',
            },
            code: {
              color: theme('colors.indigo.500'),
            },
          },
        },
        invert: {
          css: {
            a: {
              color: theme('colors.primary.500'),
              '&:hover': {
                color: `${theme('colors.primary.400')}`,
              },
              code: { color: theme('colors.primary.400') },
            },
            'h1,h2,h3,h4,h5,h6': {
              color: theme('colors.gray.100'),
            },
          },
        },
      }),
    },
  },
  plugins: [require('@tailwindcss/forms'), require('@tailwindcss/typography')],
};

```

修改 `app/posts/[id]/page.js`，代码如下：

```javascript
// ...

const Page = ({ params }) => {
  // ...

  return (
    <article className="mx-auto max-w-xl py-8 prose prose-slate">
      // ...
    </article>
  )
}

export default Page
```

Tailwind CSS Typography 通过在外层添加一个 prose 和 prose-xxx 类来控制其中元素的样式，有五种预定义的颜色和比例选项可用（这里我们用的是 prose-slate），此外还支持深色模式，具体参考其[官方说明](https://github.com/tailwindlabs/tailwindcss-typography)。

最后的效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9983c9a457640f9925761a4c823fbc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3770\&h=1958\&s=1054704\&e=png\&b=292929)

是不是看起来就正常多了？

> 1.  功能实现：博客 Contentlayer
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/next-blog-1>
> 3.  下载代码：`git clone -b next-blog-1 git@github.com:mqyqingfeng/next-app-demo.git`

## 总结

本篇我们介绍了 Contentlayer 的出现背景和使用方法，它是处理 MD 和 MDX 等内容的利器，但是 Contentlayer 这一两年近乎没有更新，使用的时候可能会遇到一些版本问题，不过目前尚未看到更好的替代方案。

## 参考链接

1.  <https://www.youtube.com/watch?v=58Pj4a4Us7A&ab_channel=Contentlayer>
2.  <https://contentlayer.dev/docs/getting-started-cddd76b7>
3.  <https://github.com/tailwindlabs/tailwindcss-typography>


## 53.实战篇 | 博客 | SEO

## 前言

对于一个技术博客而言，SEO 非常重要，好的 SEO 会为你带来更多的流量。

可是问题在于，SEO 要做的事情非常多，一时间竟不知道如何开始优化。

所以本篇我们就梳理下 SEO 要做的事情。

## 1. 开发时注意

### 1.1. 尽可能使用服务端组件

尽管搜索引擎也开始支持 JS 生成的内容，但还是尽可能使用服务端组件，将主体内容渲染成 HTML 返回给爬虫

### 1.2. 尽可能使用 Streaming

使用 Streaming 并不会对 SEO 造成负面影响，相反，因为显著改善了首次页面呈现时间等性能指标，对 SEO 更好。

### 1.3. 尽可能使用 Image 组件

Image 组件本身有尺寸优化、懒加载等功能，而且为了维持视觉稳定，它会在图片加载的时候自动阻止布局偏移，此外使用 Image 组件需要设置 alt 属性，这都有利于 SEO。

### 1.4. 尽可能使用 Font 组件

Font 组件会在构建时获取外部字体文件，并自动使用 CSS size-adjust 属性对字体进行调整，以防止发生布局偏移。像谷歌公开表示过，CLS （Cumulative Layout Shift，累计布局偏移，网页整个生命周期内发生的所有意外布局偏移的得分总和）是一个重要指标。

简单来说，就是谷歌要求网页元素在加载期间不要“乱动”，比如点赞按钮本应该在下方，但因为文章还没有加载完毕，于是呈现在上方，文章加载完毕后，就被“挤”到下方，这就很不好。

Image 组件和 Font 组件默认都做了阻止布局偏移处理。

简而言之，优化 Next.js 应用程序的性能将直接影响 SEO。

## 2. 添加 robots.txt 和 sitemap.xml

关于 robots.txt 和 sitemap.xml，我们已经在 [《Metadata 篇 | 基于文件》](https://juejin.cn/book/7307859898316881957/section/7309078702511128626#heading-27)介绍过。这里我们就直接开始讲如何做。

新建 `data/siteMetadata.js`，用于存储网站常用 SEO 字段，代码如下：

```javascript
const siteMetadata = {
  siteUrl: 'https://yayujs.com'
}

export default siteMetadata
```

为了方便引入，修改 `jsconfig.json`，代码如下：

```javascript
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/data/*": ["data/*"],
      "contentlayer/generated": ["./.contentlayer/generated"]
    }
  },
  "include": [
    "next-env.d.js",
    "**/*.js",
    "**/*.jsx",
    ".next/types/**/*.js",
    ".contentlayer/generated"
  ]
}
```

新建 `app/sitemap.js`，代码如下：

```javascript
import { allPosts } from 'contentlayer/generated'
import siteMetadata from '@/data/siteMetadata'

export default function sitemap() {
  const siteUrl = siteMetadata.siteUrl

  const blogRoutes = allPosts
    .map((post) => ({
      url: `${siteUrl}${post.url}`,
      lastModified: post.lastmod || post.date,
    }))

  const routes = ['', 'posts'].map((route) => ({
    url: `${siteUrl}/${route}`,
    lastModified: new Date().toISOString().split('T')[0],
  }))

  return [...routes, ...blogRoutes]
}
```

这里我们动态生成了所有页面地址，当你访问 <http://localhost:3000/sitemap.xml> 时，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d196bc9374ad43af9ee502a2c3474ec0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2908\&h=808\&s=223025\&e=png\&b=ffffff)

新建 `app/robots.js`，代码如下：

```javascript
import siteMetadata from '@/data/siteMetadata'

export default function robots() {
  return {
    rules: {
      userAgent: '*',
      allow: '/',
    },
    sitemap: `${siteMetadata.siteUrl}/sitemap.xml`,
    host: siteMetadata.siteUrl,
  }
}
```

当你访问 <http://localhost:3000/robots.txt> 时，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/601ca14f8cd14f62838c30644fa9c26f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1326\&h=430\&s=59537\&e=png\&b=fefefe)

## 3. 设置每个页面的 Metadata

### 3.1. 基础字段

为了方便爬取，每个页面都需要设置 title、description 等属性，除了这两个属性还有哪些属性要设置呢？

关键看搜索引擎会用到哪些字段，这个可以参考 Google 的官方文档[《Google 支持的 meta 标记和属性》](https://developers.google.com/search/docs/crawling-indexing/special-tags?hl=zh-cn)。简而言之，最常用的有：

```html
<meta name="description" content="A description of the page">
<meta name="robots" content="..., ...">
<meta name="googlebot" content="..., ...">
```

注：keywords 这种属性，Google 已经废弃不用了，参考[《Google 不会将关键字元标记用于网页排名》](https://developers.google.com/search/blog/2009/09/google-does-not-use-keywords-meta-tag?hl=zh-cn)。

### 3.2. 网站规范化字段

除此之外，还应该有：

```html
<link rel="canonical" href="https://example.com/dresses/green-dresses" />
<link rel="alternate" type="application/rss+xml" href="http://example.com/rss.xml" />
```

前者用于网站规范化，参考[《如何使用 rel="canonical" 及其他方法指定规范网址》](https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls?hl=zh-cn)。后者用于网站的 RSS 订阅（如果有的话）。

### 3.3. Open Graph protocol 字段

再然后要支持  Open Graph protocol，介绍参考[《VuePress 博客之 SEO 优化（四） Open Graph protocol》](https://juejin.cn/post/7073416301720371213)。

就是我们常见的 og: 开头的字段：

```javascript
<meta property="og:url" content="http://www.nytimes.com/2015/02/19/arts/international/when-great-minds-dont-think-alike.html" />
<meta property="og:type" content="article" />
<meta property="og:title" content="When Great Minds Don’t Think Alike" />
<meta property="og:description" content="How much does culture influence creative thinking?" />
<meta property="og:image" content="http://static01.nyt.com/images/2015/02/19/arts/international/19iht-btnumbers19A/19iht-btnumbers19A-facebookJumbo-v2.jpg" />
```

因为我们是博客，自然是选择 og 的 article 类型：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/391ba7787fb3409c8b2b0e34bbbcc067~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1334\&h=462\&s=285999\&e=png\&b=fefdfd)

最终生成的字段示例如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d6213012a3e411c9dae5dc0048d4d99~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1536\&h=410\&s=209089\&e=png\&b=ffffff)

### 3.4. 其他字段

最后还有一些其他字段，比如 [Twitter Card](https://developer.twitter.com/en/docs/twitter-for-websites/cards/guides/getting-started)，用于在 Twitter 进行分享展示，视情况添加。

至于在 Next.js 中如何添加，我们会和下一节一起实现。

## 4. 添加 JSON-LD 数据

英文全程：JavaScript Object Notation for Linked Data，官方地址：[json-ld.org/](https://link.juejin.cn?target=https%3A%2F%2Fjson-ld.org%2F)，简单的来说，就是用来描述网页的类型和内容，方便搜索引擎做展现。

比如如果我们在 Google 搜索 「Chocolate in a mug」，我们会看到这样的搜索结果：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e1a42cf37eb4af88c3ce1373607e849~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512\&h=551\&s=37344\&e=webp\&b=212327)

我们打开页面，就可以看到搜索展示的内容对应了 application/ld+json 中的内容：

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c2598fd3dd40bf9d76a1b492ea2389~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1512\&h=391\&s=112668\&e=webp\&b=f4f1f0)

注：关于 JSON-LD，参考[《VuePress 博客之 SEO 优化（五）添加 JSON-LD 数据》](https://juejin.cn/post/7073749684656799780)

修改 `data/siteMetadata.js`，代码如下：

```javascript
const siteMetadata = {
  siteUrl: 'https://yayujs.com',
  title: '冴羽的技术博客',
  description: '冴羽的技术博客，分享技术、个人成长等内容',
  author: '冴羽',
  locale: 'zh-CN',
  socialBanner: 'https://cdna.artstation.com/p/assets/images/images/028/138/058/large/z-w-gu-bandageb5f.jpg?1593594749'
}

export default siteMetadata
```

这里我们添加了 SEO 常用的字段，方便复用以及作为默认值。其中 socialBanner 用于 og 或者 twitter 分享时的 image 默认图片。

修改 `app/layout.js`，代码如下：

```javascript
import siteMetadata from '@/data/siteMetadata'
import "./globals.css";

export const metadata = {
  metadataBase: new URL(siteMetadata.siteUrl),
  title: {
    default: siteMetadata.title,
    template: `%s | ${siteMetadata.title}`,
  },
  description: siteMetadata.description,
  openGraph: {
    title: siteMetadata.title,
    description: siteMetadata.description,
    url: './',
    siteName: siteMetadata.title,
    images: [siteMetadata.socialBanner],
    locale: 'zh_CN',
    type: 'website',
  },
  alternates: {
    canonical: './',
    types: {
      'application/rss+xml': `${siteMetadata.siteUrl}/feed.xml`,
    },
  },
  robots: {
    index: true,
    follow: true,
    googleBot: {
      index: true,
      follow: true,
      'max-video-preview': -1,
      'max-image-preview': 'large',
      'max-snippet': -1,
    },
  },
  twitter: {
    title: siteMetadata.title,
    card: 'summary_large_image',
    images: [siteMetadata.socialBanner],
  },
}

export default function RootLayout({ children }) {
  return (
    <html lang={siteMetadata.locale}>
      <body>{children}</body>
    </html>
  );
}

```

此时访问 <http://localhost:3000/>，效果如下：

![截屏2024-05-13 17.30.15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3940f681e224be7a2d5a3420985e525~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3392\&h=1528\&s=832960\&e=png\&b=fefefe)

因为写在了根布局中，这些元数据相当于默认值。

如果你要修改某个页面的元数据，比如修改 `app/posts/page.js`，添加代码如下：

```javascript
export const generateMetadata = ({ params }) => {
  return { 
    title: "博客列表",
    description: "这是博客列表页面",
    openGraph: {
      title: '博客列表',
      description: '这是博客列表页面'
    }
  }
}
```

此时访问 <http://localhost:3000/posts>，效果如下：

![截屏2024-05-13 17.33.49.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/881800d7b68546daa53d6302d728bd09~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3382\&h=1380\&s=665844\&e=png\&b=ffffff)

最为复杂的应该是具体的文章页面，因为我们需要通过 FrontMatter 设置页面的元数据，并且我们使用了 Contentlayer 校验 FrontMatter 的值。

修改 `contentlayer.config.js`，代码如下：

```javascript
import { defineDocumentType, makeSource } from 'contentlayer/source-files'
import remarkGfm from 'remark-gfm'
import rehypePrismPlus from 'rehype-prism-plus'
import siteMetadata from './data/siteMetadata'

export const Post = defineDocumentType(() => ({
  name: 'Post',
  filePathPattern: `**/*.mdx`,
  contentType: 'mdx',
  fields: {
    title: { type: 'string', required: true },
    date: { type: 'date', required: true },
    description: { type: 'string' },
    lastmod: { type: 'date' },
    images: { type: 'json' },
    canonicalUrl: { type: 'string' },
  },
  computedFields: {
    url: { type: 'string', resolve: (post) => `/posts/${post._raw.flattenedPath}` },
    structuredData: {
      type: 'json',
      resolve: (doc) => ({
        '@context': 'https://schema.org',
        '@type': 'BlogPosting',
        headline: doc.title,
        datePublished: doc.date,
        dateModified: doc.lastmod || doc.date,
        description: doc.description,
        image: doc.images ? doc.images[0] : siteMetadata.socialBanner,
        url: `${siteMetadata.siteUrl}/posts/${doc._raw.flattenedPath}`,
      }),
    },
  },
}))

export default makeSource({ 
  contentDirPath: 'posts', 
  documentTypes: [Post],
  mdx: {
    remarkPlugins: [remarkGfm],
    rehypePlugins: [[rehypePrismPlus, { defaultLanguage: 'js', ignoreMissing: true }],],
  }
})
```

我们定义了一些 FrontMatter 的字段，并基于此和 siteMetadata 的字段计算当前文章的 JSON-LD 数据。

修改 `app/posts/[id]/page.js`，代码如下：

```javascript
import { allPosts } from 'contentlayer/generated'
import { useMDXComponent } from 'next-contentlayer/hooks'
import { notFound } from 'next/navigation'
import dayjs from "dayjs";
import siteMetadata from '@/data/siteMetadata'

export async function generateStaticParams() {
  return allPosts.map((post) => ({
    id: post._raw.flattenedPath,
  }))
}
export const generateMetadata = ({ params }) => {
  const post = allPosts.find((post) => post._raw.flattenedPath === params.id)
  if (!post) throw new Error(`Post not found for id: ${params.id}`)

  const publishedAt = new Date(post.date).toISOString()
  const modifiedAt = new Date(post.lastmod || post.date).toISOString()

  let imageList = [siteMetadata.socialBanner]
  if (post.images) {
    imageList = typeof post.images === 'string' ? [post.images] : post.images
  }
  const ogImages = imageList.map((img) => {
    return {
      url: img.includes('http') ? img : siteMetadata.siteUrl + img,
    }
  })

  const authors = post?.authors || [siteMetadata.author]
  
  return {
    title: post.title,
    description: post.description,
    openGraph: {
      title: post.title,
      description: post.description,
      siteName: siteMetadata.title,
      locale: 'zh_CN',
      type: 'article',
      publishedTime: publishedAt,
      modifiedTime: modifiedAt,
      url: './',
      images: ogImages,
      authors: authors
    },
    twitter: {
      card: 'summary_large_image',
      title: post.title,
      description: post.description,
      images: imageList,
    },
  }
}

const Page = ({ params }) => {
  const post = allPosts.find((post) => post._raw.flattenedPath === params.id)
  if (!post) notFound()
  const MDXContent = useMDXComponent(post.body.code)
  const jsonLd = post.structuredData
  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <article className="mx-auto max-w-xl py-8 prose prose-slate">
        <div className="mb-8 text-center">
          <time dateTime={post.date} className="mb-1 text-xs text-gray-600">
            {dayjs(post.date).format('DD/MM/YYYY')}
          </time>
          <h1 className="text-3xl font-bold">{post.title}</h1>
        </div>
        <MDXContent />
      </article>
    </>
  )
}

export default Page
```

我们根据文章页面的设置的 FrontMatter 数据动态生成页面元数据。

修改 `posts/first.mdx`，添加 FrontMatter 代码如下：

```javascript
---
title: 使用 Next.js App Router 常犯的 10 个错误
date: 2024-05-01
lastmod: 2024-05-02
description: 本篇介绍了使用 Next.js App Router 常犯的 10 个错误
images: [https://cdnb.artstation.com/p/assets/images/images/007/367/401/large/z-w-gu-dsassd2.jpg?1505659743]
---

```

此时访问 <http://localhost:3000/posts/first>，效果如下：

![截屏2024-05-13 17.48.13.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec1323139450457ea03b7704e58151d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3392\&h=1650\&s=1075928\&e=png\&b=ffffff)

## 5. 直接添加站点

不用等待 Google 慢慢收录，你可以直接将站点提交给 Google、百度等搜索引擎，参考 [《VuePress 博客之 SEO 优化（一） sitemap 与搜索引擎收录》](https://juejin.cn/post/7072291456462880782#heading-7)

## 6. 项目源码

> 1.  功能实现：博客添加 SEO
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/next-blog-2>
> 3.  下载代码：`git clone -b next-blog-2 git@github.com:mqyqingfeng/next-app-demo.git`


## 54.实战篇 | 博客 | 深色模式（Dark Mode）

## 前言

本篇我们来实现深色模式。它也被叫做暗黑模式、黑夜模式等等。这里我们选用的是苹果官方文档的翻译：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e0a67dbaec435d9b2efd47a3531122~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2104\&h=616\&s=266452\&e=png\&b=fdfdfd)

## 1. 深色模式

“深色模式”本质上是一套采用深色背景、浅色文案的配色方案。其实很早就有。现在越来越流行，是因为苹果在 2018 年提出了这一概念。

先是 2018 年的 macOS Mojave 率先支持了深色外观，然后 2019 年 IOS 13 正式支持深色外观。这些都是系统级别的支持，可以将整个系统的界面切换为深色模式。由此深色模式开始进入人们的视野，成为设计师、前端工程师的学习内容……

使用深色模式也确实有一些好处：

1.  保护视力。毕竟晚上的时候，浅色有些刺眼。
2.  增加沉浸感。阅读浏览类 App 或是内容创作型 App（比如代码编辑器）往往会使用深色模式，它们会借助黑底白字的高对比度特性让用户视线保持集中。所以切换深色模式后，可以增加沉浸感，提升使用欲望。
3.  省电。根据谷歌的官方数据，采用 OLED 屏幕的手机在「深色模式」下，耗电可下降达63%。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea2428b4d4df4a5a8a7eaca04607e892~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3024\&h=1516\&s=396568\&e=png\&b=111111)

## 2. 如何适配？

如果我们开发页面，该如何支持深色模式呢？

### 2.1. CSS 媒体查询

CSS 提供了 [prefers-color-scheme](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme) 媒体查询特性，用于检测用户是否有将系统的主题色设置为浅色或者深色。

比如 Next.js 脚手架默认创建项目的 `app/globals.css`中，就有这样一段代码：

```javascript
:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}
```

这就是一段根据系统的主题色调整网页基础样式的代码。此时页面会根据系统的外观模式进行调整，效果如下：

![1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fcc5d4d12534980a1a3ab7665b24fcb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=923\&h=630\&s=471100\&e=gif\&f=40\&b=ececee)

注：浏览器设置里也有设置模式的地方：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e3c585429d14ad591703e9b78978256~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1848\&h=444\&s=81383\&e=png\&b=26272a)

但这里设置的是浏览器的外观，不会影响具体页面的外观模式。

### 2.2. JS 查询

CSS 查询会自动跟随系统设置，但如果你要自定义外观模式，就比如很多博客页面右上角都有个外观模式按钮，点击可以切换到 light / dark 模式，这种就需要依赖 JS 了。

Web API 提供了 [Window.matchMedia()](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/matchMedia) 方法，它会返回一个新的 MediaQueryList 对象，表示指定的媒体查询字符串解析后的结果。返回的 MediaQueryList 可被用于判定 Document 是否匹配媒体查询，或者监控一个 document 来判定它匹配了或者停止匹配了此媒体查询。

#### 判断浏览器是否支持深色模式

```javascript
if (window.matchMedia('(prefers-color-scheme)').media !== 'not all') {
  console.log('🎉 Dark mode is supported');
}
```

其实支持率还蛮好的：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58867d0f23414c83b94d4368abb91e66~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3430\&h=1442\&s=524605\&e=png\&b=f0e8d8)

#### 监听深色模式变化

```javascript
const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

darkModeMediaQuery.addEventListener('change', (e) => {
  const darkModeOn = e.matches;
  console.log(`Dark mode is ${darkModeOn ? '🌒 on' : '☀️ off'}.`);
});
```

#### 自定义 React hook

如果使用 React，可以自定义一个 hook，新建 `app/theme.js`，代码如下：

```javascript
import { useEffect, useState } from "react"

function useTheme() {
 
  const [theme, setTheme] = useState('light')

  useEffect(() => {

    const darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    setTheme(darkModeMediaQuery.matches ? 'dark' : 'light')
    const listener = (event) => {
      setTheme(event.matches ? 'dark' : 'light');
    };

    darkModeMediaQuery.addEventListener('change', listener);
    return () => {
      darkModeMediaQuery.removeEventListener('change', listener);
    };
    
  }, [])
  
  return {
    theme,
    isDarkMode: theme === "dark",
    isLightMode: theme === "light",
  }
}

export default useTheme
```

修改 `app/page.js`，代码如下：

```javascript
'use client'

import Image from "next/image";
import useTheme from "./theme";

export default function Home() {
  
  const {theme} = useTheme()

  return (
    <div>Hello World! {theme}</div>
  );
}

```

浏览器效果如下：

![3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93460b20b16b4038b4d32308b28e8e84~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1153\&h=558\&s=281990\&e=gif\&f=23\&b=e4e9ec)

### 2.3. 测试不同的模式

如果要测试页面的浅色/深色模式，修改系统的外观模式会有些麻烦，Chrome 提供了快速切换的方式：

![2.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81e3cdefa1a43159a1502ffe1f3f8a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1196\&h=558\&s=366613\&e=gif\&f=32\&b=fcfcfc)

其步骤为：

1.  打开浏览器开发者工具
2.  Command + Shift + P 打开命令
3.  输入 dark 或者 light 搜索命令
4.  回车确定

注：这只是用于测试，效果是暂时的，关闭开发者工具，就会退出设置的样式。

## 3. 实战应用

基础知识我们就说这么多，只是帮助大家理解深色模式的概念和实现的基本原理。

在 Next.js 项目中，实现手动切换外观模式的效果，通常还要搭配 React Context 或者状态管理库来实现。在实际开发中，为了提高效率，我们会使用 [next-themes](https://github.com/pacocoursey/next-themes) 这个包来实现。

### 3.1. next-themes

安装依赖项：

```bash
npm install next-themes @headlessui/react
```

其中 [@headlessui/react](https://github.com/tailwindlabs/headlessui) 是 UI 库，十分适合搭配 Tailwind.css。

新建 `app/theme-providers.js`，代码如下：

```jsx
'use client'

import { ThemeProvider } from 'next-themes'

export function ThemeProviders({ children }) {
  return (
    <ThemeProvider attribute="class" defaultTheme="light" enableSystem>
      {children}
    </ThemeProvider>
  )
}
```

修改 `app/layout.js`，添加代码如下：

```jsx
import siteMetadata from '@/data/siteMetadata'
import "./globals.css";
import { ThemeProviders } from './theme-providers'

export const metadata = {
  // ...
}

export default function RootLayout({ children }) {
  return (
    <html lang={siteMetadata.locale} suppressHydrationWarning>
      <body>
        <ThemeProviders>
          {children}
        </ThemeProviders>
      </body>
    </html>
  );
}
```

修改的代码有 2 点：

1.  html 使用 suppressHydrationWarning 取消水合错误警告，这是因为 next-theme 会修改 html 元素的属性。因为 suppressHydrationWarning 只作用于一层，所以不用担心它会影响整个应用的水合错误警告。
2.  使用 ThemeProviders 组件包裹 children

此时页面并不有什么特殊效果，因为这步相当于在顶层使用了 React Context，储存了一个用于表示当前主题的值，默认是 `"light"`。

此时因为我们设置了 `attribute="class"`，当切换主题的时候，它会对应生成 `class="dark"`这种属性：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/36e097ed44e84d79a5507beaf299116d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1202\&h=126\&s=34834\&e=png\&b=2e2e2e)

此外，我们还可以看到生成了 `style="color-scheme: dark;"`属性，详细介绍参考 [MDN color-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme)。简单来说，操作系统会根据用户选择的颜色方案对用户界面进行调整，包括表单控件、滚动条和 CSS 系统颜色的使用值。

因为我们改用了 JS 来手动控制主题值，所以写样式效果的时候，也不能再用 @media (prefers-color-scheme: dark) 这种方式，它会根据系统的主题值而非 Context 中的主题值进行修改。

如果你要写 dark 和 light 两套主题，因为 html 添加了 `.dark` 类，所以可以这样写：

```javascript
html,
body {
  color: #000;
  background: #fff;
}

.dark {
  html, body {
    color: #fff;
    background: #000;
  }
}
```

当然因为我们项目使用了 Tailwind.css，Tailwind.css 也是支持 [Dark Mode](https://tailwindcss.com/docs/dark-mode#toggling-dark-mode-manually) 的。修改 `tailwind.config.js`，添加代码如下（如果你按照之前的文章写项目，此时应该已经添加了）：

```javascript
module.exports = {
  darkMode: 'class'
}
```

修改 `app/page.js`，代码如下：

```jsx
'use client'

import { useState, useEffect } from 'react'
import { useTheme } from 'next-themes'

const ThemeSwitch = () => {
  const [mounted, setMounted] = useState(false)
  const { theme, setTheme } = useTheme()

  useEffect(() => {
    setMounted(true)
  }, [])

  if (!mounted) {
    return null
  }

  return (
    <>
      <h1 className="text-black dark:text-white">Hello World! {theme}</h1>
      <select value={theme} onChange={e => setTheme(e.target.value)}>
        <option value="system">System</option>
        <option value="dark">Dark</option>
        <option value="light">Light</option>
      </select>
    </>

  )
}

export default ThemeSwitch
```

在这段代码中，展示了如何使用 useTheme 和 Taildwind.css。

1.  使用 useTheme 需要是客户端组件，且需要判断环境，否则会导致水合错误
2.  `"text-black dark:text-white"` 展示了如何为一个元素定义不同主题下的样式

此时效果如下：

![4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/618593f99c17417aaaf565d9d7e06ea0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1103\&h=461\&s=1064578\&e=gif\&f=53\&b=2c2c2c)

### 3.2. 项目开发

新建 `components/ThemeSwitch.js`，代码如下：

```jsx
'use client'

import { Fragment, useEffect, useState } from 'react'
import { useTheme } from 'next-themes'
import { Menu, RadioGroup, Transition } from '@headlessui/react'

const Sun = () => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 20 20"
    fill="currentColor"
    className="h-6 w-6 text-gray-900 dark:text-gray-100"
  >
    <path
      fillRule="evenodd"
      d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z"
      clipRule="evenodd"
    />
  </svg>
)
const Moon = () => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 20 20"
    fill="currentColor"
    className="h-6 w-6 text-gray-900 dark:text-gray-100"
  >
    <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" />
  </svg>
)
const Monitor = () => (
  <svg
    xmlns="http://www.w3.org/2000/svg"
    viewBox="0 0 20 20"
    fill="none"
    stroke="currentColor"
    strokeWidth="2"
    strokeLinecap="round"
    strokeLinejoin="round"
    className="h-6 w-6 text-gray-900 dark:text-gray-100"
  >
    <rect x="3" y="3" width="14" height="10" rx="2" ry="2"></rect>
    <line x1="7" y1="17" x2="13" y2="17"></line>
    <line x1="10" y1="13" x2="10" y2="17"></line>
  </svg>
)

const ThemeSwitch = () => {
  const [mounted, setMounted] = useState(false)
  const { theme, setTheme, resolvedTheme } = useTheme()

  // When mounted on client, now we can show the UI
  useEffect(() => setMounted(true), [])

  if (!mounted) return null

  return (
    <div className="mr-5">
      <Menu as="div" className="relative inline-block text-left">
        <div>
          <Menu.Button>{resolvedTheme === 'dark' ? <Moon /> : <Sun />}</Menu.Button>
        </div>
        <Transition
          as={Fragment}
          enter="transition ease-out duration-100"
          enterFrom="transform opacity-0 scale-95"
          enterTo="transform opacity-100 scale-100"
          leave="transition ease-in duration-75"
          leaveFrom="transform opacity-100 scale-100"
          leaveTo="transform opacity-0 scale-95"
        >
          <Menu.Items className="absolute right-0 mt-2 w-32 origin-top-right divide-y divide-gray-100 rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none dark:bg-gray-800">
            <RadioGroup value={theme} onChange={setTheme}>
              <div className="p-1">
                <RadioGroup.Option value="light">
                  <Menu.Item>
                    <button className="group flex w-full items-center rounded-md px-2 py-2 text-sm">
                      <div className="mr-2">
                        <Sun />
                      </div>
                      Light
                    </button>
                  </Menu.Item>
                </RadioGroup.Option>
                <RadioGroup.Option value="dark">
                  <Menu.Item>
                    <button className="group flex w-full items-center rounded-md px-2 py-2 text-sm">
                      <div className="mr-2">
                        <Moon />
                      </div>
                      Dark
                    </button>
                  </Menu.Item>
                </RadioGroup.Option>
                <RadioGroup.Option value="system">
                  <Menu.Item>
                    <button className="group flex w-full items-center rounded-md px-2 py-2 text-sm">
                      <div className="mr-2">
                        <Monitor />
                      </div>
                      System
                    </button>
                  </Menu.Item>
                </RadioGroup.Option>
              </div>
            </RadioGroup>
          </Menu.Items>
        </Transition>
      </Menu>
    </div>
  )
}

export default ThemeSwitch
```

这段代码看似很长，但实现的效果其实很简单：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dea2cfbb8a274a338e98461edf232c9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1306\&h=542\&s=56899\&e=png\&b=fefefe)

为了方便引入，修改 `jsconfig.json`：

```javascript
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/data/*": ["data/*"],
      "@/components/*": ["components/*"],
      "contentlayer/generated": ["./.contentlayer/generated"]
    }
  },
  // ...
}
```

我们将组件添加到根布局 `app/layout.js`中：

```jsx
import siteMetadata from '@/data/siteMetadata'
import "./globals.css";
import { ThemeProviders } from './theme-providers'
import ThemeSwitch from '@/components/ThemeSwitch';

// ...

export default function RootLayout({ children }) {
  return (
    <html lang={siteMetadata.locale} suppressHydrationWarning>
      <body>
        <ThemeProviders>
          <header className="flex justify-end">
            <ThemeSwitch />
          </header>
          {children}
        </ThemeProviders>
      </body>
    </html>
  );
}
```

这样所有页面的右上角都会有这个切换主题的按钮。

现在要做的就是为元素设置不同主题的样式。根据上节的描述有两种方式可以设置，一种是直接使用 CSS 进行设置：

```javascript
.dark {
  // ...
}
```

一种是使用 Tailwind.css，添加 `dark:`开头的类名：

```javascript
<h1 className="text-3xl font-bold dark:text-white">{post.title}</h1>
```

比较麻烦的地方在于文章页面，因为文章的内容渲染是由 MDX 生成，不能直接添加类名。

但其实 tailwindcss-typography 同样提供了 dark mode 支持，你只要在外层添加一个 `dark:prose-invert` 类名：

```javascript
<article class="prose dark:prose-invert">{{ markdown }}</article>
```

所以我们修改 `app/posts/[id]/page.js`，添加代码如下：

```jsx
// ...

const Page = ({ params }) => {
  const post = allPosts.find((post) => post._raw.flattenedPath === params.id)
  if (!post) notFound()
  const MDXContent = useMDXComponent(post.body.code)
  const jsonLd = post.structuredData
  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
        />
      <article className="mx-auto max-w-xl py-8 prose prose-slate dark:prose-invert">
        <div className="mb-8 text-center">
          <time dateTime={post.date} className="mb-1 text-xs text-gray-600 dark:text-white">
            {dayjs(post.date).format('DD/MM/YYYY')}
          </time>
          <h1 className="text-3xl font-bold dark:text-white">{post.title}</h1>
        </div>
        <MDXContent />
      </article>
    </>
  )
}

export default Page
```

此时文章页面效果如下：

![5.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e1a5769c7d84f10a96cf4daedba8361~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1019\&h=686\&s=300406\&e=gif\&f=55\&b=fefefe)

我们成功实现了深色模式！

## 项目源码

> 1.  功能实现：博客支持深色模式
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/next-blog-3>
> 3.  下载代码：`git clone -b next-blog-3 git@github.com:mqyqingfeng/next-app-demo.git`

## 参考链接

1.  <https://support.apple.com/zh-cn/guide/mac-help/mchl52e1c2d2/mac>
2.  <https://juejin.cn/post/7298997940019085366>
3.  <https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme>
4.  <https://web.dev/articles/prefers-color-scheme?hl=zh-cn#reacting_on_dark_mode_changes>
5.  <https://web.dev/articles/color-scheme?hl=zh-cn>
6.  <https://www.uisdc.com/dark-mode-history>
7.  <https://juejin.cn/post/7062986403205873701>


## 55.实战篇 | 博客 | i18n

## 前言

在[《路由篇 | 国际化》](https://juejin.cn/book/7307859898316881957/section/7308914342949290022)我们讲解了国际化的基本原理，但在实际开发中，我们往往会使用 react-i18next 或者 next-intl 辅助我们开发。在[《实战篇 | React Notes | 国际化》](https://juejin.cn/book/7307859898316881957/section/7309112133474582578#heading-0)中，我们分别对这两种技术选型进行了讲解。

其中， react-i18next 自由度高，但配置相对繁琐。next-intl 自由度低，但配置简单省事。本篇我们使用 react-i18next 来实现国际化。

我们想要实现的效果如下：

![7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3534f89cfe6c496889247ec6992c974b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1007\&h=585\&s=81041\&e=gif\&f=43\&b=fefefe)

页面右上角添加一个语言切换器，有中文和英文两种语言，默认是中文。以博客列表页面地址为例，中文页面地址是 `http://localhost:3000/posts`，英文页面地址为 `http://localhost:3000/en/posts`。当点击切换语言的时候，页面无刷新，直接实现切换。

## react-i18next

### 1. 新建文件夹

在 `app` 目录下添加一个名为  `[lng]`  的文件夹，将 `favicon.ico` 以外的文件，移动到该文件夹下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f6d12aea83e4f648c6c0571bcc94796~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1962\&h=432\&s=169371\&e=png\&b=231f2a)

因为加了一层动态路由，如果要访问原本的博客列表页面，需要访问 <http://localhost:3000/xxx/posts，比如：>

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5aa77f9f0b334810a5da3131b96aa8be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1352\&h=726\&s=81522\&e=png\&b=ffffff)

因为文章标题的页面链接地址还是之前的，所以点击链接跳转会出现错误。我们修改下 `app/[lng]/posts/page.js`，修改代码如下：

```jsx
// ...

function PostCard({ lng, ...post }) {
  return (
    <div className="mb-8">
      <h2 className="mb-1 text-xl">
        <Link
          href={`/${lng}${post.url}`}
          className="text-blue-700 hover:text-blue-900 dark:text-blue-400"
        >
          {post.title}
        </Link>
      </h2>
      <time dateTime={post.date} className="mb-2 block text-xs text-gray-600">
        {dayjs(post.date).format("DD/MM/YYYY")}
      </time>
    </div>
  );
}

export default function Home({ params: { lng } }) {
  return (
    <div className="mx-auto max-w-xl py-8">
      <h1 className="mb-8 text-center text-2xl font-black">My Blog List</h1>
      {allPosts.map((post, idx) => (
        <PostCard key={idx} lng={lng} {...post} />
      ))}
    </div>
  );
}
```

此时页面正常跳转：

![8.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5adfac0d002e4e90aed7f2bfb6a4702f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1165\&h=492\&s=50004\&e=gif\&f=17\&b=fefefe)

### 2. 添加全局 i18n 配置

修改 `data/siteMetadata.js`，添加 language 配置项：

```javascript
const siteMetadata = {
  siteUrl: 'https://yayujs.com',
  title: '冴羽的技术博客',
  description: '冴羽的技术博客，分享技术、个人成长等内容',
  author: '冴羽',
  socialBanner: 'https://cdna.artstation.com/p/assets/images/images/028/138/058/large/z-w-gu-bandageb5f.jpg?1593594749',
  languages: ['zh', 'en'],
  fallbackLanguage: "zh"
}

export default siteMetadata
```

我们新建了 2 个字段，languages 用于指定 i18n 支持的语言，并据此生成语言切换器。fallbackLanguage 用于指定默认语言。

安装依赖项 i18next：

```javascript
npm i i18next
```

修改 `app/[lng]/layout.js`，代码如下：

```jsx
// ...
import { dir } from 'i18next'

// 添加静态路由
export async function generateStaticParams() {
  return siteMetadata.languages.map((lng) => ({ lng }))
}

// 为 html 元素添加 lang、dir 属性
export default function RootLayout({ children, params: { lng } }) {
  return (
    <html lang={lng} dir={dir(lng)} suppressHydrationWarning>
      <body>
        <ThemeProviders>
          <header className="flex justify-end">
            <ThemeSwitch />
            <LangSwitch />
          </header>
          {children}
        </ThemeProviders>
      </body>
    </html>
  );
}
```

### 3. 中间件设置

安装依赖项 [accept-language](https://www.npmjs.com/package/accept-language)：

```javascript
npm i accept-language
```

这是一个帮助我们匹配语言的库。它的基本用法如下：

```javascript
import acceptLanguage from 'accept-language';
acceptLanguage.languages(['en-US', 'zh-CN']);
console.log(acceptLanguage.get('en-GB,en;q=0.8,sv'));
/* 'en-US' */
```

在这段代码中，`['en-US', 'zh-CN']`表示我们支持的语言，`'en-GB,en;q=0.8,sv'`表示 HTTP 的 Accept-Language 标头。调用 get 方法会从支持语言中匹配出合适的语言。

项目根目录新建 `middleware.js`，代码如下：

```javascript
import { NextResponse } from 'next/server'
import acceptLanguage from 'accept-language'
import siteMetadata from './data/siteMetadata'

const { fallbackLanguage, languages } = siteMetadata
acceptLanguage.languages(languages)

const publicFile = /\.(.*)$/
const excludeFile = []

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js|site.webmanifest).*)']
}

function getLocale(req) { 
  let language = acceptLanguage.get(req.headers.get('Accept-Language'))
  if (!language) language = fallbackLanguage
  return language
 }
 
export function middleware(request) {
  const { pathname } = request.nextUrl

  // 判断路径中是否存在支持的语言
  const filtedLanguage = languages.filter((locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`)

  if (filtedLanguage.length > 0) {
    if (filtedLanguage[0] === fallbackLanguage) {
      // /zh/xxx 重定向到 `/xxx`
      const url = pathname.replace(`/${fallbackLanguage}`, '');
      return NextResponse.redirect(new URL(url ? url : '/', request.url))
    }
    // 其他跳过
    return
  }

  // 如果是 public 文件，不重定向
  if (publicFile.test(pathname) && excludeFile.indexOf(pathname.substr(1)) == -1) return
 
  // 获取匹配的 locale
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`

  // 默认语言不重定向
  if (locale == fallbackLanguage) {
    return NextResponse.rewrite(request.nextUrl)
  }
  // 重定向，如 /products 重定向到 /en/products
  return Response.redirect(request.nextUrl)
}
```

这里我们自定义了一些逻辑，访问 `http://localhost:3000/zh`会重定向到 `http://localhost:3000/`，访问 `http://localhost:3000`因为重写到 `http://localhost:3000/zh`，所以可以正常访问，不会出现 404 错误。具体效果如下：

![9.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07e405ff063f4bada2b1f499f85eacc0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1165\&h=509\&s=203417\&e=gif\&f=42\&b=fefefe)

### 4. 配置翻译文件

路由的配置已经完成，接下来配置翻译相关的文件。

安装依赖项：

```bash
npm i i18next i18next-resources-to-backend react-i18next
```

新建 `next-blog/app/i18n/index.js`，代码如下：

```javascript
import { createInstance } from 'i18next'
import resourcesToBackend from 'i18next-resources-to-backend'
import { initReactI18next } from 'react-i18next/initReactI18next'
import siteMetadata from '@/data/siteMetadata'

const { fallbackLanguage, languages } = siteMetadata

const initI18next = async (lng = fallbackLanguage, ns = 'basic') => {
  const i18nInstance = createInstance()
  await i18nInstance
    .use(initReactI18next)
    .use(resourcesToBackend((language, namespace) => import(`./locales/${language}/${namespace}.json`)))
    .init({
      // debug: true,
      supportedLngs: languages,
      fallbackLng: fallbackLanguage,
      lng,
      fallbackNS: 'basic',
      defaultNS: 'basic',
      ns
    })
  return i18nInstance
}

export async function useTranslation(lng, ns, options = {}) {
  const i18nextInstance = await initI18next(lng, ns)
  return {
    t: i18nextInstance.getFixedT(lng, Array.isArray(ns) ? ns[0] : ns, options.keyPrefix),
    i18n: i18nextInstance
  }
}
```

准备翻译文件：

```markdown
app                      
└─ i18n                  
   ├─ locales            
   │  ├─ en              
   │  │  └─ basic.json  
   │  └─ zh              
   │     └─ basic.json        
   └─ index.js
```

`zh/basic.json`代码如下：

```javascript
{
  "blogList": "我的博客列表",
  "like": "喜欢"
}
```

`en/basic.json`代码如下：

```javascript
{
  "blogList": "My Blog List",
  "like": "like"
}
```

为了方便引入 useTranslation，修改 `jsconfig.json`，添加代码如下：

```javascript
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/data/*": ["data/*"],
      "@/components/*": ["components/*"],
      "@/*": ["/*"],
      "contentlayer/generated": ["./.contentlayer/generated"]
    }
  },
  "include": [
    "next-env.d.js",
    "**/*.js",
    "**/*.jsx",
    ".next/types/**/*.js",
    ".contentlayer/generated"
  ]
}
```

### 5. 服务端组件使用翻译

修改 `app/[lng]/posts/page.js`，代码如下：

```javascript
import Link from 'next/link'
import { allPosts } from 'contentlayer/generated'
import dayjs from "dayjs";
import { useTranslation } from "@/app/i18n/index.js"
import Like from './like';

export const generateMetadata = ({ params }) => {
  return { 
    title: "博客列表",
    description: "这是博客列表页面",
    openGraph: {
      title: '博客列表',
      description: '这是博客列表页面'
    }
  }
}

function PostCard({lng, ...post}) {
  return (
    <div className="mb-8">
      <h2 className="mb-1 text-xl">
        <Link href={`/${lng}${post.url}`} className="text-blue-700 hover:text-blue-900 dark:text-blue-400">
          {post.title}
        </Link>
      </h2>
      <time dateTime={post.date} className="mb-2 block text-xs text-gray-600">
        {dayjs(post.date).format('DD/MM/YYYY')}
      </time>
    </div>
  )
}

export default async function Home({ params: { lng } }) {
  const { t } = await useTranslation(lng)
  return (
    <div className="mx-auto max-w-xl py-8">
      <h1 className="mb-8 text-center text-2xl font-black">{t('blogList')}</h1>
      {allPosts.map((post, idx) => (
        <PostCard key={idx} {...post} lng={lng} />
      ))}
    </div>
  )
}
```

此时博客列表页面已经成功渲染，同时能根据路由切换翻译：

![10.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ac506824d4645a6972e21b2b59565d7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168\&h=429\&s=57778\&e=gif\&f=25\&b=fefefe)

### 6. 客户端组件使用翻译

刚才的使用方式适合服务端组件，尽可能使用服务端组件的方式。但如果需要在客户端组件中使用呢？

安装用到的库：

```bash
npm i react-cookie i18next-browser-languagedetector
```

新建 `app/i18n/client.js` ，代码如下：

```javascript
'use client'

import { useEffect, useState } from 'react'
import i18next from 'i18next'
import { initReactI18next, useTranslation as useTranslationOrg } from 'react-i18next'
import { useCookies } from 'react-cookie'
import resourcesToBackend from 'i18next-resources-to-backend'
import LanguageDetector from 'i18next-browser-languagedetector'
import siteMetadata from '@/data/siteMetadata'

const { fallbackLanguage: defaultLocale, languages: locales } = siteMetadata
export const cookieName = 'i18next'

const runsOnServerSide = typeof window === 'undefined'

i18next
  .use(initReactI18next)
  .use(LanguageDetector)
  .use(resourcesToBackend((language, namespace) => import(`./locales/${language}/${namespace}.json`)))
  .init({
    supportedLngs: locales,
    fallbackLng: defaultLocale,
    lng: defaultLocale,
    fallbackNS: 'basic',
    defaultNS: 'basic',
    ns: 'basic',
    lng: undefined,
    detection: {
      order: ['path', 'htmlTag', 'cookie', 'navigator'],
    },
    preload: runsOnServerSide ? locales : []
  })

export function useTranslation(lng, ns, options) {
  const [cookies, setCookie] = useCookies([cookieName])
  const ret = useTranslationOrg(ns, options)
  const { i18n } = ret
  if (runsOnServerSide && lng && i18n.resolvedLanguage !== lng) {
    i18n.changeLanguage(lng)
  } else {
    const [activeLng, setActiveLng] = useState(i18n.resolvedLanguage)
    useEffect(() => {
      if (activeLng === i18n.resolvedLanguage) return
      setActiveLng(i18n.resolvedLanguage)
    }, [activeLng, i18n.resolvedLanguage])
    useEffect(() => {
      if (!lng || i18n.resolvedLanguage === lng) return
      i18n.changeLanguage(lng)
    }, [lng, i18n])
    useEffect(() => {
      if (cookies.i18next === lng) return
      setCookie(cookieName, lng, { path: '/' })
    }, [lng, cookies.i18next])
  }
  return ret
}

```

新建 `app/[lng]/posts/like.js`，代码如下：

```javascript
'use client';

import { useTranslation } from "@/app/i18n/client.js"
export default function Like({lng}) {
  const { t } = useTranslation(lng, 'basic')
  return <button>{t('like')}</button>
}
```

修改 `app/[lng]/posts/page.js`，代码如下：

```jsx
import Link from 'next/link'
import { allPosts } from 'contentlayer/generated'
import dayjs from "dayjs";
import { useTranslation } from "@/app/i18n/index.js"
import Like from './like';

export const generateMetadata = ({ params }) => {
  return {
    title: "博客列表",
    description: "这是博客列表页面",
    openGraph: {
      title: '博客列表',
      description: '这是博客列表页面'
    }
  }
}

function PostCard({ lng, ...post }) {
  return (
    <div className="mb-8">
      <h2 className="mb-1 text-xl">
        <Link href={`/${lng}${post.url}`} className="text-blue-700 hover:text-blue-900 dark:text-blue-400">
          {post.title}
        </Link>
      </h2>
      <time dateTime={post.date} className="mb-2 block text-xs text-gray-600">
        {dayjs(post.date).format('DD/MM/YYYY')}
      </time>
      <Like lng={lng} />
    </div>
  )
}

export default async function Home({ params: { lng } }) {
  const { t } = await useTranslation(lng)
  return (
    <div className="mx-auto max-w-xl py-8">
      <h1 className="mb-8 text-center text-2xl font-black">{t('blogList')}</h1>
      {allPosts.map((post, idx) => (
        <PostCard key={idx} {...post} lng={lng} />
      ))}
    </div>
  )
}
```

我们添加了一个点赞按钮用于客户端组件的示例（尽管我们并没有添加任何事件），此时效果如下：

![11.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/556b929fcdab46919d641c7de94fdc54~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1168\&h=429\&s=79268\&e=gif\&f=25\&b=fefefe)

不同语言下的使用也没有问题。

### 7. 添加语言切换器

新建 `components/LangSwitch.js`，代码如下：

```jsx
"use client";

import { useState, useRef, Fragment, useEffect } from "react";
import {
  usePathname,
  useParams,
  useRouter,
  useSelectedLayoutSegments,
} from "next/navigation";
import siteMetadata from "@/data/siteMetadata";
import { Menu, Transition, RadioGroup } from "@headlessui/react";

const { languages } = siteMetadata;

const LangSwitch = () => {
  const urlSegments = useSelectedLayoutSegments();
  const router = useRouter();
  const params = useParams();
  const [locale, setLocal] = useState(params?.lng);


  const handleLocaleChange = (newLocale) => {
    const newUrl = `/${newLocale}/${urlSegments.join("/")}`;
    return newUrl;
  };

  const handleLinkClick = (newLocale) => {
    const resolvedUrl = handleLocaleChange(newLocale);
    router.push(resolvedUrl);
  };

  return (
    <div className="relative inline-block text-left mr-5">
      <Menu>
        <div>
          <Menu.Button>
            {locale.charAt(0).toUpperCase() + locale.slice(1)}
          </Menu.Button>
        </div>
        <Transition
          as={Fragment}
          enter="transition-all ease-out duration-300"
          enterFrom="opacity-0 scale-95 translate-y-[-10px]"
          enterTo="opacity-100 scale-100 translate-y-0"
          leave="transition-all ease-in duration-200"
          leaveFrom="opacity-100 scale-100 translate-y-0"
          leaveTo="opacity-0 scale-95 translate-y-[10px]"
          >
          <Menu.Items className="absolute right-0 z-50 mt-2 w-12 origin-top-right divide-y divide-gray-100 rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none dark:bg-gray-800">
            <RadioGroup value={locale} onChange={handleLinkClick}>
              <div className="py-1">
                {languages.map((newLocale) => (
            <RadioGroup.Option key={newLocale} value={newLocale}>
              <Menu.Item>
                <button className="group flex w-full items-center rounded-md px-2 py-2 text-sm">
                  {newLocale.charAt(0).toUpperCase() + newLocale.slice(1)}
                </button>
              </Menu.Item>
            </RadioGroup.Option>
          ))}
              </div>
            </RadioGroup>
          </Menu.Items>
        </Transition>
      </Menu>
    </div>
  );
};

export default LangSwitch;

```

修改 `app/[lng]/layout.js`，引入 LangSwitch 组件，代码如下：

```jsx
// ...
import LangSwitch from '@/components/LangSwitch';

// ...

export default function RootLayout({ children, params: { lng } }) {
  return (
    <html lang={lng} dir={dir(lng)} suppressHydrationWarning>
      <body>
        <ThemeProviders>
          <header className="flex justify-end">
            <ThemeSwitch />
            <LangSwitch />
          </header>
          {children}
        </ThemeProviders>
      </body>
    </html>
  );
}

```

此时效果如下：

![12.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eab3d098da15489880a402a3fdf06e80~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=956\&h=430\&s=89068\&e=gif\&f=42\&b=fefefe)

### 8. Metadata 如何生成？

metadata 如何根据国际化生成呢？其实用法跟服务端组件一样。

我们为博客列表页面添加一个单独的翻译文件。新建 `app/i18n/locales/en/posts.json`，代码如下：

```javascript
{
  "title": "My Blog List",
  "description": "This is My blog list description"
}
```

新建 `app/i18n/locales/zh/posts.json`，代码如下：

```javascript
{
  "title": "我的博客列表",
  "description": "这是我的博客列表页面的描述"
}
```

修改 `app/[lng]/posts/page.js`，完整代码如下：

```javascript
import Link from 'next/link'
import { allPosts } from 'contentlayer/generated'
import dayjs from "dayjs";
import { useTranslation } from "@/app/i18n/index.js"
import Like from './like';

export const generateMetadata = async ({ params: { lng } }) => {
  const { t } = await useTranslation(lng, 'posts')
  return {
    title: t("title"),
    description: t("description"),
    openGraph: {
      title: '博客列表',
      description: '这是博客列表页面'
    }
  }
}

function PostCard({ lng, ...post }) {
  return (
    <div className="mb-8">
      <h2 className="mb-1 text-xl">
        <Link href={`/${lng}${post.url}`} className="text-blue-700 hover:text-blue-900 dark:text-blue-400">
          {post.title}
        </Link>
      </h2>
      <time dateTime={post.date} className="mb-2 block text-xs text-gray-600">
        {dayjs(post.date).format('DD/MM/YYYY')}
      </time>
      <Like lng={lng} />
    </div>
  )
}

export default async function Home({ params: { lng } }) {
  const { t } = await useTranslation(lng)
  return (
    <div className="mx-auto max-w-xl py-8">
      <h1 className="mb-8 text-center text-2xl font-black">{t('blogList')}</h1>
      {allPosts.map((post, idx) => (
        <PostCard key={idx} {...post} lng={lng} />
      ))}
    </div>
  )
}
```

此时效果如下：

![13.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b034d590b7b4cf694419db7a30647ad~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1366\&h=539\&s=718243\&e=gif\&f=49\&b=2b2b2a)

可以看到，页面的元数据也随之发生了改变。

## 项目源码

> 1.  功能实现：博客支持国际化
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/next-blog-4>
> 3.  下载代码：`git clone -b next-blog-4 git@github.com:mqyqingfeng/next-app-demo.git`

## 总结

其实本篇跟[《实战篇 | React Notes | 国际化》](https://juejin.cn/book/7307859898316881957/section/7309112133474582578#heading-0)中的实现代码非常类似。使用 react-i18next 虽然配置繁琐，但自由度更高，可以根据自己的需求自定义效果。


## 56.实战篇 | 博客 | 性能分析

## 前言

本篇讲解如何对 Next.js 应用的性能进行监控。

## Bundle Analyzer

首先是 bundle 包的管理。Next.js 提供了 `@next/bundle-analyzer` 插件，它会生成每个模块大小及其依赖的可视化报告。你可以据此删除较大的依赖项或者拆分代码从而减少客户端 bundle 的大小。

安装插件：

```bash
npm i @next/bundle-analyzer
```

修改 `next.config.mjs`，代码如下：

```javascript
import { withContentlayer } from 'next-contentlayer'
import bundleAnalyzer from '@next/bundle-analyzer'

const withBundleAnalyzer = bundleAnalyzer({
  enabled: process.env.ANALYZE === 'true',
})

export default withBundleAnalyzer(withContentlayer({}))
```

修改 `package.json`，添加脚本命令：

```javascript
{
  // ...
  "scripts": {
    "analyze": "ANALYZE=true next build"
  },
  // ...
}

```

命令行运行 `npm run analyze`，它会陆续生成 3 个 HTML 文件，并同时为你打开浏览器展示文件：

一个是 `nodejs.html`，展示 nodejs server bundle：

![截屏2024-05-15 22.10.32.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb90f3432dc1455480378e321e78420c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3714\&h=2064\&s=1047462\&e=png\&b=f9f0ee)

一个是 `edge.html`，展示 edge server bundle：

![截屏2024-05-15 22.11.22.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d533a4f5f198448fa4e5ba669ceb8f7e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3714\&h=2064\&s=712520\&e=png\&b=d07bb9)

一个是 `client.html`，展示客户端浏览器 js bundle：

![截屏2024-05-15 22.11.57.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c8aec56784445709cd2b7724c635b1c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3714\&h=2064\&s=1231439\&e=png\&b=faf4f1)

## 性能测量

如果你只是要在上线前，测一下应用的性能，看看有哪些性能优化工作要做，履行一下前端的“职责”，那你可以：

### 1. Chrome Lighthouse 插件

安装 [Chrome Lighthouse](https://chromewebstore.google.com/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=zh-cn) 插件，安装完成后，开发者工具会有一个 lighthouse 选型，用于测量页面性能。以掘金为例：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f0a613f7edc42ffbfe850d856dc7a8a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3060\&h=1476\&s=769109\&e=png\&b=242424)

lighthouse 会列出需要具体改善的点，参照建议完善即可。

### 2. PageSpeed Insights

PageSpeed Insights 是一款由 Google 开发的网页性能评估工具，可以帮助开发者评估网页的性能，并提供优化建议。

打开 <https://pagespeed.web.dev/>，输入网址查看页面测试结果即可：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ac4248fb494d69a3150441612e48eb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2552\&h=2166\&s=713157\&e=png\&b=ffffff)

### 3. 其他性能测试网站

当然这种性能测试网站还是蛮多的，比如 <https://www.webpagetest.org/>、<https://tools.pingdom.com/> 等等

## Web Vitals Analytics

但是这种上线前测试一下性能的做法问题也很明显，样本有限导致数据不够准确，而且无法准确反应真实用户的体验。

如果真的要解决这个问题的话，就需要在页面实现测量和上报性能相关的数据。可是要测量哪些性能相关的数据呢？性能相关的数据又该如何上报、搜集、分析、输出图标呢？

这里的解决方案有很多种，我提供一种 Prometheus + Grafana 的方式，这套技术选型也是常见的用于数据采集、分析的解决方案。我们且慢慢说来。

### 1. 性能测量

其实 Next.js 支持对性能进行测量和上报。Next.js 提供了 `useReportWebVitals` hook 自行管理数据。

新建 `components/WebVitals.js`，代码如下：

```javascript
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric)
  })
}
```

修改 `next-blog/app/[lng]/layout.js`，添加代码如下：

```jsx
// ...
import { WebVitals } from '@/components/WebVitals.js'
// ...

export default function RootLayout({ children, params: { lng } }) {
  return (
    <html lang={lng} dir={dir(lng)} suppressHydrationWarning>
      <body>
        <WebVitals />
        <ThemeProviders>
          <header className="flex justify-end">
            <ThemeSwitch />
            <LangSwitch />
          </header>
          {children}
        </ThemeProviders>
      </body>
    </html>
  );
}

```

访问页面如 <http://localhost:3000/posts/first>，打印效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8749a5476f043fe86c08394d69040df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3460\&h=920\&s=369331\&e=png\&b=2a2a2a)

这 6 个指标就是 Web Vitals（网页指标），它是 Google 的一项计划，旨在针对网页质量信号提供统一指南，这些信号对于提供出色的网页用户体验至关重要。它的目标是简化各种可用的性能测量工具，并帮助网站所有者专注于最重要的指标。

注：其实业界尝试过非常多用于衡量性能和体验的指标，但很多指标由于难以测量、逻辑复杂等原因逐渐消亡。Web Vitals 背靠 Google，算是大浪淘沙，经过时间的检验。但这些指标也会随着时间的推移而演变，目前是这 6 个指标。

为了更直观的展示这些指标，我为大家总结了一个表格：



| | 指标 | 中文名 | 目的 | 标准 |
| --- | --- | --- | --- | --- |
|   | LCP（Largest Contentful Paint） | 最大内容绘制 | 衡量加载性能 | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91d1dfcf271646e3b21e327c02f96d28~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1056\&h=304\&s=35810\&e=png\&b=ffffff) |
 | Core Web Vitals <br/>这组指标侧重于用户体验的三个方面：加载、互动和视觉稳定性 | INP（Interaction to Next Paint） | 交互到绘制延迟 | 衡量互动 | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/909e25d7feb544a4a3726c2848307d75~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1034\&h=320\&s=35983\&e=png\&b=ffffff) |
 |  | CLS（Cumulative Layout Shift) | 累积布局偏移 | 衡量视觉稳定性 | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b57ac84784f84123b0aa14b00d2d7b01~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1084\&h=322\&s=34385\&e=png\&b=ffffff) |
 |  | FCP（First Contentful Paint） | 首次内容绘制 | 衡量加载体验，有助于诊断 LCP 问题（服务器响应时间过长或阻塞渲染的资源） | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4eca092a85f41bbb5262d0ee5dafa3d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1072\&h=324\&s=37089\&e=png\&b=ffffff) |
 | Core Web Vitals 的代理或补充指标 <br/>这组指标有助于捕获更广泛的体验或诊断特定问题 | FID（First Input Delay） | 首次输入延迟 | 衡量互动，未来可能完全被 INP 替代 | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a9aba8aa6984a308062c3814181cb21~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1054\&h=318\&s=37141\&e=png\&b=ffffff) |
 |  | TTFB（Time to First Byte） | 第一字节时间 | 衡量加载体验，有助于诊断 LCP 问题 | ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee6068b7946a4b0380ef770fc7ea7a6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1052\&h=326\&s=37460\&e=png\&b=ffffff) |

那如何测量这些指标呢？

Chrome 团队提供了 [web-vitals](https://github.com/GoogleChrome/web-vitals) 开源工具库，它基于统一的浏览器 Performance API 获取标准化的用户体验数据。

Next.js 提供的 useReportWebVitals hook 背后也是用这个库来实现的。

### 2. 性能上报

#### 1.1. Prometheus 介绍

采集到了数据，数据该如何上报并可视化呢？

我们的技术方案是用 Prometheus 和 Grafana。我们先来介绍一下这两个技术选型：

[Prometheus](https://prometheus.io/)（普罗米修斯）是一个用于监控和报警的开源系统，它自带一个基于时间序列的数据库。

它的架构设计如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/863b7c9e123149bfbd5a50d36683455f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1351\&h=811\&s=326973\&e=png\&b=fdfcfc)

看到这个架构图先不要害怕，其实很简单。简单来说，Prometheus 由这几部分组成：

1.  Prometheus Server 负责收集数据，将数据存放到数据库中
2.  数据怎么发给 Prometheus Server 呢？有两种方式上报数据：
    1.  一种是 pull 模式，待监控的服务暴露指标接口，由 Prometheus server 定期拉取采集。
    2.  另一种是 push 模式，待监控的服务直接将数据推给  Prometheus server（通常会借助 Pushgateway 待监控服务推给 Pushgateway，Prometheus Server pull Pushgateway）
3.  Alertmanager 负责监控指标进行报警，使用 email 等方式通知
4.  PromQL（Prometheus Query Language）是 Prometheus 内置的数据查询语言，可以结合 Grafana 等数据可视化工具将数据更好的展现出来

关于本篇我们采用的方式：

我们会使用 Express 自建一个服务，用于处理 Next.js Web Vitals 数据的上报。然后由 Prometheus Server 定期拉取指标数据，最后结合 Grafana 做数据可视化。

#### 1.2. Grafana 介绍

[Grafana](https://grafana.com/) 是一款开源的数据可视化工具，使用它是因为：

1.  与 Prometheus 兼容良好
2.  可视化模板多，界面高大上
3.  可免费私有部署

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b7c43fb8c94d2f9bd757ee90b88585~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3000\&h=2140\&s=786614\&e=png\&b=191b1f)

#### 1.3. Express Server

让我们运行：

```bash
# 创建文件夹
mkdir node-monitor && cd node-monitor
# 初始化
npm init
# 安装依赖项，其中 prom-client 是 Prometheus 的 Node 客户端
npm i express cors prom-client
```

新建 `app.js`，代码如下：

```javascript
import express from 'express';
import client, { collectDefaultMetrics } from 'prom-client';
import cors from 'cors';

const register = new client.Registry();
collectDefaultMetrics({ register });

const app = express();

app.use(express.text())
app.use(cors())

app.get('/metrics', async (_req, res) => {
  try {
    res.set('Content-Type', register.contentType);
    res.end(await register.metrics());
  } catch (err) {
    res.status(500).end(err);
  }
});

app.post('/report', function (req, res) {
  const { name, rating} = JSON.parse(req.body);
  let counter = register.getSingleMetric(name);
  if (!counter) {
    counter = new client.Counter({
      name,
      help: req.body,
      registers: [register],
      labelNames: ['rating'],
    });
  }
  counter.inc({
    rating
  }, 1);
  res.status(200).json({ success: true });
});

app.listen(4001, '0.0.0.0');
```

在这段代码中，我们提供了一个 `/metrics`接口用于 Prometheus Server 拉取数据，一个 `/report`接口用于 Next.js 应用上报数据。至于代码具体为什么这样写，参考 [prom-client](https://github.com/siimon/prom-client)。

修改 `package.json`，添加代码如下：

```javascript
{
  // ...
  "type": "module",
  "scripts": {
    "start": "node app.js"
  },
  // ...
}

```

运行 `npm start`，打开 <http://localhost:4001/metrics>，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46686888379642eb87c1e13a13270ce7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2598\&h=900\&s=287397\&e=png\&b=181818)

数据看不懂？没有关系，这些是 Node 应用相关的数据，可用于监控 Node 性能。我们真正要监控和记录的是 Web Vitals 相关的数据。

修改我们的 Next.js 应用 `components/WebVitals.js`：完整代码如下：

```javascript
'use client'
 
import { useReportWebVitals } from 'next/web-vitals'
 
export function WebVitals() {
  useReportWebVitals((metric) => {
    console.log(metric)

    const body = JSON.stringify(metric)
    const url = 'http://localhost:4001/report'
   
    // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
    if (navigator.sendBeacon) {
      navigator.sendBeacon(url, body)
    } else {
      fetch(url, { body, method: 'POST', keepalive: true })
    }
    
  })
}
```

关于 [navigator.sendBeacon](https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon)：

> navigator.sendBeacon() 方法可用于通过 HTTP POST 将少量数据 异步 传输到 Web 服务器。
> 它主要用于将统计数据发送到 Web 服务器，同时避免了用传统技术（如：XMLHttpRequest）发送分析数据的一些问题。

我们刷新一下 Next.js 的页面，上报一些数据，再查看 <http://localhost:4001/metrics>，可以看到产生了一批 Web Vitals 相关的数据指标：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0b38930a07b4b85b52dc61de06b4854~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2902\&h=800\&s=281058\&e=png\&b=161616)

这说明我们的 Next.js 应用（3000 端口）和 Express 应用（4001 端口）已经打通了！

#### 1.4. Docker

为了方便起见，我们使用 Docker 来开启 Prometheus 和 Grafana。

在 node-monitor 项目下新建 `prometheus.yml`文件（当然放在其他地方也是可以的），用于 Prometheus 的配置文件，代码如下：

```javascript
global:
  scrape_interval: 5s
scrape_configs:
  - job_name: "next-app"
    static_configs:
      - targets: ["docker.for.mac.host.internal:4001"]
```

配置文件告诉 Prometheus 每 5 秒抓取一次所有目标。目标在 scrape\_configs 下定义。在 Mac 上，需要使用 `docker.for.mac.host.internal` 作为主机，以便 Prometheus Docker 容器可以抓取本地 Node.js HTTP 服务器的指标。在 Windows 上，使用 `docker.for.win.localhost`；在 Linux 上，使用 `localhost`。

然后运行：

```javascript
docker run --rm -p 9090:9090 \
  -v `pwd`/prometheus.yml:/etc/prometheus/prometheus.yml \
  prom/prometheus
```

Windows 用户需要将 pwd 替换为当前工作目录的路径。

注：这里我们将端口开发了默认的 9090 端口，如果你开了 Clash，可能会产生端口冲突。关掉 Clash 或者修改 Clash 的配置文件，将其更改到其他端口。

如果正常开启，此时访问 <http://localhost:9090/>，可以看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe0831a7970e4ec5830011c4bb4931f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3498\&h=1052\&s=258440\&e=png\&b=212428)

对于 Prometheus 的初学者，可以通过访问 [http://localhost:9090/api/v1/label/**name**/values](http://localhost:9090/api/v1/label/__name__/values) 来查看有哪些数据指标：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3ea7aa99fe64828b0e8a34d7488585a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1936\&h=1130\&s=228595\&e=png\&b=171717)

我们输入 `FCP`，点击 `Execute` 按钮，如果能查询到数据就说明 Prometheus 应用（开在 9090 端口）与我们的 Express 应用（开在 4001 端口）连接成功：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e63b6252d104088b8cb2472b55890c0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3490\&h=1312\&s=341096\&e=png\&b=1f2226)

接下来开启 Grafana，运行：

```javascript
docker run -d --name=grafana -p 3001:3000 grafana/grafana
```

正常 Grafana 开启在 3000 端口，但跟我们的 Next.js 应用冲突了，所以开在了 3001 端口。如果正常开启，访问 <http://localhost:3001/>，会跳转到登录页面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4899f6fdea85494b9cda549f88f0bca1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2558\&h=1210\&s=1700983\&e=png\&b=2b2537)

账号和密码都是 admin，登录后：

![截屏2024-05-17 22.19.56.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d34334c8d4ea4555a69fc7099870a148~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3480\&h=1416\&s=342156\&e=png\&b=1b1d21)

选择 `Prometheus`，然后点击 `Add new data source`按钮，添加 Prometheus 作为数据源，进入设置页面：

![截屏2024-05-17 22.22.13.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd2607eefdc340e2898d399d70de7b91~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3664\&h=1450\&s=354870\&e=png\&b=1a1c20)

Prometheus server URL 这里填写 <http://host.docker.internal:9090>，这是因为 Prometheus 和 Grafana 都是通过 Docker 开启，环境与本机有隔离，所以无法通过 localhost 直接访问。如果这个地址不行，填写 `http://prometheus:9090` 试试。

如果能够配置成功，此时我们的各个应用就算联调成功了。一共涉及 4 个应用，Next.js 应用是我们开发的博客项目，博客页面会上报 Web Vitals 数据，Express 应用会接收上报的 Web Vitals，并提供 /metrics 接口供 Prometheus 应用拉取采集数据。最后 Grafana 应用会连接 Prometheus，用可视化的图表代替 Prometheus 的 PromQL 语句查询。

#### 1.5. Grafana 图表

接下来我们开始建立一个 Grafana 图表：

![截屏2024-05-17 22.30.38.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bf87963ff744bc795efe7c595db3deb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3678\&h=1280\&s=347729\&e=png\&b=1b1d21)
![截屏2024-05-17 22.31.46.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31acbd4b306c4ac1afa605e17d45400f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3668\&h=1736\&s=442489\&e=png\&b=14151a)![截屏2024-05-17 22.32.21.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d091b837d1e34f5c96f1cb31f9cc7d6a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3678\&h=1618\&s=555754\&e=png\&b=1d1f23)

![截屏2024-05-17 22.34.37.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77875e5d8e7b4b0397d0fcdaaa7b75c2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3784\&h=2050\&s=814347\&e=png\&b=1a1c20)

这样我们就建立了一个 FCP 评分占比的饼图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3b961b8f6f476294e32d18c588891d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3278\&h=1368\&s=423560\&e=png\&b=1b1d21)

可以看到评分为 poor 的有多少个，评分为 good 的有多少个。（数据量太少了，所以没有 need improvement)

接下来我们就可以根据自己的需要自定义需要的图表。

## 最后

目前整体的打通非常简陋，比如 Prometheus 和 Grafana 都没有做数据持久化，一旦重启，数据就会丢失。只监控了自定义的 Web Vitals 指标，Node 性能相关的指标没有做自定义上报。Grafana 也只实现了简单的百分比，而没有实现各种高大上的图表。

Prometheus 和 Grafana 其实内容非常多，碍于作者能力有限，只能为大家简单介绍下这套技术方案，更多的内容还需要大家自己去探索。

## 参考链接

1.  <https://web.dev/articles/vitals?hl=zh-cn>
2.  <https://web.dev/articles/fcp?hl=en>
3.  <https://codersociety.com/blog/articles/nodejs-application-monitoring-with-prometheus-and-grafana>
4.  <https://brew.sh/>
5.  <https://github.com/vercel/next.js/discussions/16205>
6.  <https://hub.docker.com/r/prom/prometheus>
7.  <https://github.com/grafana/grafana/issues/46434>


## 57.实战篇 | 博客 | 评论系统

## 前言

评论系统，一个说简单也简单，说复杂也复杂的系统。

往简单的说，搞个输入框，写个 API，数据存入数据库，展示时读取对应评论列表即可。

往复杂的说，评论的评论怎么处理？是否支持评论点赞？是否支持按赞数排序？是否支持评论置顶功能？评论框是否支持输入图片？是否支持表情？是否支持快捷键输入？是否支持 Markdown？Markdown 又细分是否支持公式、语法高亮等。此外，垃圾评论检测、XSS 防注入、后台人工审核、邮箱通知等等，想一想都是工作量。

所以虽然可以自己从头做，但有现成的还是用现成的吧。

但是现在评论系统相关的技术选项也是琳琅满目。且让我们做下调研：

## 技术选型

评论系统通常会涉及两部分，一部分是数据库，通常采用云端部署。一部分是前端展示，通常会提供客户端包方便引入使用。以下是评论系统常用的技术选型：

### 1. Waline

[Waline](https://waline.js.org/)，一款简洁、安全的评论系统。

服务端可免费部署到 Vercel，也提供了其他部署平台教程。客户端提供了 @waline/client，使用 Vue + TypeScript 编写，大小为 53kb gzip。支持 Markdown、表情包、插入图片等功能。也有安全相关的处理如内容校验、防灌水、保护敏感数据等。

GitHub 地址（2k Star）：<https://github.com/walinejs/waline>
演示地址：<https://waline.js.org/>

### 2. Twikoo

[Twikoo](https://twikoo.js.org/)，一款简洁、安全、免费的网站评论系统。也分为云函数部署和前端部署，都提供了[教程](https://twikoo.js.org/quick-start.html)。

GitHub 地址（1.3k Star）：<https://github.com/twikoojs/twikoo>
演示地址：<https://twikoo.js.org/>

个人评价：功能弱于 Waline，满足基本的评论需求。

### 3. Disqus

[Disqus](https://disqus.com/)，国外老牌的评论系统，国内不能用，免费版有广告，于是诞生了很多 Disqus 的替代品。

个人评价：国内还是用下边这个吧。

### 4. DisqusJS

[DisqusJS](https://github.com/SukkaW/DisqusJS) 是一个基于 Disqus API 和 React 开发的 Embed 插件。DisqusJS 通过 Disqus API 渲染只读的评论列表，搭配反向代理可以实现在网络审查地区加载 Disqus 评论列表；支持自动检测访客是否能够访问 Disqus、并自动选择加载原生 Disqus（评论完整模式）或 DisqusJS 提供的评论基础模式。

GitHub 地址（0.6k Star）：<https://github.com/SukkaW/DisqusJS>
演示地址：<https://disqusjs.skk.moe/>

个人评价：可以用。还需要登陆 Disqus 做些配置、再使用 Vercel 做个 Disqus API。

### 5. chirpy

[Chirpy](https://chirpy.dev/)，是一个注重隐私保护和定制化的评论系统, 支持 vercel 部署。

GitHub 地址（0.5k Star）：<https://github.com/devrsi0n/chirpy>
演示地址：<https://chirpy.dev/play>

个人评价：样式不错，但免费版每月 1000 pageviews 上限，而且只支持一个项目，使得使用它太过于鸡肋。

### 6. Cusdis

[Cusdis](https://cusdis.com/)，轻量、保护隐私、开源的 Disqus 替代品。适用于小型网站。

GitHub 地址（2.6k Star）：<https://github.com/djyde/cusdis>
演示地址：<https://cusdis.com/doc#/>

### 7. utterances

[utterances](https://utteranc.es/)，基于 Github Issues 的轻量评论组件。

GitHub 地址（8.7k Star）：<https://github.com/utterance/utterances>
演示地址：<https://utteranc.es/>

个人评价：老牌评论组件，但六七年没有更新了，也能用。

### 8. Isso

[Isso](https://isso-comments.de/)，使用 Python 和 JavaScript 编写的轻量评论服务端。

GitHub 地址（5k Star）：[https://github.com/isso-comments/isso](https://isso-comments.de/)
演示地址：<https://isso-comments.de/>

那使用什么好呢？这肯定要看你的需求而定。

我个人选择 Waline，功能丰富、用的人多、GitHub 仓库更新比较频繁。有更好的建议欢迎评论区留言。

## Waline 使用

关于 Waline 如何使用，其实[官方文档](https://waline.js.org/guide/get-started/)已经给的很详细了。这里结合博客项目来重复一遍：

### 1. 注册 LeanCloud（数据库）

LeanCloud 是一种 Serverless 云服务，提供了一站式的后端服务，如数据存储、即时通讯等等，简单的来说，比如我要实现一个数据存储功能，我只用在 LeanCloud 注册一个账号，获得对应的 App ID 和 App Key，然后调用提供的 API 即可进行数据存储。

1.  [登录](https://console.leancloud.app/login)或[注册](https://console.leancloud.app/register) LeanCloud 国际版 并进入[控制台](https://console.leancloud.app/apps)
2.  点击左上角[创建应用](https://console.leancloud.app/apps)并起一个你喜欢的名字 (请选择免费的开发版)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6e3d5df28af43a38ecec8330e89f8c1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1760\&h=824\&s=104176\&e=png\&b=ffffff)

3.  创建应用后，进入应用，点击左下角的设置 - 应用凭证，获取 `AppID`、`AppKey`、`MasterKey` 等信息：

![截屏2024-05-19 18.05.07.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de7173f76f5f4c6da2e808aa2f54ca54~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1700\&h=564\&s=73690\&e=png\&b=fefefe)

### 2. Vercel 部署（服务端）

Waline 提供了 [Vercel 模板](https://vercel.com/new/yayus-projects/clone?repository-url=https%3A%2F%2Fgithub.com%2Fwalinejs%2Fwaline%2Ftree%2Fmain%2Fexample)，点击链接，进入部署界面，创建仓库并进行部署：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79f5d9281bdb439c802777b682e61e32~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3134\&h=1830\&s=310883\&e=png\&b=0d0d0d)

部署成功后，进入应用的设置页面，设置环境变量：

![截屏2024-05-19 18.14.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6a6935487fb4c0490a046d909075d49~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3088\&h=2256\&s=472070\&e=png\&b=050505)

配置三个环境变量 `LEAN_ID`, `LEAN_KEY` 和 `LEAN_MASTER_KEY` 。它们的值分别对应上一步在 `LeanCloud` 中获得的 `AppID`, `AppKey`, `MasterKey`。

然后重新部署（这步是为了让环境变量生效）：

![截屏2024-05-19 18.19.25.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80f11798545044edbd07612ad50a1fb3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3080\&h=1396\&s=332144\&e=png\&b=050505)

### 3. 配置自定义域名

参考小册[《实战篇 | React Notes | Vercel 部署》](https://juejin.cn/book/7307859898316881957/section/7309114840307400714#heading-7)的“自定义域名”和“国内访问”章节，为我们刚部署的项目添加一个自定义域名。

![截屏2024-05-19 18.29.02.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee881735e4134899bee0cdf5fa3a0723~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3138\&h=2010\&s=440045\&e=png\&b=050505)

配置成功后，访问 <https://waline.yayujs.com/> 就可以查看评论前台界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7ef22bbe1ea41418dae564aa09eab72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2526\&h=1422\&s=176380\&e=png\&b=ffffff)

访问 <https://waline.yayujs.com/ui> 就会进入评论管理后台：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/111e8012a6b448edaf9e7a1e08b4062b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3134\&h=1348\&s=267704\&e=png\&b=f8f8f6)

当然首次登录的时候，要注册 Waline 的账号和密码，并开启两步验证，提高安全性。完成后就可以成功进入后台。后台如上图所示，可以看到所有的评论信息，并可进行置顶、编辑、回复、删除等操作。

### 4. Next.js 应用（客户端）

Next.js 项目中又该如何使用呢？

安装依赖项 `@waline/client`：

```javascript
npm i @waline/client
```

新建 `components/Waline.js`，代码如下：

```javascript
'use client'

import React, { useEffect, useRef } from 'react';
import { init } from '@waline/client';

import '@waline/client/style';

 const Waline = (props) => {
  const walineInstanceRef = useRef(null);
  const containerRef = React.createRef();

  useEffect(() => {
    walineInstanceRef.current = init({
      ...props,
      el: containerRef.current,
    });

    return () => walineInstanceRef.current?.destroy();
  }, []);

  useEffect(() => {
    walineInstanceRef.current?.update(props);
  }, [props]);

  return <div ref={containerRef} />;
};

export default Waline
```

新建 `app/[lng]/posts/[id]/page.js`，代码如下：

```jsx
// ...
import Waline from '@/components/Waline'

// ...
const Page = ({ params }) => {
  // ...
  return (
    <>
      // ...
      <article className="mx-auto max-w-xl py-8 prose prose-slate dark:prose-invert">
        // ...
      </article>
      <Waline el='#waline' serverURL="https://waline.yayujs.com/" />
    </>
  )
}

export default Page
```

serverURL 设置为上步自定义配置的域名。

此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bce090c460c94d6ebbcb2b2e582573ca~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2000\&h=2298\&s=352865\&e=png\&b=ffffff)

### 5. 自定义样式

评论框的样式该如何修改呢？就比如评论框的主题色是绿色，如果我想统一改为蓝色呢？

Waline 提供了[自定义样式](https://waline.js.org/guide/features/style.html)的文档，我们可以通过修改 CSS 变量配置样式。我们以修改主题色为例：

新建 `components/Waline.css`，代码如下：

```javascript
:root {
  /* 主题色 */
  --waline-theme-color: #42A5F5;
  --waline-active-color: #1976D2;
}
```

新建 `next-blog/components/Waline.js`，引入该样式表：

```javascript
'use client'

import React, { useEffect, useRef } from 'react';
import { init } from '@waline/client';

import '@waline/client/style';
import './Waline.css'

// ...

export default Waline

```

此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac4326032ceb465196a94f951daaee6f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2022\&h=1370\&s=131500\&e=png\&b=ffffff)

## 总结

我们的第二个实战项目就结束了，至于如何部署，可以参考第一个实战项目的部署篇，对三种常用的部署方式都有介绍。

你可能会好奇这个项目为什么没有数据库相关的内容，这是因为我们已经在第一个实战项目中讲解了 MySQL、Redis 的使用方式，所以没有再重复。在我看来，实战项目的意义一方面是熟悉技术，一方面是了解常见问题的解决方案。

如果说第一个实战项目 React Notes 的目的是为了让你熟悉 Next.js 的基本原理和常见的技术选型，那第二个实战项目则是以博客项目为例，侧重于解决内容型项目的常见问题：如何处理 MDX？如何进行 SEO 优化？如何支持深色模式？如何进行性能监控？如何接入评论系统等等？当然本篇小册对这些问题的处理并不能算是深入，实际开发中遇到的问题更为复杂，但至少能给你一个方向，节省一些时间，打下一些知识基础。

最后，如果你真的要做一个个人博客，还是建议优先用开源的改改，低成本的完成博客建设，将时间留给创作。博客项目更适合用于学习。这也算是我从过往重复建设博客的经历中总结的教训。这就是为什么项目的第一篇不是直接开始，而是教你如何找开源作品和修改。

## 58.实战篇 | 最佳实践总览

## 前言

在之前的项目中，我们都是使用 `npx create-next-app@latest`初始化项目，它是 Next.js 的官方脚手架，提供了开发 Next.js 项目最基本的配置。

然而在实际的开发中，Next.js 通常会搭配多种技术选型一起使用，主流的比如 Tailwind CSS、TypeScript、Prisma、Drizzle、NextAuth.js、tRPC、ESLint、Prettier、Husky、Lint-Staged、Commitlint 等等。如果每次都要重复配置一遍，属实有些麻烦，所以诞生了很多包含 Next.js 最佳实践的模板、Cli、框架等等。

这其中最常用的有：

1.  [create-t3-app](https://github.com/t3-oss/create-t3-app)（23.7k）

create-t3-app 是一个交互式的 Cli 用于启动一个全栈、类型安全的 Next.js 应用程序。它专注于简单性、模块化和全栈类型安全。它的技术栈包括 Next.js、tRPC、Tailwind CSS、TypeScript、Prisma、Drizzle、NextAuth.js

2.  [Next-js-Boilerplate](https://github.com/ixartz/Next-js-Boilerplate)（7.6k）

Next-js-Boilerplate 是一个 Next.js 项目模板。它的技术栈包括：Next.js + TypeScript + ESLint + Prettier + Husky + Lint-Staged + Jest + Testing Library + Cypress + Storybook + Commitlint + VSCode + Netlify + PostCSS + Tailwind CSS

3.  [Blitz](https://github.com/blitz-js/blitz)（13.4k）

Blitz 致力于添补 Next.js 缺失的全栈工具，比如类型安全的内容层（RPC）、Authentication、各种预配置（eslint、prettier、husky git hooks 等）、丰富的脚手架用于创建各种技术选型方案。

## Next-js-Boilerplate

我们的项目会以 Next-js-Boilerplate 为模板进行开发。

注：尽管以我们项目的复杂程度并不适合用这个模板，但这个模板涉及的技术栈众多且基本都是主流技术选型，从这个模板出发，可以帮助大家快速建立起自己的 Next.js 最佳实践模板。

除此之外，在实际开发中，如果喜欢 TypeScript，也推荐使用 t3，Next.js + TypeScript + tRPC 也是常用的技术选型。

使用 Next-js-Boilerplate 模板：

```bash
git clone --depth=1 https://github.com/ixartz/Next-js-Boilerplate.git my-project-name
```

如果出现以下这种错误：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d5c7b7a0ce9444ca56daea0379563aa~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2270\&h=372\&s=117088\&e=png\&b=1e1e1e)

可以改为使用 SSH 地址：

```bash
git clone --depth=1 git@github.com:ixartz/Next-js-Boilerplate.git my-project-name
```

项目运行方式同正常的 Next.js 项目：

```bash
# 进入项目目录
cd my-project-name
# 安装
npm install
# 开启开发模式
npm run dev
```

浏览器效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd0283882ae842e585ff1bad541d3015~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2570\&h=1126\&s=237765\&e=png\&b=ffffff)

从这个简单的起始界面可以看出自带了国际化和登录功能。

## 功能介绍

当然这个模板涉及的技术栈和功能可远不止这些，具体功能如下：

1.  支持 Next.js App Router + TypeScript + Tailwind CSS
2.  开启 TypeScript 和 React 18 的严格模式
3.  使用 [Clerk](https://clerk.com/) 实现鉴权：实现登录、注册、登出、忘记密码、重置密码等功能

> Clerk 是一款现代化的身份验证和用户管理平台，旨在帮助开发人员轻松实现身份验证、授权和用户管理功能。它提供了全功能的身份验证选项，包括MFA和社交媒体集成，以满足不同应用程序的需求。
>
> Clerk允许开发人员自定义身份验证界面，并提供安全性功能，以确保用户数据的安全。通过Clerk，开发人员可以轻松构建安全的用户身份验证系统和用户管理界面。

4.  支持无口令身份认证（也被称为免密认证）的 Magic Links、Multi-Factor Auth (MFA)、Social Auth (Google, Facebook, Twitter, GitHub, Apple, and more)，也支持使用通行密钥实现无密码登录

> 所谓 Magic Links，中文译为“魔法链接”，指的是在身份验证过程中发送给客户的一次性使用链接。输入用户名后，系统会向用户发送一个 URL，通过文本发送到用户的电子邮件地址或手机。用户单击即可验证自己的身份，而无需输入密码，对于某些人来说，这可能看起来像“魔法”，因此得名。
>
> 所谓 Multi-Factor Auth，中文译为“多重身份验证”，是指在授予用户帐户访问权限之前以多种不同方式对用户进行身份验证的过程。像我们常见的两步验证就是 MFA。
>
> 所谓 Socail Auth，则是通过社交媒体登录，比如 Google, Facebook, Twitter, GitHub, Apple 等等

7.  使用 [Turso](https://turso.tech/) 作为全局数据库

> Turso 是一个 sqlite 数据库。之所以使用 Turso，应该是因为 Turso 是这个项目的 Sponser。免费容量共计 9 GB，支持建立一个本地数据库和远程数据库同步。

8.  支持 ORM Drizzle

> 现代 TypeScript ORM，在[《实战篇 | React Notes | Prisma》](https://juejin.cn/book/7307859898316881957/section/7324318994751488026#heading-2)篇我们分析过 Node.js 下常用的 ORM 库，结论是目前使用度和满意度最高的是 Prisma、Drizzle、Mongoose。

9.  使用 [next-intl](https://next-intl-docs.vercel.app/) 和 [Crowdin](https://crowdin.com/) 实现国际化

> Next.js 实现国际化就 2 个主流的技术选型，react-i18next 和 next-intl。Crowdin 则是面向团队和企业的 AI 驱动本地化软件。你可以把它简单的理解为管理翻译文件的平台，可以上传、翻译、下载文件。

9.  使用 [T3 Env](https://env.t3.gg/docs/introduction) 定义类型安全的环境变量

> 定义文件在 src/libs/Env.ts，使用 zod 定义环境变量，可对环境变量进行验证并完成自动补全和类型推断。

10. 使用 [React Hook Form](https://www.react-hook-form.com/) 进行表单处理

> React Hook Form （40.1k Star）是一个老牌的用于 React 应用程序的表单验证和状态管理库。它提供了一组钩子，可以轻松地创建和管理表单，而无需编写大量样板代码

11. 使用数据校验库 Zod

> Next.js 官方推荐，用于数据校验

12. 使用 ESLint (默认 Next.js, Next.js Core Web Vitals, Tailwind CSS and Airbnb 配置)

> 代码检测工具，规则查看 .eslintrc.json

13. 使用 Prettier

> 代码美化工具，具体查看 .eslintrc.json，ESLint + Prettier，也算是常见配置了

14. 使用 [Husky](https://typicode.github.io/husky/) 添加 Git Hooks

> 自动检查 Commit Messge、代码，并在提交或推送时运行测试

15. 使用 [Lint-staged](https://github.com/lint-staged/lint-staged)

> 在 git 暂存文件上运行 linter，命令执行在 `.husky/pre-commit`

16. 使用 [Commitlint](https://commitlint.js.org/)

> 校验 Git Commit Messge，命令执行在 `.husky/commit-msg`。
>
> Husky +Prettier + ESLint + Lint-Staged + Commitlint 是常见的用于提升代码质量和提交质量的工具

17. 使用 [Commitizen](https://github.com/commitizen/cz-cli)

> 用于优化提交信息。与 commitlint 的区别在于 commitlint 校验提交信息，commitizen 辅助填写提交信息；在Git 提交工作流程中，commitlint 作用于 commit-msg 阶段，commitizen 作用于 pre-commit。

可以在 package.json 中看到添加了 commit 脚本命令。使用 [Commitizen](https://github.com/commitizen/cz-cli) 后，提交命令改为使用 npm run commit

18. 使用 [Vitest](https://vitest.dev/) 和 [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/) 进行单元测试（Unit Testing）

> Vitest 是一款JavaScript 的单元测试框架。React Testing Library 是一款用于 React 组件的 DOM Testing Library

19. 使用 [Playwright](https://playwright.dev/) 进行 Integration Testing 和 E2E Testing

> Playwright 是一个由 Microsoft 开发的用于浏览器测试和网页抓取的开源自动化库。

测试的三大基本类型：单元、集成和 E2E 测试。

> 单元测试用于验证代码中最基本的逻辑部分。
>
> 集成测试（英语：Integration testing），又称组装测试，即对程序模块采用一次性或增值方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。 实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作

> E2E 是“End to End”的缩写，可以翻译成“端到端”测试。它模仿用户，从某个入口开始，逐步执行操作，直到完成某项工作。与单元测试不同，后者通常需要测试参数、参数类型、参数值、参数数量、返回值、抛出错误等，目的在于保证特定函数能够在任何情况下都稳定可靠完成工作。单元测试假定只要所有函数都正常工作，那么整个产品就能正常工作。
>
> 相对来说，E2E 测试并没有那么强调要覆盖全部使用场景，它关注的是一个完整的操作链是否能够完成。对于 Web 前端来说，还关注界面布局、内容信息是否符合预期。

20. 使用 GitHub Actions 运行测试

> GitHub Actions 是一个持续集成 (Continuous integration)和持续交付 (Continuous delivery)的平台，它可以做到自动化构建、测试、部署。你可以创建工作流，构建和测试每一个 pull request 或者部署合并后的代码到生产环境。
>
> GitHub Actions 可以在你的代码仓库发生某个事件时运行一个工作流。举个例子，当有人给你的代码仓库新建了一个 issue，你可以跑一个工作流自动的添加合适的标签。
>
> GitHub 提供了 Linux、Windows、和 macOS 虚拟机运行你的工作流，当然你也可以自定义运行环境。
>
> 查看 .github/workflows 下的命令，可以看到会执行 Checkly、测试、Crowdin 等操作

21. [Storybook](https://storybook.js.org/) 用于 UI 开发

> Storybook 是一个用于开发 UI 组件的开源工具，它允许您创建可交互的组件并将其独立于应用程序进行开发和测试。Storybook 支持多种框架，包括 React、Vue、Angular 等。
>
> 简单来说，Storybook 用于可视化查看 UI 组件，组件根据不同的 props 传入形成不同的 “ story”，共同组成了一个 “Storybook”。可用于测试组件、添加组件文档。

22. [Sentry](https://sentry.io/for/nextjs/?utm_source=github\&utm_medium=paid-community\&utm_campaign=general-fy25q1-nextjs\&utm_content=github-banner-nextjsboilerplate-logo) 用于错误监控

> 常见的用于监控错误和性能的解决方案。需要在平台注册账号。

23. [Codecov](https://about.codecov.io/codecov-free-trial/?utm_source=github\&utm_medium=paid-community\&utm_campaign=general-fy25q1-nextjs\&utm_content=github-banner-nextjsboilerplate-logo) 用于代码覆盖率

> Codecov 是一个用于代码覆盖率分析的工具，它可以帮助开发人员了解他们的代码被测试的程度。 Codecov 支持多种编程语言，并提供多种功能，例如可视化覆盖率报告、代码审查集成和与其他工具的集成

24. 使用 [Pino.js](https://github.com/pinojs/pino) 打日志并使用 [Better Stack](https://betterstack.com/?utm_source=github\&utm_medium=sponsorship\&utm_campaign=next-js-boilerplate) 做日志管理

> Pino 是一个非常快速且简洁的 Node.js 日志库，其设计宗旨在于提供最小的开销以及高性能的日志记录功能。
>
> Better Stack是一个日志管理与分析协作平台，通过将监控、日志记录、事件管理和状态页面整合到一个平台中，为开发人员提供实时协作服务。

25. 使用 [Checkly](https://www.checklyhq.com/?utm_source=github\&utm_medium=sponsorship\&utm_campaign=next-js-boilerplate) 监控应用程序

> Checkly 是一款验证 API 端点正确性和浏览器点击流的监控工具。

26. 使用 [semantic-release](https://github.com/semantic-release/semantic-release) 做自动化 changelog 生成

> 自动化包的发布工作流程，包括：确定下一个版本号，生成发行说明，以及发布包。

27. 使用 [Percy](https://percy.io/) 可视化测试（可选）

> Percy是一个可视化回归测试工具。它非常适合保持你的UI测试的相关性，帮助你在不同的浏览器和设备上保持用户界面的一致性。

28. 使用 `@` 作为绝对地址引入前缀

29. 添加 VSCode 配置如： Debug、Settings、Tasks 和 Extensions

30. SEO metadata, JSON-LD 和 Open Graph tags

31. Sitemap.xml 和 robots.txt

32. [Bundler Analyzer ](https://www.npmjs.com/package/@next/bundle-analyzer)用于分析包依赖关系，参考[《实战篇 | 博客 | 性能分析》](https://juejin.cn/book/7307859898316881957/section/7309115349148270642#heading-1)

简单总结一下：

1.  App Router + TypeScript + Tailwind CSS
2.  自带鉴权（Clerk）和国际化实现（next-intl 和 Crowdin）
3.  配套技术选型：React Hook Form（表单处理） + Zod（数据校验）
4.  提升代码和 Git 提交质量相关：Husky +Prettier + ESLint + Lint-Staged + Commitlint + Commitizen + [Codecov](https://about.codecov.io/codecov-free-trial/?utm_source=github\&utm_medium=paid-community\&utm_campaign=general-fy25q1-nextjs\&utm_content=github-banner-nextjsboilerplate-logo) + [semantic-release](https://github.com/semantic-release/semantic-release) + VSCode 配置
5.  测试相关： [Vitest](https://vitest.dev/)、[React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)、[Playwright](https://playwright.dev/)、[Percy](https://percy.io/)
6.  可视化相关：[Storybook](https://storybook.js.org/)、[Bundler Analyzer ](https://www.npmjs.com/package/@next/bundle-analyzer)
7.  数据监控相关：[Sentry](https://sentry.io/for/nextjs/?utm_source=github\&utm_medium=paid-community\&utm_campaign=general-fy25q1-nextjs\&utm_content=github-banner-nextjsboilerplate-logo) + [Pino.js](https://github.com/pinojs/pino) + [Better Stack](https://betterstack.com/?utm_source=github\&utm_medium=sponsorship\&utm_campaign=next-js-boilerplate) + [Checkly](https://www.checklyhq.com/?utm_source=github\&utm_medium=sponsorship\&utm_campaign=next-js-boilerplate)
8.  SEO 相关：metadata, JSON-LD、Open Graph tags、Sitemap.xml、robots.txt
9.  数据库相关： Drizzle + Turso

总的来说，使用这个模板的好处在于：

1.  只是作为项目的初始化代码，拥有高度自由根据自己的需要调整配置，且容易自定义
2.  最小化代码模板、SEO 友好、可用于生产环境

## 如何使用

因为项目涉及的技术栈和平台众多，很多都需要登录到对应的平台上，获取特殊的 key 或者 token 等。所以如果真的要使用这些技术栈的话，还要做一些配置

### 1. 设置身份验证

在 Clerk.com 创建一个 Clerk 帐户，并在 Clerk Dashboard 中创建新应用程序。然后，将 `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` 和 `CLERK_SECRET_KEY` 复制到 `.env.local` 文件中：

```bash
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=your_clerk_pub_key
CLERK_SECRET_KEY=your_clerk_secret_key
```

现在就拥有了一个功能齐全的身份验证系统：注册、登录、注销、忘记密码、重置密码、更新个人资料、更新密码、更新电子邮件、删除帐户等等。

### 2. 设置远程数据库

首先，需要在 Turso.tech 创建一个 Turso 帐户并安装 Turso CLI：

```bash
brew install tursodatabase/tap/turso
turso auth signup # Sign up to Turso
```

然后，创建一个新数据库：

```bash
turso db create nextjs-boilerplate
```

再然后，使用 Turso 提供的数据库 URL 更新 `.env` 文件中的 `DATABASE_URL`：

    turso db show nextjs-boilerplate --url

    # .env
    # DATABASE_URL=libsql://[RANDOM-CHARS]-[DB-NAME]-[ORG-NAME].turso.io

最后，还需要使用 Turso 提供的身份验证令牌在 `.env.local` 中创建一个新的环境变量 `DATABASE_AUTH_TOKEN`：

    turso db tokens create nextjs-boilerplate

    # .env.local
    # DATABASE_AUTH_TOKEN=[your-auth-token]

### 3. 修改自定义配置

项目搜索 `FIXME`可以看到一些需要自定义配置的地方。这是一些需要自定义的最重要的文件：

*   `public/apple-touch-icon.png`、`public/favicon.ico`、`public/favicon-16x16.png` 、`public/favicon-32x32.png`: 网站图标，可以从 <https://favicon.io/favicon-converter/> 生成
*   `src/utils/AppConfig.ts`: 配置文件
*   `src/templates/BaseTemplate.tsx`: 默认主题
*   `next.config.mjs`: Next.js 配置
*   `.env`: 环境变量

### 4. 提交消息

```bash
npm run commit
```

### 5. 运行测试

```bash
npm run test
```

### 6. 集成和E2E测试

```bash
npx playwright install # Only for the first time in a new environment
npm run test:e2e
```

### 7. 部署生产环境

```bash
npm run build
npm run start
```

### 8. 其他功能

*   如果要设置翻译功能 (i18n)，需要登录 Crowdin.com 创建帐户并进行配置
*   如果要用到 Sentry，需要登录 Sentry 创建账号并进行配置
*   如果要用到代码覆盖率报告，需要创建 Codecov 帐户并进行设置
*   如果要查看日志，需要 Better Stack 账户并进行配置

具体的配置方案可以在官方文档中查看：<https://github.com/ixartz/Next-js-Boilerplate>

## 最后

Next-js-Boilerplate 用到的基本都是主流技术选型，即便不使用这个模板，这些技术选择也很有借鉴意义，我们在这个项目中也会使用一些，帮助大家更深入的理解这些功能。


## 59.实战篇 | Clerk 与登录注册

## 前言

登录与注册，一个说简单也简单，说复杂也复杂的功能。

往简单的说，注册的时候搞两个输入框，将数据写入数据库，登录的时候校验一下数据是否正确即可。

往复杂的说，除了登录注册，还有账号注销、忘记密码、密码重置、邮箱验证、更新个人资料、更新密码、删除账号等功能，此外，数据的安全性如何保证？Magic Links、Multi-Factor Auth (MFA)、社交媒体登录 (Google, Facebook, Twitter, GitHub, Apple, and more) 是否要支持？是不是还要做个后台统计用户登录数据？想一想都是工作量。

所以虽然可以自己从头做，但有现成的还是用现成的吧。

所幸关于登录注册的技术方案，并不像评论系统那么多，推荐 3 个主流的技术选型：

1.  [**Clerk**](https://clerk.com/)

> The most comprehensive User Management Platform

Clerk 提供了一个开发人员友好的身份验证和用户管理解决方案，帮助开发者轻松构建和管理用户身份验证、用户账户和权限管理功能。它提供了安全的身份验证、社交登录集成、角色和权限管理等功能。

2.  [**Supabase**](https://supabase.com/)

> Supabase is an open source Firebase alternative.

> Start your project with a Postgres database, Authentication, instant APIs, Edge Functions, Realtime subscriptions, Storage, and Vector embeddings.

简单来说，Supabase 是 Firebase 的开源替代品，属于 BaaS（后端即服务）产品。所谓 BaaS，开发者只需要开发和维护前端代码，由 BaaS 服务商提供了开发应用所需要的后端服务，如用户身份验证、数据库管理、推送通知（针对移动应用程序），以及云存储和托管等。

此外，Supabase 建立在 Postgres 之上。Postgres 是一个免费的开源数据库，被认为是世界上最稳定、最先进的数据库之一。

所以用户身份验证只是 Supabase 提供的功能之一。

如果要比较 Clerk 和 Supabse 的话，Clerk 更专注于身份验证和用户管理，对应功能更加丰富。Supabase 实现的功能更多，身份验证只是其中之一。

实际使用的时候，两者也可以一起使用。Clerk 和 Supabse 各自提供了接入对方的文档：

1.  [Clerk：Integrate Supabase with Clerk](https://clerk.com/docs/integrations/databases/supabase)
2.  [Supabase：Integrate Clerk](https://supabase.com/partners/integrations/clerk)

注意：这两个平台都提供了免费版，但免费版毕竟有一些限制，比如 Clerk 会限制 10000 月活跃用户等，Supabse 会限制 50000 月活跃用户，数据库大小为 500 MB 等等。

3.  [**Next-Auth**](https://next-auth.js.org/getting-started/introduction)

我们在[《实战篇 | React Notes | next-auth》](https://juejin.cn/book/7307859898316881957/section/7317925907765657638)介绍的便是 Next-Auth，Next-auth 不是平台，是一个开源库，可以帮助我们快速实现登录注册等功能。

总的来说，如果要快速接入登录注册功能，最好还是使用平台，也就是 Clerk 和 Supabse，其中 Clerk 提供的功能更为丰富，但免费版月活限制用户数更少。

本篇我们对 Clerk 的使用进行讲解。

## Clerk

### 1. Clerk 注册并创建应用

打开 <https://clerk.com/> 注册一个账号，首次登录后会进入创建应用界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91000aed3a344c5098eafd1e09107741~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3414\&h=2088\&s=525729\&e=png\&b=ffffff)

输入应用的名字，左边选择支持的登录方式，右边为预览登录界面 UI，样式会根据左边的选择有所不同。

创建应用后，会跳转到 Get started 页面，指导用户如何接入 Clerk：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46bada6c507f4faa9886936f3fabb4d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3878\&h=2090\&s=687809\&e=png\&b=ffffff)

### 2. 接入 Clerk

为了演示如何接入 Clerk，我们使用官方脚手架创建一个新项目：

```bash
npx create-next-app@latest
```

项目安装依赖项：

```bash
npm install @clerk/nextjs
```

添加本地环境变量：

```bash
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_test_xxxxxxxxxxxxxxxxxxxxxxxxx
CLERK_SECRET_KEY=sk_test_xxxxxxxxxxxxxxxxxxxxxxxxx
```

新建 `middleware.js`，代码如下：

```javascript
import { clerkMiddleware } from "@clerk/nextjs/server";

export default clerkMiddleware();

export const config = {
  matcher: ["/((?!.*\\..*|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

修改 `app/layout.jsx`，代码如下：

```jsx
import {
  ClerkProvider,
  SignInButton,
  SignedIn,
  SignedOut,
  UserButton
} from '@clerk/nextjs'
import './globals.css'
export default function RootLayout({
  children,
}) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body>
          <SignedOut>
            <SignInButton />
          </SignedOut>
          <SignedIn>
            <UserButton />
          </SignedIn>
          {children}
        </body>
      </html>
    </ClerkProvider>
  )
}
```

解释下这段代码中用到的组件：

所有 Clerk hooks 和组件都必须是 `<ClerkProvider>` 的子组件，所以我们用 `<ClerkProvider>` 将整个页面代码包裹，该组件会存储 session 和用户上下文数据。

`<SignedIn>`下的子组件仅在登录状态时显示。`<SignedOut>`下的子组件仅在非登录状态时显示。

`<SignInButton>` 是一个链接至登录页面的无样式组件。`<UserButton>`是一个 Clerk 提供的自带样式的组件，用于展示用户头像。

此时我们就实现了 Clerk 的接入，并已经实现了账号的登录、注册、账号管理、注销等功能。

打开 <http://localhost:3000/>，浏览器效果如下：

![4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ea058d2522d491a8feacf7dc87617e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1353\&h=976\&s=866418\&e=gif\&f=146\&b=fdfdfd)

### 3. 添加中文

从上图可以发现，虽然 Clerk 实现了登录注册的功能，但有一个问题，那就是界面都是英文，如何改成中文界面呢？Clerk 也考虑到了这一点，并提供了[本地化方法](https://clerk.com/docs/components/customization/localization)。

安装依赖项：

```bash
npm install @clerk/localizations
```

修改 `app/layout.js`，代码如下：

```jsx
import {
  ClerkProvider,
  SignInButton,
  SignedIn,
  SignedOut,
  UserButton
} from '@clerk/nextjs'
import './globals.css'
import { zhCN } from "@clerk/localizations";

export default function RootLayout({
  children,
}) {
  return (
    <ClerkProvider localization={zhCN}>
      <html lang="zh-CN">
        <body>
          <SignedOut>
            <SignInButton mode="modal">
              登录
            </SignInButton>
          </SignedOut>
          <SignedIn>
            <UserButton showName={true} />
          </SignedIn>
          {children}
        </body>
      </html>
    </ClerkProvider>
  )
}
```

此时浏览器效果如下：

![5.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d6b22f41eec4b2396ee8e8a8b18be3d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1353\&h=976\&s=801725\&e=gif\&f=132\&b=fdfdfd)

注意：这里`<SignInButton>` 的 `mode` 设置为了 `"modal"` 才让登录界面的本地化生效。如果不设置为 modal 则会直接跳转到登录界面，此时本地化不会生效。如果让跳转登录界面也实现本地化的话，可以参考接下来讲到的 Next-js-Boilerplate 的实现方式。

### 4. 后台界面

Clerk 提供了后台界面，可以查看登录用户数据以及进行登录相关的设置：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28698b3eea6b44249a1f4240451feec0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3872\&h=2124\&s=622794\&e=png\&b=ffffff)

当然，Clerk 实现的功能远不止如此，你可以完全自定义登录界面、使用内置的组件自定义开发、构架自己的登录流程等等，Clerk 都提供了详细的文档：<https://clerk.com/docs>

## Next-js-Boilerplate

既然我们已经知道了 Next.js 项目如何接入 Clerk，那回到我们之前讲到的 Next-js-Boilerplate 模板。

### 1. 基础设置

在这个模板中使用 Clerk，最基础的就是设置 `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` 和 `CLERK_SECRET_KEY`。

> 从安全的角度来讲，应该将 `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` 放到 `.env`文件中，`CLERK_SECRET_KEY` 放到 `.env.local`文件中，并且 Git 不提交 `.env.local`

### 2. 登录路由

但与之前简易接入 Clerk 的方式不同，在 Next-js-Boilerplate 中，当用户点击 Sign In 的时候，跳转的并不是 Clerk 的登录页面，而是 <http://localhost:3000/sign-in>，这是因为在 `.env`中，我们通过 `CLERK_SIGN_IN_URL` 环境变量重新设置了登录的跳转地址：

```bash
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
```

查看 `/sign-in`路由对应的文件代码，打开 `src/app/[locale]/(auth)/(center)/sign-in/[[...sign-in]]/page.tsx`：

```tsx
import { SignIn } from '@clerk/nextjs';
import { getTranslations } from 'next-intl/server';
import { getI18nPath } from '@/utils/Helpers';

// ...

const SignInPage = (props: { params: { locale: string } }) => (
  <SignIn path={getI18nPath('/sign-in', props.params.locale)} />
);

export default SignInPage;

```

在这个页面路由中，我们使用了 Clerk 提供的 `<SignIn>` 组件来渲染登录界面，其中 `path` 属性用来设置组件挂载的路径。

### 3. 中文设置

如果我们的 Next-js-Boilerplate 要实现默认中文登录界面的效果，该如何实现呢？

首先，修改 `src/utils/AppConfig.ts`，完整代码如下：

```typescript
import type { LocalePrefix } from 'node_modules/next-intl/dist/types/src/shared/types';

const localePrefix: LocalePrefix = 'as-needed';

export const AppConfig = {
  name: 'Nextjs Starter',
  locales: ['zh', 'en'],
  defaultLocale: 'zh',
  localePrefix,
};
```

然后修改 `src/app/[locale]/(auth)/layout.tsx`，完整代码如下：

```tsx
import { enUS, zhCN } from '@clerk/localizations';
import { ClerkProvider } from '@clerk/nextjs';

export default function AuthLayout(props: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  let clerkLocale = zhCN;
  let signInUrl = '/sign-in';
  let signUpUrl = '/sign-up';
  let dashboardUrl = '/dashboard';

  if (props.params.locale === 'en') {
    clerkLocale = enUS;
  }

  if (props.params.locale !== 'zh') {
    signInUrl = `/${props.params.locale}${signInUrl}`;
    signUpUrl = `/${props.params.locale}${signUpUrl}`;
    dashboardUrl = `/${props.params.locale}${dashboardUrl}`;
  }

  return (
    <ClerkProvider
      localization={clerkLocale}
      signInUrl={signInUrl}
      signUpUrl={signUpUrl}
      signInFallbackRedirectUrl={dashboardUrl}
      signUpFallbackRedirectUrl={dashboardUrl}
      >
      {props.children}
    </ClerkProvider>
  );
}
```

最后，添加翻译文件，新建 `src/locales/zh.json`，代码如下：

```javascript
{
  "RootLayout": {
    "home_link": "主页",
    "about_link": "关于",
    "guestbook_link": "Guestbook",
    "portfolio_link": "Portfolio",
    "sign_in_link": "登录",
    "sign_up_link": "注册"
  },
  "BaseTemplate": {
    "description": "Starter code for your Nextjs Boilerplate with Tailwind CSS",
    "made_with": "Made with"
  },
  "Index": {
    "meta_title": "Next.js Boilerplate Presentation",
    "meta_description": "Next js Boilerplate is the perfect starter code for your project. Build your React application with the Next.js framework."
  },
  "Guestbook": {
    "meta_title": "Guestbook",
    "meta_description": "An example of CRUD operation",
    "database_powered_by": "Database powered by",
    "loading_guestbook": "Loading guestbook...",
    "error_reporting_powered_by": "Error reporting powered by"
  },
  "GuestbookForm": {
    "username": "Username",
    "body": "Body",
    "save": "Save"
  },
  "About": {
    "meta_title": "About",
    "meta_description": "About page description",
    "about_paragraph": "Welcome to our About page! We are a team of passionate individuals dedicated to creating amazing software.",
    "translation_powered_by": "Translation powered by"
  },
  "Portfolio": {
    "meta_title": "Portfolio",
    "meta_description": "Welcome to my portfolio page!",
    "presentation": "Welcome to my portfolio page! Here you will find a carefully curated collection of my work and accomplishments. Through this portfolio, I'm to showcase my expertise, creativity, and the value I can bring to your projects.",
    "portfolio_name": "Portfolio {name}",
    "error_reporting_powered_by": "Error reporting powered by",
    "coverage_powered_by": "Code coverage powered by"
  },
  "PortfolioSlug": {
    "meta_title": "Portfolio {slug}",
    "meta_description": "Portfolio {slug} description",
    "header": "Portfolio {slug}",
    "content": "Created a set of promotional materials and branding elements for a corporate event. Crafted a visually unified theme, encompassing a logo, posters, banners, and digital assets. Integrated the client's brand identity while infusing it with a contemporary and innovative approach. Garnered favorable responses from event attendees, resulting in a successful event with heightened participant engagement and increased brand visibility.",
    "log_management_powered_by": "Log management powered by"
  },
  "SignIn": {
    "meta_title": "Sign in",
    "meta_description": "Seamlessly sign in to your account with our user-friendly login process."
  },
  "SignUp": {
    "meta_title": "Sign up",
    "meta_description": "Effortlessly create an account through our intuitive sign-up process."
  },
  "Dashboard": {
    "meta_title": "Dashboard",
    "hello_message": "Hello {email}!"
  },
  "UserProfile": {
    "meta_title": "User Profile"
  },
  "DashboardLayout": {
    "dashboard_link": "Dashboard",
    "user_profile_link": "Manage your account",
    "sign_out": "Sign out"
  }
}

```

当然在这里我们只翻译了登录相关的文字，其他内容的翻译我们会在下篇借助 CrowdIn 来实现。

此时浏览器效果如下：

![6.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75584a3120d84ef8a41bef6f18795d56~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1357\&h=814\&s=291796\&e=gif\&f=74\&b=fefefe)

## 总结

登录注册所代表的鉴权功能，主流技术选型有 3 个：Clerk、Supabase 和 Next-Auth。其不同之处在于 Clerk 专注于用户管理，Supabse 是 BaaS 产品，鉴权是其中一个功能。Next-Auth 是一个开源库，需要自己实现数据库等。

总的来说，为了快速接入，会优先选择接入 Clerk 和 Supabase，这两个平台自带数据库实现，但免费版都有一些限制。但两者也不冲突，Clerk 和 Supabse 可以一起使用。


## 6.路由篇 | 路由处理程序

## 前言

路由处理程序是指使用 Web [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) 和 [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) API 对于给定的路由自定义处理逻辑。

简单的来说，前后端分离架构中，客户端与服务端之间通过 API 接口来交互。这个“API 接口”在 Next.js 中有个更为正式的称呼，就是路由处理程序。

本篇我们会讲解如何定义一个路由处理程序以及写路由处理程序时常遇到的一些问题。

## 1. 定义路由处理程序

写路由处理程序，你需要定义一个名为 `route.js`的特殊文件。（注意是 `route` 不是 `router`）

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/babbee6771464a4f86b56a6ec8acc6f9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=444\&s=212806\&e=png\&b=171717)

该文件必须在 `app`目录下，可以在 `app` 嵌套的文件夹下，但是要注意 `page.js`和 `route.js`不能在同一层级同时存在。

想想也能理解，`page.js`和 `route.js`本质上都是对路由的响应。`page.js`主要负责渲染 UI，`route.js`主要负责处理请求。如果同时存在，Next.js 就不知道用谁的逻辑了。

### 1.1. GET 请求

让我们从写 GET 请求开始，比如写一个获取文章列表的接口。

新建 `app/api/posts/route.js` 文件，代码如下：

```javascript
import { NextResponse } from 'next/server'
 
export async function GET() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const data = await res.json()
 
  return NextResponse.json({ data })
}
```

浏览器访问 `http://localhost:3000/api/posts` 查看接口返回的数据：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a067b254ed254d738e7384fcd1a13bb0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3602&h=1482&s=412488&e=png&b=ffffff)


在这个例子中：

1. 我们 `export` 一个名为 `GET` 的 `async` 函数来定义 GET 请求处理，注意是 export 而不是 export default


2. 我们使用 `next/server` 的 NextResponse 对象用于设置响应内容，但这里不一定非要用 `NextResponse`，直接使用 `Response` 也是可以的：

```javascript
export async function GET() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const data = await res.json()
  
  return Response.json({ data })
}
```

但在实际开发中，推荐使用 `NextResponse`，因为它是 Next.js 基于 `Response` 的封装，它对 TypeScript 更加友好，同时提供了更为方便的用法，比如获取 Cookie 等。

3. 我们将接口写在了 `app/api` 文件夹下，并不是因为接口一定要放在名为 `api` 文件夹下（与 Pages Router 不同）。如果你代码写在 `app/posts/route.js`，对应的接口地址就是 `/posts`。放在 `api` 文件夹下只是为了方便区分地址是接口还是页面。

### 1.2. 支持方法

Next.js 支持 `GET`、`POST`、`PUT`、`PATCH`、`DELETE`、`HEAD` 和 `OPTIONS` 这些 HTTP 请求方法。如果传入了不支持的请求方法，Next.js 会返回 `405 Method Not Allowed`。

```javascript
// route.js
export async function GET(request) {}
 
export async function HEAD(request) {}
 
export async function POST(request) {}
 
export async function PUT(request) {}
 
export async function DELETE(request) {}
 
export async function PATCH(request) {}
 
// 如果 `OPTIONS` 没有定义, Next.js 会自动实现 `OPTIONS`
export async function OPTIONS(request) {}
```

现在让我们再写一个 POST 请求练练手。

继续修改 `app/api/posts/route.js`，添加代码如下：

```javascript
export async function POST(request) {
  const article = await request.json()
  
  return NextResponse.json({
    id: Math.random().toString(36).slice(-8),
    data: article
  }, { status: 201 })
}
```

现在让我们用 Postman 调用一下：


![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75d5b058673841c3b4f4b9ab75507c2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1750&h=1030&s=170274&e=png&b=252525)


### 1.3. 传入参数

现在让我们具体看下请求方法。每个请求方法的处理函数会被传入两个参数，一个 `request`，一个 `context` 。两个参数都是可选的：

```javascript
export async function GET(request, context) {}
```

#### request (optional)

request 对象是一个 [NextRequest](https://juejin.cn/book/7307859898316881957/section/7309079651500949530#heading-23) 对象，它是基于 [Web Request API](https://developer.mozilla.org/en-US/docs/Web/API/Request) 的扩展。使用 request ，你可以快捷读取 cookies 和处理 URL。

我们这里讲讲如何获取 URL 参数：

```javascript
export async function GET(request, context) {
  //  访问 /home, pathname 的值为 /home
	const pathname = request.nextUrl.pathname
	// 访问 /home?name=lee, searchParams 的值为 { 'name': 'lee' }
	const searchParams = request.nextUrl.searchParams
}
```

其中 nextUrl 是基于 Web URL API 的扩展（如果你想获取其他值，参考 [URL API](https://developer.mozilla.org/en-US/docs/Web/API/URL)），同样提供了一些方便使用的方法。

#### context (optional)

目前`context` 只有一个值就是 `params`，它是一个包含当前动态路由参数的对象。举个例子：

```javascript
// app/dashboard/[team]/route.js
export async function GET(request, { params }) {
  const team = params.team
}
```

当访问 `/dashboard/1` 时，params 的值为 `{ team: '1' }`。其他情况还有：

| Example                          | URL            | params                    |
| -------------------------------- | -------------- | ------------------------- |
| `app/dashboard/[team]/route.js`  | `/dashboard/1` | `{ team: '1' }`           |
| `app/shop/[tag]/[item]/route.js` | `/shop/1/2`    | `{ tag: '1', item: '2' }` |
| `app/blog/[...slug]/route.js`    | `/blog/1/2`    | `{ slug: ['1', '2'] }`    |

注意第二行：此时 params 返回了当前链接所有的动态路由参数。

#### 示例代码

现在让我们写个 demo 复习下这些知识。

需求：目前 GET 请求 `/api/posts` 时会返回所有文章数据，现在希望 GET 请求 `/api/posts/1?dataField=title` 获取 post id 为 1 的文章数据，dataField 用于指定返回哪些字段数据。

让我们开始写吧。新建 `/api/posts/[id]/route.js`，代码如下：

```javascript
import { NextResponse } from 'next/server'

export async function GET(request, { params }) {
  const field = request.nextUrl.searchParams.get("dataField")
  const data = await ((await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`)).json())
  const result = field ? { [field]: data[field] } : data
  return NextResponse.json(result)
}
```

用 Postman 测试一下，如果请求地址是 `http://localhost:3000/api/posts/1?dataField=title`，效果如下：


![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfbe33a5acae40978e0633c66953be55~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1828&h=798&s=143154&e=png&b=222222)

如果请求地址是 `http://localhost:3000/api/posts/1`，效果如下：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5eebccd5d7b41f5a8614c18364702b8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1826&h=876&s=177175&e=png&b=232323)

### 1.4. 缓存行为

#### 默认缓存

默认情况下，使用 `Response` 对象（`NextResponse` 也是一样的）的 GET 请求会被缓存。

让我们举个例子，新建 `app/api/time/route.js`，代码如下：

```javascript
export async function GET() {
  console.log('GET /api/time')
  return Response.json({ data: new Date().toLocaleTimeString() })
}
```

注意：在开发模式下，并不会被缓存，每次刷新时间都会改变：


![get-cache.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d95418beb1214522a86c15aebde94538~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=521&h=144&s=22089&e=gif&f=27&b=fefefe)

现在我们部署生产版本，运行 `npm run build && npm run start`：


![get-cache-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/114035e161cb479b9aa4e12cc036ba94~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=521&h=144&s=16832&e=gif&f=23&b=fefefe)

你会发现，无论怎么刷新，时间都不会改变。这就是被缓存了。

可是为什么呢？Next.js 是怎么实现的呢？

让我们看下构建（npm run build）时的命令行输出：

![截屏2024-02-29 12.02.47.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/403817cc707a4a95ad6c994d03353ccc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1418&h=1368&s=1535239&e=png&b=090316)

根据输出的结果，你会发现 `/api/time` 是静态的，也就是被预渲染为静态的内容，换言之，`/api/time` 的返回结果其实在构建的时候就已经确定了，而不是在第一次请求的时候才确定。

#### 退出缓存

但大家也不用担心默认缓存带来的影响。实际上，默认缓存的条件是非常“严苛”的，这些情况都会导致退出缓存：

* `GET` 请求使用 `Request` 对象

修改 `app/api/time/route.js`，代码如下：

```javascript
export async function GET(request) {
  const searchParams = request.nextUrl.searchParams
  return Response.json({ data: new Date().toLocaleTimeString(), params: searchParams.toString() })
}
```

现在我们部署生产版本，运行 `npm run build && npm run start`：

![截屏2024-02-29 12.37.21.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/55aceee3f8c340359a8517ee57903212~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1340&h=1326&s=1393960&e=png&b=090316)

运行效果如下：

![get-cache-2.gif](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bfa4f4e118343c795d4f377826f525e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=521&h=144&s=25261&e=gif&f=19&b=fdfdfd)

此时会动态渲染，也就是在请求的时候再进行服务端渲染，所以时间会改变。

*   添加其他 HTTP 方法，比如 POST

修改 `app/api/time/route.js`，代码如下：

```javascript
export async function GET() {
  console.log('GET /api/time')
  return Response.json({ data: new Date().toLocaleTimeString() })
}

export async function POST() {
  console.log('POST /api/time')
  return Response.json({ data: new Date().toLocaleTimeString() })
}
```

此时会转为动态渲染。这是因为 POST 请求往往用于改变数据，GET 请求用于获取数据。如果写了 POST 请求，表示数据会发生变化，此时不适合缓存。

*   使用像 cookies、headers 这样的[动态函数](https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-9)

修改 `app/api/time/route.js`，代码如下：

```javascript
export async function GET(request) {
  const token = request.cookies.get('token')
  return Response.json({ data: new Date().toLocaleTimeString() })
}
```

此时会转为动态渲染。这是因为 cookies、headers 这些数据只有当请求的时候才知道具体的值。

*   [路由段配置项](https://juejin.cn/book/7307859898316881957/section/7309079033223446554#heading-3)手动声明为动态模式

修改 `app/api/time/route.js`，代码如下：


```javascript
export const dynamic = 'force-dynamic'

export async function GET() {
  return Response.json({ data: new Date().toLocaleTimeString() })
}
```

此时会转为动态渲染。这是因为你手动设置为了动态渲染模式……

#### 重新验证

除了退出缓存，也可以设置缓存的时效，适用于一些重要性低、时效性低的页面。

有两种常用的方案，一种是使用[路由段配置项](https://juejin.cn/book/7307859898316881957/section/7309079033223446554#heading-5)。

修改 `app/api/time/route.js`，代码如下：

```javascript
export const revalidate = 10

export async function GET() {
  return Response.json({ data: new Date().toLocaleTimeString() })
}
```

`export const revalidate = 10` 表示设置重新验证频率为 10s，但是要注意：

这句代码的效果并不是设置服务器每 10s 会自动更新一次 `/api/time`。而是最少 10s 后才重新验证。

举个例子，假设你现在访问了 `/api/time`，此时时间设为 0s，10s 内持续访问，`/api/time`返回的都是之前缓存的结果。当 10s 过后，假设你第 12s 又访问了一次 `/api/time`，此时虽然超过了 10s，但依然会返回之前缓存的结果，但同时会触发服务器更新缓存，当你第 13s 再次访问的时候，就是更新后的结果。

简单来说，超过 revalidate 设置时间的首次访问会触发缓存更新，如果更新成功，后续的返回就都是新的内容，直到下一次触发缓存更新。

还有一种是使用 `next.revalidate` 选项。

为了演示它的效果，我们需要准备一个能够随机返回数据的接口。

如果你喜欢猫猫，可以调用 <https://api.thecatapi.com/v1/images/search>，每次调用它都会返回一张随机的猫猫图片数据。

如果你喜欢狗狗，可以调用 <https://dog.ceo/api/breeds/image/random>，每次调用它都会返回一张随机的狗狗图片数据。

如果你喜欢美女帅哥，请自己解决。

现在让我们开始吧！新建 `app/api/image/route.js`，代码如下：

```javascript
export async function GET() {
  const res = await fetch('https://api.thecatapi.com/v1/images/search')
  const data = await res.json()
  console.log(data)
  return Response.json(data)
}
```

让我们在开发模式下打开这个页面：


![get-cache-3.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d24ddaaf8cf74ecd89f7209696210260~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=154&s=35397&e=gif&f=20&b=fcfcfc)

你会发现与之前的 `/api/time` 不同，`/api/image` 接口返回的数据在开发模式下刷新就已经不会改变了，即使 console.log 每次都会打印，返回的结果却还是一样。

这是因为 Next.js 拓展了原生的 fetch 方法，会自动缓存 fetch 的结果。现在我们使用 `next.revalidate` 设置 fetch 请求的重新验证时间，修改 `app/api/image/route.js`，代码如下：


```javascript
export async function GET() {
  const res = await fetch('https://api.thecatapi.com/v1/images/search', {
    next: { revalidate: 5 }, //  每 5 秒重新验证
  })
  const data = await res.json()
  console.log(data)
  return Response.json(data)
}
```

在本地多次刷新页面，你会发现数据发生了更新：


![get-cache-4.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61b01c30135e4776919b1eaab0e0f375~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720&h=154&s=72128&e=gif&f=63&b=fcfcfc)

如果你使用生产版本，虽然在构建的时候，`/api/image` 显示的是静态渲染，但是数据会更新。具体更新的规律和第一种方案是一样的，这里就不多赘述了。


注：Next.js 的缓存方案我们还会在 [《缓存篇 | Caching》](https://juejin.cn/book/7307859898316881957/section/7309077169735958565)中详细介绍。

## 2. 写接口常见问题

接下来我们讲讲写接口时常遇到的一些问题，比如如何获取网址参数，如何读取 cookie，各种方法了解即可。实际开发中遇到问题的时候再来查就行。

### 2.1. 如何获取网址参数？

```javascript
// app/api/search/route.js
// 访问 /api/search?query=hello
export function GET(request) {
  const searchParams = request.nextUrl.searchParams
  const query = searchParams.get('query') // query
}
```

### 2.2. 如何处理 Cookie？

第一种方法是通过 `NextRequest`对象：

```javascript
// app/api/route.js
export async function GET(request) {
  const token = request.cookies.get('token')
  request.cookies.set(`token2`, 123)
}
```

其中，`request` 是一个 `NextRequest` 对象。正如上节所说，`NextRequest` 相比 `Request` 提供了更为便捷的用法，这就是一个例子。

此外，虽然我们使用 set 设置了 cookie，但设置的是请求的 cookie，并没有设置响应的 cookie。

第二种方法是通过`next/headers`包提供的 `cookies`方法。

因为 cookies 实例只读，如果你要设置 Cookie，你需要返回一个使用 `Set-Cookie` header 的 Response 实例。示例代码如下：

```javascript
// app/api/route.js
import { cookies } from 'next/headers'
 
export async function GET(request) {
  const cookieStore = cookies()
  const token = cookieStore.get('token')
 
  return new Response('Hello, Next.js!', {
    status: 200,
    headers: { 'Set-Cookie': `token=${token}` },
  })
}
```

### 2.3. 如何处理 Headers ？

第一种方法是通过 `NextRequest`对象：

```javascript
// app/api/route.js
export async function GET(request) {
  const headersList = new Headers(request.headers)
  const referer = headersList.get('referer')
}
```

第二种方法是`next/headers`包提供的 `headers` 方法。

因为 headers 实例只读，如果你要设置 headers，你需要返回一个使用了新 header 的 Response 实例。使用示例如下：

```javascript
// app/api/route.js
import { headers } from 'next/headers'
 
export async function GET(request) {
  const headersList = headers()
  const referer = headersList.get('referer')
 
  return new Response('Hello, Next.js!', {
    status: 200,
    headers: { referer: referer },
  })
}
```

### 2.4. 如何重定向？

重定向使用 `next/navigation` 提供的 `redirect` 方法，示例如下：

```javascript
import { redirect } from 'next/navigation'
 
export async function GET(request) {
  redirect('https://nextjs.org/')
}
```

### 2.5. 如何获取请求体内容？

```javascript
// app/items/route.js 
import { NextResponse } from 'next/server'
 
export async function POST(request) {
  const res = await request.json()
  return NextResponse.json({ res })
}
```

如果请求正文是 FormData 类型：

```javascript
// app/items/route.js
import { NextResponse } from 'next/server'
 
export async function POST(request) {
  const formData = await request.formData()
  const name = formData.get('name')
  const email = formData.get('email')
  return NextResponse.json({ name, email })
}
```

### 2.6. 如何设置 CORS ？

```javascript
// app/api/route.ts
export async function GET(request) {
  return new Response('Hello, Next.js!', {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}
```

### 2.7. 如何响应无 UI 内容？

你可以返回无 UI 的内容。在这个例子中，访问 `/rss.xml`的时候，会返回 XML 结构的内容：

```javascript
// app/rss.xml/route.ts
export async function GET() {
  return new Response(`<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
 
<channel>
  <title>Next.js Documentation</title>
  <link>https://nextjs.org/docs</link>
  <description>The React Framework for the Web</description>
</channel>
 
</rss>`)
}
```

注：`sitemap.xml`、`robots.txt`、`app icons` 和 `open graph images` 这些特殊的文件，Next.js 都已经提供了内置支持，这些内容我们会在[《Metadata 篇 | 基于文件》](https://juejin.cn/book/7307859898316881957/section/7309078702511128626)详细讲到。



### 2.8. Streaming

openai 的打字效果背后用的就是流：

```javascript
// app/api/chat/route.js
import OpenAI from 'openai'
import { OpenAIStream, StreamingTextResponse } from 'ai'
 
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})
 
export const runtime = 'edge'
 
export async function POST(req) {
  const { messages } = await req.json()
  const response = await openai.chat.completions.create({
    model: 'gpt-3.5-turbo',
    stream: true,
    messages,
  })
 
  const stream = OpenAIStream(response)
 
  return new StreamingTextResponse(stream)
}
```

当然也可以直接使用底层的 Web API 实现 Streaming：

```javascript
// app/api/route.js
// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream
function iteratorToStream(iterator) {
  return new ReadableStream({
    async pull(controller) {
      const { value, done } = await iterator.next()
 
      if (done) {
        controller.close()
      } else {
        controller.enqueue(value)
      }
    },
  })
}
 
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(resolve, time)
  })
}
 
const encoder = new TextEncoder()
 
async function* makeIterator() {
  yield encoder.encode('<p>One</p>')
  await sleep(200)
  yield encoder.encode('<p>Two</p>')
  await sleep(200)
  yield encoder.encode('<p>Three</p>')
}
 
export async function GET() {
  const iterator = makeIterator()
  const stream = iteratorToStream(iterator)
 
  return new Response(stream)
}
```

注：Streaming 更完整详细的示例和解释可以参考 [《如何用 Next.js v14 实现一个 Streaming 接口？》](https://juejin.cn/post/7344089411983802394)

## 小结

恭喜你，完成了本节内容的学习！

这一节我们介绍了如何定义一个路由处理程序，那就是使用新的约定文件 `route.js`，切记 `route.js` 不能跟同级的 `page.js` 一起使用。

同时我们介绍了写路由处理程序中可能会遇到的问题。在开发的时候，尽可能使用 NextRequest 和 NextResponse，它们是基于原生 Request 和 Response 的封装，提供了快捷处理 url 和 cookie 的方法。


## 参考链接

1.  [Routing: Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)
2.  [File Conventions: route.js](https://nextjs.org/docs/app/api-reference/file-conventions/route)
3.  [Functions: NextResponse](https://nextjs.org/docs/app/api-reference/functions/next-response)


## 60.实战篇 | Crowdin 与本地化

## 前言

我们在[《实战篇 | React Notes | 国际化》](https://juejin.cn/book/7307859898316881957/section/7309112133474582578)介绍过，Next.js 项目实现国际化，目前有三个主流的技术选型：

1.  [next-i18next](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fi18next%2Fnext-i18next)
2.  [next-intl](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Famannn%2Fnext-intl)
3.  [next-translate](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Faralroca%2Fnext-translate)

本篇我们聊聊搭配这些技术选型使用的、做本地化管理的平台 —— Crowdin。

## Crowdin

Crowdin 是一个翻译和本地化管理平台，简单的来说，你可以在这个平台上传翻译文件、翻译校对、下载翻译文件等等，同时支持团队协作、提供质量保证工具、与多个工具集成等以完善翻译流程。

> 注：当然这类本地化翻译平台其实还蛮多的，这是一个关于本地化工具的[榜单](https://www.g2.com/categories/software-localization-tools)。

Crowdin 算是比较主流的工具。之所以讲解这个平台：

1.  Next-js-Boilerplate 用的就是 Crowdin，且配置代码已经写好，可直接使用

> 注：当然之所以使用 Crowdin ，很有可能 Crowdin 是项目 Sponsor 的缘故

2.  Node.js 的新官网便是用的 Crowdin 实现本地化翻译，参考[《Diving into the Node.js Website Redesign》](https://nodejs.org/en/blog/announcements/diving-into-the-nodejs-website-redesign)

### 1. 创建项目

打开 [https://crowdin.com](https://crowdin.com/profile)，注册账号后进入创建项目页面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f17fecac7e34b85a21fd49735ad0e73~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3742\&h=1264\&s=523376\&e=png\&b=fefefe)

先不着急创建项目，这类平台往往都可以设置中文界面。

点击右上角的头像，进入 `Settings`，找到 `Language & Region`：

![截屏2024-06-13 17.54.43.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4708adcc6b24a7fbc7a20a3510d734a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3740\&h=988\&s=213614\&e=png\&b=ffffff)

选择“简体中文”，便会跳转到中文界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ef2172e85b849b5b192e8b13f2c7410~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3750\&h=944\&s=362489\&e=png\&b=ffffff)

点击“创建项目”，创建一个测试项目：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbabdb9393be4ea49ce72b2bf6da482d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3304\&h=2122\&s=459204\&e=png\&b=ffffff)

这里源语言选择了英语，因为作为示例展示，我们想把原本 Next-js-Boilerplate 中的英文（en.json）自动翻译为中文（zh.json）。

如果自己的项目原本是中文，想要翻译成其他语言做国际化，那源语言就选择中文。

### 2. AI 翻译设置

平台可以手动上传待翻译的文件，也可以与工具集成，集成后比如可以直接在 VSCode 上传文件。

我们先演示下如何手动上传一个翻译文件，熟悉下整个翻译流程。

找到 Next-js-Boilerplate 中的 `src/locales/en.json`文件，在 「原文」页面上传：

![截屏2024-06-13 18.21.32.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46b3fed919094b25964edcdd788374ae~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2910\&h=1548\&s=336388\&e=png\&b=ffffff)

上传文件后，可以在「主页」看到一条目标是简体中文的翻译任务：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a81c2473e3b5483182223c61f89c24f0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3980\&h=1512\&s=403943\&e=png\&b=ffffff)

这样一条翻译任务，目前进度为 0%，你需要先翻译，后校对（批准），才算是完成这条翻译任务（进度 100%）。

CrowdIn 中的机器翻译和 AI 翻译都需要借助对应平台的 API 密钥，比如使用谷歌翻译就需要用到谷歌翻译 API 的密钥。

这里我们选择 AI，然后自备一个 GPT3.5 的 Token，开启 OpenAI  提供商：

![截屏2024-06-13 18.28.12.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31baa50f58a046eb90174daab4982cce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3966\&h=952\&s=219702\&e=png\&b=fefefe)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e3c802a241048f1a5af53d54bfb3ca1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3964\&h=1644\&s=327287\&e=png\&b=ffffff)

添加提示词：

![7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ba3c9f684784b06ba6505621257c1ba~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1981\&h=766\&s=670447\&e=gif\&f=121\&b=fefefe)

> 注：如果是 GPT 3.5，注意不要勾选 ScreenShots

### 3. 翻译校对

回到项目界面，使用 AI 进行预翻译：

![8.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99da2160f0244970a80731bcf9b00a40~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2042\&h=924\&s=437773\&e=gif\&f=78\&b=fdfdfd)

预翻译成功后会出现提示界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f6f28c1bb5f4a1ea5297174262155b0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4086\&h=1698\&s=593786\&e=png\&b=969696)

此时翻译任务的状态也发生了变化：

![截屏2024-06-13 18.42.13.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97e7ea74bdc4d56826a9b40bb6f6fcb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4086\&h=1552\&s=438793\&e=png\&b=ffffff)

点击“校对”，就会进入 Crowdin 的翻译编辑器界面：

![截屏2024-06-13 18.46.15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e34cc632c82f473f8024e8bb6805a535~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4088\&h=2088\&s=774555\&e=png\&b=ffffff)

可以看到编辑器会列出翻译的原文和翻译后的文案，右侧还提供了建议翻译。

修改完毕后，我们勾选所有的条目，点击对号，表示校对完成。

校对完成后，这个翻译任务就算完成。回到项目界面，下载翻译完成的文件：

![截屏2024-06-13 18.51.35.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d7fdbd31bfe436ca2f47dc36ffb92e5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4082\&h=1610\&s=385705\&e=png\&b=ffffff)

打开翻译文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ca25388ef524ddc90c87e4beb09d1d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2934\&h=1520\&s=409515\&e=png\&b=1e1e1e)

我们把文件更名为 `zh.json`即可放入 Next-js-Boilerplate 使用。

就这样我们实现了一个翻译文件的翻译、校对工作，相信大家也对 CrowdIn 的使用流程有了一个大致的了解。

### 4. 与 VSCode 集成

Crowdin 实现了与 500+ 应用程序和工具集成，我们演示下如何与 VSCode 进行集成，即通过 VSCode 编辑器实现文件上传和下载。

点击项目页面的「集成」，点击「浏览集成」，搜索 「VSCode」，点击搜索结果：

![截屏2024-06-13 19.08.51.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c5d16171056482d8eab29fc85056047~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3536\&h=1584\&s=319204\&e=png\&b=989898)

此时会跳转到具体的 VSCode 插件介绍页面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e77a17a944340738a227a3c7e9cf8a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4050\&h=1428\&s=503263\&e=png\&b=ffffff)

注：这只是介绍下如何查找与 CrowdIn 集成的工具和安装方法。其实这个 Crowdin VSCode 插件可以直接在 VScode 插件面板搜索安装：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/468f331fb22b4aa3a4ef8049e09766b4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1874\&h=442\&s=78385\&e=png\&b=232323)

Crowdin 会自动搜索工作区的 Crowdin 配置文件（crowdin.yml），并将内容显示在单独的 Crowdin 面板：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96c28e00fd904426ac1e48bac4a84fc5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2658\&h=1370\&s=370538\&e=png\&b=202020)

当然刚安装的时候，因为配置没有完成，所以面板里不会显示任何内容。我们还需要进行一些认证和配置。

打开 VSCode 编辑器，Command + Shift + P 打开命令面板：

1.  输入 `Crowdin: Sign In` 登录 Crowdin 账户（注意登录时需要邮箱认证过的账号）
2.  输入 `Crowdin: Select Project` 选择 Crowdin 项目

打开 Next-js-Boilerplate 项目代码，打开 `crowdin.yml`文件，注释掉 `base_url`这一行（这是企业版会用到的）：

```yaml
# "base_url": "https://api.crowdin.com"
```

此时 Crowdin 面板应该已经能正常显示出需要翻译的文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95b503c80ba5403c99569dc92fdef854~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2658\&h=1370\&s=370538\&e=png\&b=202020)

Crowdin 面板具体分为 3 块内容，UPLOAD 负责上传待翻译文件，DOWNLOAD 负责下载翻译后的文件，PROGRESS 负责追踪翻译进度。

为了防止混淆，我们在平台上删除掉之前上传的 en.json 文件，并删除本地的 zh.json 文件，在这里再重新翻译一遍。

首先是在 UPLOAD 区上传待翻译文件：

![截屏2024-06-14 00.02.29.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5d065a2f3d9437e8409114b6dfa3d8d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2940\&h=862\&s=221003\&e=png\&b=212121)

上传完毕后，就可以在平台查看到上传的文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89498854b56a453ea66ce8583809c0df~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3406\&h=976\&s=164183\&e=png\&b=fefefe)

然后按照之前的流程，使用 AI 翻译并批准完成，将翻译的进度推进到 100%。

最后在 DOWNLOAD 区下载翻译后的文件：

![截屏2024-06-14 00.04.38.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed123d388aa1498494160dd162e4285f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2778\&h=1232\&s=285458\&e=png\&b=202020)

Crowdin 会下载翻译后的文件，并自动生成一个新的名为 `zh.json`的文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e51b50355b894c45a5466726d4de77d5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2004\&h=506\&s=101658\&e=png\&b=1e1e1e)

当然之所以会如此实现，其实是因为我们的 `crowdin.yml` 配置文件中指定了翻译文件的位置和命名方式。

通过与 VSCode 集成，待翻译文件的上传和翻译文件的下载都可以直接在编辑器中完成，确实便捷了一些。

## Next-js-Boilerplate

### 1. 与 GitHub Actions 集成

Next-js-Boilerplate 的实现则更加便捷一些，它结合了 GitHub Actions，当你将代码提交到 GitHub 的时候，GitHub Actions 会自动同步 Crowdin 的本地化文件，同时创建一个新分支用于合并。

具体是什么效果呢？比如你已经在 Crowdin 平台完成了 `en.json` 的中文翻译，你不需要下载翻译后的文件，只需要正常提交 `en.json`文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44f71d85ea7048489bb86ab99ba2227c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2466\&h=754\&s=130671\&e=png\&b=0f1217)

GitHub Actions 会自动创建一个分支，将翻译后的文件写入代码并提交，你只需要处理分支合并就行：

![截屏2024-06-14 01.47.46.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97102d21c71e4c85bcb0b7ccc9a04668~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3458\&h=1162\&s=240390\&e=png\&b=0e1116)

### 2. 配置代码解析

实现这段功能的代码在 `.github/workflows/crowdin.yml`文件：

```yaml
name: Crowdin Action

on:
  push:
    branches: [ main ] # Run on push to the main branch
  schedule:
    - cron: "0 5 * * *" # Run every day at 5am
  workflow_dispatch: # Run manually

jobs:
  synchronize-with-crowdin:
    name: Synchronize with Crowdin
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: crowdin action
        uses: crowdin/github-action@v1
        with:
          upload_sources: true
          upload_translations: true
          download_translations: true
          localization_branch_name: l10n_crowdin_translations
          create_pull_request: true
          pull_request_title: 'New Crowdin Translations'
          pull_request_body: 'New Crowdin translations by [Crowdin GH Action](https://github.com/crowdin/github-action)'
          pull_request_base_branch_name: 'main'
          commit_message: 'chore: new Crowdin translations by GitHub Action'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CROWDIN_PROJECT_ID: ${{ secrets.CROWDIN_PROJECT_ID }}
          CROWDIN_PERSONAL_TOKEN: ${{ secrets.CROWDIN_PERSONAL_TOKEN }}

```

这段代码并不复杂，主要是各种声明：

1.  `branches: [ main ]`表示推送到 main 分支的时候才运行此 Actions
2.  `uses: crowdin/github-action@v1`表示使用 Crowdin 提供的 [actions 代码](https://github.com/crowdin/github-action/tree/v1/)进行处理，简单来说，就是核心功能已经实现好了，你还需要配置一些变量。
3.  `upload_sources: true`表示上传待翻译文件
4.  `download_translations: true`表示下载翻译文件
5.  `localization_branch_name`表示要创建的分支名
6.  `commit_message`表示下载翻译后的文件并提交代码，提交的 commit\_message
7.  `pull_request_title`表示 PR 的 title
8.  `pull_request_base_branch_name: 'main'`表示基于 main 分支创建 PR

> 当然还有其他配置声明，参考 <https://github.com/crowdin/github-action/tree/v1/>

### 3. 配置方法

为了能够让这个 Action 生效，首先你要获得 `CROWDIN_PROJECT_ID` 和 `CROWDIN_PERSONAL_TOKEN` 的值。

> 注：GITHUB\_TOKEN 不需要，GitHub 会自动生成

`CROWDIN_PROJECT_ID` 的值在项目主页即可查到：

![截屏2024-06-14 11.28.15.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e26e1ecf2a47f48a02e093bdf5acbc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3816\&h=1062\&s=225358\&e=png\&b=ffffff)

`CROWDIN_PERSONAL_TOKEN` 则需要到个人设置里生成：

![截屏2024-06-14 11.29.48.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/797131e06a9548199d00513130f0cb5e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2664\&h=1516\&s=320508\&e=png\&b=ffffff)

然后因为涉及到 PR 的创建，所以需要添加 Actions 的权限：

![截屏2024-06-14 11.32.30.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60b53b97693f4f88948efc10b1aaaee8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3164\&h=2302\&s=722483\&e=png\&b=ffffff)

最后添加 GitHub Secrets：

![截屏2024-06-14 11.34.47.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1026d76b2204d6d92facf6a2b2dcc8b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3182\&h=1910\&s=555070\&e=png\&b=ffffff)

### 4. 运行效果

此时再将代码提交到 main 分支，GitHub 会自动运行 Crowdin Actions，同步 Crowdin 数据，并创建新的本地化分支：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/442e52546b8e4f23a5879e78dedf64e2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4180\&h=1140\&s=388344\&e=png\&b=ffffff)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/912cec09b5064a5293712378040a848d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3594\&h=644\&s=170196\&e=png\&b=ffffff)

## 总结

Crowdin 是一个不错的本地化管理平台，同时支持多人协作，所以也很适合中大型团队使用。

Crowdin 的中文知识库地址：<https://support.crowdin.com/zh/translation-process-overview/>

## 63.源码篇 | 手写 React SSR

## 前言

讲了那么多遍 SSR，是不是对 SSR 感到很神奇？SSR 到底是怎么实现的呢？

本篇我们手写一个 Mini React SSR，借此来了解 SSR 的基本原理。千万不要觉得很难，其实很简单，让我们直接开始吧。

## Mini React CSR

我们先从 CSR 开始说起。如果对 CSR、SSR 这两个概念不太清楚，可以参考 [小册《渲染篇 | 从 CSR、SSR、SSG、ISR 开始说起》](https://juejin.cn/book/7307859898316881957/section/7309077054263066662)。

涉及的目录结构和文件如下：

```javascript
react-csr             
├─ app.js             
├─ client.js          
├─ index.html            
├─ package.json       
└─ webpack.client.js  
```

运行：

```bash
# 新建文件夹
mkdir react-csr && cd react-csr

# 自动生成 package.json
npm init
```

然后安装用到的依赖项：

```bash
npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env @babel/preset-react react react-dom
```

其中：
1. webpack、webpack-cli 用于 webpack 打包
2. babel-loader、@babel/core、@babel/preset-env、 @babel/preset-react 用于编译 React
3. react、react-dom 用于书写 React 代码

新建 `index.html`，代码如下：

```html
<html>

<head>
  <title>Tiny React SSR</title>
</head>

<body>
  <div id='root'>
  </div>
  <script src="./index.js"></script>
</body>

</html>
```

我们的目标是用 webpack 打包 React 代码，生成 index.js。浏览器打开 `index.html`，直接查看效果。

我们开始写 React 代码，新建 `client.js`，代码如下：

```javascript
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from'./app'

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

新建 `app.js`，代码如下：

```javascript
import { useState } from 'react';

export default function MyApp() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counters { count } times</h1>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

代码逻辑很简单，就是我们初学 React 时，在 React 官网常看到的点击按钮更新次数的计数器例子。

因为 JavaScript 不能直接识别 React 的 JSX 格式，所以需要 webpack 和 babel 将 JSX 代码编译成普通的 JavaScript 代码。新建 `webpack.client.js`，代码如下：

```javascript
const path = require('path')

module.exports = {
  mode: 'development',
  entry: './client.js',
  output: {
    filename: 'index.js',
    path: path.resolve(__dirname)
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env', ["@babel/preset-react", { "runtime": "automatic" }]]
          }
        }
      }
    ]
  }
}
```

注：`webpack.client.js`是为了我们区分用于客户端还是服务端而起的名字，它不会像 `webpack.config.js`一样被自动读取。所以我们还需要在运行 webpack 命令的时候，指定该配置文件。

修改 `package.json`，添加新的脚本命令：

```javascript
{
  "scripts": {
    "start": "webpack --config webpack.client.js"
  }
}

```

此时运行 `npm start`，交互效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c3e0147d7ef4ac8ab936a311b6876e0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1454\&h=752\&s=1182562\&e=png\&b=150722)

项目根目录会生成 `index.js`，浏览器打开 `index.html`，效果如下：

![csr.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c258223e5d5644cd980c2afa11a12fc7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1185\&h=547\&s=76713\&e=gif\&f=23\&b=fdfdfd)

这就是一个典型的 CSR 例子。我们查看其 HTML 文件，也只有一个 root 节点，渲染都在客户端发生。

> 1. 功能实现：React CSR
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-csr-1>
> 3. 下载代码：`git clone -b react-csr-1 git@github.com:mqyqingfeng/next-app-demo.git`

## Mini React SSR

### 1. Step1：Express 起个服务

现在让我们实现 SSR。实现 SSR 需要起一个服务，我们借助 Express 来实现。

注：关于为什么使用 Express 而不是 koa2？主要考虑到以下几个因素：

1. Express 的使用远比 koa 更加广泛，根据 2022 年（虽然 2024 年了，但 2023 年还没有出来）的[后端框架统计](https://2022.stateofjs.com/en-US/other-tools/#backend_frameworks)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43a89fcaca1046bb90c96aec6f3086f1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3470\&h=1360\&s=445600\&e=png\&b=252325)

2. Express 内置的功能更加强大，生态更加丰富。语法上的差异随着 Node 的发展问题不大。更新频率上，两个框架都不算频繁，不过其本身设计就比较简单，更上层的应用还是应该用 Next.js 这类框架。

废话不多说，让我们开始吧！涉及的目录结构和文件如下：

```javascript
react-ssr                           
├─ pages                            
│  └─ index.js                                   
├─ package.json                     
├─ server.js                        
└─ webpack.server.js                
```

运行：

```bash
# 新建文件夹
mkdir react-ssr && cd react-ssr

# 自动生成 package.json
npm init
```

然后安装用到的依赖项：

```bash
npm install webpack webpack-cli babel-loader @babel/core @babel/preset-env @babel/preset-react react react-dom express
```

相比 CSR 的实现，多装了一个 express，毕竟我们需要 express 起个 Node 服务。

新建 `server.js`，代码如下：

```javascript
const express = require('express')
const app = express()

app.get('/', (req, res) => res.send(`
<html>
   <head>
       <title>Tiny React SSR</title>
   </head>
   <body>
    <div id='root'>
      Counters 0 times
    </div>
   </body>
</html>
`))

app.listen(3000, () => console.log('listening on port 3000!'))
```

运行 `node server.js`，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37d3af7c7fc04b30a95fdf1ffb59dbb0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1222\&h=374\&s=31291\&e=png\&b=ffffff)

说明 Express 启动成功。让我们继续写 SSR。

### 2. Step2：实现 SSR

修改 `server.js`，代码如下：

```javascript
import express from 'express'
import React from 'react'
import { renderToString } from 'react-dom/server'
import App from './pages/index'

const app = express()
const content = renderToString(<App />)

app.get('/', (req, res) => res.send(`
<html>
   <head>
       <title>Tiny React SSR</title>
   </head>
   <body>
    <div id='root'>${content}</div>
   </body>
</html>
`))

app.listen(3000, () => console.log('listening on port 3000!'))
```

新建 `pages/index.js`，代码如下：

```javascript
import React, { useState } from 'react';

export default function MyApp() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counters { count } times</h1>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

运行 `node server.js`，此时肯定会报错，有两个原因：

1.  我们使用了 import 语法，这是 ES 规范，而非 Node.js 的 CommonJS 规范
2.  我们使用了 React 的 JSX 语法，JavaScript 并不认识，需要进行编译

为此我们需要使用 webpack、babel 进行打包，新建 `webpack.server.js`，代码如下：

```javascript
const path = require('path') 

module.exports = {
  mode:'development',
  target: 'node',
  entry: './server.js',       
  output: {                     
    filename: 'server.bundle.js',    
    path: path.resolve(__dirname, 'build')    
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env', '@babel/preset-react']
          }
        }
      }
    ]
  }
}
```

借助 webpack，我们将 server.js 代码和依赖项都打包到 build 下的 server.bundle.js，然后我们 node 命令启动server.bundle.js 即可。修改 `package.json`，添加脚本命令：

```javascript
{
  "scripts": {
    "start": "webpack --config webpack.server.js && node ./build/server.bundle.js"
  }
}

```

运行 `npm start`，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0c5a39c819f479483c0c75cb9777ffc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1584\&h=1162\&s=1634586\&e=png\&b=0a0418)

此时打开 `localhost:3000`，你会发现页面成功渲染：

![ssr.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/933a56251f624b4d91005cd387ae3c4b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=776\&h=335\&s=24120\&e=gif\&f=27\&b=fefefe)

但是点击按钮毫无反应……

这是因为我们只是调用了 [renderToString](https://react.dev/reference/react-dom/server/renderToString) 将 React 组件树转为 HTML 字符串，并没有进行任何水合（事件绑定）相关的操作，自然只是输出静态的 HTML。查看返回的 HTML：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4a24132b8504240b2fdb850fa6e0909~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2966\&h=1174\&s=336584\&e=png\&b=fefefe)

借助 React 提供的 Server API —— renderToString，虽然没有绑定事件，但至少我们成功的实现了服务端渲染。

### 3. Step3：绑定事件

怎么绑定事件呢？

既然服务端渲染只能渲染 HTML，客户端渲染能绑定事件，那就结合一下。

我们再实现一遍 CSR， 让页面插入一个打包后的 bundle，挂载到 id 为 root 的 DOM 节点上。

也就是说，先在服务端调用 renderToString 将组件代码渲染到 HTML 中，再调用一遍客户端打包后的 bundle 代码，挂载到相同的节点，让客户端将一模一样的内容重新渲染一遍，并绑定上事件。

虽然同样的内容被渲染了 2 遍，但至少事件是绑定上去了。让我们先干起来：

涉及的目录和文件如下：

```javascript
react-ssr                           
├─ pages                            
│  └─ index.js                            
├─ client.js                                      
├─ package.json                     
├─ server.js                        
├─ webpack.client.js                
└─ webpack.server.js                
```

修改 `server.js`，代码如下：

```javascript
import express from 'express'
import React from 'react'
import { renderToString } from 'react-dom/server'
import App from './pages/index'

const app = express()
app.use(express.static('public'));
const content = renderToString(<App />)

app.get('/', (req, res) => res.send(`
<html>
   <head>
       <title>Tiny React SSR</title>
   </head>
   <body>
    <div id='root'>${content}</div>
    <script src="/client.bundle.js"></script>
   </body>
</html>
`))

app.listen(3000, () => console.log('listening on port 3000!'))
```

在这段代码中，我们声明了 public 为静态文件目录。

引用的 JS 文件地址为 `/client.bundle.js`，所以还需要新建 `public` 目录，我们会将客户端代码打包到 `client.bundle.js`，并放到 public 目录下。

新建 `client.js`，代码如下：

```javascript
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from'./pages/index'

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

新建 `webpack.client.js`，代码如下：

```javascript
const path = require('path')

module.exports = {
  mode: 'development',
  entry: './client.js',
  output: {
    filename: 'client.bundle.js',
    path: path.resolve(__dirname, 'public')
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env', ["@babel/preset-react", { "runtime": "automatic" }]]
          }
        }
      }
    ]
  }
}
```

梳理下现在的流程：

我们先打包客户端 JS，将引用 `pages/index.js`核心 React 代码的 client.js 打包到 `public`下的 client.bundle.js 中。

然后将同样引用 `pages/index.js`核心 React 代码的 server.js 打包到 `build` 下的 server.bundle.js 中，然后 node 开启 server.bundle.js。

这样当访问 `localhost:3000`的时候，服务端会先渲染一遍组件代码，然后输出到 HTML 中，然后引用 client.bundle.js，然后用 JS 重新渲染一遍，并同时绑定上事件。

修改 `package.json`，代码如下：

```javascript
{
  "scripts": {
    "start": "webpack --config webpack.client.js && webpack --config webpack.server.js && node ./build/server.bundle.js"
  }
}

```

运行 `npm start`，打开 `localhost:3000`，交互效果如下：

\`![ssr-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48afcb5f165f4126bd02592140c8956a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1476\&h=525\&s=158768\&e=gif\&f=27\&b=fdfdfd)

此时既实现了服务端渲染，客户端也绑定上了事件，能够进行正常的点击操作。

### 4. Step4：hydrateRoot

目前最大的问题就是同样的内容渲染了两遍，为了解决这个问题，React 提供了 [hydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot)  API。

> hydrateRoot 函数允许你在先前由 react-dom/server 生成的浏览器 HTML DOM 节点中展示 React 组件。

简单的来说，我们常用的 createRoot 会重新渲染，hydrateRoot 会复用已有的 DOM 节点（当然前提是服务端和客户端渲染一致，这样才能够复用）。

hydrateRoot 通常就是搭配 React 的服务端 API react-dom/server 而使用的：react-dom/server 负责服务端渲染，hydrateRoot 负责复用 DOM 进行水合。

我们修改下 `client.js`，代码如下：

```javascript
import React from 'react';
import { hydrateRoot } from 'react-dom/client';
import App from'./pages/index'

hydrateRoot(document.getElementById('root'), <App />);
```

运行 `npm start`，打开 `localhost:3000`，交互效果如下：

\`![ssr-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d85ffa712d50484588fed502219a2aef~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1476\&h=525\&s=158768\&e=gif\&f=27\&b=fdfdfd)

此时既实现了服务端渲染，客户端也绑定上了事件，也不会渲染 2 遍。

> 1. 功能实现：React SSR
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-1>
> 3. 下载代码：`git clone -b react-ssr-1 git@github.com:mqyqingfeng/next-app-demo.git`

## 总结

想想 Next.js 的 Pages Router，如果我们在 `pages/index.js` 中写入如下代码：

```javascript
import React, { useState } from 'react';

export default function MyApp() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counters { count } times</h1>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

当访问 `/`的时候，会渲染该组件的内容。是不是跟我们现在的 Mini React SSR 很像？

不过这才刚刚开始，下篇让我们继续完善这个 Mini React SSR，并在此基础上实现 React SSG 与 React ISR。




## 64.源码篇 | 手写 React SSG 和 ISR

## 前言

上篇我们手写了一个 React SSR，实现了基本的服务端渲染和客户端绑定事件。

本篇我们先继续完善 React SSR，并在此基础上实现 React SSG 和 React ISR。

## 1. 优化 Ract SSR

### Step1：实现 getServerSideProps

在使用 Next.js Pages Router 的时候，经常会用到一个 [getServerSideProps](https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props) 的 API，用于在页面请求时获取数据渲染页面的内容。举个例子：

```javascript
export async function getServerSideProps() {
  // 获取数据
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo = await res.json()
  // 通过 props 将数据传给 page
  return { props: { repo } }
}
 
export default function Page({ repo }) {
  return (
    <main>
      <p>{repo.stargazers_count}</p>
    </main>
  )
}
```

这个功能该怎么实现呢？

其实思路很简单：import 该文件，获取导出的 getServerSideProps 函数。然后在服务端调用该函数，最后将返回的数据传入到组件中。

修改 `server.js`，完整代码如下：

```jsx
import express from 'express'
import React from 'react'
import { renderToString } from 'react-dom/server'
import { readdirSync } from "fs";
import { join } from "path";

const app = express()
app.use(express.static('public'));

app.get("/", async (req, res) => {
    const file = await import(`./pages/index.js`);
    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps({ query: req.query });
      propsObj = props
    }
    const Component = file.default;

    const content = renderToString(<Component {...propsObj} />)
    res.send(`
    <html>
       <head>
           <title>Tiny React SSR</title>
       </head>
       <body>
        <div id='root'>${content}</div>
        <script src="/client.bundle.js"></script>
       </body>
    </html>
    `)
})

app.listen(3000, () => console.log('listening on port 3000!'))
```

为了测试效果，修改 `pages/index.js`，代码如下：

```javascript
import React from 'react';

export async function getServerSideProps() {
  const res = await fetch('https://api.thecatapi.com/v1/images/search')
  const cat = await res.json()
  return { props: { cat } }
}
 
export default function Page({ cat }) {
  return <img src={cat[0].url} width="200" />
}
```

运行 `npm start`，访问 `http://localhost:3000/`，此时页面空白且有报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ef5ee83c8c344469536a59195a577a7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3464\&h=1312\&s=692215\&e=png\&b=faf4f4)

但是让我们查看 localhost 页面的 HTML 返回：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/388e0271d3fd4be0aaa0814a876bee9a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3640\&h=842\&s=274474\&e=png\&b=ffffff)
至少 HTML 返回是正确的，并成功的获取了数据。

可是为什么会有报错呢？

根据报错的信息，是水合（hydration）时出现了错误。这是因为服务端渲染的 HTML 和客户端渲染的 HTML 并不匹配（前面我们说过，服务端渲染和客户端渲染一致，是复用 DOM 节点进行水合的前提）。

服务端渲染的时候我们调用接口传入了数据，但是客户端渲染的时候并没有调用接口传入数据，自然渲染不一致，导致了报错。

所以客户端渲染的时候也要获取数据，才能保证两端渲染一致。

尴尬的是我们的接口是一个随机返回数据的接口，每次调用都会返回不同的数据。

注：其实这种每次调用数据返回不一致的情况很常见，比如 feeds 流，客户端调用和服务端调用尽管时间差不了几秒，但可能数据已经发生了更改。

最为简单的方式是将数据写入 HTML 脚本中，然后客户端渲染的时候直接获取。

修改 `server.js`，完整代码如下：

```javascript
import express from 'express'
import React from 'react'
import { renderToString } from 'react-dom/server'
import { readdirSync } from "fs";
import { join } from "path";

const app = express()
app.use(express.static('public'));

app.get("/", async (req, res) => {
    const file = await import(`./pages/index.js`);
    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps({ query: req.query });
      propsObj = props
    }
    const Component = file.default;

    const content = renderToString(<Component {...propsObj} />)
    res.send(`
    <html>
       <head>
           <title>Tiny React SSR</title>
       </head>
       <body>
        <div id='root'>${content}</div>
        <script>
          window.__DATA__ = ${JSON.stringify(propsObj)}
        </script>
        <script src="/client.bundle.js"></script>
       </body>
    </html>
    `)
})

app.listen(3000, () => console.log('listening on port 3000!'))
```

我们将数据放到 `window.__DATA__`变量中，然后在 JS 文件中就可以直接获取。

修改 `client.js`，代码如下：

```javascript
import React from 'react';
import { hydrateRoot } from 'react-dom/client';
import App from'./pages/index'

hydrateRoot(document.getElementById('root'), <App {...window.__DATA__}/>);
```

重新运行 `npm start`，访问 `http://localhost:3000/`，现在页面渲染正常了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a61c28bf89b4be0adc388c4cbeddb48~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3584\&h=1094\&s=741932\&e=png\&b=fefdfd)

> 1. 功能实现：React SSR 实现 gerServerSideProps
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-2>
> 3. 下载代码：`git clone -b react-ssr-2 git@github.com:mqyqingfeng/next-app-demo.git`

### Step2：实现路由

Next.js 的路由基于的是文件系统，也就是说，一个文件就可以是一个路由。

举个例子，在 Next.js 的 Pages Router 下，你在 `pages` 目录下创建一个 `index.js` 文件，它会直接映射到 `/` 路由地址：

```javascript
import React from 'react'
export default () => <h1>Hello world</h1>
```

在 `pages` 目录下创建一个 `about.js` 文件，它会直接映射到 `/about` 路由地址：

```javascript
import React from 'react'
export default () => <h1>About us</h1>
```

如果我们要实现这个效果，该怎么实现呢？

实现思路其实很简单，判断路由地址，导入对应的模块进行渲染即可。

修改 `server.js`，完整代码如下：

```javascript
import express from 'express'
import React from 'react'
import { renderToString } from 'react-dom/server'
import { readdirSync } from "fs";
import { join } from "path";

const app = express()
app.use(express.static('public'));

const pagesDir = join(process.cwd(), "/pages")
const pages = readdirSync(pagesDir).map(page => page.split(".")[0]);

app.get(/.*$/, async (req, res) => {

  const path = req.path.split('/')[1]
  const page = path ? path : 'index'

  if (pages.includes(page)) {
    const file = await import(`./pages/${page}.js`);
    const Component = file.default;

    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps({ query: req.query });
      propsObj = props
    }

    const content = renderToString(<Component {...propsObj} />)
    res.send(`
      <html>
         <head>
             <title>Tiny React SSR</title>
         </head>
         <body>
          <div id='root'>${content}</div>
          <script>
            window.__DATA__ = ${JSON.stringify({
              props: propsObj,
              page: page
            })}
          </script>
          <script src="/client.bundle.js"></script>
         </body>
      </html>
      `)
  } else {
    return res.status(200).json({ message: `${page} not found in ${pages}` });
  }
})

app.listen(3000, () => console.log('listening on port 3000!'))
```

但最为麻烦的地方是 `client.js`，之前的代码是：

```javascript
import React from 'react';
import { hydrateRoot } from 'react-dom/client';
import App from'./pages/index'

hydrateRoot(document.getElementById('root'), <App />);
```

我们是固定导入的 App 组件，现在改成了跟随路由导入不同的组件，也就是说导入的组件要跟随路由不同而不同，然后打包成不同的 client.bundle.js。

一种方案是打包 pages 下的文件，分别对应生成不同的 bundle.js，比如 `index.js`生成 `index.bundle.js`，`cat.js`生成 `cat.bundle.js`，然后我们根据路由引入不同的 bundle.js。

一种方案可以参考最早的 [Next.js v1.0.0 源码](https://github.com/vercel/next.js/tree/1.0.0)，可以说是简单粗暴的解决了这个问题，那就是用 node.fs 读取 pages 下的文件，然后放入到 `window.__DATA__`，然后客户端渲染的时候获取组件代码进行渲染，伪代码如下：

```javascript
const {
  __NEXT_DATA__: { component }
} = window

const Component = evalScript(component).default

render(createElement(Component, appProps), container)
```

这两种方案都有些麻烦，这里我们直接使用 Webpack 动态加载来实现，修改 `client.js`，代码如下：

```javascript
import React from 'react';
import { hydrateRoot } from 'react-dom/client';

const { props, page } = window.__DATA__

const importFile = async (path) => {
  return await import (`./pages/${path}.js`)
}
const data = await importFile(page)
const Component = data.default

hydrateRoot(document.getElementById('root'), <Component {...props} />);
```

在 `pages` 目录下再新建一个 counter.js，代码如下:

```js
import React, { useState } from 'react';

export default function MyApp() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Counters { count } times</h1>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

重新运行 `npm start`，访问 `http://localhost:3000/`，效果如下：

![react-rsc-19.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc08b7fc236d4e65a93454f26269b9c4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1580&h=646&s=258580&e=gif&f=33&b=fcfbfc)

当访问未定义的路由时，会出现错误提示：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757b9567dd4740e98466694f8c63dd6b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1470&h=332&s=38968&e=png&b=fefefe)

> 1. 功能实现：React SSR 实现路由
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-3>
> 3. 下载代码：`git clone -b react-ssr-3 git@github.com:mqyqingfeng/next-app-demo.git`

## 2. 实现 React SSG

SSG 会在构建阶段，就将页面编译为静态的 HTML 文件。

其实核心方法不变，还是用 renderToString，只不过不写在路由中，而是渲染成具体的 HTML 文件。

让我们新建一个 `build.js`，代码如下：

```javascript
import { existsSync, readdirSync, mkdirSync, writeFileSync } from 'node:fs';
import { renderToString } from 'react-dom/server';
import { createElement } from 'react'
import { join } from "path";

const pagesDir = join(process.cwd(), "/pages")
const pages = readdirSync(pagesDir).map(page => page.split(".")[0]);

if (!existsSync('output')) {
  mkdirSync('output');
}

pages.forEach(async (page) => {
  const file = await import(`./pages/${page}.js`);
  const Component = file.default;

  let propsObj = {};
  if (file.getServerSideProps) {
    const { props } = await file.getServerSideProps();
    propsObj = props
  }
  
  const content = renderToString(createElement(Component, propsObj))
  writeFileSync(
    `output/${page}.html`,
    `    <html>
    <head>
        <title>Tiny React SSR</title>
    </head>
    <body>
     <div id='root'>${content}</div>
     <script>
       window.__DATA__ = ${JSON.stringify({
      props: propsObj,
      page: page
    })}
     </script>
     <script src="../public/client.bundle.js"></script>
    </body>
 </html>`
  );
})
```

为了让 node 能够正确运行 `build.js`，我们需要新建一个 `webpack.build.js` 文件用于打包 build.js 文件：

```javascript
const path = require('path') 

module.exports = {
  mode:'development',
  target: 'node',
  entry: './build.js',       
  output: {                     
    filename: 'build.bundle.js',    
    path: path.resolve(__dirname, 'build')    
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env', '@babel/preset-react']
          }
        }
      }
    ]
  }
}
```

现在让我们在 `package.json` 中添加一个脚本命令：

```javascript
{
  "scripts": {
    "build": "webpack --config webpack.client.js && webpack --config webpack.build.js && node ./build/build.bundle.js"
  }
}
```

现在运行 `npm run build`，`output`文件夹下会生成两个 HTML 文件：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdf0680ae0c5415a962fc62c458a1fa4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2176&h=770&s=226394&e=png&b=fcfcfc)

浏览器直接打开这两个文件，都能正常运行：

![react-rsc-20.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41c47017d707429ca5ffeefff0463f3b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=910&h=314&s=127985&e=gif&f=32&b=fefcfc)

> 1. 功能实现：React SSG
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-4>
> 3. 下载代码：`git clone -b react-ssr-4 git@github.com:mqyqingfeng/next-app-demo.git`

## 3. 实现 React ISR

SSG 都实现了，就让我们再实现一个 ISR 吧！

其实原理很简单，就是在访问的时候检查是否过期，如果过期了，就重新生成 HTML 文件。

新建 `isr.js`，代码如下：

```javascript
import express from 'express'
import { createElement } from 'react'
import { renderToString } from 'react-dom/server'
import { existsSync, readdirSync, mkdirSync, writeFileSync, stat } from 'node:fs';
import { join } from "path";

const app = express()
app.use(express.static('public'));

async function asyncForEach(array, callback) {
  for (let index = 0; index < array.length; index++) {
    await callback(array[index], index, array);
  }
}

const pagesDir = join(process.cwd(), "/pages")
const pages = readdirSync(pagesDir).map(page => page.split(".")[0]);

const expiresTime = 1000 * 10;

async function build() {
  if (!existsSync('output')) {
    mkdirSync('output');
  }

  await asyncForEach(pages, async (page) => {
    const file = await import(`./pages/${page}.js`);
    const Component = file.default;

    let propsObj = {};
    if (file.getServerSideProps) {
      const { props } = await file.getServerSideProps();
      propsObj = props
    }

    const content = renderToString(createElement(Component, propsObj))
    writeFileSync(
      `output/${page}.html`,
      `    <html>
      <head>
          <title>Tiny React SSR</title>
      </head>
      <body>
       <div id='root'>${content}</div>
       <script>
         window.__DATA__ = ${JSON.stringify({
        props: propsObj,
        page: page
      })}
       </script>
       <script src="/client.bundle.js"></script>
      </body>
   </html>`
    );
  })
}

app.get(/.*$/, async (req, res) => {

  const path = req.path.split('/')[1]
  const page = path ? path : 'index'

  if (pages.includes(page)) {

    const htmlPath = join('./output', page + '.html')

    stat(htmlPath, async function (err, stats) {
      if (err) {
          await build()
          return res.sendFile(join(process.cwd(), "output", page + '.html'));
      }
      if (Date.now() - stats.mtime > expiresTime) {
        await build()
        return res.sendFile(join(process.cwd(), "output", page + '.html'));
      } else {
        return res.sendFile(join(process.cwd(), "output", page + '.html'));
      }
    });
  } else {
    return res.status(200).json({ message: `${page} not found in ${pages}` });
  }
})

app.listen(3000, () => console.log('listening on port 3000!'))
```

为了编译 isr.js 文件，新建 `webpack.isr.js`，代码如下：

```javascript
const path = require('path') 

module.exports = {
  mode:'development',
  target: 'node',
  entry: './isr.js',       
  output: {                     
    filename: 'isr.bundle.js',    
    path: path.resolve(__dirname, 'build')    
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env', '@babel/preset-react']
          }
        }
      }
    ]
  }
}
```

`packages.json`文件添加对应的脚本命令：

```javascript
{
  "scripts": {
    "isr": "webpack --config webpack.isr.js && node ./build/isr.bundle.js"
  }
}

```

运行 `npm run isr`，交互效果如下：

![react-ssr-3.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b83285f3c6614c1e8b7d160638141fce~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=821\&h=425\&s=263452\&e=gif\&f=93\&b=fefefe)

可以看到，10s 后图片数据发生了更新。

注：当然这个 ISR 的实现并不算贴近 Next.js 的 ISR 实现，Next.js 的 ISR 是在超过验证时间的首次，依然返回之前的结果，同时进行更新，然后下次访问才返回新的结果。这里我们直接同步构建并返回了新的结果。

> 1. 功能实现：React ISR
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-ssr-5>
> 3. 下载代码：`git clone -b react-ssr-5 git@github.com:mqyqingfeng/next-app-demo.git`

## 总结

本篇我们优化了 React SSR 的功能，并在此基础上实现了 React SSG 和 React ISR，但至此实现的都是 Next.js 的 Pages Router，也就是 Next.js v13 之前的实现。

Next.js v13 推出了基于 React Server Components 的 App Router，下篇开始，我们会进入 RSC 的实现讲解。


## 65.源码篇 | 手写 RSC（上）

## 前言

本篇我们从零开始，手写一个 React Server Component 实现。为了帮助大家理解 React Server Component 的出现背景，我们会从最原始的页面实现方式开始讲起，跟随着 React 的发展历史不断完善代码，最终实现 React Server Component。

现在就让我们开始吧。

## 步骤 1：实现一个博客页面

首先创建项目，运行以下命令，完成项目初始化：

```javascript
mkdir react-rsc && cd react-rsc

npm init

npm i tsx --save-dev

npm i express escape-html react react-dom --save
```

注：在[《源码篇 | 手写 React SSR》](https://juejin.cn/book/7307859898316881957/section/7309116396511133705)，我们通过 webpack 和自定义配置实现了 JSX 语法的编译。本篇为了更加方便，我们将直接使用 [tsx](https://www.npmjs.com/package/tsx) 进行处理，虽然文件会命名为 `.ts`或 `.tsx`，但我们并不会使用 TypeScript 语法，只是借助其对 JSX 语法的编译功能。

新建文件 `index.ts`，代码如下：

```javascript
import express from "express";
import { readFile } from "fs/promises";
import escapeHtml from 'escape-html'

const app = express();

app.get("/:route(*)", async (req, res) => {
  const html = await htmlGenerator();
  res.setHeader("Content-Type", "text/html");
  res.end(html);
});

async function htmlGenerator() {
  const author = "YaYu";
  const postContent = await readFile("./posts/hello.txt", "utf8");

  return `<html>
  <head>
    <title>My blog</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="p-5">
    <nav class="flex items-center justify-center gap-10 text-blue-600">
      <a href="/">Home</a>
    </nav>
    <article class="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">
      ${escapeHtml(postContent)}
    </article>
    <footer class="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">
      (c) ${escapeHtml(author)}, ${new Date().getFullYear()}
    </footer>
  </body>
</html>`;
}

app.listen(3000, (err) => {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3000`);
});

```

博客的具体内容我们会读取 `/posts/hello.txt`文件，所以新建 `/posts/hello.txt`，随便写入一些内容，比如：

```javascript
<h1>Hello World!</h1>
```

修改 `package.json`文件中的脚本命令，添加代码如下：

```javascript
{
  "scripts": {
    "start": "tsx watch ./index.ts"
  }
}

```

运行 `npm start`，此时效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71245cefb55944b59b265f25d4adfc61~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1526\&h=1156\&s=79378\&e=png\&b=6689db)

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-1>
> 3. 下载代码：`git clone -b react-rsc-1 git@github.com:mqyqingfeng/next-app-demo.git`

效果上，我们实现的是一个博客页面的简化版，顶部是导航栏，底部是页脚，中间是具体的文章内容。

技术实现上，我们使用 express 起了一个服务器，在读取了 txt 文件的内容后，通过模板字符串的形式，直接返回了页面 HTML 内容。

值得注意的是，当我们读取完 txt 的内容后，使用了 escape-html 对内容进行了转义。这是一种常见的内容安全处理。麻烦的地方在于，所有写入内容的地方，都需要自己添加逻辑处理，难道就没有更加简单、便捷、安全的使用方式呢？

## 步骤 2：发明 JSX

为了解决这个问题，React 发明了 JSX。你可以把它理解成一种特殊的模板语言。使用 JSX，你可以在 JavaScript 中直接使用 HTML 标签，比如：

```jsx
const res = <html>
  <head>
    <title>My blog</title>
  </head>
  <body>
    <nav>
      <a href="/">Home</a>
      <hr />
    </nav>
    <article>
      {postContent}
    </article>
    <footer>
      <hr />
      <p><i>(c) {author}, {new Date().getFullYear()}</i></p>
    </footer>
  </body>
</html>
```

其中变量使用 `{}`进行包裹。这种语法，无论是 JavaScript 还是 HTML 其实都不能直接识别，所以使用 JSX 语法还需要搭配编译器（比如 Babel）使用，Babel 会将代码编译成如下形式：

```javascript
import { jsx } from "react/jsx-runtime";

const res = jsx("html", {
  children: [
    jsx("head", {
      children: jsx("title", {
        children: "My blog"
      })
    }), 
  jsx("body", {
    children: [...]
  })]
});
```

之所以编译成这种函数执行的形式，是因为我们还需要在函数运行的时候读取外边的变量（就比如上图中的 postContent 和 author）。最终该函数会返回一个描述 HTML 的 JSON 对象（为了方便，我们就简称为 JSX 对象了），类似于如下这种形式：

```javascript
// Slightly simplified
{
  $$typeof: Symbol.for("react.element"), // Tells React it's a JSX element (e.g. <html>)
  type: 'html',
  props: {
    children: [
      {
        $$typeof: Symbol.for("react.element"),
        type: 'head',
        props: {
          children: {
            $$typeof: Symbol.for("react.element"),
            type: 'title',
            props: { children: 'My blog' }
          }
        }
      },
      {
        $$typeof: Symbol.for("react.element"),
        type: 'body',
        props: {
          children: [
            {
              $$typeof: Symbol.for("react.element"),
              type: 'nav',
              props: {
                children: [{
                  $$typeof: Symbol.for("react.element"),
                  type: 'a',
                  props: { href: '/', children: 'Home' }
                }, {
                  $$typeof: Symbol.for("react.element"),
                  type: 'hr',
                  props: null
                }]
              }
            },
            {
              $$typeof: Symbol.for("react.element"),
              type: 'article',
              props: {
                children: postContent
              }
            },
            {
              $$typeof: Symbol.for("react.element"),
              type: 'footer',
              props: {
                /* ...And so on... */
              }              
            }
          ]
        }
      }
    ]
  }
}
```

所以我们写代码的时候，写的是：

```javascript
const res = <html>...</html>
```

到 JavaScript 具体执行的时候，其实是一个对象：

```javascript
const res = {
  $$typeof: Symbol.for("react.element"),
  type: 'html',
  props: {
    children: [ ... ]
  }
}
```

但有了描述 HTML 的 JSX 对象还不够，我们还需要一个 render 函数，将 JSX 对象渲染为具体的 HTML，返回给客户端的应该是这个具体的 HTML。

我们修改 `index.ts`，代码如下：

```javascript
import express from "express";
import { htmlGenerator } from "./generator";
const app = express();

app.get("/:route(*)", async (req, res) => {
  const html = await htmlGenerator();
  res.setHeader("Content-Type", "text/html");
  res.end(html);
});

app.listen(3000, (err) => {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3000`);
});
```

新建 `generator.tsx`，代码如下：

```javascript
import { readFile } from "fs/promises";
import React from 'react';
import { renderJSXToHTML } from './utils'

export async function htmlGenerator() {
  const author = "YaYu";
  const postContent = await readFile("./posts/hello.txt", "utf8");

  let jsx = <html>
  <head>
    <title>My blog</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body className="p-5">
    <nav className="flex items-center justify-center gap-10 text-blue-600">
      <a href="/">Home</a>
    </nav>
    <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">
      { postContent }
    </article>
    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">
      (c) { author }, {new Date().getFullYear()}
    </footer>
  </body>
</html>

  return renderJSXToHTML(jsx);
}
```

这里我们直接使用了 JSX 语法，tsx 会帮助我们进行编译，我们就不需要引入 Webpack 和 Babel 来处理了。

新建 `utils.ts`，代码如下：

```javascript
import escapeHtml from 'escape-html'

export function renderJSXToHTML(jsx) {
  if (typeof jsx === "string" || typeof jsx === "number") {
    return escapeHtml(jsx);
  } else if (jsx == null || typeof jsx === "boolean") {
    return "";
  } else if (Array.isArray(jsx)) {
    return jsx.map((child) => renderJSXToHTML(child)).join("");
  } else if (typeof jsx === "object") {
    if (jsx.$$typeof === Symbol.for("react.element")) {
      let html = "<" + jsx.type;
      for (const propName in jsx.props) {
        if (jsx.props.hasOwnProperty(propName) && propName !== "children") {
          html += " ";
          html += propName;
          html += "=";
          html += `"${escapeHtml(jsx.props[propName])}"`;
        }
      }
      html += ">";
      html += renderJSXToHTML(jsx.props.children);
      html += "</" + jsx.type + ">";
      html = html.replace(/className/g, "class")
      return html;
    } else throw new Error("Cannot render an object.");
  } else throw new Error("Not implemented.");
}
```

renderJSXToHTML 的代码并不复杂，简单的来说，就是不断判断 jsx 对象节点的类型，递归处理，最终拼接得到一个 HTML 字符串。

运行 `npm start`，此时效果不变：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a7720bcef104226ac5a9602c63ee52e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1526\&h=1156\&s=79378\&e=png\&b=6689db)

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-2>
> 3. 下载代码：`git clone -b react-rsc-2 git@github.com:mqyqingfeng/next-app-demo.git`

## 步骤 3：发明组件

这里我们写的是一篇博客页面，但其实每个博客页面内容都是相似的，有着相同的顶部导航和页脚，为了代码能够复用，React 引入了组件的概念，将重复的内容抽离成一个组件，用到的地方直接引入使用即可。

我们来实现一下，新建 `components.tsx`，代码如下：

```javascript
import React from 'react';

export function BlogPostPage({ postContent, author }) {
  return (
    <html>
    <head>
      <title>My blog</title>
      <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body className="p-5">
      <nav className="flex items-center justify-center gap-10 text-blue-600">
        <a href="/">Home</a>
      </nav>
      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">
        { postContent }
      </article>
      <Footer author={author} />
    </body>
  </html>
  );
}

export function Footer({ author }) {
  return (
    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">
      (c) { author }, {new Date().getFullYear()}
    </footer>
  );
}
```

这里我们将页脚抽离成 Footer 组件，然后在 BlogPostPage 组件中引入使用。

修改 `generator.tsx`，代码如下：

```javascript
import { readFile } from "fs/promises";
import React from 'react';
import { renderJSXToHTML } from './utils'
import { BlogPostPage } from './components'

export async function htmlGenerator() {
  const author = "YaYu";
  const postContent = await readFile("./posts/hello.txt", "utf8");
  return renderJSXToHTML(<BlogPostPage postContent={postContent} author={author}/>);
}
```

此时页面会空白，查看其 HTML 如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe6eadec72734b39a3d3047457437599~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2614\&h=698\&s=229146\&e=png\&b=faf9f8)

这是因为我们的 renderJSXToHTML 函数目前还只能识别普通的 HTML 标签，对于像 `<BlogPostPage>` 这样的组件类型并不能处理。

我们在写组件的时候，写的是一个函数，函数执行后才返回具体的 JSX 对象。所以我们在 render 的时候，需要判断节点是否是函数，如果是函数，就执行函数，渲染函数返回的 JSX 对象。

修改 `utils.js`中的 renderJSXToHTML 函数，完整代码如下：

```javascript
import escapeHtml from 'escape-html'

export function renderJSXToHTML(jsx) {
  if (typeof jsx === "string" || typeof jsx === "number") {
    return escapeHtml(jsx);
  } else if (jsx == null || typeof jsx === "boolean") {
    return "";
  } else if (Array.isArray(jsx)) {
    return jsx.map((child) => renderJSXToHTML(child)).join("");
  } else if (typeof jsx === "object") {
    if (jsx.$$typeof === Symbol.for("react.element")) {
      // 普通 HTML 标签
      if (typeof jsx.type === "string") {
        let html = "<" + jsx.type;
        for (const propName in jsx.props) {
          if (jsx.props.hasOwnProperty(propName) && propName !== "children") {
            html += " ";
            html += propName;
            html += "=";
            html += `"${escapeHtml(jsx.props[propName])}"`;
          }
        }
        html += ">";
        html += renderJSXToHTML(jsx.props.children);
        html += "</" + jsx.type + ">";
        html = html.replace(/className/g, "class")
        return html;
      }
      // 组件类型如 <BlogPostPage> 
      else if (typeof jsx.type === "function") {
        const Component = jsx.type;
        const props = jsx.props;
        const returnedJsx = Component(props);
        return renderJSXToHTML(returnedJsx); 
      } else throw new Error("Not implemented.");
    } else throw new Error("Cannot render an object.");
  } else throw new Error("Not implemented.");
}
```

运行 `npm start`，此时效果不变：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79a9cb20bc954dfb9bf2294966768a4d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1526\&h=1156\&s=79378\&e=png\&b=6689db)

JSX 和组件不就是 React 的基础吗？从某种角度来讲，我们已经手写了一个 React 雏形。

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-3>
> 3. 下载代码：`git clone -b react-rsc-3 git@github.com:mqyqingfeng/next-app-demo.git`

## 步骤 4：添加路由

现在我们实现了一个博客内容页面，但我想实现的效果是，当访问 `/` 的时候，展示博客文章列表，访问 `/hello` 的时候，才展示 hello.txt 这篇文章的具体内容。

我们再添加一篇文章，新建 `/posts/earth.txt`，内容随意，比如：

```javascript
<h1>Hello Earth!</h1>
```

修改 `components.tsx`代码如下：

```jsx
import React from 'react';

export function Layout({ children }) {
  const author = "YaYu";
  return (
    <html>
    <head>
      <title>My blog</title>
      <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body className="p-5">
      <nav className="flex items-center justify-center gap-10 text-blue-600">
        <a href="/">Home</a>
      </nav>
      <main>{children}</main>
      <Footer author={author} />
    </body>
  </html>
  );
}

export function IndexPage({ slugs, contents }) {
  return (
    <section>
      <h1>Blog List:</h1>
      <div>
        {slugs.map((slug, index) => (
          <section key={slug} className="mt-4">
            <a className="text-blue-600" href={"/" + slug}>{slug}</a>
            <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{contents[index]}</article>
          </section>
        ))}
      </div>
    </section>
  );
}

export function PostPage({ slug, content }) {
  return (
    <section>
      <a className="text-blue-600" href={"/" + slug}>{slug}</a>
      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>
    </section>
  );
}

export function Footer({ author }) {
  return (
    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">
      (c) { author }, {new Date().getFullYear()}
    </footer>
  );
}
```

这里我们新建了 4 个组件，其中 Layout 负责基础的 HTML 样式，包含顶部的导航栏和页脚，Footer 负责页脚。IndexPage 负责首页的文章样式，PostPage 负责具体文章页面的样式。

当访问 `/` 的时候，应该导航至 `IndexPage`，当访问 `/xxx` 的时候，应该导航至 `PostPage`，这个功能就叫做路由（Router），不过现在我们先用一个 matchRouter 函数实现。

修改 `index.ts`，代码如下：

```javascript
import express from "express";
import { htmlGenerator } from "./generator";
const app = express();

app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const html = await htmlGenerator(url);
  res.setHeader("Content-Type", "text/html");
  res.end(html);
});

app.listen(3000, (err) => {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3000`);
});
```

我们获取了当前的页面地址，并将其传入 htmlGenerator 函数。

修改 `generator.tsx`，代码如下：

```javascript
import { readFile, readdir } from "fs/promises";
import React from 'react';
import { renderJSXToHTML } from './utils'
import { Layout, IndexPage, PostPage } from './components'

export async function htmlGenerator(url) {
  const content = await readFile("./posts/hello.txt", "utf8");
  const page = await matchRoute(url);
  return renderJSXToHTML(<Layout>{page}</Layout>);
}

async function matchRoute(url) {
  if (url.pathname === "/") {
    const files = await readdir("./posts");
    const slugs = files.map((file) => file.slice(0, file.lastIndexOf(".")));
    const contents = await Promise.all(
      slugs.map((slug) =>
        readFile("./posts/" + slug + ".txt", "utf8")
      )
    );
    return <IndexPage slugs={slugs} contents={contents} />;
  } else {
    const slug = url.pathname.slice(1);
    const content = await readFile("./posts/" + slug + ".txt", "utf8");
    return <PostPage slug={slug} content={content} />;
  }
}
```

我们写了一个 matchRoute 函数，根据 URL 返回不同的组件（IndexPage 或 PostPage），然后将组件作为 children 传入 Layout 组件中，得到最终的 JSX 对象。

此时交互效果如下：

![react-rsc.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a961ac78c384c759e4acc49bf7a3bf6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=687\&h=1018\&s=157055\&e=gif\&f=53\&b=626be8)

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-4>
> 3. 下载代码：`git clone -b react-rsc-4 git@github.com:mqyqingfeng/next-app-demo.git`

## 步骤 5：异步组件与 Router

其实目前的组件抽象还是有点问题的，IndexPage 和 PostPage 的文章样式（图中紫色部分）其实是重复的，我们应该抽离一个 Post 组件，然后 IndexPage 和 PostPage 引用 Post 组件。

不仅如此，现在我们在 matchRoute 这个函数中实现了路由匹配和获取数据（readdir、readFile），但其实没有必要，因为反正都是在服务端运行，获取数据完全可以放在具体的 Post 组件中运行，这样我们就可以将获取数据的代码从 matchRoute 中分离出来，让 matchRoute 如它的函数名一样，专注于路由匹配，而非掺杂数据获取的代码。

直接说似乎有点抽象，让我们写代码吧。

修改 `components.tsx`，完整代码如下：

```jsx
import React from 'react';
import { readFile, readdir } from "fs/promises";

export function Layout({ children }) {
  const author = "YaYu";
  return (
    <html>
    <head>
      <title>My blog</title>
      <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body className="p-5">
      <nav className="flex items-center justify-center gap-10 text-blue-600">
        <a href="/">Home</a>
      </nav>
      <main>{children}</main>
      <Footer author={author} />
    </body>
  </html>
  );
}

export async function IndexPage() {
  const files = await readdir("./posts");
  const slugs = files.map((file) =>
    file.slice(0, file.lastIndexOf("."))
  );

  return (
    <section>
      <h1>Blog List:</h1>
      <div>
        {slugs.map((slug, index) => <Post key={index} slug={slug} />)}
      </div>
    </section>
  );
}

export function PostPage({ slug }) {
  return <Post slug={slug} />;
}

async function Post({ slug }) {
  let content = await readFile("./posts/" + slug + ".txt", "utf8");
  return (
    <section>
      <a className="text-blue-600" href={"/" + slug}>{slug}</a>
      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>
    </section>
  )
}

export function Footer({ author }) {
  return (
    <footer className="h-20 mt-5 flex-1 rounded-xl bg-cyan-500 text-white flex items-center justify-center">
      (c) { author }, {new Date().getFullYear()}
    </footer>
  );
}
```

在这段代码中，我们抽离了一个 Post 组件，并将数据读取放在了 IndexPage 和 Post 组件中实现。因此我们的 matchRouter 函数得以简化，我们将函数替换为 Router 组件，修改 `generator.tsx`，代码如下：

```javascript
import { readFile, readdir } from "fs/promises";
import React from 'react';
import { renderJSXToHTML } from './utils'
import { Layout, IndexPage, PostPage } from './components'

export async function htmlGenerator(url) {
  return renderJSXToHTML(<Router url={url} />);
}

function Router({ url }) {
  let page;
  if (url.pathname === "/") {
    page = <IndexPage />;
  } else {
    const slug = url.pathname.slice(1);
    page = <PostPage slug={slug} />;
  }
  return <Layout>{page}</Layout>;
}
```

此时页面渲染失败，是因为我们的组件函数使用了 async，所以渲染的时候，也要对应进行处理，修改 `utils.ts`，代码如下：

```javascript
import escapeHtml from 'escape-html'

export async function renderJSXToHTML(jsx) {
  if (typeof jsx === "string" || typeof jsx === "number") {
    return escapeHtml(jsx);
  } else if (jsx == null || typeof jsx === "boolean") {
    return "";
  } else if (Array.isArray(jsx)) {
    // 这里添加了 await 和 Promise.all
    const childHtmls = await Promise.all(
      jsx.map((child) => renderJSXToHTML(child))
    );
    return childHtmls.join("");
  } else if (typeof jsx === "object") {
    if (jsx.$$typeof === Symbol.for("react.element")) {
      if (typeof jsx.type === "string") {
        let html = "<" + jsx.type;
        for (const propName in jsx.props) {
          if (jsx.props.hasOwnProperty(propName) && propName !== "children") {
            html += " ";
            html += propName;
            html += "=";
            html += `"${escapeHtml(jsx.props[propName])}"`;
          }
        }
        html += ">";
        // 这里添加了 await
        html += await renderJSXToHTML(jsx.props.children);
        html += "</" + jsx.type + ">";
        html = html.replace(/className/g, "class")
        return html;
      }
      else if (typeof jsx.type === "function") {
        const Component = jsx.type;
        const props = jsx.props;
        // 这里添加了 await
        const returnedJsx = await Component(props);
        return renderJSXToHTML(returnedJsx); 
      } else throw new Error("Not implemented.");
    } else throw new Error("Cannot render an object.");
  } else throw new Error("Not implemented.");
}
```

此时页面正常渲染：

![react-rsc.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccfbef805f1b4416a2b1b83a2a1d492d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=687\&h=1018\&s=157055\&e=gif\&f=53\&b=626be8)

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-5>
> 3. 下载代码：`git clone -b react-rsc-5 git@github.com:mqyqingfeng/next-app-demo.git`

回过头来看我们的 Router 组件：

```javascript
function Router({ url }) {
  let page;
  if (url.pathname === "/") {
    page = <IndexPage />;
  } else {
    const slug = url.pathname.slice(1);
    page = <PostPage slug={slug} />;
  }
  return <Layout>{page}</Layout>;
}
```

它接收当前 URL，然后返回对应的组件。用过 React-Router 的同学可能知道，React-Rouer 有一个 StaticRouter，用于处理 node 环境下的路由，基本用法如下：

```javascript
import * as React from "react";
import * as ReactDOMServer from "react-dom/server";
import { StaticRouter } from "react-router-dom/server";
import http from "http";

function requestHandler(req, res) {
  let html = ReactDOMServer.renderToString(
    <StaticRouter location={req.url}>
      {/* The rest of your app goes here */}
    </StaticRouter>
  );

  res.write(html);
  res.end();
}

http.createServer(requestHandler).listen(3000);
```

你可以发现非常相似，也是接收当前 URL，返回对应的组件。从某种角度来说，我们实现了一个 React-Router 的雏形。

## 总结

本篇我们从最原始的页面开发方式开始，讲述了 React 和 React-Router 的起源背景，手写了 React 和 React-Router 最基础的实现方式。因为这个例子的所有代码都运行在服务端，所以这其实也是 React SSR 的基础实现，甚至比 [《源码篇 | 手写 React SSR》](https://juejin.cn/book/7307859898316881957/section/7309116396511133705) 实现的还要基础，就比如我们手写的 renderJSXToHTML 对应的其实就是 root.render 函数。

不过至此，其实还没有涉及到任何 RSC 相关的内容，因为我们的进度相当于在追溯 React 的发展历史，目前才刚发展到 React SSR，下个阶段才开始进入 React Server Components 呢，快开始进入下一篇吧！


## 66.源码篇 | 手写 RSC（下）

## 前言

在[《源码篇 | 手写 RSC（上）》](https://juejin.cn/book/7307859898316881957/section/7309116337833148454)中，我们实现了 React SSR 并添加了路由跳转，最终的效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f9ab7f5b56e4b1a83d1353c3846787f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=687\&h=1018\&s=157055\&e=gif\&f=53\&b=626be8" width="300">

当我们点击 `hello`链接的时候，页面从 `/`跳转到 `/hello`，两个页面都是 SSR 加载。

但理想情况下，我们想要的效果是，仅更改需要更改的地方，而其他的地方继续保持原本的状态。不过当前的例子中并无所谓“状态”，为了演示状态的保持，我们在 `<Layout>` 组件中添加一个 `<input />` 标签，修改 `components.ts`下的 `<Layout>` 组件代码：

```jsx
export function Layout({ children }) {
  const author = "YaYu";
  return (
    <html>
      <head>
        <title>My blog</title>
        <script src="https://cdn.tailwindcss.com"></script>
      </head>
      <body className="p-5">
        <nav className="flex items-center justify-center gap-10 text-blue-600">
          <a href="/">Home</a>
        </nav>
        <input required className="block w-full rounded-md border-0 px-1.5 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6" />
        <main>{children}</main>
        <Footer author={author} />
      </body>
    </html>
  );
}
```

我们先在输入框输入一些数据再点击链接跳转，交互效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37f77e50ebfb46f183a0f3340daa7840~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=686\&h=1026\&s=137349\&e=gif\&f=56\&b=626be9" width="300">

结果很容易想到，页面跳转后，输入框被重置。对于两次 SSR 来说，因为每次都是重新渲染，所以状态无法保持。

但为了更好的用户体验，我们想要的效果是，在发生页面跳转的时候，仅更改需要更改的地方，其他的地方继续保持原本的状态。也就是说，在这个例子中，输入框的内容应该继续保持不变。

那你可能会问，这不就是 CSR？如果还要控制页面跳转，这不一个就是基于 CSR 的 SPA 应用吗？

单论这个效果而言，传统 SPA 确实也能实现，RSC 也能实现，而 CSR 和 RSC 的区别就在于 CSR 组件的渲染在客户端，RSC 组件的渲染在服务端。

那用 RSC 该怎么实现呢？

## 实现思路

我们在[《源码篇 | 手写 React SSR》](https://juejin.cn/book/7307859898316881957/section/7309116396511133705)介绍过 React 的 [hydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot) 函数：

> hydrateRoot 允许您在浏览器 DOM 节点内显示 React 组件，该节点的 HTML 内容先前由 react-dom/server 生成。

简单的来就是，先通过 react-dom/server 将 JSX 渲染成 HTML，再调用 hydrateRoot 将其水合，添加事件。基本用法如下：

```javascript
import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');
const root = hydrateRoot(domNode, reactNode);
```

当调用 hydrateRoot 后就会由 React 接管 DOM，而 React 又提供了 root.render 方法来更新 DOM：

![react-rsc-4.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33314b470b9f47f19c45316bbbf0a2f4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1221\&h=541\&s=48091\&e=gif\&f=32\&b=fdfdfd)

在上图中，我们每秒都调用了一次 root.render，但输入框中的状态并未遭到破坏，这就是我们实现 React Server Component 的关键。

那我们具体该怎么实现呢？简单的来说，可以分为 3 个步骤：

1.  拦截客户端跳转，实现客户端 JS 导航
2.  导航的时候，获取目标路由的 JSX 对象
3.  客户端获取返回的 JSX 对象调用 root.render 进行重新渲染

如果这样说还是有点抽象，那就让我们直接上代码吧！

## 步骤 1：实现客户端导航

我们先拦截传统的页面跳转，将其转为客户端导航。

新建 `client.js`，代码如下：

```javascript
let currentPathname = window.location.pathname;

async function navigate(pathname) {
  currentPathname = pathname;
  // 获取导航页面的 HTML
  const response = await fetch(pathname);
  const html = await response.text();

  if (pathname === currentPathname) {
    //  获取其中的 body 标签内容
    const res = /<body(.*?)>/.exec(html);
    const bodyStartIndex = res.index + res[0].length
    const bodyEndIndex = html.lastIndexOf("</body>");
    const bodyHTML = html.slice(bodyStartIndex, bodyEndIndex);
    // 简单粗暴的直接替换 HTML
    document.body.innerHTML = bodyHTML;
  }
}

window.addEventListener("click", (e) => {
  // 忽略非 <a> 标签点击事件
  if (e.target.tagName !== "A") {
    return;
  }
  // 忽略 "open in a new tab".
  if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {
    return;
  }
  // 忽略外部链接
  const href = e.target.getAttribute("href");
  if (!href.startsWith("/")) {
    return;
  }
  // 组件浏览器重新加载页面
  e.preventDefault();
  // 但是 URL 还是要更新
  window.history.pushState(null, null, href);
  // 调用我们自己的导航逻辑
  navigate(href);
}, true);

window.addEventListener("popstate", () => {
  // 处理浏览器前进后退事件
  navigate(window.location.pathname);
});
```

在这段代码中，我们监听了 `<a>` 标签的点击事件，当发生点击的时候，调用我们自己的 navigate 函数，在 navigate 中，我们 fetch 了目标路由的 HTML，提取 `<body>`标签中内容，替换当前页面。

可是页面怎么引入这个 `client.js`呢？简单的来说，就是直接拼进去，修改 `generator.tsx`的 htmlGenerator 函数：

```javascript
export async function htmlGenerator(url) {
  let html = await renderJSXToHTML(<Router url={url} />);
  // 直接拼虽然有些错误，但浏览器会纠正，并正确解析
  html += `<script type="module" src="/client.js"></script>`;
  return html;
}
```

修改 `index.ts`，保证服务器正确返回 client.js 的内容，代码如下：

```javascript
app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // 匹配 client.js
  if (url.pathname === "/client.js") {
    const content = await readFile("./client.js", "utf8");
    res.setHeader("Content-Type", "text/javascript");
    res.end(content);
  } 
  else {
    const html = await htmlGenerator(url);
    res.setHeader("Content-Type", "text/html");
    res.end(html);
  }
});
```

此时交互效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/256c08b32a1145e4880c560b47d16361~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=693\&h=888\&s=117134\&e=gif\&f=50\&b=626be8" width="300">

因为我们是直接替换的 HTML，所以状态的保持依然没有实现，但是页面已经转为了客户端导航，当我们点击链接跳转的时候，页面并没有刷新。

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-6>
> 3. 下载代码：`git clone -b react-rsc-6 git@github.com:mqyqingfeng/next-app-demo.git`

## 步骤 2：获取客户端 JSX

按照我们的思路，当点击跳转的时候，应该获取目标路由的 JSX 对象，然后在客户端重新渲染。为了区分是获取目标路由的 HTML 还是 JSX 对象，我们可以在链接上添加一个 `jsx` 参数作为区分。

修改 `client.js`，更改 navigate 函数的代码：

```javascript
async function navigate(pathname) {
  currentPathname = pathname;
  // 添加 jsx 参数表示获取目标路由的 jsx 对象
  const response = await fetch(pathname + "?jsx");
  const jsonString = await response.text();
  if (pathname === currentPathname) {
    console.log(jsonString);
  }
}
```

修改 `index.ts`，代码如下：

```javascript
import { htmlGenerator, jsxGenerator } from "./generator";

app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  if (url.pathname === "/client.js") {
    const content = await readFile("./client.js", "utf8");
    res.setHeader("Content-Type", "text/javascript");
    res.end(content);
  }
  // 如果网址有 jsx 参数，那就说明要获取 JSX 对象，我们改为调用 jsxGenerator 函数
  else if (url.searchParams.has("jsx")) {
    url.searchParams.delete("jsx");
    const clientJSXString = await jsxGenerator(url);
    res.setHeader("Content-Type", "application/json");
    res.end(clientJSXString);
  } 
  else {
    const html = await htmlGenerator(url);
    res.setHeader("Content-Type", "text/html");
    res.end(html);
  }
});
```

在 `generator.tsx` 添加 jsxGenerator 函数，代码如下：

```javascript
export async function jsxGenerator(url) {
  let jsx = <Router url={url} />;
  // 查看服务段的打印结果
  console.dir(jsx)
  return JSON.stringify(jsx)
}
```

然而此时，当点击跳转的时候，获取目标路径的  JSX 对象，但返回的数据却不如人意：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fe4ba3f5b874abcbd9d0b955723d8be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3514\&h=1078\&s=337454\&e=png\&b=fbfafa)

我们再查看下命令行中的打印结果：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b2c5904247e4834b771717919e1ce31~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1660\&h=392\&s=55225\&e=png\&b=1e1e1e)

这里存在两个问题：

1.  我们渲染的是 `<Router url={url} />`，这个 JSX 节点是一个函数类型，只有运行这个函数才会返回最终的 JSX 对象
2.  使用 JSON.stringify 会丢失部分属性，就比如 `$$typeof: Symbol.for("react.element")`，而客户端 React 正是根据这个属性判断是否是有效的 JSX 节点

为了解决第一个问题，我们需要再写一个 renderJSXToClientJSX 函数，将 JSX 对象转为最终的 JSX 对象。修改 `utils.ts`，添加 renderJSXToClientJSX 函数，其代码如下：

```javascript
export async function renderJSXToClientJSX(jsx) {
  if (
    typeof jsx === "string" ||
    typeof jsx === "number" ||
    typeof jsx === "boolean" ||
    jsx == null
  ) {
    return jsx;
  } else if (Array.isArray(jsx)) {
    return Promise.all(jsx.map((child) => renderJSXToClientJSX(child)));
  } else if (jsx != null && typeof jsx === "object") {
    if (jsx.$$typeof === Symbol.for("react.element")) {
      if (typeof jsx.type === "string") {
        return {
          ...jsx,
          props: await renderJSXToClientJSX(jsx.props),
        };
      } else if (typeof jsx.type === "function") {
        const Component = jsx.type;
        const props = jsx.props;
        const returnedJsx = await Component(props);
        return renderJSXToClientJSX(returnedJsx);
      } else throw new Error("Not implemented.");
    } else {
      return Object.fromEntries(
        await Promise.all(
          Object.entries(jsx).map(async ([propName, value]) => [
            propName,
            await renderJSXToClientJSX(value),
          ])
        )
      );
    }
  } else throw new Error("Not implemented");
}

```

修改 `generate.ts`，引入 renderJSXToClientJSX，代码如下：

```javascript
import { renderJSXToHTML, renderJSXToClientJSX } from './utils'

export async function jsxGenerator(url) {
  let clientJSX = await renderJSXToClientJSX(<Router url={url} />);
  const clientJSXString = JSON.stringify(clientJSX);
  return clientJSXString
}
```

此时返回的结果看起来正确多了：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7462ae07dd6b4a85933b7700d9c29ec0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3632\&h=1412\&s=512064\&e=png\&b=fbfafa)

现在我们来解决第二个问题，解决的方式也很简单，那就是我们在 JSON.stringify 的时候将特殊的对象使用特殊的字符串进行替换，客户端 JSON.parse 的时候再转过来。正好 JSON.stringify 接收一个替换器函数，该函数允许我们自定义 JSON 的生成方式。在服务端，我们将 Symbol.for('react.element') 用一个特殊的字符串来替换，例如"\$RE"。

修改 `utils.ts`，添加 stringifyJSX 函数：

```javascript
export function stringifyJSX(key, value) {
  if (value === Symbol.for("react.element")) {
    // We can't pass a symbol, so pass our magic string instead.
    return "$RE"; // Could be arbitrary. I picked RE for React Element.
  } else if (typeof value === "string" && value.startsWith("$")) {
    // To avoid clashes, prepend an extra $ to any string already starting with $.
    return "$" + value;
  } else {
    return value;
  }
}
```

修改 `generator.tsx`，引入 stringifyJSX，代码如下：

```javascript

import { renderJSXToHTML, renderJSXToClientJSX, stringifyJSX } from './utils'

export async function jsxGenerator(url) {
  let clientJSX = await renderJSXToClientJSX(<Router url={url} />);
  const clientJSXString = JSON.stringify(clientJSX, stringifyJSX);
  return clientJSXString
}
```

此时我们点击链接，已经能够正常的获取客户端 JSX 对象：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461ad7ddfbc54d42b15bae63c852452c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3734\&h=1346\&s=421647\&e=png\&b=fbfaf9)

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-7>
> 3. 下载代码：`git clone -b react-rsc-7 git@github.com:mqyqingfeng/next-app-demo.git`

## 步骤 3：客户端更新

现在我们就需要在导航的时候，调用 root.render 来更新应用。

修改 `client.js`，添加代码如下：

```javascript
import { hydrateRoot } from 'react-dom/client';

let currentPathname = window.location.pathname;
const root = hydrateRoot(document, getInitialClientJSX());

function getInitialClientJSX() {
  // 暂时先返回 null
  return null
}

async function navigate(pathname) {
  currentPathname = pathname;
  const clientJSX = await fetchClientJSX(pathname);
  if (pathname === currentPathname) {
    root.render(clientJSX);
  }
}

async function fetchClientJSX(pathname) {
  const response = await fetch(pathname + "?jsx");
  const clientJSXString = await response.text();
  const clientJSX = JSON.parse(clientJSXString, parseJSX);
  return clientJSX;
}

function parseJSX(key, value) {
  if (value === "$RE") {
    return Symbol.for("react.element");
  } else if (typeof value === "string" && value.startsWith("$$")) {
    return value.slice(1);
  } else {
    return value;
  }
}
```

我们在客户端代码中引用了 react-dom/client，为了能够正常运行，我们修改 `generator.tsx` 的 htmlGenerator 函数，代码如下：

```jsx
export async function htmlGenerator(url) {
  let html = await renderJSXToHTML(<Router url={url} />);
  html += `
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"
      }
    }
  </script>
  <script type="module" src="/client.js"></script>
`;
  return html;
}
```

注：关于 `<script type="importmap">`，可以参考 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script/type/importmap)。

此时交互效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93caaa18fd204c75ad438d8faaf7a4d4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=641\&h=533\&s=92384\&e=gif\&f=62\&b=fefefe" width="300">

交互效果可以说是十分奇怪，但主要是 2 个问题：

1.  首次导航的时候，状态无法保持，后续可以正常保持
2.  导航的时候，样式丢失了

我们先解决第一个问题。这是因为我们首次水合页面的时候，并未传入当前页面的客户端 JSX 对象，导致首次水合的时候，React 的组件树其实是空的，点击跳转的时候，获取了新的组件树，因为完全不同，所以页面重新渲染，状态也没有保持。调用 root.render，React 会保留该状态，也要建立在组件树结构与之前渲染的结构匹配的基础上。所以后续导航的时候，都保持了状态。

那么如何获取当前页面的客户端 JSX 对象呢？最简单的方法就是写入到脚本代码中，然后渲染的时候直接读取。

修改 `generator.tsx`的 htmlGenerator 函数：

```javascript
export async function htmlGenerator(url) {
  let jsx = <Router url={url} />
  let html = await renderJSXToHTML(jsx);
  // 获取当前页面的客户端 JSX 对象
  const clientJSX = await renderJSXToClientJSX(jsx);
  // 拼接到脚本代码中
  const clientJSXString = JSON.stringify(clientJSX, stringifyJSX);
  html += `<script>window.__INITIAL_CLIENT_JSX_STRING__ = `;
  html += JSON.stringify(clientJSXString).replace(/</g, "\\u003c");
  html += `</script>`;
  html += `
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"
      }
    }
  </script>
  <script type="module" src="/client.js"></script>
`;
  return html;
}
```

修改 `client.js`，在水合的时候获取页面的客户端 JSX 对象：

```javascript
const root = hydrateRoot(document, getInitialClientJSX());

function getInitialClientJSX() {
  const clientJSX = JSON.parse(window.__INITIAL_CLIENT_JSX_STRING__, parseJSX);
  return clientJSX;
}
```

修改 `utils.ts`中的 renderJSXToHTML 函数，做了一点字符节点的处理，为了保持客户端和服务端渲染一致，以便进行水合：

```javascript
export async function renderJSXToHTML(jsx) {
  if (typeof jsx === "string" || typeof jsx === "number") {
    return escapeHtml(jsx);
  } else if (jsx == null || typeof jsx === "boolean") {
    return "";
  } else if (Array.isArray(jsx)) {
    const childHtmls = await Promise.all(
      jsx.map((child) => renderJSXToHTML(child))
    );
    // 字符之间拼接 "<!-- -->"
    let html = "";
    let wasTextNode = false;
    let isTextNode = false;
    for (let i = 0; i < jsx.length; i++) {
      isTextNode = typeof jsx[i] === "string" || typeof jsx[i] === "number";
      if (wasTextNode && isTextNode) {
        html += "<!-- -->";
      }
      html += childHtmls[i];
      wasTextNode = isTextNode;
    }
    return html;
    // return childHtmls.join("");
  } else if (typeof jsx === "object") {
    if (jsx.$$typeof === Symbol.for("react.element")) {
      // 普通 HTML 标签
      if (typeof jsx.type === "string") {
        let html = "<" + jsx.type;
        for (const propName in jsx.props) {
          if (jsx.props.hasOwnProperty(propName) && propName !== "children") {
            html += " ";
            html += propName;
            html += "=";
            html += `"${escapeHtml(jsx.props[propName])}"`;
          }
        }
        html += ">";
        html += await renderJSXToHTML(jsx.props.children);
        html += "</" + jsx.type + ">";
        html = html.replace(/className/g, "class")
        return html;
      }
      // 组件类型如 <BlogPostPage> 
      else if (typeof jsx.type === "function") {
        const Component = jsx.type;
        const props = jsx.props;
        const returnedJsx = await Component(props);
        return renderJSXToHTML(returnedJsx); 
      } else throw new Error("Not implemented.");
    } else throw new Error("Cannot render an object.");
  } else throw new Error("Not implemented.");
}
```

此时状态已经能够正常保持，不仅如此，页面样式也正常了：

![react-rsc-7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/835bd6bc798449648f39ebe1d3460bd8~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1519\&h=784\&s=232270\&e=gif\&f=51\&b=272727)

> 1. 功能实现：React RSC 实现
> 2. 源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-8>
> 3. 下载代码：`git clone -b react-rsc-8 git@github.com:mqyqingfeng/next-app-demo.git`

现在我们已经实现了 RSC 和状态保持，其实现的主要思路是监听客户端跳转，改为获取目标路由的客户端 JSX 对象，然后调用 root.render 进行更新，在前后组件树匹配的基础上，状态会继续保持。

不过为什么之前样式会丢失呢？这是因为我们的 tailwind.css 用的是 `<script src="https://cdn.tailwindcss.com"></script>`的方式直接引入的，它会在 `<head>` 中生成 `<style>` 标签：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df5429eaaf154b6f9e7c6a019506add1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2936\&h=558\&s=242001\&e=png\&b=2b2b2b)

之前首次导航的时候，前后组件树不匹配，React 使用新的组件树重新渲染了 DOM，导致 style 标签中的内容消失，这才丢失了样式。

## 总结

至此，我们已经实现了 RSC，想想我们的 Next.js 应用，是不是也是客户端导航，虽然 Next.js 内置 `<Link>`的标签被渲染为 `<a>`标签，但并不会触发页面重新加载，而是会获取对应页面的 RSC Payload，只不过我们的实现，获取的是目标路由的客户端 JSX 对象，而 Next.js 获取的是基于 JSX 对象生成的、对流做过特殊适配的二进制格式，但基本原理是类似的。

感谢 Dan 的这篇文章 [《RSC From Scratch. Part 1: Server Components》 ](https://github.com/reactwg/server-components/discussions/5)，其实这 2 篇实现就是参考了 Dan 的实现,用 express 和 tsx 来实现了一遍。希望对大家理解 React 和 Next.js 的 RSC 有所帮助。


## 67.源码篇 | RSC 实现原理

## 前言

在[《源码篇 | 手写 RSC（下）》](https://juejin.cn/book/7307859898316881957/section/7309116033020018697)中，我们实现了 React RSC，最终的效果如下：

![react-rsc-7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58ec60ed75da4278a424c4ba06b64ea4~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1519\&h=784\&s=232270\&e=gif\&f=51\&b=272727)

本篇并不会拓展新的功能，而是会在此基础上进行优化，并讲解 RSC 与 Next.js 实现的基本原理。

如果没有实现之前的代码，可以运行：

```javascript
# 下载指定分支的代码
git clone -b react-rsc-8 git@github.com:mqyqingfeng/next-app-demo.git
# 进入目录并安装依赖项
cd next-app-demo && npm i
# 启动
npm start
```

## 优化一：解决重复调用

查看我们的 `generator.tsx`中的 htmlGenerator 函数代码：

```javascript
export async function htmlGenerator(url) {
  let jsx = <Router url={url} />
  let html = await renderJSXToHTML(jsx);
  const clientJSX = await renderJSXToClientJSX(jsx);
  // ...
}
```

运行 renderJSXToHTML 时我们递归调用了 Router 和子组件，运行 renderJSXToClientJSX 时，我们又递归调用了 Router 和子组件，这就造成了两次重复调用，如果数据变化（比如 feeds）就会产生问题，所以最好的解决方法是使用 clientJSX 渲染最终的 HTML。修改代码如下：

```javascript
export async function htmlGenerator(url) {
  let jsx = <Router url={url} />
  const clientJSX = await renderJSXToClientJSX(jsx);
  let html = await renderJSXToHTML(clientJSX);
  // ...
}
```

## 优化二：React renderToString

我们自定义的 renderJSXToHTML 其实对应的就是 React 的 renderToString 函数，我们直接修改为使用 renderToString。修改 `generator.tsx`中的 htmlGenerator 函数代码：

```javascript
import { renderToString } from 'react-dom/server';

export async function htmlGenerator(url) {
  let jsx = <Router url={url} />
  const clientJSX = await renderJSXToClientJSX(jsx);
  let html = await renderToString(clientJSX);
  // ...
}
```

## 优化三：服务拆分

在优化一中，我们已经将组件运行和生成 HTML 解耦：

首先，renderJSXToClientJSX 生成客户端 JSX 对象，再调用 renderToString 将客户端 JSX 转换为 HTML。

因为步骤相互独立，所以我们完全可以拆分为两个服务：

*   server/rsc.js： 负责生成客户端 JSX 对象
*   server/ssr.js： 负责渲染 HTML

现在让我们开始修改代码吧。

新建 `server/rsc.ts` 和 `server.ssr.ts`，为了能够同时运行，我们安装 [concurrently](https://www.npmjs.com/package/concurrently)：

```bash
npm i concurrently
```

修改 `package.json`，代码如下：

```javascript
{
  "scripts": {
    "start": "concurrently \"npm run start:ssr\" \"npm run start:rsc\"",
    "start:rsc": "tsx watch ./server/rsc.ts",
    "start:ssr": "tsx watch ./server/ssr.ts"
  }
}

```

其中`server/rsc.ts`代码如下：

```javascript
import express from "express";
import { jsxGenerator } from "../generator";

const app = express();

app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const clientJSXString = await jsxGenerator(url);
  res.setHeader("Content-Type", "application/json");
  res.end(clientJSXString);
});

app.listen(3001, (err) => {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3001`);
});

```

`server/ssr.ts`代码如下：

```javascript
import express from "express";
import { readFile } from "fs/promises";
import { renderToString } from "react-dom/server";
import { parseJSX } from "../utils";

const app = express();

app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // client.js
  if (url.pathname === "/client.js") {
    const content = await readFile("./client.js", "utf8");
    res.setHeader("Content-Type", "text/javascript");
    res.end(content);
    return;
  }

  // 获取客户端 JSX 对象
  const response = await fetch("http://127.0.0.1:3001" + url.pathname);

  if (!response.ok) {
    res.statusCode = response.status;
    res.end();
    return;
  }

  const clientJSXString = await response.text();

  // 获取客户端 JSX 对象
  if (url.searchParams.has("jsx")) {
    res.setHeader("Content-Type", "application/json");
    res.end(clientJSXString);
  }
  // 获取 HTML
  else {
    const clientJSX = JSON.parse(clientJSXString, parseJSX);
    let html = renderToString(clientJSX);

    html += `<script>window.__INITIAL_CLIENT_JSX_STRING__ = `;
    html += JSON.stringify(clientJSXString).replace(/</g, "\\u003c");
    html += `</script>`;
    html += `
      <script type="importmap">
        {
          "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"
          }
        }
      </script>
      <script type="module" src="/client.js"></script>
    `;

    res.setHeader("Content-Type", "text/html");
    res.end(html);
  }
});

app.listen(3000, (err) => {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3000`);
});
```

`utils.js`新增 parseJSX 函数：

```javascript
export function parseJSX(key, value) {
  if (value === "$RE") {
    return Symbol.for("react.element");
  } else if (typeof value === "string" && value.startsWith("$$")) {
    return value.slice(1);
  } else {
    return value;
  }
}
```

运行 `npm start`，此时效果应该是不变的：

![react-rsc-7.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6de7d1522f8646dc8644b260cfcb57be~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1519\&h=784\&s=232270\&e=gif\&f=51\&b=272727)

## 原理解析

### 1. 原理图

现在让我们重新看下实现的原理。当页面初始加载时：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5a4c78d352a4173ab3af365cb4726e7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1346\&h=990\&s=196101\&e=png\&b=ffffff)

当用户访问 `/` 的时候，请求首先会到 SSR server 上，然后 SSR server 请求 RSC server，RSC server 返回 `/`的 React 树，SSR server 获取到 React 树后，会根据 React 树渲染 HTML，最后将 HMTL 返回给用户。

当后续发生导航时：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72b6f1e0b01b4666b3a5f44581994c3b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1454\&h=992\&s=221823\&e=png\&b=ffffff)

当用户发生导航行为时，客户端会拦截浏览器的默认跳转，改为客户端请求目标路径的数据。请求首先会到 SSR server，SSR server 根据其中的 ?jsx 参数判断出是获取客户端 JSX 对象，然后请求 RSC server，SC server 返回 `/`的 React 树，SSR server 获取到 React 树后，将 React 树返回给客户端，客户端根据 React 树修改 DOM。

### 2. 理解 Next.js 组件渲染原理

理解这个过程，有助于我们学习 Next.js。比如我们在 [《渲染篇 | 服务端组件和客户端组件》](https://juejin.cn/book/7307859898316881957/section/7309076661532622885#heading-12)讲到组件的渲染原理时：

在服务端：

Next.js 使用 React API 编排渲染，渲染工作会根据路由和 Suspense 拆分成多个块（chunks），每个块分两步进行渲染：

1.  React 将服务端组件渲染成一个特殊的数据格式称为 **React Server Component Payload (RSC Payload)**
2.  Next.js 使用 RSC Payload 和客户端组件代码在服务端渲染 HTML

> RSC payload 中包含如下这些信息：
>
> 1.  服务端组件的渲染结果
> 2.  客户端组件占位符和引用文件
> 3.  从服务端组件传给客户端组件的数据

在客户端：

1.  加载渲染的 HTML 快速展示一个非交互界面（Non-interactive UI）
2.  RSC Payload 会被用于协调（reconcile）客户端和服务端组件树，并更新 DOM
3.  JavaScript 代码被用于水合客户端组件，使应用程序具有交互性（Interactive UI）

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8e343dc5c2c455596a8c3bd00e569cf~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1570\&h=854\&s=820753\&e=png\&b=111415#id=qIm8c\&originalType=binary\&ratio=1\&rotation=0\&showTitle=false\&status=done\&style=none\&title=)

你会发现，这个架构设计其实十分类似。不过目前客户端组件的实现还没有讲到，但单看服务端组件的部分，是不是对 Next.js 的实现有了更多的理解了？

### 3. 理解 Next.js 缓存机制

此外，我们在[《缓存篇 | Caching（上）》](https://juejin.cn/editor/book/7307859898316881957/section/7309077169735958565)时讲到 Next.js 中的四种缓存机制：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/123d757f5a07412185ba6bc69d5bc395~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1600\&h=1179\&s=374811\&e=png\&b=0d0d0d)

现在再看其中的 RenderToPayload 和 RenderToHTML 是不是似曾相识？

按照我们目前的实现方式，所谓“全路由缓存”，就是在服务端缓存目标路由的客户端 JSX 对象和 HTML。

在后续导航的时候，目标路由的客户端 JSX 对象会发送给客户端，客户端根据这个客户端 JSX 对象进行更新，所谓“路由缓存”，其实就是将返回的客户端 JSX 对象缓存在浏览器中。

现在让我们顺手实现一下“路由缓存”。修改 `client.js`，代码如下：

```javascript
import { hydrateRoot } from 'react-dom/client';

let currentPathname = window.location.pathname;
const root = hydrateRoot(document, getInitialClientJSX());

// 客户端路由缓存
let clientJSXCache = {}
clientJSXCache[currentPathname] = getInitialClientJSX()

function getInitialClientJSX() {
  const clientJSX = JSON.parse(window.__INITIAL_CLIENT_JSX_STRING__, parseJSX);
  return clientJSX;
}

async function navigate(pathname) {
  currentPathname = pathname;

  if (clientJSXCache[pathname]) {
    root.render(clientJSXCache[pathname])
    return
  } else {
    const clientJSX = await fetchClientJSX(pathname);
    clientJSXCache[pathname] = clientJSX
    if (pathname === currentPathname) {
      root.render(clientJSX);
    }
  }
}

// 其他保持不变
```

实现并不复杂。页面初始加载的时候，将页面的客户端 JSX 对象保存在缓存中。导航的时候，如果没有命中缓存，则触发请求，然后将返回的结果保存在缓存中，如果命中缓存，则直接缓存中的数据。

效果如下：

![react-rsc-12.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b71937998054443bc68aadbd00ebb86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606\&h=1015\&s=325073\&e=gif\&f=77\&b=fafafa)

因为有了客户端路由缓存，所以只会触发一次 `earth?jsx`和 `hello?jsx`请求，后续点击的时候，使用的都是缓存中的数据。

现在是不是对 Next.js 的缓存有了更加深入的理解了？

> 1. 功能实现：优化了 RSC 实现和实现客户端路由缓存
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-9>
> 3.  下载代码：`git clone -b react-rsc-9 git@github.com:mqyqingfeng/next-app-demo.git`


## 68.源码篇 | 实现 Streaming

## 前言

在[《 源码篇 | RSC 实现原理》](https://juejin.cn/book/7307859898316881957/section/7309115864737611827)中，我们优化了 React RSC 的实现，最终的效果如下：

![react-rsc-12.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d98817c58b744efa83bd9da9dc28d2f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606\&h=1015\&s=325073\&e=gif\&f=77\&b=fafafa)

导航的时候，其实获取的是目标页面的 JSX 对象，但在 Next.js 中，返回的其实是针对流进行过优化的特殊格式，我们称之为 RSC Payload，效果如下：

![截屏2024-04-16 15.49.37.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da1954ff6701460d97d007212800bb2a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=4366\&h=1432\&s=619356\&e=png\&b=fcfbfb)

此外 Next.js 也支持 `<Suspense>` 组件：

```jsx
import { Suspense } from 'react'

const sleep = ms => new Promise(r => setTimeout(r, ms));

async function PostFeed() {
  await sleep(2000)
  return <h1>Hello PostFeed</h1>
}

export default function Dashboard() {
  return (
    <section>
      <Suspense fallback={<p>Loading PostFeed Component</p>}>
        <PostFeed />
      </Suspense>
    </section>
  )
}
```

但目前我们的实现并不支持 Suspense 组件，因为我们使用自定义的 renderJSXToClientJSX 获取页面 JSX 对象时，并不支持识别 Suspense 组件。

本篇我们会在[《 源码篇 | RSC 实现原理》](https://juejin.cn/book/7307859898316881957/section/7309115864737611827)的实现基础上，实现 Streaming 并且支持 `<Suspense>` 组件。如果没有实现之前的代码，可以运行：

```javascript
# 下载指定分支的代码
git clone -b react-rsc-9 git@github.com:mqyqingfeng/next-app-demo.git
# 进入目录并安装依赖项
cd next-app-demo && npm i
# 启动
npm start
```

## 实现思路

该如何实现 Streaming 效果呢？

其实 React 提供了 [react-server-dom-webpack](https://www.npmjs.com/package/react-server-dom-webpack?activeTab=readme) 用于处理 RSC，尽管它现在都没有正式的介绍，查看 [GitHub 仓库](https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack)，也只有简短的说明：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b4d50859ee445f86834a027f397ce1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1866\&h=376\&s=63394\&e=png\&b=ffffff)

其中 Flight 是 RSC 的代号，简单来说，就是该功能还在实验中，使用 Webpack 用于 RSC DOM 绑定，可以自己玩着玩，但不能用于生产……

虽然介绍很少，但在 [React Flight](https://github.com/facebook/react/blob/734956ace6450bc0c95d8d749dee74f4a140597b/fixtures/flight/src/index.js#L4) 以及 [server-components-demo](https://github.com/reactjs/server-components-demo/blob/main/server/api.server.js) 都可以看到它的身影。而我们今天的实现也要用到 react-server-dom-webpack，所以我们先介绍一下它的基本用法（以下都是我摸索出来的，最终用法还尚未确定）。

当在服务端使用的时候：

```javascript
import { renderToPipeableStream } from "react-server-dom-webpack/server.node"

app.get("/", async (req, res) => {
  const { pipe } = renderToPipeableStream(<App />);
  pipe(res);
});
```

它会将组件渲染成下图这种流格式：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c15cb01077e4403ab166d6ffec04a86~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3858\&h=868\&s=426399\&e=png\&b=fefefe)

而在客户端使用的时候，如果是在浏览器环境：

```javascript
import { createFromFetch } from "react-server-dom-webpack/client"

let data = createFromFetch(
  fetch(currentPathname + '?jsx')
)
```

data 是一个包含页面 JSX 对象的 Promise，你可以这样读取其中的值：

```javascript
data.then((jsx) => {
  hydrateRoot(document, jsx)
})
```

但为了优雅一点，可以结合 React 的 [use hook](https://react.dev/reference/react/use#) 来使用：

```javascript
function Shell({ data }) {
  const [root, setRoot] = useState(use(data))
  return root
}

hydrateRoot(document, React.createElement(Shell, { data }))
```

这里我们构建了一个空壳 Shell 组件，并将 JSX 对象设置为状态，这样当调用 setRoot 的时候，页面内容就会更新。

如果是在 Node 环境（就比如 SSR Server）：

```javascript
import { createFromNodeStream } from "react-server-dom-webpack/client"

const root = await createFromNodeStream(stream, {})
```

root 最终是页面的 JSX 对象。因为是流，可以结合 react-dom/server 的 [renderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream) 来使用：

```javascript
app.get("/", async (req, res) => {
  const { pipe } = renderToPipeableStream(root)
  pipe(res)
});
```

让我们再回顾下之前的实现方案：

页面首次加载时，RSC Server 负责生成页面的 JSX 对象，SSR Server 负责生成 HTML，页面 client.js 调用 `hydrateRoot(document, getInitialClientJSX())`水合页面。在后续导航时，获取目标页面的 JSX 对象，调用 `root.render(clientJSX)` 进行更新。

但是鉴于 react-server-dom-webpack 的特殊使用方式，新的实现方案为：

页面首次加载时，RSC Server 负责生成页面的 RSC Payload，SSR Server 负责生成 HTML，页面 client.js 调用`createFromFetch()`获取页面 JSX 对象，调用 `hydrateRoot(document, jsx)`水合页面。在后续导航时，依然用 createFromFetch 获取目标页面 JSX 对象，借助空壳 Shell 组件的更新状态函数，实现页面更新。

其核心代码实现是：

```javascript
// fetch 返回的是页面的 RSC Payload，createFromFetch 返回的是包含页面 JSX 对象的 Promise
let data = createFromFetch(fetch(currentPathname + '?jsx'))

let updateRoot

function Shell({ data }) {
  // 使用 use(data) 读取页面 JSX 对象
  const [root, setRoot] = useState(use(data))
  updateRoot = setRoot
  return root
}

// 首次加载的时候使用页面的 JSX 对象水合页面
hydrateRoot(document, React.createElement(Shell, { data }))

// 后续导航时更新状态
async function navigate(pathname) {
  const root = await createFromFetch(fetch(pathname + '?jsx'))
  updateRoot(root)
}
```

如果你还不理解，没有关系，我们边写边理解吧！

## Step1：实现 RSC Payload

首先安装依赖，为了保持与 React、React DOM 与 react-server-dom-webpack 版本一致，我们统一使用 `18.3.0-canary-c3048aab4-20240326` 这个版本：

```javascript
npm i react@18.3.0-canary-c3048aab4-20240326 react-dom@18.3.0-canary-c3048aab4-20240326 react-server-dom-webpack@18.3.0-canary-c3048aab4-20240326
```

注：为什么使用这个版本呢？翻看 react-server-dom-webpack npm 的[版本记录](https://www.npmjs.com/package/react-server-dom-webpack?activeTab=versions)，这是 18.3.0 版本最新的一版。下一版本就是 19.0.0 了，鉴于 React 的最新版本才 18.2.0，我们继续使用 v18。

修改 `generator.tsx`，代码如下：

```javascript
import { renderToPipeableStream } from "react-server-dom-webpack/server.node"

// 注意是普通函数，而非 async 函数
export function jsxGenerator(url) {
  return renderToPipeableStream(<Router url={url} />)
}
```

修改 `server/rsc.ts`，代码如下：

```javascript
app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const { pipe } = jsxGenerator(url);
  pipe(res)
});
```

此时我们就完成了 RSC 组件的流式渲染。但命令行会出现报错：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a483f88806a44bccbf4605ad64e7a13c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2382\&h=250\&s=109585\&e=png\&b=1f1f1f)

这是因为 React Server Components 需要 `react-server` condition（关于 condition，参考 [Node 官方文档](https://nodejs.org/api/cli.html#-c-condition---conditionscondition)）。

我们修改 `package.json`，代码如下：

```javascript
{
  "scripts": {
    "start": "concurrently \"npm run start:ssr\" \"npm run start:rsc\"",
    "start:rsc": "tsx watch --conditions=react-server ./server/rsc.ts",
    "start:ssr": "tsx watch ./server/ssr.ts"
  }
}

```

运行 `npm start`，你会发现此时还是有报错，页面也是空白。但是没有关系，我们慢慢解决，访问 <http://localhost:3001/hello>，也就是直接访问 RSC 服务，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5eba44e5a1d417d9e65825058a455d6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3858\&h=868\&s=426399\&e=png\&b=fefefe)

借助 react-server-dom-webpack，我们已经将 React Server Component 渲染成流的格式，但是 SSR Server 和客户端还不能做正确的解析，所以出现了错误。

## Step2：服务端解析 RSC Payload

SSR Server 该如何解析返回的 RSC Payload 呢？

其实在实现思路一节已经讲过了，借助 createFromNodeStream 和 renderToPipeableStream。首先安装 [node-fetch](https://www.npmjs.com/package/node-fetch) 这个包：

```javascript
npm i node-fetch
```

这是因为我们使用的毕竟是 react-server-dom-webpack 的 createFromNodeStream，既然是 NodeStream，自然是要用 Node 的 Stream。

修改 `server/ssr.js`，代码如下：

```javascript
import express from "express";
import { readFile } from "fs/promises";
import fetch from 'node-fetch';
import { renderToPipeableStream } from "react-dom/server"
import { createFromNodeStream } from "react-server-dom-webpack/client"

const app = express();

app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // client.js
  if (url.pathname === "/client.js") {
    const content = await readFile("./client.js", "utf8");
    res.setHeader("Content-Type", "text/javascript");
    res.end(content);
    return;
  }

  const response = await fetch("http://127.0.0.1:3001" + url.pathname);

  if (!response.ok) {
    res.statusCode = response.status;
    res.end();
    return;
  }
  const stream = response.body;

  // 获取客户端 JSX 对象
  if (url.searchParams.has("jsx")) {
    res.set("Content-type", "text/x-component")
    stream.on("data", (data) => {
      res.write(data)
    })
    stream.on("end", (data) => {
      res.end()
    })
  }
  // 获取 HTML
  else {
    const root = await createFromNodeStream(stream, {})
    res.set("Content-type", "text/html")
    const { pipe } = renderToPipeableStream(root)
    pipe(res)
  }
});

app.listen(3000, (err) => {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3000`);
});

```

fetch 的 response.body 会返回一个 Stream，createFromNodeStream 传入的便是这个 Steam，最终返回的 root 是页面的 JSX 对象，我们有调用了 renderToPipeableStream 将其渲染为流式 HTML。

此时访问 <http://localhost:3000/>，页面已经可以正常渲染：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08029f02a31b44c9b8f2c2772f4655a2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3922\&h=2038\&s=447600\&e=png\&b=fbfaf9)

尽管页面正常渲染，但注意这里，页面的请求数量只有 3 个，没有 `client.js`，也没有 react 相关的 JS。

这是因为以前我们是在将 clientJSX 渲染成 HTML 后再拼接的 HTML，但是这里我们直接返回了渲染结果，所以没有机会写入 client.js。

此外，访问 <http://localhost:3000/?jsx>，效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2e0ff40742843b7abb1ec5d335d2391~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3668\&h=960\&s=555683\&e=png\&b=fbfafa)

你可以发现，无论是 `/`的 Transfer-Encoding 响应头还是 `/?jsx` 的 Transfer-Encoding 响应头都是 chunked。这说明 HTML 和 RSC Payload 都已经实现了 Streaming。

## Step3：客户端解析 RSC Payload

回到刚才的问题，如何引入 client.js 呢？

我们可以改为在 components.tsx 的 `<Layout>`中引入，修改 `components.tsx`，代码如下：

```javascript
const importMap = `{
  "imports": {
    "react": "https://esm.sh/react@18.3.0-canary-c3048aab4-20240326?dev",
        "react-dom/client": "https://esm.sh/react-dom@18.3.0-canary-c3048aab4-20240326/client?dev",
        "react-server-dom-webpack": "https://esm.sh/react-server-dom-webpack@18.3.0-canary-c3048aab4-20240326/client?dev"
  }
}`

export function Layout({ children }) {
  const author = "YaYu";
  return (
    <html>
    <head>
      <title>My blog</title>
      <script src="https://cdn.tailwindcss.com"></script>
      <script dangerouslySetInnerHTML={{ __html: `window.__webpack_require__ = async (id) => {
          return import(id)
        }` }}>
      </script>
      <script
          type="importmap"
          dangerouslySetInnerHTML={{ __html: importMap }}
      ></script>
      <script type="module" src="/client.js"></script>
    </head>
    <body className="p-5">
      <nav className="flex items-center justify-center gap-10 text-blue-600">
        <a href="/">Home</a>
      </nav>
      <input required className="block w-full rounded-md border-0 px-1.5 py-1.5 text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 placeholder:text-gray-400 focus:ring-2 focus:ring-inset focus:ring-indigo-600 sm:text-sm sm:leading-6" />
      <main>{children}</main>
      <Footer author={author} />
    </body>
  </html>
  );
}
```

修改 `client.js`，完整代码如下：

```javascript
import * as React from "react"
import { use, useState, startTransition } from "react"
import { createFromFetch } from "react-server-dom-webpack"
import { hydrateRoot } from 'react-dom/client';

// 客户端路由缓存
let clientJSXCache = {}
let currentPathname = window.location.pathname
let updateRoot

function Shell({ data }) {
  console.log("Shell", data)
  const [root, setRoot] = useState(use(data))
  clientJSXCache[currentPathname] = root
  updateRoot = setRoot
  return root
}

let data = createFromFetch(
  fetch(currentPathname + '?jsx')
)

hydrateRoot(document, React.createElement(Shell, { data }))

async function navigate(pathname) {
  currentPathname = pathname;
  if (clientJSXCache[pathname]) {
    updateRoot(clientJSXCache[pathname])
    return
  } else {
    const response = fetch(pathname + '?jsx')
    const root = await createFromFetch(response)
    clientJSXCache[pathname] = root
    startTransition(() => {
      updateRoot(root)
    })
  }
}

window.addEventListener("click", (e) => {
  // 忽略非 <a> 标签点击事件
  if (e.target.tagName !== "A") {
    return;
  }
  // 忽略 "open in a new tab".
  if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {
    return;
  }
  // 忽略外部链接
  const href = e.target.getAttribute("href");
  if (!href.startsWith("/")) {
    return;
  }
  // 组件浏览器重新加载页面
  e.preventDefault();
  // 但是 URL 还是要更新
  window.history.pushState(null, null, href);
  // 调用我们自己的导航逻辑
  navigate(href);
}, true);

window.addEventListener("popstate", () => {
  // 处理浏览器前进后退事件
  navigate(window.location.pathname);
});
```

此时页面已经可以正常运行：

![react-rsc-13.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9a70d464c774e5dbc48ae990a688da2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606\&h=1015\&s=333179\&e=gif\&f=59\&b=fafafa)

现在 Suspense 组件也能正常使用了，修改 `components.tsx`，代码如下：

```javascript
import React, { Suspense } from 'react';
const sleep = ms => new Promise(r => setTimeout(r, ms));

export async function IndexPage() {
  const files = await readdir("./posts");
  const slugs = files.map((file) =>
    file.slice(0, file.lastIndexOf("."))
  );

  return (
    <section>
      <h1>Blog List:</h1>
      <div>
        {slugs.map((slug, index) => (
          <Suspense key={index} fallback={<p>Loading Post...</p>}>
            <Post slug={slug} />
          </Suspense>
        ))}
      </div>
    </section>
  );
}

export function PostPage({ slug }) {
  return (
    <Suspense fallback={<p>Loading Post...</p>}>
      <Post slug={slug} />
    </Suspense>
  );
}

async function Post({ slug }) {
  let content = await readFile("./posts/" + slug + ".txt", "utf8");
  await sleep(2000)
  return (
    <section>
      <a className="text-blue-600" href={"/" + slug}>{slug}</a>
      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>
    </section>
  )
}
```

为了让效果明显，我们为 Post 组件添加了 2s 的延时，并在 IndexPage 和 PostPage 中使用了 Suspense。

最终的交互效果如下：

![react-rsc-14.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf7b532018104bda82b61ff7908e23d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1606\&h=1015\&s=501487\&e=gif\&f=91\&b=fafafa)

> 1.  功能实现：Streaming 与 Suspense
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-10>
> 3.  下载代码：`git clone -b react-rsc-10 git@github.com:mqyqingfeng/next-app-demo.git`

## 参考链接

1.  <https://github.com/facebook/react/tree/main/packages/react-server-dom-webpack>
2.  <https://timtech.blog/posts/react-server-components-rsc-no-framework/>
3.  <https://react.dev/reference/react-dom/server/renderToPipeableStream>


## 69.源码篇 | 实现 Server Actions

## 前言

本篇我们会在 [《源码篇 | 实现 Streaming》](https://juejin.cn/book/7307859898316881957/section/7309115240284127283)的基础上，实现 Server Actions 功能。

如果没有实现之前的代码，可以运行：

```javascript
# 下载指定分支的代码
git clone -b react-rsc-10 git@github.com:mqyqingfeng/next-app-demo.git
# 进入目录并安装依赖项
cd next-app-demo && npm i
# 启动
npm start
```

为了演示 Server Actions 的效果，我们将以实现博客评论功能为例。

在具体技术实现上，我们将使用 `<form>` 实现评论框，评论内容储存在 JSON 文件中。此外我们会拓展 client.js 中的逻辑以拦截表单提交，防止提交数据的时候，页面重新加载。

简单来说就是，form 表单提交后，页面无刷新，评论列表立刻更新。就像我们使用 Next.js 实现的效果一样。具体效果如下：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d64a79d94cd491f9fd2b8b597079b2c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=603\&h=961\&s=66492\&e=gif\&f=33\&b=fefefe" width="300">

## Step1：实现正常表单提交

我们先实现正常的表单提交，也就是使用 `<form>` 的 action 属性进行提交。

先添加表单和评论列表组件，修改`components.tsx`，添加如下代码：

```jsx
export function PostPage({ slug }) {
  return (
    <Suspense fallback={<p>Loading Post...</p>}>
      <Post slug={slug} />
      <CommentForm slug={slug} />
      <CommentList slug={slug} />
    </Suspense>
  );
}

async function CommentForm({ slug }) {
  return (
    <form id="form" method="POST" action="/actions/comment" className="my-6 flex max-w-md gap-x-4 mx-auto">
      <input
        name="comment"
        required
        className="min-w-0 flex-auto rounded-md border-0 bg-white/5 px-3.5 py-2 text-black shadow-sm ring-1 ring-inset ring-white/10 focus:ring-2 focus:ring-inset focus:ring-indigo-500 sm:text-sm sm:leading-6"
        placeholder="Enter your Comment"
        />
      <input type="hidden" name="slug" value={slug} />
      <button
        type="submit"
        className="flex-none rounded-md bg-indigo-500 px-3.5 py-2.5 text-sm font-semibold text-white shadow-sm hover:bg-indigo-400 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-500"
        >
        Submit
      </button>
    </form>
  )
}

async function CommentList({ slug }) {
  let comments
  try {
    const commentsData = await readFile("./comments/" + slug + ".json", "utf8")
    comments = JSON.parse(commentsData)
  } catch (err) {
    comments = []
  }

  return (
    <div>
      <h2>Comments:</h2>
      <div className='divide-y divide-gray-100'>
        {comments.map((comment, i) => {
      return (
        <div key={i} className="px-4 py-6 sm:grid sm:grid-cols-3 sm:gap-4 sm:px-0">
          <div className="text-sm font-medium leading-6 text-gray-900">Floor {i+1}</div>
          <div className="mt-1 text-sm leading-6 text-gray-700 sm:col-span-2 sm:mt-0">{comment.content}</div>
        </div>
      )
    })}
      </div>
    </div>
  )
}
```

代码并不复杂，修改了 `<PostPage>`组件，新增了 `<CommentForm>` 和 `<CommentList>`组件。在 `<CommentForm>` 中，我们将表单数据提交到 `/actions/comment`，表示这是一个 Server Action，提交的数据有两个字段，其中 comment 字段表示具体评论的内容，slug 字段表示具体是哪篇文章的评论。

我们来实现下 `/actions/comment`请求处理，为了更便捷的处理表单提交数据，我们引入 body-parser，这是 Express 处理 body 非常常用的一个库。运行：

```bash
npm i body-parser
```

修改 `server/ssr.ts`，完整代码如下：

```javascript
import express from "express";
import { readFile } from "fs/promises";
import fetch from 'node-fetch';
import { renderToPipeableStream } from "react-dom/server"
import { createFromNodeStream } from "react-server-dom-webpack/client"
import bodyParser from 'body-parser';
import { serverAction }  from "../actions";

const app = express();
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: false }))

app.get("/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  // client.js
  if (url.pathname === "/client.js") {
    const content = await readFile("./client.js", "utf8");
    res.setHeader("Content-Type", "text/javascript");
    res.end(content);
    return;
  }

  const response = await fetch("http://127.0.0.1:3001" + url.pathname);

  if (!response.ok) {
    res.statusCode = response.status;
    res.end();
    return;
  }
  const stream = response.body;

  // 获取客户端 JSX 对象
  if (url.searchParams.has("jsx")) {
    res.set("Content-type", "text/x-component")
    stream.on("data", (data) => {
      res.write(data)
    })
    stream.on("end", (data) => {
      res.end()
    })
  }
  // 获取 HTML
  else {
    const root = await createFromNodeStream(stream, {})
    res.set("Content-type", "text/html")
    const { pipe } = renderToPipeableStream(root)
    pipe(res)
  }
});

app.post("/actions/:route(*)", async (req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  if (url.pathname.startsWith("/actions/")) {
    await serverAction(req, res)
  }
});

app.listen(3000, (err) => {
  if (err) return console.error(err);
  return console.log(`Server is listening on 3000`);
});
```

Next.js 中的 Server Actions 只支持 POST 请求，所以我们也写在 POST 请求上。如果请求以 `/actions`开头，并且是 POST 请求，我们就调用 serverAction 方法。

新建 `actions.ts`，写入具体的 serverAction 函数：

```javascript
export async function serverAction(req, res) {
  const action = req.url.slice(9)

  const module = await import("./actions/" + action + ".js")
  const actionFunction = module.default
  await actionFunction(req, res)

  res.redirect(302, "/" + req.body.slug)
}
```

我们使用 Next.js Server Actions 的时候，往往会新建一个 `actions.js`，然后在其中写入具体的逻辑处理，换句话说，具体处理的逻辑由用户定义。这里我们也是交给用户来定义，如果请求的是 `/actions/comment` 对应的处理代码就在 `/actions/comment.js`中。

新建 `actions/comment.ts`，代码如下：

```javascript
import { readFile, writeFile } from "fs/promises"

export default async function handleCommentPost(req, res) {
  const {slug, comment} = req.body

  let comments

  try {
    const commentsData = await readFile("./comments/" + slug + ".json", "utf8")
    comments = JSON.parse(commentsData)
  } catch (err) {
    if (err.code === "ENOENT") {
      comments = []
    } else {
      throw err
    }
  }

  comments.push({
    content: comment
  })
  
  const commentsFile = "./comments/" + slug + ".json"
  await writeFile(commentsFile, JSON.stringify(comments, null, 2))
}
```

处理的代码并不复杂，读取保存数据的 json 文件，然后写入新的数据。目前还没有建立 json 文件，\*\*我们先新建 \*\*`**comments**`**文件夹，防止出现读取错误**。

此时涉及到的文件目录结构如下：

```javascript
next-app-demo         
├─ actions            
│  └─ comment.ts   
├─ comments                
├─ server             
│  ├─ rsc.ts          
│  └─ ssr.ts          
├─ actions.ts          
├─ components.tsx         
```

在 `actions.ts`中，最后我们调用了 `res.redirect`返回之前的页面。

此时交互效果如下：

![react-rsc-15.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a7824f7f06149aebd57ff82ed70d811~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1396\&h=968\&s=510411\&e=gif\&f=35\&b=f9f9f9)

表单数据成功提交和渲染。其实现逻辑是，Form 表单数据提交到 `/actions/comment`，对应读取 `/actions/comment.js`文件进行处理，然后重定向回到之前的页面，页面重新加载，评论列表数据更新。

因为我们用的是 form 的 action 提交的数据，所以即使禁用 JavaScript，表单也是可以成功提交的。禁用 JavaScript 的效果如下：

![react-rsc-10.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b872250515944bc293595c09acb6fa94~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1599\&h=934\&s=154352\&e=gif\&f=48\&b=fdfdfd)

注：这里的演示，我们删除了 Suspense 组件，因为 Suspense 需要依赖 JS，在获得数据后，更新 DOM 节点。此外因为我们的 tailwind.css 是通过 `<script>`标签引入的，所以禁用 JavaScript 时，样式失效。但是表单依然可以正常提交。

## Step2: 客户端拦截表单提交

但是在 Next.js 中，使用 Server Action 提交表单，页面是不会刷新的。这是因为客户端拦截了表单提交。

修改 `client.js`，添加如下代码：

```javascript
window.addEventListener("submit", async (e) => {
  const action = e.target.action
  const actionURL = new URL(action, window.location.origin)

  if (!actionURL.pathname.startsWith("/actions/")) {
    return
  }

  e.preventDefault()

  if (e.target.method === "post") {
    const formData = new FormData(e.target)
    const body = Object.fromEntries(formData.entries())
    const response = await fetch(action, {
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
      },
    })

    if (!response.ok) return
    navigate(window.location.pathname, true)
    return
  } else {
    console.error("unknown method", e.target.method)
  }
})
```

这段代码逻辑并不复杂，首先是阻止表单提交，然后是以 POST 请求调用 `/actions/comment`，具体返回的数据我们并未处理，主要是触发对应 `/actions/comment.ts`代码的执行，最后调用 navigate 函数重新渲染页面。交互效果如下：

![react-rsc-16.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9278db4806b94d18a45488c2a5b1ea72~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1276\&h=931\&s=107898\&e=gif\&f=28\&b=fcfbfc)

你会发现，很奇怪，评论并没有更新。按理说，提交的时候应该有 3 个请求产生，首先是 `/actions/comment`请求，由客户端触发，`actions.ts`代码重定向到原页面，于是触发了第 2 个 `earth` 请求，客户端同时执行了 `naviagte` 函数，触发第三个 `/earth?jsx`请求。

但是现在只有 2 个请求，没有第 3 个 `/earth?jsx`请求。这是因为我们在之前的实现中实现了客户端路由缓存，所以用了缓存中的数据。

继续修改 `client.js`，代码如下：

```javascript
async function navigate(pathname, revalidate) {
  currentPathname = pathname;
  if (!revalidate && clientJSXCache[pathname]) {
    updateRoot(clientJSXCache[pathname])
    return
  } else {
    const response = fetch(pathname + '?jsx')
    const root = await createFromFetch(response)
    clientJSXCache[pathname] = root
    startTransition(() => {
      updateRoot(root)
    })
  }
}
```

我们添加了一个 revalidate 变量，当为 true 的时候，不读取缓存，重新请求。此时页面正常运行：

![react-rsc-17.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/076c967f649d428da4f09ba67d498cf0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1276\&h=931\&s=174683\&e=gif\&f=38\&b=fcfbfc)

注：提交的时候之所以会有卡顿感，是因为我们为文章添加了 2s 延迟。

想想 [《缓存篇 | Caching（下）》](https://juejin.cn/book/7307859898316881957/section/7344650215729430565#heading-6)中，我们讲到客户端路由缓存的失效方式：

> 有两种方法可以让路由缓存失效：
>
> 1.  在 Server Action 中
>     1.  通过 revalidatePath 或 revalidateTag 重新验证数据
>     2.  使用 cookies.set 或者 cookies.delete 会使路由缓存失效，这是为了防止使用 cookie 的路由过时（如身份验证）
> 2.  调用 router.refresh 会使路由缓存失效并发起一个重新获取当前路由的请求

我们这里的实现就是一个简易的 Server Action revalidate  功能。

> 1.  功能实现：Server Action
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-11>
> 3.  下载代码：`git clone -b react-rsc-11 git@github.com:mqyqingfeng/next-app-demo.git`

## 总结

至此，我们的 Server Actions 功能就实现了，其实跟 Next.js 的实现有很大的差别。

在 Next.js 中，Server Actions 的请求是以 POST 请求提交到当前页面的 URL，提交的时候会携带 \$ACTION\_ID 以区分不同的 Server Action。同时 Next.js 会在这一次请求中返回所有需要的信息，然后更新状态，不像我们这般简单粗暴的重新请求。

但原理是类似的，希望这个简单的 Server Actions 实现对大家理解 Next.js 的实现有所帮助。


## 7.路由篇 | 中间件

## 前言

中间件（Middleware），一个听起来就很高级、很强大的功能。实际上也确实如此。使用中间件，你可以拦截并控制应用里的所有请求和响应。

比如你可以基于传入的请求，重写、重定向、修改请求或响应头、甚至直接响应内容。一个比较常见的应用就是鉴权，在打开页面渲染具体的内容前，先判断用户是否登录，如果未登录，则跳转到登录页面。

## 定义

写中间件，你需要在项目的根目录定义一个名为 `middleware.js`的文件：

```javascript
// middleware.js
import { NextResponse } from 'next/server'
 
// 中间件可以是 async 函数，如果使用了 await
export function middleware(request) {
  return NextResponse.redirect(new URL('/home', request.url))
}

// 设置匹配路径
export const config = {
  matcher: '/about/:path*',
}
```

注意：这里说的项目根目录指的是和 `pages` 或 `app` 同级。但如果项目用了 `src`目录，则放在 `src`下。

在这个例子中，我们通过 `config.matcher`设置中间件生效的路径，在 `middleware`函数中设置中间件的逻辑，作用是将 `/about`、`/about/xxx`、`/about/xxx/xxx` 这样的的地址统一重定向到 `/home`，效果如下：

![middleware.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdca5873307f494b88c091513c81d072~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720\&h=154\&s=25085\&e=gif\&f=17\&b=ffffff)

## 设置匹配路径

了解了大致用途，现在让我们看下具体用法。

先说说如何设置匹配路径。有两种方式可以指定中间件匹配的路径。

### matcher 配置项

第一种是使用 `matcher`配置项，示例代码如下：

```javascript
export const config = {
  matcher: '/about/:path*',
}
```

`matcher` 不仅支持字符串形式，也支持数组形式，用于匹配多个路径：

```javascript
export const config = {
  matcher: ['/about/:path*', '/dashboard/:path*'],
}
```

初次接触的同学可能会对 `:path*` 这样的用法感到奇怪，这个用法来自于  [path-to-regexp](https://github.com/pillarjs/path-to-regexp) 这个库，它的作用就是将 `/user/:name`这样的路径字符串转换为正则表达式。Next.js 背后用的正是 path-to-regexp 解析地址。作为一个有着十年历史的开源库，path-to-regexp 还被 express、react-router、vue-router 等多个知名库引用。所以不妨让我们多多了解一下。

path-to-regexp 通过在参数名前加一个冒号来定义**命名参数**（Named Parameters），matcher 支持命名参数，比如 `/about/:path`匹配 `/about/a`和 `/about/b`，但是不匹配 `/about/a/c`

注：实际测试的时候，`/about/:path` 并不能匹配 `/about/xxx`，只能匹配 `/about`，如果要匹配 `/about/xxx`，需要写成 `/about/:path/`

命名参数的默认匹配逻辑是 `[^/]+`，但你也可以在命名参数后加一个括号，在其中自定义命名参数的匹配逻辑，比如 `/about/icon-:foo(\\d+).png` 匹配 `/about/icon-1.png`，但不匹配 `/about/icon-a.png`。

命名参数可以使用修饰符，其中 `*` 表示 0 个或 1 个或多个，`?`表示 0 个或 1 个，`+`表示 1 个或多个，比如

*   `/about/:path*` 匹配 `/about`、`/about/xxx`、`/about/xxx/xxx`
*   `/about/:path?` 匹配 `/about`、`/about/xxx`
*   `/about/:path+` 匹配 `/about/xxx`、`/about/xxx/xxx`

也可以在圆括号中使用标准的正则表达式，比如`/about/(.*)` 等同于 `/about/:path*`，比如 `/(about|settings)` 匹配 `/about` 和 `/settings`，不匹配其他的地址。`/user-(ya|yu)`匹配 `/user-ya`和 `/user-yu`。

一个较为复杂和常用的例子是：

```javascript
export const config = {
  matcher: [
    /*
     * 匹配所有的路径除了以这些作为开头的：
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}
```

除此之外，还要注意，路径必须以 `/`开头。`matcher` 的值必须是常量，这样可以在构建的时候被静态分析。使用变量之类的动态值会被忽略。

matcher 的强大可远不止正则表达式，matcher 还可以判断查询参数、cookies、headers：

```javascript
export const config = {
  matcher: [
    {
      source: '/api/*',
      has: [
        { type: 'header', key: 'Authorization', value: 'Bearer Token' },
        { type: 'query', key: 'userId', value: '123' },
      ],
      missing: [{ type: 'cookie', key: 'session', value: 'active' }],
    },
  ],
}
```

在这个例子中，不仅匹配了路由地址，还要求 header 的 Authorization 必须是 Bearer Token，查询参数的 userId 为 123，且 cookie 里的 session 值不是 active。

注：关于 has 和 missing，可以参考 [ API 篇 | next.config.js（上）](https://juejin.cn/book/7307859898316881957/section/7309079234708766746#heading-10)。

### 条件语句

第二种方法是使用条件语句：

```javascript
import { NextResponse } from 'next/server'
 
export function middleware(request) {
  if (request.nextUrl.pathname.startsWith('/about')) {
    return NextResponse.rewrite(new URL('/about-2', request.url))
  }
 
  if (request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.rewrite(new URL('/dashboard/user', request.url))
  }
}
```

matcher 很强大，可有的时候不会写真的让人头疼，那就在具体的逻辑里写！

## 中间件逻辑

接下来我们看看中间件具体该怎么写：

```javascript
export function middleware(request) {
  // 如何读取和设置 cookies ？
  // 如何读取 headers ？
  // 如何直接响应?
}
```

### 如何读取和设置 cookies？

用法跟路由处理程序一致，使用 NextRequest 和 NextResponse 快捷读取和设置 cookies。

对于传入的请求，NextRequest 提供了 `get`、`getAll`、`set`和 `delete`方法处理 cookies，你也可以用 `has`检查 cookie 或者 `clear`删除所有的 cookies。

对于返回的响应，NextResponse 同样提供了 `get`、`getAll`、`set`和 `delete`方法处理 cookies。示例代码如下：

```javascript
import { NextResponse } from 'next/server'
 
export function middleware(request) {
  // 假设传入的请求 header 里 "Cookie:nextjs=fast"
  let cookie = request.cookies.get('nextjs')
  console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
  const allCookies = request.cookies.getAll()
  console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]
 
  request.cookies.has('nextjs') // => true
  request.cookies.delete('nextjs')
  request.cookies.has('nextjs') // => false
 
  // 设置 cookies
  const response = NextResponse.next()
  response.cookies.set('vercel', 'fast')
  response.cookies.set({
    name: 'vercel',
    value: 'fast',
    path: '/',
  })
  cookie = response.cookies.get('vercel')
  console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
  
  // 响应 header 为 `Set-Cookie:vercel=fast;path=/test`
  return response
}
```

在这个例子中，我们调用了 `NextResponse.next()` 这个方法，这个方法专门用在 middleware 中，毕竟我们写的是中间件，中间件进行一层处理后，返回的结果还要在下一个逻辑中继续使用，此时就需要返回 `NextResponse.next()`。当然如果不需要再走下一个逻辑了，可以直接返回一个 Response 实例，接下来的例子中会演示其写法。

### 如何读取和设置 headers？

用法跟路由处理程序一致，使用 NextRequest 和 NextResponse 快捷读取和设置 headers。示例代码如下：

```javascript
// middleware.js 
import { NextResponse } from 'next/server'
 
export function middleware(request) {
  //  clone 请求标头
  const requestHeaders = new Headers(request.headers)
  requestHeaders.set('x-hello-from-middleware1', 'hello')
 
  // 你也可以在 NextResponse.rewrite 中设置请求标头
  const response = NextResponse.next({
    request: {
      // 设置新请求标头
      headers: requestHeaders,
    },
  })
 
  // 设置新响应标头 `x-hello-from-middleware2`
  response.headers.set('x-hello-from-middleware2', 'hello')
  return response
}
```

这个例子比较特殊的地方在于调用 NextResponse.next 的时候传入了一个对象用于转发 headers，根据 [NextResponse](https://nextjs.org/docs/app/api-reference/functions/next-response) 的官方文档，目前也就这一种用法。

#### CORS

这是一个在实际开发中会用到的设置 CORS 的例子：

```javascript
import { NextResponse } from 'next/server'
 
const allowedOrigins = ['https://acme.com', 'https://my-app.org']
 
const corsOptions = {
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
}
 
export function middleware(request) {
  // Check the origin from the request
  const origin = request.headers.get('origin') ?? ''
  const isAllowedOrigin = allowedOrigins.includes(origin)
 
  // Handle preflighted requests
  const isPreflight = request.method === 'OPTIONS'
 
  if (isPreflight) {
    const preflightHeaders = {
      ...(isAllowedOrigin && { 'Access-Control-Allow-Origin': origin }),
      ...corsOptions,
    }
    return NextResponse.json({}, { headers: preflightHeaders })
  }
 
  // Handle simple requests
  const response = NextResponse.next()
 
  if (isAllowedOrigin) {
    response.headers.set('Access-Control-Allow-Origin', origin)
  }
 
  Object.entries(corsOptions).forEach(([key, value]) => {
    response.headers.set(key, value)
  })
 
  return response
}
 
export const config = {
  matcher: '/api/:path*',
}
```

### 如何直接响应?

用法跟路由处理程序一致，使用 NextResponse 设置返回的 Response。示例代码如下：

```javascript
import { NextResponse } from 'next/server'
import { isAuthenticated } from '@lib/auth'

export const config = {
  matcher: '/api/:function*',
}
 
export function middleware(request) {
  // 鉴权判断
  if (!isAuthenticated(request)) {
    // 返回错误信息
    return new NextResponse(
      JSON.stringify({ success: false, message: 'authentication failed' }),
      { status: 401, headers: { 'content-type': 'application/json' } }
    )
  }
}
```

## 执行顺序

在 Next.js 中，有很多地方都可以设置路由的响应，比如 next.config.js 中可以设置，中间件中可以设置，具体的路由中可以设置，所以要注意它们的执行顺序：

1.  `headers`（`next.config.js`）
2.  `redirects`（`next.config.js`）
3.  中间件 (`rewrites`, `redirects` 等)
4.  `beforeFiles` (`next.config.js`中的`rewrites`)
5.  基于文件系统的路由 (`public/`, `_next/static/`, `pages/`, `app/` 等)
6.  `afterFiles` (`next.config.js`中的`rewrites`)
7.  动态路由 (`/blog/[slug]`)
8.  `fallback`中的 (`next.config.js`中的`rewrites`)

注： `beforeFiles` 顾名思义，在基于文件系统的路由之前，`afterFiles`顾名思义，在基于文件系统的路由之后，`fallback`顾名思义，垫底执行。

执行顺序具体是什么作用呢？其实我们写个 demo 测试一下就知道了，文件目录如下：

```markdown
next-app             
├─ app                      
│  ├─ blog                  
│  │  ├─ [id]               
│  │  │  └─ page.js         
│  │  ├─ yayu               
│  │  │  └─ page.js         
│  │  └─ page.js                                    
├─ middleware.js            
└─ next.config.js
```

`next.config.js` 中声明 `redirects`、`rewrites`：

```javascript
module.exports = {
  async redirects() {
    return [
      {
        source: '/blog/yayu',
        destination: '/blog/yayu_redirects',
        permanent: true,
      },
    ]
  },
  async rewrites() {
    return {
      beforeFiles: [
        {
          source: '/blog/yayu',
          destination: '/blog/yayu_beforeFiles',
        },
      ],
      afterFiles: [
        {
          source: '/blog/yayu',
          destination: '/blog/yayu_afterFiles',
        },
      ],
      fallback: [
        {
          source: '/blog/yayu',
          destination: `/blog/yayu_fallback`,
        },
      ],
    }
  },
}
```

`middleware.js` 的代码如下：

```javascript
import { NextResponse } from 'next/server'
 
export function middleware(request) {
  return NextResponse.redirect(new URL('/blog/yayu_middleware', request.url))
}

export const config = {
  matcher: '/blog/yayu',
}
```

`app/blog/page.js`代码如下：

```javascript
import { redirect } from 'next/navigation'

export default function Page() {
  redirect('/blog/yayu_page')
}
```

`app/blog/[id]/page.js`代码如下：

```javascript
import { redirect } from 'next/navigation'

export default function Page() {
  redirect('/blog/yayu_slug')
}
```

现在我们在多个地方都配置了重定向和重写，那么问题来了，现在访问 `/blog/yayu`，最终浏览器地址栏里呈现的 URL 是什么？

答案是 `/blog/yayu_slug`。按照执行顺序，访问 `/blog/yayu`，先根据 `next.config.js` 的 `redirects`重定向到 `/blog/yayu_redirects`，于是走到动态路由的逻辑，重定向到 `/blog/yayu_slug`。

## 中间件相关配置项

Next.js v13.1 为中间件增加了两个新的配置项，`skipMiddlewareUrlNormalize`和`skipTrailingSlashRedirect`，用来处理一些特殊的情况。

### skipTrailingSlashRedirect

首先解释一下  **Trailing Slashes**，中文翻译为“尾部斜杠”，它指的是放在 URL 末尾的正斜杠，举个例子: `www.yauyjs.com/users/`地址中最后一个斜杠就是尾部斜杠。

一般来说，尾部斜杠用于区分目录还是文件，有尾部斜杠，表示目录，没有尾部斜杠，表示文件。当然这只是一个建议，具体你想怎么处理都行。

从 URL 的角度来看，`www.yauyjs.com/users/`和 `www.yayujs.com/users`是两个地址，不过通常我们都会做重定向。比如你在 Next.js 中访问 `/about/`它会自动重定向到 `/about`，URL 也会变为 `/about`。

**skipTrailingSlashRedirect** 顾名思义，跳过尾部斜杠重定向，当你设置 `skipTrailingSlashRedirect`为 true 后，假设再次访问 `/about/`，URL 依然会是 `/about/`。

使用 `skipTrailingSlashRedirect`的示例代码如下：

```javascript
// next.config.js
module.exports = {
  skipTrailingSlashRedirect: true,
}
```

```javascript
// middleware.js
const legacyPrefixes = ['/docs', '/blog']
 
export default async function middleware(req) {
  const { pathname } = req.nextUrl
 
  if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
    return NextResponse.next()
  }
 
  // 应用尾部斜杠
  if (
    !pathname.endsWith('/') &&
    !pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
  ) {
    req.nextUrl.pathname += '/'
    return NextResponse.redirect(req.nextUrl)
  }
}
```

在这个例子中，这里我们实现了除 `/docs` 和 `/blog` 作为前缀的路由之外，其他路由都自动添加上尾部斜杠。

### skipMiddlewareUrlNormalize

关于 **skipMiddlewareUrlNormalize**，让我们直接看一个例子：

```javascript
// next.config.js
module.exports = {
  skipMiddlewareUrlNormalize: true,
}
```

```javascript
// middleware.js
export default async function middleware(req) {
  const { pathname } = req.nextUrl
 
  // GET /_next/data/build-id/hello.json
 
  console.log(pathname)
  // 如果设置为 true，值为：/_next/data/build-id/hello.json
  // 如果没有配置，值为： /hello
}
```

设置 **skipMiddlewareUrlNormalize** 为 true 后，可以获取路由原始的地址，常用于国际化场景中。

## 运行时

使用 Middleware 的时候还要注意一点，那就是目前 Middleware 只支持 Edge runtime，并不支持 Node.js runtime。这意味着写 Middleware 的时候，尽可能使用 Web API，避免使用 Node.js API

### 实战：控制请求数

需求：如果大家调用过 openai 的接口，常用的 ChatGPT v3.5 接口会有每分钟最多 3 次的调用限制。现在你也开发了一个 `/api/chat` 的接口，为了防止被恶意调用，限制每分钟最多调用 3 次。使用 Next.js 该怎么实现呢？

让我们来实现吧！为此我们需要安装一个依赖包 [limiter](https://www.npmjs.com/package/limiter)：

```bash
npm install limiter
```

新建 `app/api/chat/route.js`，代码如下：

```javascript

import { NextResponse } from 'next/server'
import { RateLimiter } from "limiter";
const limiter = new RateLimiter({ tokensPerInterval: 3, interval: "min", fireImmediately: true });

export async function GET() {
  const remainingRequests = await limiter.removeTokens(1);
  if (remainingRequests < 0) {
    return new NextResponse(
      JSON.stringify({ success: false, message: 'Too Many Requests' }),
      { status: 429, headers: { 'content-type': 'application/json' } }
    )
  }
 
  return NextResponse.json({ data: "你好！" })
}
```

此时成功运行，效果如下：

![middleware-1.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5309c82eccdf4c1b8223399f12348442~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=720\&h=154\&s=20799\&e=gif\&f=20\&b=fdfdfd)

我们将控制次数的逻辑写在了具体的路由里，现在让我们尝试写在中间件里：

```javascript
import { NextResponse } from 'next/server'
import { RateLimiter } from "limiter";
const limiter = new RateLimiter({ tokensPerInterval: 3, interval: "min", fireImmediately: true });

export async function middleware(request) {

  const remainingRequests = await limiter.removeTokens(1);
  if (remainingRequests < 0) {
    return new NextResponse(
      JSON.stringify({ success: false, message: 'Too Many Requests' }),
      { status: 429, headers: { 'content-type': 'application/json' } }
    )
  }

  return NextResponse.next()
}

// 设置匹配路径
export const config = {
  matcher: '/api/chat',
}
```

然而此时你会发现：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/373759a3b9bf4ac8b4aeeb0f266bd62e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2202\&h=1062\&s=258688\&e=png\&b=eaeaea)

代码是报错的，这是为什么呢？

这就是初学者写中间件常犯的一个错误。之所以出错，是因为 limiter 其实是一个用在 node.js 环境的库，然而目前 Middleware 只支持 Edge runtime，并不支持 Node.js runtime，所以才会报错。举这个项目作为例子，只是为了提醒大家注意运行时问题。

## 中间件的代码维护

如果项目比较简单，中间件的代码通常不会写很多，将所有代码写在一起倒也不是什么太大问题。可当项目复杂了，比如在中间件里又要鉴权、又要控制请求、又要国际化等等，各种逻辑写在一起，中间件很快就变得难以维护。如果我们要在中间件里实现多个需求，该怎么合理的拆分代码呢？

一种简单的方式是：

```javascript
import { NextResponse } from 'next/server'

async function middleware1(request) {
  console.log(request.url)
  return NextResponse.next()
}

async function middleware2(request) {
  console.log(request.url)
  return NextResponse.next()
}

export async function middleware(request) {
  await middleware1(request)
  await middleware2(request)
}

export const config = {
  matcher: '/api/:path*',
}
```

一种更为优雅的方式是借助高阶函数：

```javascript
import { NextResponse } from 'next/server'

function withMiddleware1(middleware) {
  return async (request) => {
    console.log('middleware1 ' + request.url)
    return middleware(request)
  }
}

function withMiddleware2(middleware) {
  return async (request) => {
    console.log('middleware2 ' + request.url)
    return middleware(request)
  }
}

async function middleware(request) {
  console.log('middleware ' + request.url)
  return NextResponse.next()
}

export default withMiddleware2(withMiddleware1(middleware))

export const config = {
  matcher: '/api/:path*',
}
```

请问此时的执行顺序是什么？试着打印一下吧。是不是感觉回到了学 redux 的时候？

但这样写起来还是有点麻烦，让我们写一个工具函数帮助我们：

```javascript
import { NextResponse } from 'next/server'

function chain(functions, index = 0) {
  const current = functions[index];
  if (current) {
    const next = chain(functions, index + 1);
    return current(next);
  }
  return () => NextResponse.next();
}

function withMiddleware1(middleware) {
  return async (request) => {
    console.log('middleware1 ' + request.url)
    return middleware(request)
  }
}

function withMiddleware2(middleware) {
  return async (request) => {
    console.log('middleware2 ' + request.url)
    return middleware(request)
  }
}

export default chain([withMiddleware1, withMiddleware2])

export const config = {
  matcher: '/api/:path*',
}
```

请问此时的执行顺序是什么？答案是按数组的顺序，middleware1、middleware2。

如果使用这种方式，实际开发的时候，代码类似于：

```javascript
import { chain } from "@/lib/utils";
import { withHeaders } from "@/middlewares/withHeaders";
import { withLogging } from "@/middlewares/withLogging";

export default chain([withLogging, withHeaders]);

export const config = {
  matcher: '/api/:path*',
}
```

具体写中间件时：

```javascript
export const withHeaders = (next) => {
  return async (request) => {
    // ...
    return next(request);
  };
};
```

## 参考链接

1.  <https://nextjs.org/docs/app/building-your-application/routing/middleware>
2.  <https://github.com/pillarjs/path-to-regexp>
3.  <https://nextjs.org/docs/messages/invalid-route-source>
4.  <https://www.youtube.com/watch?v=fmFYH_Xu3d0&ab_channel=HamedBahram>


## 70.源码篇 | 实现客户端组件

## 前言

本来我想在 [《源码篇 | 实现 Server Actions》](https://juejin.cn/book/7307859898316881957/section/7309116644436115482)的基础上，完整实现客户端组件，但奈何实现之路太过坎坷，遇到太多莫名奇妙的问题，所以本篇只能浅浅实现一下，尽管如此，却也能帮助大家理解其背后实现。

现在就让我们开始吧。这次我们基于的是[《源码篇 | RSC 实现原理》](https://juejin.cn/book/7307859898316881957/section/7309115864737611827#heading-7)的实现，此时刚实现 RSC Server 和 SSR Server 的拆分。如果没有实现之前的代码，可以运行：

```javascript
# 下载指定分支的代码
git clone -b react-rsc-9 git@github.com:mqyqingfeng/next-app-demo.git
# 进入目录并安装依赖项
cd next-app-demo && npm i
# 启动
npm start
```

## 实现思路

该怎么实现客户端组件呢？其实实现思路是比较简单的：

编译代码的时候，如果遇到以 `'use client'`为开头的组件，说明是客户端组件，使用特殊的占位符替代。比如以目前的 JSX 对象实现方式为例的话，可以替换为 <div data-client="client" data-component="Like"> 这样的节点。表明该位置是客户端组件占位，指向的客户端组件是 `<Like>`。

然后将客户端组件编译为单独的 JS 代码。在客户端加载的时候，遍历所有的客户端组件占位，加载对应的 JS 代码，为每个组件单独进行渲染水合。

## Step1：客户端组件编译

修改 `client.js`，添加代码如下：

```javascript
import React from 'react'
import { readFile, writeFile } from "fs/promises"
import path from "path"

export async function renderJSXToClientJSX(jsx) {
  if (
    typeof jsx === "string" ||
    typeof jsx === "number" ||
    typeof jsx === "boolean" ||
    jsx == null
  ) {
    return jsx;
  } else if (Array.isArray(jsx)) {
    return Promise.all(jsx.map((child) => renderJSXToClientJSX(child)));
  } else if (jsx != null && typeof jsx === "object") {
    if (jsx.$$typeof === Symbol.for("react.element")) {
      if (typeof jsx.type === "string") {
        return {
          ...jsx,
          props: await renderJSXToClientJSX(jsx.props),
        };
      } else if (typeof jsx.type === "function") {
        const Component = jsx.type;
        const props = jsx.props;
        const isClientComponent = Component.toString().includes("use client")
        if (isClientComponent) {
          return await transformClientComponent(Component, props)
        } else {
          const returnedJsx = await Component(props)
          return renderJSXToClientJSX(returnedJsx)
        }
      } else throw new Error("Not implemented.");
    } else {
      return Object.fromEntries(
        await Promise.all(
          Object.entries(jsx).map(async ([propName, value]) => [
            propName,
            await renderJSXToClientJSX(value),
          ])
        )
      );
    }
  } else throw new Error("Not implemented");
}

async function transformClientComponent(Component, props) {

  const raw = Component.toString()
  const children = await renderJSXToClientJSX(props.children)

  const clientComponent = {
    value: raw,
    props: {
      ...props,
      "data-client": true,
      "data-component": Component.name,
      children,
    },
  }

  await createClientComponentJS(clientComponent)

  return React.createElement(
    "div",
    {
      "data-client": true,
      "data-component": Component.name
    }
  )
}

async function createClientComponentJS(Component) {
  const { props, value } = Component
  const name = props["data-component"]
  const filenameRaw = path.join(process.cwd(), "public", "client", name + ".js")
  const filename = path.normalize(filenameRaw)
  const fileContents = `import React from "react"
      export const props = ${JSON.stringify(props)}
      export const jsx = ${value.replaceAll('import_react.default', 'React')}`
  try {
    await writeFile(filename, fileContents)
  } catch (err) {
    console.log("error in writeComponentToDisk", err)
  }
}
```

在这段代码中，我们修改了 `renderJSXToClientJSX`函数，当函数组件代码包含 `"use client"` 时，视为客户端组件，调用 `transformClientComponent` 函数进行处理

在 `transformClientComponent` 中，我们首先会构建一个名为 `clientComponent` 的客户端组件对象，然后将其传给 `createClientComponentJS` 函数用于生成对应的客户端 JS。

以这样一段客户端组件代码为例的话：

```javascript
  "use client";

import React from "react";
function Like() {
  const [likes, setLikes] = React.useState(100)
  return <button onClick={() => {setLikes(likes + 1)}}>❤️ {likes}</button>;
}
export default Like
```

最终生成的 JS 代码大致如下：

```javascript
import React from "react"
export const props = {"data-client":true,"data-component":"Like"}
export const jsx = function Like(){const[likes,setLikes]=React.useState(100);return React.createElement("button",{onClick:()=>{setLikes(likes+1)}},"\u2764\uFE0F ",likes)}
```

其中 jsx 对应组件的代码，props 对应组件的 props。

因为我们将编译的 JS 代码放在了 `public/client`目录下，\*\*所以别忘了新建 \*\*`**public/client**`**目录**。

在 `transformClientComponent` 中，最后我们会返回一个 `React.createElement( "div", { "data-client": true, "data-component": Component.name})`的 JSX 对象，它会被渲染为 `<div data-client="client" data-component="Like">`，用于客户端组件占位。

## Step2：添加客户端组件

现在让我们添加一个客户端组件试试吧。

修改 `components.tsx`，代码如下：

```jsx
import Like from "./Like";

async function Post({ slug }) {
  let content = await readFile("./posts/" + slug + ".txt", "utf8");
  return (
    <section>
      <a className="text-blue-600" href={"/" + slug}>{slug}</a>
      <article className="h-40 mt-5 flex-1 rounded-xl bg-indigo-500 text-white flex items-center justify-center">{content}</article>
      <Like />
    </section>
  )
}
```

新建 `Like.tsx`，代码如下：

```javascript
import React from "react";

function Like() {
  "use client";

  const [likes, setLikes] = React.useState(100)
  
  return <button onClick={() => {setLikes(likes + 1)}}>❤️ {likes}</button>;
}

export default Like
```

代码看起来有些奇怪，其实也是迫不得已才这样写的。

因为我们用的是 tsx 进行的编译，当调用 renderJSXToClientJSX 的时候，获取不到顶部的 `use client`指令，所以为了区分客户端组件，我们就“委曲求全”的写在了组件内部。

## Step3：客户端处理

修改 `client.js`，添加代码如下：

```javascript
import React from "react"
import { hydrateRoot, createRoot } from 'react-dom/client';

const clientComponents = document.querySelectorAll("[data-client=true]")

for (const clientComponent of clientComponents) {
  const componentName = clientComponent.getAttribute("data-component")
  const ClientComponent = await import("./client/" + `${componentName}.js`)
  const { jsx, props } = ClientComponent

  const clientComponentJSX = React.createElement(jsx, props)
  clientComponent.setAttribute("data-loading", false)

  const clientComponentRoot = createRoot(clientComponent)
  clientComponentRoot.render(clientComponentJSX)
}
```

实现的效果就是遍历所有的客户端组件占位，根据其 data-component 属性，加载对应的 JS 文件，然后在客户端进行渲染水合。

修改 `server/ssr.ts`，将 publick 设为静态目录，顺便修正 2 处细节问题：

```javascript
// 1. 添加 public 静态目录
app.use(express.static('public'))

app.get("/:route(*)", async (req, res) => {

  // 2. 处理 favicon.ico 文件，防止报错
  if (url.pathname === '/favicon.ico') {
    return
  }

  // 3. 拼接 HTML 这里修改了 react 导入的地址，加了一个 dev 参数
    html += `
      <script type="importmap">
        {
          "imports": {
            "react": "https://esm.sh/react@18.2.0?dev",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?dev"
          }
        }
      </script>
      <script type="module" src="/client.js"></script>
    `;
  }
});
```

此时运行 `npm start`，刷新页面，`public/client`下会导出 `Like.js`，浏览器交互效果如下：

![react-rsc-18.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2df536a5de2415693878dd1f9cd12c5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1113\&h=701\&s=116800\&e=gif\&f=35\&b=252728)

此时我们就实现了客户端组件。

> 1.  功能实现：客户端组件
> 2.  源码地址：<https://github.com/mqyqingfeng/next-app-demo/tree/react-rsc-12>
> 3.  下载代码：`git clone -b react-rsc-12 git@github.com:mqyqingfeng/next-app-demo.git`

## 总结

其实我们实现的客户端组件非常“脆弱”，页面刷新的时候会有，导航的时候就没有了……所以还有很多要处理的地方，但个人能力有限，只能借这个简单的实现帮助大家理解客户端组件的实现。

在 Next.js 中的实现，客户端组件其实是会被预渲染的，而我们是直接替换为一个 `<div data-client="client" data-component="Like">`DOM 节点。因为 DOM 节点无内容，所以我们直接用了 createRoot，更贴合的实现应该用 hyrateRoot。

此外，Next.js 是在 RSC Payload 中显示要加载的客户端 JS，客户端收到 RSC Payload 后，加载对应的 JS 代码再进行水合，而我们是简单粗暴的遍历节点加载对应的 JS。

Next.js 的客户端组件，你可以简单粗暴的理解为“SSR + 水合 + CSR”，在服务端进行预渲染即 SSR，在客户端进行水合，添加事件，最后在客户端进行更新即 CSR。


## 71.面试篇 | 五千字的面试技巧分享

## 前言

本篇我们聊一聊面试技巧，分享这个并不是帮助大家“包装自己”，亦或者“投机取巧”。实力不济被淘汰固然可惜，但真正可惜的还是能力达标，却因各种原因没有发挥出自己真正的实力。

其实无论是写简历、还是面试都是有一定技巧的，本篇就和大家聊聊我的思考。

## 1. 项目经历如何写？

在回答“项目经历如何写”前，我们需要先知道，哪些项目经历是可以写在简历上的？

以 Next.js 为例，如果你只是看过这本小册或者官网，写过一些简单的 Demo，没有真的使用 Next.js 做过项目，那我建议还是不要写了。

简历中甚至可以不提及 Next.js，因为**如果你写了 Next.js，就要做好被提问的准备**。如果只是为了彰显自己厉害而凑数的技术栈，一旦被提问，回答得乱七八糟，只会是大大的减分项，进而让面试官怀疑你其他技术栈的真实度。

那你可能要问，简历里都不写，那我岂不是白学了？简历里不写，并不代表回答的时候可以不说，你可以假装无意的提及到自己对 Next.js 的涉猎，出于兴趣学习过 Next.js，这样反而会是一种加分项。

当然写也是可以的，只是不需要做过多笔墨，比如在技术栈部分写上一句如“熟悉 Next.js + Prisma + Mongodb + Vercel 开发流程，实现过自己的技术博客”即可。不过写了就要做好被提问的准备，比如准备一段实现技术博客经历描述、看看这本小册的面试题回答等等。

如果你在项目中确实用过 Next.js，那就可以写一写。在我看来，简历的一大作用是引导面试官进行提问（那些按照题库面试的就没办法了，至少阿里的面试官都是根据简历进行提问的），而其中项目经历又是重中之重。

一个好的项目经历该怎么写呢？

这个问题的本质问的是其实是一家公司想要什么样的人？所以你可以把这个问题换成：如果你开了一家外包公司，你想招什么样的人？

最基本的肯定是这个人能够按时完成自己的工作，其次在工作之余，能为公司考虑，创造更多的价值。再往后的就比较黑心了，就不多说了……

反过来也是一样的，当写在简历上的时候，完成公司的项目只是最基本的要求（当然有很多人连项目都完成不好，但是他们不会写在简历上），所以只是简单的介绍下项目以及在项目中做的事情和用到的技术栈，其实并无亮点可言。你要重点描述的是：你在完成项目之外做了什么？

给大家看个实际的例子就明白了：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/127f9971475a4ec7ad1f29637a7505b3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750\&h=650\&s=102030\&e=jpg\&b=fcfcfc" width="400">

这就是一个不错的模板。**在言简意赅的介绍项目之后，可以讲讲在项目中遇到的问题，自己是如何优化解决的，带来了哪些价值，为了增加真实度，最好有数据支撑。**

那你可能要问，我没有做过什么优化，该怎么编呢？

这我就不知道了……因为我分享的并不是包装简历，而是告诉你什么是好的“简历”，什么是好的“回答”。

这些准备其实不是在面试前简单学习一下就能做到的，而是要**在日常工作中就开始为自己的简历，为自己的“价值”铺路，如此才能在关键的阶段将自己推上更高的位置**。

优秀的人往往有一些独特的品质，比如行动力强、学习快、爱折腾、举一反三等，这些结果其实是品质在日常工作中的开花结果。面试只是透过题目和交流挖掘面试者的优秀品质而已。但这并不是说，你没好的项目经历就没有好的品质，而是说，每个人都有优势和劣势，如何扬长避短，发挥出自己的优势，在项目中留下印记是一件日常就需要思考和准备的事情。

完成一个项目经历的书写只是一个开始，作为提问的重点，面试官会通过询问你具体做的事情，了解项目经历的真实度和所做内容的含金量。

那具体的项目经历该怎么回答呢？这就要说到老套的 STAR 法则（其他公司我不清楚，但阿里的面试官在做面试官之前都要过一个面试官培训课程，其中就明确的讲到这个原则）。

所谓 STAR 原则是结构化面试当中一个非常重要的理论，它是 Situation（情景）、Task（任务）、Action（行动）和 Result（结果）四个英文单词的首字母组合。

1.  Situation：事情发生的情境
2.  Task：你的任务是什么
3.  Action：你的行动是什么
4.  Result：结果如何，你取得了什么成果

《金字塔原理》中的 SCQA 模型也是差不多的：

1.  S（Situation）情景：由大家都熟悉的情景、事实引入
2.  C（Complication）冲突：实际情况往往和我们的要求有冲突
3.  Q（Question）疑问：怎么办？
4.  A（Answer）回答：我们的解决方案是什么？

我们就以 STAR 原则为例，比如“请讲出一件你通过学习尽快胜任新的工作任务的事”：

1.  这件事发生在什么时候？（S）
2.  你要从事的工作任务是什么？（T）
3.  接到任务后你怎么办？（A）
4.  你用了多长时间获得完成该任务所必须的知识？（深层次了解员工学习能力等）
5.  你在这个过程中遇见困难了吗？（了解坚韧性，以及处理事件的灵活性）
6.  你最后完成任务的情况如何？（R）

当然这是从面试官的角度来看的，反过来从面试者的角度也是一样的。

首先千万不要让面试官这样追问。面试官追问一点你回答一点，如此挤牙膏的感觉就像悬疑探案，你将自己的弱点隐藏起来，面试官一点一点扒开寻找“真相”，这种“着急”的感觉会让面试官在寻找出点蛛丝马迹的时候，就恨不得将你判刑淘汰。倒不如大大方方的跟他直接完整讲述，都扒拉出来给你看，生怕你不知道，发现不了我的优秀……当然这个前提是你做足准备。

其次在面试前，要多准备几段这样的经历，每段经历都按照 STAR 法则编写，最好再口语化、有趣味一点就更好了。其实项目经历是非常容易勾起面试官好奇的部分，也是最容易展现个人品质的部分。写文章讲究起承转合，讲究冲突与矛盾，你遇到的问题其实就是非常好的“冲突与矛盾”，为什么会遇到这个问题呢？你是怎么思考的？你尝试了哪些方法？学习了哪些东西？最后是怎么解决的？解决完后是否将其升华？比如建成工具平台，推广团队业务等等，这些故事化的描述会非常凸显个人能力和品质。

最后，项目经历的回答表面上可以“风轻云淡”、甚至“洋洋得意，颇为自豪”，但内心一定要慎重再慎重。你可以在项目经历上添加一些特殊的技术关键词，吸引面试官去提问。你要知道，那些面试官可都是“老狐狸”，他们特别喜欢在面试者讲述一些抽象事情的时候追问其细节，在讲经历的时候追问技术，以检查其内容的真实度。为了满足他们，你可以故意抛出一些准备好的点，勾引他们提问，所以千万不要“飘”，人一飘，就容易夸耀自己，扯出一些自己其实都不熟的东西，这些东西一旦被抓住，不仅拉低面试分，也是对自己面试状态的损害。

## 2. 面试心态

之所以将“面试心态”部分单独拿出来讲，是因为面试很考验心态，心态往往又决定了发挥。

有的面试者一开始就心态就不好，紧张恐惧，回答支支吾吾、放不开。有的面试者一开始心态不错，但遇到几个不会的问题就开始丧失信心，气势全无。有的面试者则看人，遇到亲切的面试官能够谈笑风生，遇到严肃的面试官则胆小谨慎。

如果面试前很紧张，分享你一个小技巧：

> 布鲁克斯设计了一个实验，来寻找答案。她告诉一些要演讲的人放松，通过对自己说“我很冷静”来舒缓紧张。而
> 鼓励另一些人拥抱焦虑，对自己说“我很兴奋”。
>
> 哪个策略都没消除焦虑。演讲前，两组人还是紧张。然而，对自己说“我很兴奋”那些人，感觉更能处理压力。虽然还是紧张，他们自信有能力做好演讲。

面试前紧张其实是正常的，紧张这种情绪的客观目的是为了让人能够集中注意力，调动更多资源处理问题。真到事情开始的时候，紧张往往会消除大半。

但是心态上的问题其实跟人的底层认知有很大关系，一时间也难以改变。与其聊个人成长和心理学，我更想和你聊聊我眼中的面试官。

简单的来说就是，你遇到的 99% 的面试官，都是普通人，没几个真正牛逼的，无论是不是大厂。套用罗翔老师的话就是：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0676bd24bb24865b38fb8dcab39969b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1080\&h=1531\&s=190350\&e=jpg\&b=1f2e3b" width="400">

注：其实这样说我心中也有点忐忑，因为中小厂的情况我并不清楚，大厂反正是这种情况。

技术面试官分两种，一种主要考察技术，一种主要考察人。

前者主要在一二面，往往由一线开发同学承担。千万不要觉得在一线开发，技术就很强，他们只是一群加班狗而已。白天开会，晚上写代码，还要忧虑被裁。为了薪资，咬牙坚持、故作工作开心。加上大厂工作强度高、节奏快、压力大，到了周末只想躺平，这种情况哪有什么时间研究技术呢，平时做业务也更多是堆代码，毫无成长可言。毕竟公司雇你是让你干活的，不是让你学习的，付你的工资里本身就包含了委屈费。

那你可能要问，大厂里不还有纯做技术的团队吗？现在大多都被裁了，所以你遇到的概率不大。

至于后者，主要在三四面，往往由团队 leader 承担。这种技术上就更不用担心了，他们很少问技术类的问题，就算问了，也只是问问而已，他们自己可能自己都不知道答案。

哪怕他们曾经技术很强，从团队中脱颖而出，但作为 leader，工作的职责就不再是研究技术，技术上注定是要弱于一线开发同学的。阿里的很多技术 leader，大团队是会要求每年至少一次参与到实际业务开发的，结果上，无论 P7、P8、P9……，写的代码不多，还 bug 一堆，P 级越高，bug 越多。

所以我朋友圈发过防割韭菜小技巧：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bac0e268c87d485e844da84838a069ff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=500&h=1890&s=595394&e=png&b=faf9f9" width="400">

但我说这些并不是让你睥睨面试官，只是想告诉你，平台牛逼不代表个体牛逼，面试官也是普通人，会内耗、焦虑、忧虑、恐惧，技术上也不一定全面牛逼，顶多在某个细分的技术领域上有些经验。

如果你把面试看的太过重要，把面试官看的太过神圣，把他当成高高在上的决定你“未来生死”之人，那大可不必。绝大部分的面试官在作为同事相处的时候，都非常融洽随和。职级越高，越是如此，因为越是在大厂职级高，越是需要跨团队协作沟通，高冷之人是混不下去的……

但这也不是说，上来就把面试官当成朋友看待，无话不谈。面试官在面试的时候是“无情”的，千万不要通过所谓“真诚”来打动面试官，聊着聊着就开始抖出自己的底子。

真诚确实是一张好牌，它跟任何一张牌一起出都是王炸，但唯独单独出的时候，是一张废牌。所以真诚也要建立在能力过关的基础上。君子有所为有所不为，面试有所谈有所不谈。原则性的东西更要坚守，比如不要泄露公司机密信息、不要过多抱怨上家，尤其是谈跟上家撕破脸的事情。（维护自己的利益当然是你正常的权利，我只是建议面试的时候不要聊这些，没什么价值，回答不好还降低印象分）

## 3. 面试题该怎么回答？

回答面试题我们通常理解为“背八股”，确实，很多面试题看似都有标准答案，但这些标准答案其实只能算一个 60 分的回答。面试题考察的不仅仅是面试者的知识储备，更要通过面试题发现面试者的优秀品质。

比如“性能优化”是一个非常经典的面试题，大家搜一搜回答，总结整理一下，便能对这个问题回答的头头是道。但是面试官真的是在问这个问题本身吗？反正我遇到这个问题的时候，会追问面试者：“停停停，你说了这么多，我想想问你在项目中具体用到了哪些性能优化？性能优化的效果到底怎么样？最后带来了哪些收益？”

所以面试官看的其实并不是这个问题的标准回答，而是看面试者是否真的为自己的项目思考过，进行过优化，并带来了收益。如果你在之前的公司能够做到这些，那就可以认定你的积极主动性是满足要求的，自然也会在新的公司创造收益。

那你可能要问，带来收益的又不止性能优化，我就非要做性能优化？确实不止，所以你就更要在其他的回答中体现出来呀，如果你都不能体现出来，可不是只能问“性能优化”这种最常见的问题吗？

所以面试篇里的问题，我会给大家一个“标准答案”的同时，我也会给一个实际回答用于参考，你可以在比较中感受两种回答的差异。

最后，如果面试中遇到不会的该怎么回答呢？引用[《淘系前端校招负责人直播答疑文字实录》](https://juejin.cn/post/6844904126438965256#heading-5)这篇文章里的回答：

> 元彦：面试中遇到问题不会回答，这是非常正常的，毕竟大家在学习过程中遇到的问题，跟我们在工作中遇到的问题是非常不一样的，除此之外，我们看问题的角度，也是有差别很大的。
> 
> 举个例子，很多人都在看 React Fiber，但是如果问你们，为什么要有 Fiber 这个东西，可能很多人都回答不上来，因为大家只在社区里面看到说，Fiber 是怎么工作的啊，但是为什么要有 Fiber？如果没有会怎样，而这种思考，其实是非常底层的。我相信，很多人可能都没有思考过。
> 
> 那如果遇到的问题不会，你可以先选择不会，说我觉得自己没有信心能答出这个问题，当然我更希望听到你说，我现在不会，但是你给我两分钟思考一下，我想一下这个问题有没有答案？我觉得这是一个很好的思考习惯，首先你在面对不会的东西是坦然的，我当下不会，很正常，我之前没有思考过这个问题嘛，那我们再花两分钟思考一下，给一个初步的答案。
> 
> 所以说遇到问题，也不用不会就不会，也可以有一个积极的方式回应。

## 其他

过往我也写过一点面试相关的文章可以参考：

1.  [《前端，校招，面淘宝，指南》](https://juejin.cn/post/6931913100371165192)
2.  [《前端，社招，面淘宝，指南》](https://juejin.cn/column/7035531222663036965)
3.  [《你累死累活做业务，绩效还不怎么样，我只能帮你到这了……》](https://juejin.cn/post/6844904150161948679)
4.  [《淘系前端校招负责人直播答疑文字实录》](https://juejin.cn/post/6844904126438965256)


## 72.面试篇 |  常见面试题及解析（1）

## 1. Next.js 与 React

### 1.1. 常见问题

Next.js 与 React 技术选型的区别在哪里？使用 Next.js 比使用 React 有什么优势？

### 1.2. 解题思路

考察对 Next.js 和 React 的基本理解，其实 React 和 Next.js 的差别说“多”你可以列很多点，说“少”一句话也可以概括。所以重点不在于一条条列出不同点，表明你对两个框架的极致理解。

只需要大致说出最核心的区别，然后引申到比如“如何进行技术选型的选择？”或者自己的实际使用经历即可，最好在使用经历中埋下一些引导词，吸引面试官继续提问。

### 1.3. 八股答案

React 是一个用于构建用户界面的 JavaScript 库，它提供了 JSX 语法用于快速创建可复用的组件，并基于数据驱动的理念，建立单向数据流，简化了调试流程。底层则使用虚拟 DOM 和 Fiber 优化渲染性能。

Next.js 是一个基于 React 的用于构建全栈 Web 应用程序的生产框架。不仅可以使用 React 构建用户界面，还可以使用 Next.js 的各种功能和优化，使用户可以专注于构建应用程序，而不是花时间进行配置。

从使用的角度来看，React 关心的是状态管理和渲染，所以 React 的定位是一个库，通常还要搭配其他库一起使用。而 Next.js 则是一个大而全的框架，提供了开箱即用的脚手架，内置了各种优化组件和 API，Next.js v12 前实现了 SSR、SSG、ISR，而 Next.js v13 则基于 React Server Components 进行了重构，实现了 App Router、服务端组件和客户端组件、Server Actions、路由处理程序、中间件、内置各种 CSS 支持等功能。

使用 Next.js 的优势：

1. 开箱即用的脚手架，零配置，支持 TypeScipt、ESLint、Tailwind.css 等常用技术选型，快速上手使用
2. 内置各种优化组件，如图片、字体、脚本、链接等
3. SEO 友好，基于服务端组件和客户端组件进行客户端渲染和服务端渲染，自动进行静态、动态路由优化，支持流式传输
4. 基于文件的路由系统，支持布局、嵌套路由、加载状态、错误处理等以及各种高级路由功能，解决了复杂场景下的路由实现
5. 内置多种 CSS 支持，如 CSS Modules、Tailwind CSS 和 CSS-in-JS

### 1.4. 回答参考

React 是一个纯前端库，而 Next.js 是基于 React 的全栈框架。

传统的前后端分离架构，虽然带来了“前端”的繁荣，但也带来了诸如 SEO 优化、首屏加载时间过长等问题，由此诞生了 Next.js，主要解决了服务端渲染以及内置了各种全栈开发会用到的组件、工具、API 等，提高了开发效率。**（简明扼要的说明区别就好）**

我大概是 2020 年接触的 Next.js，这几年也用 Next.js 做过一些项目，我对 Next.js 的理解就是大而全的全栈框架，既可以写页面，又可以写接口，一把梭全部搞定。**（假装自己这几年持续有关注，一直在学习实践）**

我认为 Next.js 作为一个生产框架，追求的就是一个字——“快”。**（说出自己的真实感受，有自己的理解，而不是直接背答案，吸引面试官）**

当然这个“快”有两方面的解释，一个是应用程序本身性能上的快，比如它从 SSR 到 SSG 到 ISR 以及 v13 基于 RSC 进行重构，推出了 App Router，我理解都是为了进一步提升应用程序的性能。**（抛出技术名词，吸引面试官提问如 SSR 原理、App Router、RSC 方向）**

第二个“快”是开发效率上的快，比如它提供开箱即用的脚手架，内置各种优化后的组件比如图片、字体等，像图片组件我也可以自己写，自己实现懒加载，但是 Next.js 直接内置了，这就便捷了很多。此外 Next.js 还内置了各种 CSS 支持，比如 CSS Module，Tailwind CSS，当然我个人只用 Tailwind CSS。

还有 App Router，除了简化常见的加载状态、错误状态处理等，还提供了拦截路由、平行路由等高级路由功能，解决了特定场景下的路由问题。加上 Next.js 背靠 Vercel，部署也很方便，我基本做全栈的个人项目都是用 Next.js。**（抛出一堆技术名词，继续吸引面试官提问，尽可能让面试官在自己熟悉的技术领域提问，而不要回到他擅长但你不一定擅长的技术领域）**

## 2. 服务端渲染

### 2.1. 常见问题

什么是服务器端渲染（SSR）？SSR 的原理是什么？了解渐进式渲染和流式渲染嘛？

### 2.2. 解题思路

考察对 SSR 实现原理的理解，这种对原理的考察都是为了了解面试者的学习深度，是否在实现应用之外，有对实现原理有所了解。为了表达出自己真实研究过，可以引申到自己的实际研究经历。

### 2.3. 八股答案

服务器端渲染 (SSR) 是一种网页渲染技术，它在服务器端生成完整的 HTML 页面，然后将页面发送给浏览器。与客户端渲染 (CSR) 不同，SSR 在服务器端完成页面渲染，浏览器只需解析和显示 HTML 页面即可。 

SSR 的工作原理：当用户请求一个页面时，服务器会执行以下步骤：

1. 获取页面数据和模板。
2. 使用数据和模板生成完整的 HTML 页面。
3. 将 HTML 页面发送给浏览器。
4. 浏览器解析和显示 HTML 页面。 

SSR 的优势：

1. 更快的首屏加载速度： 由于浏览器无需等待 JavaScript 下载和执行，SSR 可以提供更快的首屏加载速度。
2. 更好的 SEO： 搜索引擎可以更容易抓取和索引 SSR 生成的页面，从而提高网站的 SEO 排名。
3. 更易于访问： SSR 生成的页面无需 JavaScript 即可访问，这对于禁用 JavaScript 的用户或低带宽连接的用户来说非常有用。

流式渲染是指将 HTML 文档分块传输给客户端，客户端收到每一段内容时进行分批渲染。与一次性发送整个 HTML 文档相比，流式渲染可以更早地向用户展示内容，提升页面加载速度和用户体验。 

流式渲染适用于各种需要快速展示内容的场景，例如：

1. 大型电商网站的商品列表页面
2. 社交媒体的动态消息流
3. 实时数据更新的仪表盘 

流式渲染可以通过多种技术实现，例如：

1. HTTP/1.1 的分块传输编码
2. WebSockets
### 2.4. 回答参考

所谓服务端渲染就是……在服务端进行渲染……

这样说好像有点草率……不过服务端渲染不就是这个意思吗……**（这看似草率的回答说明我可没有背八股……）**

其实我以前用 Webpack 和 React 实现过 React SSR **（参考[《源码篇 | 手写 React SSR》](https://juejin.cn/book/7307859898316881957/section/7309116396511133705)，至于你是否真的实现过，你讲得清原理就可以说成自己真的实现过）。**

其实 React 的 react-dom/server 提供了服务端渲染的 API，像 renderToString，当然也有用于流式渲染的 renderToPipeableStream 等 API，服务端渲染成具体的 HTML 后传给客户端，同时 React 提供了用于客户端的 hyrateRoot API 进行水合，实现客户端事件的绑定，就这样完成了一个基本的 SSR。

当然这是最早期的 SSR 实现，虽然解决了 SEO 等问题，但还有很多问题。**（SSR 没有什了不起的，且听我和你逼逼）**

首先，SSR 需要在服务端完全渲染完毕后才能传给客户端。其次，为了保持服务端组件树和客户端组件树一致，所有的组件代码都要打包到客户端 bundle 中。最后，一旦开始水合，整个过程是阻塞的，必须全部完成水合后，用户才能开始操作。

为了缓解这个问题，就出现了 Streaming SSR，也就是您问的流式渲染。React 用的是 Suspense 组件来实现的，Suspense 的巧妙之处就在于它在渲染的时候先用一个占位符替代，等数据获取完毕的时候，在流式传输给 HTML，用脚本替换之前的占位符，从而实现渐进式渲染内容。

这个实现很好，在我看来，解决了 2 个问题：

一个是组件并不一定非要在服务端渲染完毕再传输给客户端组件，可以边渲染边传输，体验更好。第二个是选择性水合，页面分多个部分进行水合，甚至可以根据用户操作提高水合的优先级。

但问题并没有完全解决，客户端该下载的代码并没有少，所有的组件都需要水合，哪怕它只是需要静态渲染并不涉及客户端操作，也要水合一遍，这就浪费了性能。目前的终极解决方案就是 RSC。

……（下接第三个问题）

注：仅仅看文字有点在向面试官科普知识的感觉，实际上跟你交流的语气有很大关系，社招招的是平等相处的同事，卑微的语气没有什么用，但也不要心高气傲，平心静气的与面试官分享你的看法和思考即可。

这里分享的是 SSR 的发展，相同的问题你也可以引申到自己使用 SSR 的过程中遇到的问题等。

## 3. React Server Components

### 3.1. 常见问题

RSC 的实现是为了解决什么问题？说说你对 RSC 的理解？

### 3.2. 解题思路

依然考察的是对原理的理解，毕竟 RSC 是 Next.js v13 的实现基础，如果没有接触过 React，可能对 RSC 感到陌生。

### 3.3. 八股答案

RSC 是 React 设计的一种新架构，这种方法旨在利用服务器和客户端环境的优势，实现用户体验、易于维护和高性能的三角平衡。

使用服务端组件有很多好处：

1. 数据获取：通常服务端环境（网络、性能等）更好，离数据源更近，在服务端获取数据会更快。通过减少数据加载时间以及客户端发出的请求数量来提高性能
2. 安全：在服务端保留敏感数据和逻辑，不用担心暴露给客户端
3. 缓存：服务端渲染的结果可以在后续的请求中复用，提高性能
4. bundle 大小：服务端组件的代码不会打包到 bundle 中，减少了 bundle 包的大小
5. 初始页面加载和 FCP：服务端渲染生成 HTML，快速展示 UI
6. Streaming：服务端组件可以将渲染工作拆分为 chunks，并在准备就绪时将它们流式传输到客户端。用户可以更早看到页面的部分内容，而不必等待整个页面渲染完毕

### 3.4. 回答参考

RSC 是一个很难理解的概念，至少当时卡了我很久，后来我还是自己实现了一个简单的 RSC，才理解了一些。**（我可不是背答案，我真的研究过）**

我觉得 RSC 它主要解决了 2 个问题：

第一个是 bundle size，将组件拆分为客户端组件和服务端组件后，服务端组件在服务端渲染即可，客户端只需要最后的渲染结果，所以服务端组件的依赖项不需要打包到客户端 bundle 中，这就减少了客户端 JS 的大小。

第二个是局部渲染和水合，传统的 SSR 实现中，所有的组件代码都要下载到客户端以进行水合，但是在 RSC 中，因为明确进行了组件区分，所以可以做到只有客户端组件进行水合。在后续导航的时候，RSC 将组件的渲染放在服务端，并渲染成特殊格式的 RSC Payload，根据 RSC Payload，客户端可以进行局部渲染和更新，由此实现了状态的保持。

不过这里我说的是纯 RSC，跟 Next.js 的实现还不一样，Next.js 更像是 RSC、SSR、Streaming 的结合。比如所有组件，无论客户端组件还是服务端组件都会在服务端进行渲染，Streaming 流式传输 HTML。后续导航的时候，RSC Payload 也针对流进行了优化，同样实现了 Streaming。RSC 和 SSR 相辅相成，共同提升了应用的性能。

## 总结

我的答案也不一定对，也不一定符合你对“面试答案”的期望，欢迎在评论区补充自己的回答！

**我想告诉你的是，不用拘泥于问题本身的答案，在问题之外，可以引申到自己的真实见解和思考，增加真实度。可以引申到自己的项目经历，展现个人品质，可以引申到相似的问题，展现自己的思考。“高分答案”有很多。**






## 73.面试篇 |  常见面试题及解析（2）

## 1. 服务端组件和客户端组件

### 1.1. 常见问题

服务端组件和客户端组件的区别有哪些？什么时候用服务端组件，什么时候用客户端组件？

### 1.2. 解题思路

Next.js 的基础问题，正常回答即可

### 1.3. 八股答案

在 Next.js 中，组件默认就是服务端组件。如果在文件顶部添加一个 "use client" 声明，则是声明为客户端组件。

使用服务端组件的好处：

1. 数据获取：通常服务端环境（网络、性能等）更好，离数据源更近，在服务端获取数据会更快。通过减少数据加载时间以及客户端发出的请求数量来提高性能
2. 安全：在服务端保留敏感数据和逻辑，不用担心暴露给客户端
3. 缓存：服务端渲染的结果可以在后续的请求中复用，提高性能
4. bundle 大小：服务端组件的代码不会打包到 bundle 中，减少了 bundle 包的大小
5. 初始页面加载和 FCP：服务端渲染生成 HTML，快速展示 UI
6. Streaming：服务端组件可以将渲染工作拆分为 chunks，并在准备就绪时将它们流式传输到客户端。用户可以更早看到页面的部分内容，而不必等待整个页面渲染完毕

使用客户端组件的好处：

1. 交互性：客户端组件可以使用 state、effects 和事件监听器，意味着用户可以与之交互
2. 浏览器 API：客户端组件可以使用浏览器 API 如地理位置、localStorage 等

组件如何选择：

| 如果你需要…… | 服务端组件 | 客户端组件 |
| --- | --- | --- |
| 获取数据 | ✅ | ❌ |
| 访问后端资源（直接） | ✅ | ❌ |
| 在服务端上保留敏感信息（访问令牌、API 密钥等） | ✅ | ❌ |
| 在服务端使用依赖包，从而减少客户端 JavaScript 大小 | ✅ | ❌ |
| 添加交互和事件侦听器（onClick(), onChange() 等） | ❌ | ✅ |
| 使用状态和生命周期（useState(), useReducer(), useEffect()等） | ❌ | ✅ |
| 使用仅限浏览器的 API | ❌ | ✅ |
| 使用依赖于状态、效果或仅限浏览器的 API 的自定义 hook | ❌ | ✅ |
| 使用 React 类组件 | ❌ | ✅ |

### 1.4. 回答参考

简单的来说，如果需要添加事件、使用状态和生命周期以及使用浏览器的 API，都需要声明为客户端组件，除此之外，都应该尽可能使用服务端组件。

为了尽可能多的使用服务端组件，常用的技巧有两个，一个是客户端组件下移，尽可能减少客户端组件的范围，降低客户端组件在组件树的位置。另一个是将服务端组件作为 props 传给客户端组件。

服务端组件和客户端组件的最大区别，表明上看是各种用法上的差别，但我理解根本上还是渲染原理上的差别。像服务端组件在服务端进行渲染，渲染为 HTML 传给客户端，流程就结束了。但是客户端组件它会先在服务端进行一次预渲染，传给客户端后还要进行一次水合，添加事件处理程序，最后根据客户端事件进行更新。所以客户端组件我觉得可以简单粗暴的理解为“SSR + 水合 + CSR”。

## 2. 性能优化

### 2.1. 常见问题

如何优化 Next.js 应用程序的性能？Next.js 有哪些常用的性能优化手段？

### 2.2. 解题思路

考察对 Next.js 常用性能优化方法的理解，性能优化更多是开发者完成工作之外做的事情，考察这些事情是为了发现面试者的做项目的能力和态度，所以在回答问题本身之外，可以引申到自己在实际项目中做的一些性能优化相关的工作经历。

### 2.3. 八股答案

Next.js 有哪些常用的性能优化手段？

1. 渲染策略

Next.js 存在三种不同的服务端渲染策略，1. 静态渲染 2. 动态渲染 3. Streaming，选择合适的渲染策略可以大大提高加载速度

2. 缓存策略

Next.js 中有四种缓存策略，基于 React 的函数记忆化、跨请求和部署的数据缓存、完整路由缓存和客户端路由缓存。默认情况下，Next.js 会尽可能多的使用缓存以提高性能和降低成本。

3. 减少 JavaScript 大小

尽可能多的使用服务端组件，将客户端组件树的位置尽可能下移，减少客户端组件 bundle 的大小。Next.js 也提供了 next/dynamic 实现组件懒加载，进一步拆分代码。

4. 优先使用内置组件

Next.js 内置的 Image 组件内置了懒加载、图片优化等功能，内置的字体组件可以在构建的时候将谷歌字体下载到本地，避免重复请求。内置的 Link 组件默认带预加载功能等。由于自带多种优化，在使用 Next.js 的时候，优先使用内置组件。

5. 使用性能测量工具

Next.js 提供了 @next/bundle-analyzer 插件用于分析管理 JavaScript 模块大小。可以根据分析图，删除不必要的依赖项或者拆分代码。同时 Next.js 内置了性能测量和上报。可以使用 useReportWebVitals hook 进行上报或者依托于 Verecl 自动进行收集。

### 2.4. 回答参考

Next.js 本身就内置了各种性能优化方法。比如它提供了三种服务端渲染策略，静态渲染、动态渲染和 Streaming，有四种缓存策略，基于 React 的函数记忆化、跨请求和部署的数据缓存、完整路由缓存和客户端路由缓存。默认情况下，Next.js 会自动判断渲染策略，并尽可能多的使用缓存以提高性能和降低成本。

在开发的时候，尽可能使用服务端组件，对于非首屏的代码可以使用 next/dynamic 实现懒加载，进一步降低客户端 bundle 的大小。Next.js 内置的各种组件都自带了各种优化，比如 Image 组件内置懒加载和图片优化，Link 组件默认预加载等。尽可能使用内置组件。

此外，Next.js 还内置了性能测量和优化工具，比如 useReportWebVitals hook 可以上报性能数据，也有 bundle-analyzer 插件用于分析 bundle 依赖等。

其实性能优化的方法本身是有很多的，哪怕不从 Next.js 本身的层面，从网络层面、服务端层面也有一些优化方法。但我个人觉得，做性能优化最重要的是不要空想，不能自嗨，一定要数据先行。**（引申到自己的性能优化体验和经历）**

性能优化只是改善前端项目的方式之一，最终你要改善的是用户体验和开发体验，为用户、公司和开发者带来价值才行。所以一要准确的发现问题，二是要选择尽可能 ROI 高的优化方式，三是要用数据和案例证明它的价值。

所以做性能优化，要先把性能数据的测量和上报做好。像浏览器有 Lighthouse 可以直接测量性能。Vercel 本身提供了 speed-insights 可以快捷接入，看到页面的核心 Web 指标数据，但是免费版有限制，我后面试着接入了 Prometheus 和 Grafana，通过上报 Web 指标建立可视化后台，不过遇到了一些问题卡住了。**（留个悬念，面试官对这种“失败”的事情可好奇了，做好对应的故事准备即可）**

而在具体的数据指标中，其实主要看的就是 6 个指标，就是 Chrome 总结的那 6 个，核心是三个，衡量加载速度的 LCP，衡量互动的 INP，衡量视觉稳定性的 CLS，除此之外还有第一字节时间 (Time to First Byte，TTFB)、首次内容绘制 (First Contentful Paint，FCP)、首次输入延迟 (First Input Delay ，FID)，性能上的优化就是将这些值都优化到合理的范围内，监控这些数据也是对应用的用户体验进行客观衡量。

注：最后应该再上一个故事，比如我接手过一个前台 APP 应用（把锅甩给同事），用户反馈页面卡顿（临危受命），但是相关的各种指标监控都没有（从零到一），我先用工具测试了一下页面性能，然后进行了一些常见的优化工作，加载时间从之前的 12s 提升到了 4s（先解决问题），然后我开始着手用建立了性能监控后台（系统解决问题），发现页面的 XXX 指标时间比较长，经过排查是 XXX 惹的祸，最终进行了优化，将加载时间提升到了 2s，然后就这些事情总结了技术方案，做了团队分享，拿到了领导同事的表彰（升华一下）……balabala
## 3. 使用中的问题

### 3.1. 常见问题

Next.js 服务端和客户端渲染不一致导致的水合报错该怎么解决？

### 3.2. 解题思路

这是使用 Next.js 的常见问题，通过考察这类常见问题的解决方法，判断面试者是否对日常开发中遇到的问题进行过系统总结和思考。

### 3.3. 八股答案

使用 Next.js 的时候经常会遇到这类报错：

```
Error: Hydration failed because the initial UI does not match what was rendered on the server.
```

其实这个报错并不来自于 Next.js，而是来自于 react-dom。比如我们在[《源码篇 | 手写 React SSR》](https://juejin.cn/book/7307859898316881957/section/7309116396511133705)中就使用 React 的客户端 API hyrateRoot 进行水合。

之所以出现这个报错，是因为服务端预渲染的 React 树和浏览器首次渲染的 React 树不一致，换句话说，服务端渲染的 内容应该和水合时传入的内容一致，否则水合的时候无法正确复用 DOM，导致水合报错。

导致水合错误的原因有很多：

1. 渲染的时候，使用了诸如 typeof window !== 'undefined' 这样的判断

```javascript
export default function Page() {
    if (typeof window !== 'undefined') return <div>Hello Browser</div>
    return (
        <div>
            Hello Node!
        </div>
    );
}
```

比如这段代码，在服务端渲染的时候，因为在 Node 环境，渲染结果为 `<div>Hello Node!</div>`，在浏览器环境，渲染结果为 `<div>Hello Browser</div>`，前后内容不一致，就会导致水合错误

2. 渲染的时候，使用了仅限浏览器的 API，比如 window 或 localStorage
3. 渲染的时候，使用了时间相关的 API，比如 Date()
4. 浏览器扩展修改了 HTML

常用的解决方法有：

1. 使用 useEffect 仅在客户端运行

```javascript
import { useState, useEffect } from 'react'
 
export default function App() {
  const [isClient, setIsClient] = useState(false)
 
  useEffect(() => {
    setIsClient(true)
  }, [])
 
  return <h1>{isClient ? 'This is never prerendered' : 'Prerendered'}</h1>
}
```

2. 禁用特定组件的 SSR 渲染

```javascript
import dynamic from 'next/dynamic'
 
const NoSSR = dynamic(() => import('../components/no-ssr'), { ssr: false })
 
export default function Page() {
  return (
    <div>
      <NoSSR />
    </div>
  )
}
```

3. 使用 suppressHydrationWarning 消除警告

如果实在无法避免，可以添加 suppressHydrationWarning 属性消除警告

```javascript
<time datetime="2016-10-25" suppressHydrationWarning />
```
### 3.4. 回答参考

这个问题很常见，本质上是服务端预渲染的 React 树和水合时的 React 树不一致导致，导致这个错误的原因有很多，我专门研究过还写过文章分享，大致有几种原因：

第一种是使用了 window、document 等客户端 API 判断，使用了浏览器 API，如 localstorage 等

第二种是使用了时间这类 API

我遇到的就这两种，但可能原因还有很多，据我所知，还有标签嵌套错误，比如 button 嵌套 button，浏览器插件导致渲染不一致，错误配置 CSS-In-JS 导致等等

解决方案有几种：

第一种是使用 useEffect，将在客户端运行的内容放在 useEffect 中执行

第二种是禁用组件的 SSR 渲染，据我所知，目前 Next.js 只提供了 dynamic 方法可以禁用组件的预渲染

第三种是添加一个属性，具体我忘了，这是在无法避免水合错误的时候，添加这个属性，消除水合警告

（其实我记得，但这么小众的属性，我如果记得那么牢，面试官可能怀疑我背过答案了……）

## 总结

我的答案也不一定对，也不一定符合你对“面试答案”的期望，欢迎在评论区补充自己的回答！

## 74.番外篇 | 拓展阅读

## 前言
大家阅读小册的时候，想必已经发现了，不少地方都附上了拓展阅读的文章链接。这是来自于我的 Next.js 专栏[《Next.js 开发指北》](https://juejin.cn/column/7343569488744611849)，欢迎订阅更新！

小册主系统性，专栏则是对一些单点知识进行了详细讲解：

## 1. 路由篇

1. [《Next.js v14 的模板（template.js）到底有啥用？》](https://juejin.cn/post/7343569488744300553)

3. [《如何用 Next.js v14 实现一个 Streaming 接口？》](https://juejin.cn/post/7344089411983802394)

5. [《Next.js v14 如何为多个根布局自定义不同的 404 页面？竟然还有些麻烦！欢迎探讨》](https://juejin.cn/post/7351321244125265930)

## 2. 渲染篇

1. [《Next.js v14 实现乐观更新，面向未来的 UI 更新方式》](https://juejin.cn/post/7347957960884355113)

## 3. 数据获取篇

1. [《（技巧）当 Next.js 遇到频繁重复的数据库操作时，记住使用 React 的 cache 函数》](https://juejin.cn/post/7348643498117038099)

2. [《Next.js App Router + Socket.IO 实现简易聊天室》](https://juejin.cn/post/7371423076662493224)

3. [《Next.js v14 如何实现 SSE、接入 ChatGPT Stream?》](https://juejin.cn/post/7372020457124659234)

4. [《Next.js 项目接入 AI 的利器 —— Vercel AI SDK》](https://juejin.cn/post/7376622203301969959)

## 4. 原理篇

1. [《Next.js v14 的 cookies()、header() 函数实现原理 —— AsyncLocalStorage》](https://juejin.cn/post/7360737180392996899)

## 5. 总结篇

1. [《使用 Next.js App Router 常犯的 10 个错误》](https://juejin.cn/post/7361204571828731956)

2. [《Next.js 常见错误 Hydration Failed 该如何解决？》](https://juejin.cn/post/7365793739892228096)

3. [《Next.js v14 报 document is not defined 这种错怎么办？基本都会遇到，深入解析，收藏备用》](https://juejin.cn/post/7352342892785352755)

5. [《Next.js 跨域问题的各种解法》](https://juejin.cn/post/7366177423775531008)

## 6. 资讯篇
1. [《Next.js v15 要来了，有哪些更新？附升级指南》](https://juejin.cn/post/7375858343179255862)


## 8.渲染篇 | 从 CSR、SSR、SSG、ISR 开始说起

## 前言

以前学习 Next.js 可能是听说了 Next.js 一个框架就可以实现 CSR、SSR、SSG、ISR 这些功能，但在 Next.js v13 之后，Next.js 推出了基于 React Server Component 的 App Router。

SSR、SSG 等名词也在最新的文档中被弱化、少有提及（这些功能当然还在的），但理解这些名词背后的原理和区别，依然有助于我们理解和使用 Next.js。

## 1. CSR

### 1.1. 概念介绍

我们先从传统的 CSR 开始说起。

**CSR，英文全称“Client-side Rendering”，中文翻译“客户端渲染”。顾名思义，渲染工作主要在客户端执行。**

像我们传统使用 React 的方式，就是客户端渲染。浏览器会先下载一个非常小的 HTML 文件和所需的  JavaScript 文件。在 JavaScript 中执行发送请求、获取数据、更新 DOM 和渲染页面等操作。

这样做最大的问题就是不够快。（SEO 问题是其次，现在的爬虫已经普遍能够支持 CSR 渲染的页面）

在下载、解析、执行 JavaScript以及请求数据没有返回前，页面不会完全呈现。

### 1.2. Next.js 实现 CSR

Next.js 支持 CSR，在 Next.js Pages Router 下有两种方式实现客户端渲染。

一种是在页面中使用 React `useEffect` hook，而不是服务端的渲染方法（比如 `getStaticProps`和 `getServerSideProps`，这两个方法后面会讲到），举个例子：

```javascript
// pages/csr.js
import React, { useState, useEffect } from 'react'
 
export default function Page() {
  const [data, setData] = useState(null)
 
  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://jsonplaceholder.typicode.com/todos/1')
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      const result = await response.json()
      setData(result)
    }
 
    fetchData().catch((e) => {
      console.error('An error occurred while fetching the data: ', e)
    })
  }, [])
 
  return <p>{data ? `Your data: ${JSON.stringify(data)}` : 'Loading...'}</p>
}
```

可以看到，请求由客户端发出，同时页面显示 loading 状态，等数据返回后，主要内容在客户端进行渲染。

当访问 `/csr`的时候，渲染的 HTML 文件为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cac714341954b49a46dbf336da6e0ab~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750\&h=108\&s=19401\&e=png\&b=202124)

JavaScript 获得数据后，最终更新为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dfd817e4b444a089889031ced76257f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1332\&h=140\&s=46266\&e=png\&b=202124)

第二种方法是在客户端使用数据获取的库比如 [SWR](https://swr.vercel.app/)（也是 Next.js 团队开发的）或 [TanStack Query](https://tanstack.com/query/latest/)，举个例子：

```javascript
// pages/csr2.js
import useSWR from 'swr'
const fetcher = (...args) => fetch(...args).then((res) => res.json())

export default function Page() {
  const { data, error, isLoading } = useSWR(
    'https://jsonplaceholder.typicode.com/todos/1',
    fetcher
  )
 
  if (error) return <p>Failed to load.</p>
  if (isLoading) return <p>Loading...</p>
 
  return <p>Your Data: {data.title}</p>
}
```

效果同上

## 2. SSR

### 2.1. 概念介绍

**SSR，英文全称“Server-side Rendering”，中文翻译“服务端渲染”。顾名思义，渲染工作主要在服务端执行。**

比如打开一篇博客文章页面，没有必要每次都让客户端请求，万一客户端网速不好呢，那干脆由服务端直接请求接口、获取数据，然后渲染成静态的 HTML 文件返回给用户。

虽然同样是发送请求，但通常服务端的环境（网络环境、设备性能）要好于客户端，所以最终的渲染速度（首屏加载时间）也会更快。

虽然总体速度是更快的，但因为 CSR 响应时只用返回一个很小的 HTML，SSR 响应还要请求接口，渲染 HTML，所以其响应时间会更长，对应到性能指标 TTFB (Time To First Byte)，SSR 更长。

### 2.2. Next.js 实现 SSR

Next.js 支持 SSR，我们使用 Pages Router 写个 demo：

```javascript
// pages/ssr.js
export default function Page({ data }) {
  return <p>{JSON.stringify(data)}</p>
}
 
export async function getServerSideProps() {
  const res = await fetch(`https://jsonplaceholder.typicode.com/todos`)
  const data = await res.json()
 
  return { props: { data } }
}
```

使用 SSR，你需要导出一个名为 `getServerSideProps`的 async 函数。这个函数会在每次请求的时候被调用。返回的数据会通过组件的 props 属性传递给组件。

效果如下：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecc132bc3e7e4fe4a98608218746599a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1226\&h=202\&s=34404\&e=png\&b=fefefe)

服务端会在每次请求的时候编译 HTML 文件返回给客户端。查看 HTML，这些数据可以直接看到：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3892d6c273e74e4191ba1619f171036b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2108\&h=114\&s=41646\&e=png\&b=202124)

## 3. SSG

### 3.1. 概念介绍

**SSG，英文全称“Static Site Generation”，中文翻译“静态站点生成”。**

SSG 会在构建阶段，就将页面编译为静态的 HTML 文件。

比如打开一篇博客文章页面，既然所有人看到的内容都是一样的，没有必要在用户请求页面的时候，服务端再请求接口。干脆先获取数据，提前编译成 HTML 文件，等用户访问的时候，直接返回 HTML 文件。这样速度会更快。再配上 CDN 缓存，速度就更快了。

所以能用 SSG 就用 SSG。“在用户访问之前是否能预渲染出来？”如果能，就用 SSG。

### 3.2. Next.js 实现 SSG

Next.js 支持 SSG。当不获取数据时，默认使用的就是 SSG。我们使用 Pages Router 写个 demo：

```javascript
// pages/ssg1.js
function About() {
  return <div>About</div>
}
 
export default About
```

像这种没有数据请求的页面，Next.js 会在构建的时候生成一个单独的 HTML 文件。

不过 Next.js 默认没有导出该文件。如果你想看到构建生成的 HTML 文件，修改 `next.config.js` 文件：

```javascript
const nextConfig = {
  output: 'export'
}
 
module.exports = nextConfig
```

再执行 `npm run build`，你就会在根目录下看到生成的 `out` 文件夹，里面存放了构建生成的 HTML 文件。

那如果要获取数据呢？这分两种情况。

第一种情况，页面内容需要获取数据。就比如博客的文章内容需要调用 API 获取。Next.js 提供了 `getStaticProps`。写个 demo：

```javascript
// pages/ssg2.js
export default function Blog({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const posts = await res.json()
  return {
    props: {
      posts,
    },
  }
}
```

`getStaticProps`会在构建的时候被调用，并将数据通过 props 属性传递给页面。

（还记得 `getServerSideProps` 吗？两者在用法上类似，不过 `getServerSideProps` 是在每次请求的时候被调用，`getStaticProps` 在每次构建的时候）

第二种情况，是页面路径需要获取数据。

这是什么意思呢？就比如数据库里有 100 篇文章，我肯定不可能自己手动定义 100 个路由，然后预渲染 100 个 HTML 吧。Next.js 提供了 `getStaticPaths`用于定义预渲染的路径。它需要搭配动态路由使用。写个 demo：

新建 `/pages/post/[id].js`，代码如下：

```javascript
// /pages/post/[id].js
export default function Blog({ post }) {
  return (
    <>
      <header>{post.title}</header>
      <main>{post.body}</main>
    </>
  )
}

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const posts = await res.json()
 
  const paths = posts.map((post) => ({
    params: { id: String(post.id) },
  }))

  // { fallback: false } 意味着当访问其他路由的时候返回 404
  return { paths, fallback: false }
}

export async function getStaticProps({ params }) {
  // 如果路由地址为 /posts/1, params.id 为 1
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`)
  const post = await res.json()
 
  return { props: { post } }
}
```

其中，`getStaticPaths` 和 `getStaticProps`都会在构建的时候被调用，`getStaticPaths` 定义了哪些路径被预渲染，`getStaticProps`获取路径参数，请求数据传给页面。

当你执行 `npm run build`的时候，就会看到 post 文件下生成了一堆 HTML 文件：

<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837825bf2e9c4d70a4d8abb86b842fea~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=306\&h=480\&s=30167\&e=png\&b=252526" width="120">

## 4. ISR

### 4.1. 概念介绍

**ISR，英文全称“Incremental Static Regeneration”，中文翻译“增量静态再生”。**

还是打开一篇博客文章页面，博客的主体内容也许是不变的，但像比如点赞、收藏这些数据总是在变化的吧。使用 SSG 编译成 HTML 文件后，这些数据就无法准确获取了，那你可能就退而求其次改为 SSR 或者 CSR 了。

考虑到这种情况，Next.js 提出了 ISR。当用户访问了这个页面，第一次依然是老的 HTML 内容，但是 Next.js 同时静态编译成新的 HTML 文件，当你第二次访问或者其他用户访问的时候，就会变成新的 HTML 内容了。

Next.js v9.5 就发布了稳定的 ISR 功能，这是当时提供的 [demo](https://reactions-demo.vercel.app/) 效果：

![reactions-demo.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26964dd0d6c14517abe5aa90fca2bba6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1434\&h=1464\&s=1406805\&e=gif\&f=226\&b=fcfcfc)

不过目前 demo 失效中。你可以在[新 demo](https://on-demand-isr.vercel.app/) 中测试 ISR 效果。

### 4.2. Next.js 实现 ISR

Next.js 支持 ISR，并且使用的方式很简单。你只用在 `getStaticProps` 中添加一个 `revalidate`即可。我们基于 SSG 的示例代码上进行修改：

```javascript
// pages/post/[id].js
// 保持不变
export default function Blog({ post }) {
  return (
    <>
      <header>{post.title}</header>
      <main>{post.body}</main>
    </>
  )
}

// fallback 的模式改为 'blocking'
export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const posts = await res.json()
 
  const paths = posts.slice(0, 10).map((post) => ({
    params: { id: String(post.id) },
  }))
 
  return { paths, fallback: 'blocking' }
}

// 使用这种随机的方式模拟数据改变
function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

// 多返回了 revalidata 属性
export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${getRandomInt(100)}`)
  const post = await res.json()
 
  return { 
    props: { post }, 
    revalidate: 10
  }
}
```

`revalidate`表示当发生请求的时候，至少间隔多少秒才更新页面。

这听起来有些抽象，以 `revalidate: 10` 为例，在初始请求后和接下来的 10 秒内，页面都会使用之前构建的 HTML。10s 后第一个请求发生的时候，依然使用之前编译的 HTML。但 Next.js 会开始构建更新 HTML，从下个请求起就会使用新的 HTML。（如果构建失败了，就还是用之前的，等下次再触发更新）

当你在本地使用 `next dev`运行的时候，`getStaticProps`会在每次请求的时候被调用。所以如果你要测试 ISR 功能，先构建出生产版本，再运行生产服务。也就是说，测试 ISR 效果，用这俩命令：

```javascript
next build // 或 npm run build
next start // 或 npm run start
```

最终示例代码的效果如下：

![isr.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff96d135af07484eaff5c670633bf808~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=665\&h=178\&s=83852\&e=gif\&f=70\&b=fcfcfc)

你可以看到，页面刷新后，文章内容发生变化。然后 10s 内的刷新，页面内容都没有变化。10s 后的第一次刷新触发了更新，10s 后的第二次刷新内容发生了变化。

注意这次 `getStaticPaths` 函数的返回为`return { paths, fallback: 'blocking' }`。它表示构建的时候就渲染 `paths` 里的这些路径。如果请求其他的路径，那就执行服务端渲染。在上节 SSG 的例子中，我们设置 `fallback`为 false，它表示如果请求其他的路径，就会返回 404 错误。

所以在这个 ISR demo 中，如果请求了尚未生成的路径，Next.js 会在第一次请求的时候就执行服务端渲染，编译出 HTML 文件，再请求时就从缓存里返回该 HTML 文件。SSG 优雅降级到 SSR。

## 5. 支持混合使用

在写 demo 的时候，想必你已经发现了，其实每个页面你并没有专门声明使用哪种渲染模式，Next.js 是自动判断的。所以一个 Next.js 应用里支持混合使用多种渲染模式。

当页面有 `getServerSideProps`的时候，Next.js 切成 SSR 模式。没有 `getServerSideProps` 则会预渲染页面为静态的 HTML。那你可能会问，CSR 呢？就算用 CSR 模式，Next.js 也要提供一个静态的 HTML，所以还是要走预渲染这步的，只不过相比 SSG，渲染的内容少了些。

页面可以是 SSG + CSR 的混合，由 SSG 提供初始的静态页面，提高首屏加载速度。CSR 动态填充内容，提供交互能力。举个例子：

```javascript
// pages/postList.js
import React, { useState } from 'react'

export default function Blog({ posts }) {
  const [data, setData] = useState(posts)
  return (
    <>
      <button onClick={async () => {
          const res = await fetch('https://jsonplaceholder.typicode.com/posts')
          const posts = await res.json()
          setData(posts.slice(10, 20))
      }}>换一批</button>
      <ul>
        {data.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </>
  )
}

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts')
  const posts = await res.json()
  return {
    props: {
      posts: posts.slice(0, 10),
    },
  }
}
```

初始的文章列表数据就是在构建的时候写入 HTML 里的，在点击换一批按钮的时候，则是在客户端发送请求重新渲染内容。

## 小结

恭喜你，完成了本篇内容的学习！

这一篇我们简单回顾了 Next.js Pages Router 下的的 4 种渲染模式，但是在 App Router 下，因为改为使用 React  Server Component，所以弱化了这些概念，转而使用“服务端组件、客户端组件”等概念。那这些渲染模式跟所谓“服务端组件、客户端组件”又有什么联系和区别呢？欢迎继续学习。

## 参考链接

1.  [Next.js 9.5](https://nextjs.org/blog/next-9-5)
2.  [Deploying: Static Exports](https://nextjs.org/docs/app/building-your-application/deploying/static-exports)
3.  [Rendering: Server-side Rendering (SSR)](https://nextjs.org/docs/pages/building-your-application/rendering/server-side-rendering)
4.  [Rendering: Static Site Generation (SSG)](https://nextjs.org/docs/pages/building-your-application/rendering/static-site-generation)
5.  [Rendering: Incremental Static Regeneration (ISR)](https://nextjs.org/docs/pages/building-your-application/rendering/incremental-static-regeneration)
6.  [Rendering: Automatic Static Optimization](https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization)
7.  [Rendering: Client-side Rendering (CSR)](https://nextjs.org/docs/pages/building-your-application/rendering/client-side-rendering)


## 9.渲染篇 | React Server Component 与 SSR

## 前言

Next.js v13 推出了基于 React Server Component 的 App Router 路由解决方案。对于 Next.js 而言堪称是一个颠覆式的更新，更是将 React 一直宣传的 React Server Component 这个概念真正推进并落实到项目中。

因为 React Server Component 的引入，Next.js 中的组件开始区分客户端组件还是服务端组件，但考虑到部分同学对 React Server Component 并不熟悉，本篇我们会先从 React Server Components 的出现背景开始讲起，并将其与常混淆的 SSR 概念做区分，为大家理解和使用服务端组件和客户端组件打下基础。

## React Server Components

2020 年 12 月 21 日，React 官方发布了 React Server Components 的[介绍文章](https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html)，并配上了由 Dan Abramov 和 Lauren Tan 两位 React 团队的工程师分享的长约 1h 的[分享](https://www.youtube.com/watch?time_continue=15\&v=TQQPAU21ZUw\&embeds_referring_euri=https%3A%2F%2Flegacy.reactjs.org%2F\&source_ve_path=MzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMzY4NDIsMjg2NjY\&feature=emb_logo)和 [Demo](https://github.com/reactjs/server-components-demo)，详细的介绍了 React Server Components 的出现背景和使用方式。

了解 React Server Components 对理解 Next.js 的渲染方式至关重要。所以我们稍微花些篇幅来回顾下这场演讲的主要内容。

其中 Dan 介绍了应用开发的三个注意要点：

![Data Fetching with React Server Components - YouTube - 1\_41.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7680e211aaf54b7e803401b6ecd07a3c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=838797\&e=png\&b=1b1d26)

这三点分别是**好的用户体验**、**易于维护**和**高性能**。但是这三点却很难兼顾，我们以 [Spotify](https://open.spotify.com/artist/3WrFJ7ztbogyGnTHbHJFl2) 这个网站的页面为例：

![Data Fetching with React Server Components - YouTube - 1\_57.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08de63dfe38a4a00bed2aac7ee7e5a2c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=924428\&e=png\&b=161616)

这是一个音乐家介绍页面，内容主要包含两块区域，一块是热门单曲区域（TopTracks），一块是唱片目录（Discography），如果我们要模拟实现这样一个页面，使用 React，我们可能会这样写：

![Data Fetching with React Server Components - YouTube - 2\_32.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe8ed72599f943f6bc1f0941e66f67d2~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=879724\&e=png\&b=1b1d26)

看起来很简洁的样子，但当我们加上数据请求后，代码就会变成这个样子：

![Data Fetching with React Server Components - YouTube - 4\_10.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76bc145a8414b7688f4a6375a1e6f74~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=1141608\&e=png\&b=1b1d26)

我们从顶层获取数据，然后传给需要的子组件，虽然一次请求就可以解决，但这样的代码并不易于维护。

比如在以后的迭代中删除了某个 UI 组件，但是对应数据没有从接口中删除，这就造成了冗余的数据。又比如你在接口里添加了一个字段，然后在某个组件里使用，但你忘记在另一个引用该组件的组件中传入这个字段，这可能就导致了错误。

为了易于维护，我们就会想回归到刚才简单的结构中，然后每个组件负责各自的数据请求：

![Data Fetching with React Server Components - YouTube - 5\_16.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c9c9bfbc7294b4bb3d7e2cf1d71d572~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=935649\&e=png\&b=1b1d26)

但是这样就慢了，本来一个请求就能解决，现在拆分为了三个请求。难道就不能全兼顾吗？

我们分析下原因，将数据请求拆分到各个组件中为什么会慢呢？本质上还是客户端发起了多次 HTTP 请求，如果这些请求是串行的（比如 TopTracks 和 Discography 组件需要在 ArtistDetails 组件的数据返回后再拿其中的 id 数据发送请求），那就更慢了。为了解决这个问题，便有了 React Server Component。

![Data Fetching with React Server Components - YouTube - 11\_08.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83e451cb15214ca08d5049555136eaa7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=604748\&e=png\&b=1b1d26)

React Server Component 把数据请求的部分放在服务端，由服务端直接给客户端返回带数据的组件。

最终的目标是：在原始只有 Client Components 的情况下，一个 React 树的结构如下：

![Data Fetching with React Server Components - YouTube - 48\_03.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a404d317b3604eb4bb238b4efb8c3785~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=557630\&e=png\&b=1b1d26)

在使用 React Server Component 后，React 树会变成：

![Data Fetching with React Server Components - YouTube - 46\_49.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a06dcb1d2ea64333b0299a3752f66b3d~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=555556\&e=png\&b=1b1d26)

其中黄色节点表示 React Server Component。在服务端，React 会将其渲染会一个包含基础 HTML 标签和**客户端组件占位**的树。它的结构类似于：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ced5fb4bd945f3aa9d48e520126ccc~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=953\&h=809\&s=314046\&e=png\&b=fefdfd)

因为客户端组件的数据和结构在客户端渲染的时候才知道，所以客户端组件此时在树中使用特殊的占位进行替代。

当然这个树不可能直接就发给客户端，React 会做序列化处理，客户端收到后会在客户端根据这个数据重构 React 树，然后用真正的客户端组件填充占位，渲染最终的结果。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/146a170c4626428db92e5624f5be0212~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=919\&h=796\&s=246213\&e=png\&b=fefefe)

使用 React Server Component，因为服务端组件的代码不会打包到客户端代码中，它可以减小包（bundle）的大小。且在 React Server Component 中，可以直接访问后端资源。当然因为在服务端运行，对应也有一些限制，比如不能使用 useEffect 和客户端事件等。

在这场分享里，Dan 也提到了 Next.js，表示会和 Next.js 团队的合作伙伴们一起开发，让每个人都能使用这个功能。

![Data Fetching with React Server Components - YouTube - 42\_56.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d17f67bc4ac4b399918343d0db3055b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2560\&h=1440\&s=332996\&e=png\&b=1b1d26)

终于 Next.js 在 v13 版本中实现了 React Server Component，此时已过去了两年之久。

## **Server-side Rendering**

**Server-side Rendering**，中文译为“服务端渲染”，在上篇[《渲染篇 | 从 CSR、SSR、SSG、ISR 开始说起》](https://juejin.cn/book/7307859898316881957/section/7309077054263066662)已经介绍过，并提供了一个基于 Pages Router 的 demo：

```javascript
// pages/ssr.js
export default function Page({ data }) {
  return <p>{JSON.stringify(data)}</p>
}
 
export async function getServerSideProps() {
  const res = await fetch(`https://jsonplaceholder.typicode.com/todos`)
  const data = await res.json()
 
  return { props: { data } }
}
```

从这个例子中可以看出，Next.js v12 之前的 SSR 都是通过 `getServerSideProps`这样的方法，在页面层级获取数据，然后通过 props 传给每个组件，然后将整个组件树在服务端渲染为 HTML。

但是 HTML 是没有交互性的（non-interactive UI），客户端渲染出 HTML 后，还要等待 JavaScript 完全下载并执行。JavaScript 会赋予 HTML 交互性，这个阶段被称为水合（Hydration）。此时内容变为可交互的（interactive UI）。

从这个过程中，我们可以看出 SSR 的几个缺点：

1.  SSR 的数据获取必须在组件渲染之前
2.  组件的 JavaScript 必须先加载到客户端，才能开始水合
3.  所有组件必须先水合，然后才能跟其中任意一个组件交互

可以看出 SSR 这种技术“大开大合”，加载整个页面的数据，加载整个页面的 JavaScript，水合整个页面，还必须按此顺序串行执行。如果有某些部分慢了，都会导致整体效率降低。

此外，SSR 只用于页面的初始化加载，对于后续的交互、页面更新、数据更改，SSR 并无作用。

## RSC 与 SSR

了解了这两个基本概念，现在让我们来回顾下 React Server Components 和 Server-side Rendering，表面上看，RSC 和 SSR 非常相似，都发生在服务端，都涉及到渲染，目的都是更快的呈现内容。但实际上，这两个技术概念是相互独立的。RSC 和 SSR 既可以各自单独使用，又可以搭配在一起使用（搭配在一起使用的时候是互补的）。

正如它们的名字所表明的那样，Server-side Rendering 的重点在于 **Rendering**，React Server Components 的重点在于 **Components**。

简单来说，RSC 提供了更细粒度的组件渲染方式，可以在组件中直接获取数据，而非像 Next.js v12 中的 SSR 顶层获取数据。RSC 在服务端进行渲染，组件依赖的代码不会打包到 bundle 中，而 SSR 需要将组件的所有依赖都打包到 bundle 中。

当然两者最大的区别是：

SSR 是在服务端将组件渲染成 HTML 发送给客户端，而 RSC 是将组件渲染成一种特殊的格式，我们称之为 RSC Payload。这个 RSC Payload 的渲染是在服务端，但不会一开始就返回给客户端，而是在客户端请求相关组件的时候才返回给客户端，RSC Payload 会包含组件渲染后的数据和样式，客户端收到 RSC Payload 后会重建 React 树，修改页面 DOM。

这样的描述好像很抽象，其实很简单。让我们本地开启一下当时 React 提供的 [Server Components Demo](https://github.com/reactjs/server-components-demo)：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d84b3b6a207437ca22dd3548005166c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3536\&h=1914\&s=832890\&e=png\&b=fefefe)

你会发现 `localhost` 这个 HTML 页面的内容就跟 CSR 一样，都只有一个用于挂载的 DOM 节点。当点击左侧 Notes 列表的时候，会发送请求，这个请求的地址是：

> http://localhost:4000/react?location={"selectedId":3,"isEditing":false,"searchText":""}

返回的结果是：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e914003081be4027a89b67e0c0e51678~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3536\&h=1914\&s=690003\&e=png\&b=ffffff)

除此之外没有其他的请求了。其实这条请求返回的数据就是 RSC Payload。

让我们看下这条请求，我们请求的这条笔记的标题是 Make a thing，具体内容是 It's very easy to make some……，我们把返回的数据具体查看一下，你会发现，返回的请求里包含了这些数据：

![截屏2024-03-04 16.51.55.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60fd931e61bc42c2a6a7c78268d243d3~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=3472\&h=1736\&s=1312711\&e=png\&b=1f1f1f)

不仅包含数据，完整渲染后的 DOM 结构也都包含了。客户端收到 RSC Payload 后就会根据这其中的内容修改 DOM。而且在这个过程，页面不会刷新，页面实现了 partial rendering（部分更新）。

这也就带来了我们常说的 SSR 和 RSC 的最大区别，那就是**状态的保持**（渲染成不同的格式是“因”，状态的保持是“果”）。每次 SSR 都是一个新的 HTML 页面，所以状态不会保持（传统的做法是 SSR 初次渲染，然后 CSR 更新，这种情况，状态可以保持，不过现在讨论的是 SSR，对于两次 SSR，状态是无法维持的）。

但是 RSC 不同，RSC 会被渲染成一种特殊的格式（RSC Payload），可以多次重新获取，然后客户端根据这个特殊格式更新 UI，而不会丢失客户端状态。

所谓不丢失状态，让我们看个例子：

![1116.gif](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10f53b9439e6417cab8bffb150affb69~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=982\&h=321\&s=819592\&e=gif\&f=78\&b=fefefe)

在上图中，我们新建了一条 note，重点在左侧的搜索结果列表，新建后，原本的那条 note 依然保持了展开状态。（注：这个状态在技术上是通过 useState 来实现的。实战篇的时候会用 Next.js 重写这个 Demo）

注意：这里我们比较的是 React Demo 展示的 RSC 特性和 Next.js v12 所代表的传统 SSR。跟我们接下来要讲的 Next.js 服务端组件、客户端组件并不一样。

Next.js 的服务端组件、客户端组件虽然是基于 RSC 提出的用于区分组件类型的概念，但在具体实现上，为了追求高性能，技术上其实是融合了 RSC 和 SSR（前面也说过，RSC 和 SSR 互补）。这里比较是纯粹的 RSC 和 SSR，以防大家在概念理解上产生混淆。

## 总结

本篇我们介绍并比较了 RSC 和 SSR，虽然并不涉及 Next.js 具体的写法和使用，但对于大家理解 Next.js 中的服务端组件、客户端组件概念有所帮助。


